/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 51);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/*!**************************************!*\
  !*** ./public/scripts/lib/jquery.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery v2.1.1 -deprecated,-effects,-effects/Tween,-effects/animatedSelector,-css/hiddenVisibleSelectors,-wrap | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */\n!function (a, b) {\n\t\"object\" == ( false ? \"undefined\" : _typeof(module)) && \"object\" == _typeof(module.exports) ? module.exports = a.document ? b(a, !0) : function (a) {\n\t\tif (!a.document) throw new Error(\"jQuery requires a window with a document\");return b(a);\n\t} : b(a);\n}(\"undefined\" != typeof window ? window : undefined, function (a, b) {\n\tvar c = [],\n\t    d = c.slice,\n\t    e = c.concat,\n\t    f = c.push,\n\t    g = c.indexOf,\n\t    h = {},\n\t    i = h.toString,\n\t    j = h.hasOwnProperty,\n\t    k = {},\n\t    l = a.document,\n\t    m = \"2.1.1 -deprecated,-effects,-effects/Tween,-effects/animatedSelector,-css/hiddenVisibleSelectors,-wrap\",\n\t    n = function n(a, b) {\n\t\treturn new n.fn.init(a, b);\n\t},\n\t    o = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\t    p = /^-ms-/,\n\t    q = /-([\\da-z])/gi,\n\t    r = function r(a, b) {\n\t\treturn b.toUpperCase();\n\t};n.fn = n.prototype = { jquery: m, constructor: n, selector: \"\", length: 0, toArray: function toArray() {\n\t\t\treturn d.call(this);\n\t\t}, get: function get(a) {\n\t\t\treturn null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this);\n\t\t}, pushStack: function pushStack(a) {\n\t\t\tvar b = n.merge(this.constructor(), a);return b.prevObject = this, b.context = this.context, b;\n\t\t}, each: function each(a, b) {\n\t\t\treturn n.each(this, a, b);\n\t\t}, map: function map(a) {\n\t\t\treturn this.pushStack(n.map(this, function (b, c) {\n\t\t\t\treturn a.call(b, c, b);\n\t\t\t}));\n\t\t}, slice: function slice() {\n\t\t\treturn this.pushStack(d.apply(this, arguments));\n\t\t}, first: function first() {\n\t\t\treturn this.eq(0);\n\t\t}, last: function last() {\n\t\t\treturn this.eq(-1);\n\t\t}, eq: function eq(a) {\n\t\t\tvar b = this.length,\n\t\t\t    c = +a + (0 > a ? b : 0);return this.pushStack(c >= 0 && b > c ? [this[c]] : []);\n\t\t}, end: function end() {\n\t\t\treturn this.prevObject || this.constructor(null);\n\t\t}, push: f, sort: c.sort, splice: c.splice }, n.extend = n.fn.extend = function () {\n\t\tvar a,\n\t\t    b,\n\t\t    c,\n\t\t    d,\n\t\t    e,\n\t\t    f,\n\t\t    g = arguments[0] || {},\n\t\t    h = 1,\n\t\t    i = arguments.length,\n\t\t    j = !1;for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == (typeof g === \"undefined\" ? \"undefined\" : _typeof(g)) || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) {\n\t\t\tif (null != (a = arguments[h])) for (b in a) {\n\t\t\t\tc = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n\t\t\t}\n\t\t}return g;\n\t}, n.extend({ expando: \"jQuery\" + (m + Math.random()).replace(/\\D/g, \"\"), isReady: !0, error: function error(a) {\n\t\t\tthrow new Error(a);\n\t\t}, noop: function noop() {}, isFunction: function isFunction(a) {\n\t\t\treturn \"function\" === n.type(a);\n\t\t}, isArray: Array.isArray, isWindow: function isWindow(a) {\n\t\t\treturn null != a && a === a.window;\n\t\t}, isNumeric: function isNumeric(a) {\n\t\t\treturn !n.isArray(a) && a - parseFloat(a) >= 0;\n\t\t}, isPlainObject: function isPlainObject(a) {\n\t\t\treturn \"object\" !== n.type(a) || a.nodeType || n.isWindow(a) ? !1 : a.constructor && !j.call(a.constructor.prototype, \"isPrototypeOf\") ? !1 : !0;\n\t\t}, isEmptyObject: function isEmptyObject(a) {\n\t\t\tvar b;for (b in a) {\n\t\t\t\treturn !1;\n\t\t\t}return !0;\n\t\t}, type: function type(a) {\n\t\t\treturn null == a ? a + \"\" : \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) || \"function\" == typeof a ? h[i.call(a)] || \"object\" : typeof a === \"undefined\" ? \"undefined\" : _typeof(a);\n\t\t}, globalEval: function globalEval(a) {\n\t\t\tvar b,\n\t\t\t    c = eval;a = n.trim(a), a && (1 === a.indexOf(\"use strict\") ? (b = l.createElement(\"script\"), b.text = a, l.head.appendChild(b).parentNode.removeChild(b)) : c(a));\n\t\t}, camelCase: function camelCase(a) {\n\t\t\treturn a.replace(p, \"ms-\").replace(q, r);\n\t\t}, nodeName: function nodeName(a, b) {\n\t\t\treturn a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();\n\t\t}, each: function each(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e = 0,\n\t\t\t    f = a.length,\n\t\t\t    g = s(a);if (c) {\n\t\t\t\tif (g) {\n\t\t\t\t\tfor (; f > e; e++) {\n\t\t\t\t\t\tif (d = b.apply(a[e], c), d === !1) break;\n\t\t\t\t\t}\n\t\t\t\t} else for (e in a) {\n\t\t\t\t\tif (d = b.apply(a[e], c), d === !1) break;\n\t\t\t\t}\n\t\t\t} else if (g) {\n\t\t\t\tfor (; f > e; e++) {\n\t\t\t\t\tif (d = b.call(a[e], e, a[e]), d === !1) break;\n\t\t\t\t}\n\t\t\t} else for (e in a) {\n\t\t\t\tif (d = b.call(a[e], e, a[e]), d === !1) break;\n\t\t\t}return a;\n\t\t}, trim: function trim(a) {\n\t\t\treturn null == a ? \"\" : (a + \"\").replace(o, \"\");\n\t\t}, makeArray: function makeArray(a, b) {\n\t\t\tvar c = b || [];return null != a && (s(Object(a)) ? n.merge(c, \"string\" == typeof a ? [a] : a) : f.call(c, a)), c;\n\t\t}, inArray: function inArray(a, b, c) {\n\t\t\treturn null == b ? -1 : g.call(b, a, c);\n\t\t}, merge: function merge(a, b) {\n\t\t\tfor (var c = +b.length, d = 0, e = a.length; c > d; d++) {\n\t\t\t\ta[e++] = b[d];\n\t\t\t}return a.length = e, a;\n\t\t}, grep: function grep(a, b, c) {\n\t\t\tfor (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) {\n\t\t\t\td = !b(a[f], f), d !== h && e.push(a[f]);\n\t\t\t}return e;\n\t\t}, map: function map(a, b, c) {\n\t\t\tvar d,\n\t\t\t    f = 0,\n\t\t\t    g = a.length,\n\t\t\t    h = s(a),\n\t\t\t    i = [];if (h) for (; g > f; f++) {\n\t\t\t\td = b(a[f], f, c), null != d && i.push(d);\n\t\t\t} else for (f in a) {\n\t\t\t\td = b(a[f], f, c), null != d && i.push(d);\n\t\t\t}return e.apply([], i);\n\t\t}, guid: 1, proxy: function proxy(a, b) {\n\t\t\tvar c, e, f;return \"string\" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (e = d.call(arguments, 2), f = function f() {\n\t\t\t\treturn a.apply(b || this, e.concat(d.call(arguments)));\n\t\t\t}, f.guid = a.guid = a.guid || n.guid++, f) : void 0;\n\t\t}, now: Date.now, support: k }), n.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (a, b) {\n\t\th[\"[object \" + b + \"]\"] = b.toLowerCase();\n\t});function s(a) {\n\t\tvar b = a.length,\n\t\t    c = n.type(a);return \"function\" === c || n.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : \"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a;\n\t}var t = a.document.documentElement,\n\t    u,\n\t    v = t.matches || t.webkitMatchesSelector || t.mozMatchesSelector || t.oMatchesSelector || t.msMatchesSelector,\n\t    w = function w(a, b) {\n\t\tif (a === b) return u = !0, 0;var c = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);return c ? 1 & c ? a === l || n.contains(l, a) ? -1 : b === l || n.contains(l, b) ? 1 : 0 : 4 & c ? -1 : 1 : a.compareDocumentPosition ? -1 : 1;\n\t};n.extend({ find: function find(a, b, c, d) {\n\t\t\tvar e,\n\t\t\t    f,\n\t\t\t    g = 0;if (c = c || [], b = b || l, !a || \"string\" != typeof a) return c;if (1 !== (f = b.nodeType) && 9 !== f) return [];if (d) while (e = d[g++]) {\n\t\t\t\tn.find.matchesSelector(e, a) && c.push(e);\n\t\t\t} else n.merge(c, b.querySelectorAll(a));return c;\n\t\t}, unique: function unique(a) {\n\t\t\tvar b,\n\t\t\t    c = [],\n\t\t\t    d = 0,\n\t\t\t    e = 0;if (u = !1, a.sort(w), u) {\n\t\t\t\twhile (b = a[d++]) {\n\t\t\t\t\tb === a[d] && (e = c.push(d));\n\t\t\t\t}while (e--) {\n\t\t\t\t\ta.splice(c[e], 1);\n\t\t\t\t}\n\t\t\t}return a;\n\t\t}, text: function text(a) {\n\t\t\tvar b,\n\t\t\t    c = \"\",\n\t\t\t    d = 0,\n\t\t\t    e = a.nodeType;if (e) {\n\t\t\t\tif (1 === e || 9 === e || 11 === e) return a.textContent;if (3 === e || 4 === e) return a.nodeValue;\n\t\t\t} else while (b = a[d++]) {\n\t\t\t\tc += n.text(b);\n\t\t\t}return c;\n\t\t}, contains: function contains(a, b) {\n\t\t\tvar c = 9 === a.nodeType ? a.documentElement : a,\n\t\t\t    d = b && b.parentNode;return a === d || !(!d || 1 !== d.nodeType || !c.contains(d));\n\t\t}, isXMLDoc: function isXMLDoc(a) {\n\t\t\treturn \"HTML\" !== (a.ownerDocument || a).documentElement.nodeName;\n\t\t}, expr: { attrHandle: {}, match: { bool: /^(?:checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped)$/i, needsContext: /^[\\x20\\t\\r\\n\\f]*[>+~]/ } } }), n.extend(n.find, { matches: function matches(a, b) {\n\t\t\treturn n.find(a, null, null, b);\n\t\t}, matchesSelector: function matchesSelector(a, b) {\n\t\t\treturn v.call(a, b);\n\t\t}, attr: function attr(a, b) {\n\t\t\treturn a.getAttribute(b);\n\t\t} });var x = n.expr.match.needsContext,\n\t    y = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n\t    z = /^.[^:#\\[\\.,]*$/;function A(a, b, c) {\n\t\tif (n.isFunction(b)) return n.grep(a, function (a, d) {\n\t\t\treturn !!b.call(a, d, a) !== c;\n\t\t});if (b.nodeType) return n.grep(a, function (a) {\n\t\t\treturn a === b !== c;\n\t\t});if (\"string\" == typeof b) {\n\t\t\tif (z.test(b)) return n.filter(b, a, c);b = n.filter(b, a);\n\t\t}return n.grep(a, function (a) {\n\t\t\treturn g.call(b, a) >= 0 !== c;\n\t\t});\n\t}n.filter = function (a, b, c) {\n\t\tvar d = b[0];return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {\n\t\t\treturn 1 === a.nodeType;\n\t\t}));\n\t}, n.fn.extend({ find: function find(a) {\n\t\t\tvar b,\n\t\t\t    c = this.length,\n\t\t\t    d = [],\n\t\t\t    e = this;if (\"string\" != typeof a) return this.pushStack(n(a).filter(function () {\n\t\t\t\tfor (b = 0; c > b; b++) {\n\t\t\t\t\tif (n.contains(e[b], this)) return !0;\n\t\t\t\t}\n\t\t\t}));for (b = 0; c > b; b++) {\n\t\t\t\tn.find(a, e[b], d);\n\t\t\t}return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + \" \" + a : a, d;\n\t\t}, filter: function filter(a) {\n\t\t\treturn this.pushStack(A(this, a || [], !1));\n\t\t}, not: function not(a) {\n\t\t\treturn this.pushStack(A(this, a || [], !0));\n\t\t}, is: function is(a) {\n\t\t\treturn !!A(this, \"string\" == typeof a && x.test(a) ? n(a) : a || [], !1).length;\n\t\t} });var B,\n\t    C = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\t    D = n.fn.init = function (a, b) {\n\t\tvar c, d;if (!a) return this;if (\"string\" == typeof a) {\n\t\t\tif (c = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : C.exec(a), !c || !c[1] && b) return !b || b.jquery ? (b || B).find(a) : this.constructor(b).find(a);if (c[1]) {\n\t\t\t\tif (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : l, !0)), y.test(c[1]) && n.isPlainObject(b)) for (c in b) {\n\t\t\t\t\tn.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);\n\t\t\t\t}return this;\n\t\t\t}return d = l.getElementById(c[2]), d && d.parentNode && (this.length = 1, this[0] = d), this.context = l, this.selector = a, this;\n\t\t}return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? \"undefined\" != typeof B.ready ? B.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this));\n\t};D.prototype = n.fn, B = n(l);var E = /^(?:parents|prev(?:Until|All))/,\n\t    F = { children: !0, contents: !0, next: !0, prev: !0 };n.extend({ dir: function dir(a, b, c) {\n\t\t\tvar d = [],\n\t\t\t    e = void 0 !== c;while ((a = a[b]) && 9 !== a.nodeType) {\n\t\t\t\tif (1 === a.nodeType) {\n\t\t\t\t\tif (e && n(a).is(c)) break;d.push(a);\n\t\t\t\t}\n\t\t\t}return d;\n\t\t}, sibling: function sibling(a, b) {\n\t\t\tfor (var c = []; a; a = a.nextSibling) {\n\t\t\t\t1 === a.nodeType && a !== b && c.push(a);\n\t\t\t}return c;\n\t\t} }), n.fn.extend({ has: function has(a) {\n\t\t\tvar b = n(a, this),\n\t\t\t    c = b.length;return this.filter(function () {\n\t\t\t\tfor (var a = 0; c > a; a++) {\n\t\t\t\t\tif (n.contains(this, b[a])) return !0;\n\t\t\t\t}\n\t\t\t});\n\t\t}, closest: function closest(a, b) {\n\t\t\tfor (var c, d = 0, e = this.length, f = [], g = x.test(a) || \"string\" != typeof a ? n(a, b || this.context) : 0; e > d; d++) {\n\t\t\t\tfor (c = this[d]; c && c !== b; c = c.parentNode) {\n\t\t\t\t\tif (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {\n\t\t\t\t\t\tf.push(c);break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}return this.pushStack(f.length > 1 ? n.unique(f) : f);\n\t\t}, index: function index(a) {\n\t\t\treturn a ? \"string\" == typeof a ? g.call(n(a), this[0]) : g.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n\t\t}, add: function add(a, b) {\n\t\t\treturn this.pushStack(n.unique(n.merge(this.get(), n(a, b))));\n\t\t}, addBack: function addBack(a) {\n\t\t\treturn this.add(null == a ? this.prevObject : this.prevObject.filter(a));\n\t\t} });function G(a, b) {\n\t\twhile ((a = a[b]) && 1 !== a.nodeType) {}return a;\n\t}n.each({ parent: function parent(a) {\n\t\t\tvar b = a.parentNode;return b && 11 !== b.nodeType ? b : null;\n\t\t}, parents: function parents(a) {\n\t\t\treturn n.dir(a, \"parentNode\");\n\t\t}, parentsUntil: function parentsUntil(a, b, c) {\n\t\t\treturn n.dir(a, \"parentNode\", c);\n\t\t}, next: function next(a) {\n\t\t\treturn G(a, \"nextSibling\");\n\t\t}, prev: function prev(a) {\n\t\t\treturn G(a, \"previousSibling\");\n\t\t}, nextAll: function nextAll(a) {\n\t\t\treturn n.dir(a, \"nextSibling\");\n\t\t}, prevAll: function prevAll(a) {\n\t\t\treturn n.dir(a, \"previousSibling\");\n\t\t}, nextUntil: function nextUntil(a, b, c) {\n\t\t\treturn n.dir(a, \"nextSibling\", c);\n\t\t}, prevUntil: function prevUntil(a, b, c) {\n\t\t\treturn n.dir(a, \"previousSibling\", c);\n\t\t}, siblings: function siblings(a) {\n\t\t\treturn n.sibling((a.parentNode || {}).firstChild, a);\n\t\t}, children: function children(a) {\n\t\t\treturn n.sibling(a.firstChild);\n\t\t}, contents: function contents(a) {\n\t\t\treturn a.contentDocument || n.merge([], a.childNodes);\n\t\t} }, function (a, b) {\n\t\tn.fn[a] = function (c, d) {\n\t\t\tvar e = n.map(this, b, c);return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = n.filter(d, e)), this.length > 1 && (F[a] || n.unique(e), E.test(a) && e.reverse()), this.pushStack(e);\n\t\t};\n\t});var H = /\\S+/g,\n\t    I = {};function J(a) {\n\t\tvar b = I[a] = {};return n.each(a.match(H) || [], function (a, c) {\n\t\t\tb[c] = !0;\n\t\t}), b;\n\t}n.Callbacks = function (a) {\n\t\ta = \"string\" == typeof a ? I[a] || J(a) : n.extend({}, a);var b,\n\t\t    c,\n\t\t    d,\n\t\t    e,\n\t\t    f,\n\t\t    g,\n\t\t    h = [],\n\t\t    i = !a.once && [],\n\t\t    j = function j(l) {\n\t\t\tfor (b = a.memory && l, c = !0, g = e || 0, e = 0, f = h.length, d = !0; h && f > g; g++) {\n\t\t\t\tif (h[g].apply(l[0], l[1]) === !1 && a.stopOnFalse) {\n\t\t\t\t\tb = !1;break;\n\t\t\t\t}\n\t\t\t}d = !1, h && (i ? i.length && j(i.shift()) : b ? h = [] : k.disable());\n\t\t},\n\t\t    k = { add: function add() {\n\t\t\t\tif (h) {\n\t\t\t\t\tvar c = h.length;!function g(b) {\n\t\t\t\t\t\tn.each(b, function (b, c) {\n\t\t\t\t\t\t\tvar d = n.type(c);\"function\" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && \"string\" !== d && g(c);\n\t\t\t\t\t\t});\n\t\t\t\t\t}(arguments), d ? f = h.length : b && (e = c, j(b));\n\t\t\t\t}return this;\n\t\t\t}, remove: function remove() {\n\t\t\t\treturn h && n.each(arguments, function (a, b) {\n\t\t\t\t\tvar c;while ((c = n.inArray(b, h, c)) > -1) {\n\t\t\t\t\t\th.splice(c, 1), d && (f >= c && f--, g >= c && g--);\n\t\t\t\t\t}\n\t\t\t\t}), this;\n\t\t\t}, has: function has(a) {\n\t\t\t\treturn a ? n.inArray(a, h) > -1 : !(!h || !h.length);\n\t\t\t}, empty: function empty() {\n\t\t\t\treturn h = [], f = 0, this;\n\t\t\t}, disable: function disable() {\n\t\t\t\treturn h = i = b = void 0, this;\n\t\t\t}, disabled: function disabled() {\n\t\t\t\treturn !h;\n\t\t\t}, lock: function lock() {\n\t\t\t\treturn i = void 0, b || k.disable(), this;\n\t\t\t}, locked: function locked() {\n\t\t\t\treturn !i;\n\t\t\t}, fireWith: function fireWith(a, b) {\n\t\t\t\treturn !h || c && !i || (b = b || [], b = [a, b.slice ? b.slice() : b], d ? i.push(b) : j(b)), this;\n\t\t\t}, fire: function fire() {\n\t\t\t\treturn k.fireWith(this, arguments), this;\n\t\t\t}, fired: function fired() {\n\t\t\t\treturn !!c;\n\t\t\t} };return k;\n\t}, n.extend({ Deferred: function Deferred(a) {\n\t\t\tvar b = [[\"resolve\", \"done\", n.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", n.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", n.Callbacks(\"memory\")]],\n\t\t\t    c = \"pending\",\n\t\t\t    d = { state: function state() {\n\t\t\t\t\treturn c;\n\t\t\t\t}, always: function always() {\n\t\t\t\t\treturn e.done(arguments).fail(arguments), this;\n\t\t\t\t}, then: function then() {\n\t\t\t\t\tvar a = arguments;return n.Deferred(function (c) {\n\t\t\t\t\t\tn.each(b, function (b, f) {\n\t\t\t\t\t\t\tvar g = n.isFunction(a[b]) && a[b];e[f[1]](function () {\n\t\t\t\t\t\t\t\tvar a = g && g.apply(this, arguments);a && n.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + \"With\"](this === d ? c.promise() : this, g ? [a] : arguments);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}), a = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t}, promise: function promise(a) {\n\t\t\t\t\treturn null != a ? n.extend(a, d) : d;\n\t\t\t\t} },\n\t\t\t    e = {};return d.pipe = d.then, n.each(b, function (a, f) {\n\t\t\t\tvar g = f[2],\n\t\t\t\t    h = f[3];d[f[1]] = g.add, h && g.add(function () {\n\t\t\t\t\tc = h;\n\t\t\t\t}, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {\n\t\t\t\t\treturn e[f[0] + \"With\"](this === e ? d : this, arguments), this;\n\t\t\t\t}, e[f[0] + \"With\"] = g.fireWith;\n\t\t\t}), d.promise(e), a && a.call(e, e), e;\n\t\t}, when: function when(a) {\n\t\t\tvar b = 0,\n\t\t\t    c = d.call(arguments),\n\t\t\t    e = c.length,\n\t\t\t    f = 1 !== e || a && n.isFunction(a.promise) ? e : 0,\n\t\t\t    g = 1 === f ? a : n.Deferred(),\n\t\t\t    h = function h(a, b, c) {\n\t\t\t\treturn function (e) {\n\t\t\t\t\tb[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);\n\t\t\t\t};\n\t\t\t},\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k;if (e > 1) for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) {\n\t\t\t\tc[b] && n.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;\n\t\t\t}return f || g.resolveWith(k, c), g.promise();\n\t\t} });var K;n.fn.ready = function (a) {\n\t\treturn n.ready.promise().done(a), this;\n\t}, n.extend({ isReady: !1, readyWait: 1, holdReady: function holdReady(a) {\n\t\t\ta ? n.readyWait++ : n.ready(!0);\n\t\t}, ready: function ready(a) {\n\t\t\t(a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (K.resolveWith(l, [n]), n.fn.triggerHandler && (n(l).triggerHandler(\"ready\"), n(l).off(\"ready\"))));\n\t\t} });function L() {\n\t\tl.removeEventListener(\"DOMContentLoaded\", L, !1), a.removeEventListener(\"load\", L, !1), n.ready();\n\t}n.ready.promise = function (b) {\n\t\treturn K || (K = n.Deferred(), \"complete\" === l.readyState ? setTimeout(n.ready) : (l.addEventListener(\"DOMContentLoaded\", L, !1), a.addEventListener(\"load\", L, !1))), K.promise(b);\n\t}, n.ready.promise();var M = n.access = function (a, b, c, d, e, f, g) {\n\t\tvar h = 0,\n\t\t    i = a.length,\n\t\t    j = null == c;if (\"object\" === n.type(c)) {\n\t\t\te = !0;for (h in c) {\n\t\t\t\tn.access(a, b, h, c[h], !0, f, g);\n\t\t\t}\n\t\t} else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function b(a, _b2, c) {\n\t\t\treturn j.call(n(a), c);\n\t\t})), b)) for (; i > h; h++) {\n\t\t\tb(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n\t\t}return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;\n\t};n.acceptData = function (a) {\n\t\treturn 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;\n\t};function N() {\n\t\tObject.defineProperty(this.cache = {}, 0, { get: function get() {\n\t\t\t\treturn {};\n\t\t\t} }), this.expando = n.expando + Math.random();\n\t}N.uid = 1, N.accepts = n.acceptData, N.prototype = { key: function key(a) {\n\t\t\tif (!N.accepts(a)) return 0;var b = {},\n\t\t\t    c = a[this.expando];if (!c) {\n\t\t\t\tc = N.uid++;try {\n\t\t\t\t\tb[this.expando] = { value: c }, Object.defineProperties(a, b);\n\t\t\t\t} catch (d) {\n\t\t\t\t\tb[this.expando] = c, n.extend(a, b);\n\t\t\t\t}\n\t\t\t}return this.cache[c] || (this.cache[c] = {}), c;\n\t\t}, set: function set(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e = this.key(a),\n\t\t\t    f = this.cache[e];if (\"string\" == typeof b) f[b] = c;else if (n.isEmptyObject(f)) n.extend(this.cache[e], b);else for (d in b) {\n\t\t\t\tf[d] = b[d];\n\t\t\t}return f;\n\t\t}, get: function get(a, b) {\n\t\t\tvar c = this.cache[this.key(a)];return void 0 === b ? c : c[b];\n\t\t}, access: function access(a, b, c) {\n\t\t\tvar d;return void 0 === b || b && \"string\" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b);\n\t\t}, remove: function remove(a, b) {\n\t\t\tvar c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f = this.key(a),\n\t\t\t    g = this.cache[f];if (void 0 === b) this.cache[f] = {};else {\n\t\t\t\tn.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in g ? d = [b, e] : (d = e, d = d in g ? [d] : d.match(H) || [])), c = d.length;while (c--) {\n\t\t\t\t\tdelete g[d[c]];\n\t\t\t\t}\n\t\t\t}\n\t\t}, hasData: function hasData(a) {\n\t\t\treturn !n.isEmptyObject(this.cache[a[this.expando]] || {});\n\t\t}, discard: function discard(a) {\n\t\t\ta[this.expando] && delete this.cache[a[this.expando]];\n\t\t} };var O = new N(),\n\t    P = new N(),\n\t    Q = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t    R = /([A-Z])/g;function S(a, b, c) {\n\t\tvar d;if (void 0 === c && 1 === a.nodeType) if (d = \"data-\" + b.replace(R, \"-$1\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n\t\t\ttry {\n\t\t\t\tc = \"true\" === c ? !0 : \"false\" === c ? !1 : \"null\" === c ? null : +c + \"\" === c ? +c : Q.test(c) ? n.parseJSON(c) : c;\n\t\t\t} catch (e) {}P.set(a, b, c);\n\t\t} else c = void 0;return c;\n\t}n.extend({ hasData: function hasData(a) {\n\t\t\treturn P.hasData(a) || O.hasData(a);\n\t\t}, data: function data(a, b, c) {\n\t\t\treturn P.access(a, b, c);\n\t\t}, removeData: function removeData(a, b) {\n\t\t\tP.remove(a, b);\n\t\t}, _data: function _data(a, b, c) {\n\t\t\treturn O.access(a, b, c);\n\t\t}, _removeData: function _removeData(a, b) {\n\t\t\tO.remove(a, b);\n\t\t} }), n.fn.extend({ data: function data(a, b) {\n\t\t\tvar c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f = this[0],\n\t\t\t    g = f && f.attributes;if (void 0 === a) {\n\t\t\t\tif (this.length && (e = P.get(f), 1 === f.nodeType && !O.get(f, \"hasDataAttrs\"))) {\n\t\t\t\t\tc = g.length;while (c--) {\n\t\t\t\t\t\tg[c] && (d = g[c].name, 0 === d.indexOf(\"data-\") && (d = n.camelCase(d.slice(5)), S(f, d, e[d])));\n\t\t\t\t\t}O.set(f, \"hasDataAttrs\", !0);\n\t\t\t\t}return e;\n\t\t\t}return \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? this.each(function () {\n\t\t\t\tP.set(this, a);\n\t\t\t}) : M(this, function (b) {\n\t\t\t\tvar c,\n\t\t\t\t    d = n.camelCase(a);if (f && void 0 === b) {\n\t\t\t\t\tif (c = P.get(f, a), void 0 !== c) return c;if (c = P.get(f, d), void 0 !== c) return c;if (c = S(f, d, void 0), void 0 !== c) return c;\n\t\t\t\t} else this.each(function () {\n\t\t\t\t\tvar c = P.get(this, d);P.set(this, d, b), -1 !== a.indexOf(\"-\") && void 0 !== c && P.set(this, a, b);\n\t\t\t\t});\n\t\t\t}, null, b, arguments.length > 1, null, !0);\n\t\t}, removeData: function removeData(a) {\n\t\t\treturn this.each(function () {\n\t\t\t\tP.remove(this, a);\n\t\t\t});\n\t\t} }), n.extend({ queue: function queue(a, b, c) {\n\t\t\tvar d;return a ? (b = (b || \"fx\") + \"queue\", d = O.get(a, b), c && (!d || n.isArray(c) ? d = O.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0;\n\t\t}, dequeue: function dequeue(a, b) {\n\t\t\tb = b || \"fx\";var c = n.queue(a, b),\n\t\t\t    d = c.length,\n\t\t\t    e = c.shift(),\n\t\t\t    f = n._queueHooks(a, b),\n\t\t\t    g = function g() {\n\t\t\t\tn.dequeue(a, b);\n\t\t\t};\"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();\n\t\t}, _queueHooks: function _queueHooks(a, b) {\n\t\t\tvar c = b + \"queueHooks\";return O.get(a, c) || O.access(a, c, { empty: n.Callbacks(\"once memory\").add(function () {\n\t\t\t\t\tO.remove(a, [b + \"queue\", c]);\n\t\t\t\t}) });\n\t\t} }), n.fn.extend({ queue: function queue(a, b) {\n\t\t\tvar c = 2;return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {\n\t\t\t\tvar c = n.queue(this, a, b);n._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && n.dequeue(this, a);\n\t\t\t});\n\t\t}, dequeue: function dequeue(a) {\n\t\t\treturn this.each(function () {\n\t\t\t\tn.dequeue(this, a);\n\t\t\t});\n\t\t}, clearQueue: function clearQueue(a) {\n\t\t\treturn this.queue(a || \"fx\", []);\n\t\t}, promise: function promise(a, b) {\n\t\t\tvar c,\n\t\t\t    d = 1,\n\t\t\t    e = n.Deferred(),\n\t\t\t    f = this,\n\t\t\t    g = this.length,\n\t\t\t    h = function h() {\n\t\t\t\t--d || e.resolveWith(f, [f]);\n\t\t\t};\"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";while (g--) {\n\t\t\t\tc = O.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n\t\t\t}return h(), e.promise(b);\n\t\t} });var T = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n\t    U = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n\t    V = function V(a, b) {\n\t\treturn a = b || a, \"none\" === n.css(a, \"display\") || !n.contains(a.ownerDocument, a);\n\t},\n\t    W = /^(?:checkbox|radio)$/i;!function () {\n\t\tvar a = l.createDocumentFragment(),\n\t\t    b = a.appendChild(l.createElement(\"div\")),\n\t\t    c = l.createElement(\"input\");c.setAttribute(\"type\", \"radio\"), c.setAttribute(\"checked\", \"checked\"), c.setAttribute(\"name\", \"t\"), b.appendChild(c), k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;\n\t}();var X = \"undefined\";k.focusinBubbles = \"onfocusin\" in a;var Y = /^key/,\n\t    Z = /^(?:mouse|pointer|contextmenu)|click/,\n\t    $ = /^(?:focusinfocus|focusoutblur)$/,\n\t    _ = /^([^.]*)(?:\\.(.+)|)$/;function ab() {\n\t\treturn !0;\n\t}function bb() {\n\t\treturn !1;\n\t}function cb() {\n\t\ttry {\n\t\t\treturn l.activeElement;\n\t\t} catch (a) {}\n\t}n.event = { global: {}, add: function add(a, b, c, d, e) {\n\t\t\tvar f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    l,\n\t\t\t    m,\n\t\t\t    o,\n\t\t\t    p,\n\t\t\t    q,\n\t\t\t    r = O.get(a);if (r) {\n\t\t\t\tc.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) {\n\t\t\t\t\treturn (typeof n === \"undefined\" ? \"undefined\" : _typeof(n)) !== X && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0;\n\t\t\t\t}), b = (b || \"\").match(H) || [\"\"], j = b.length;while (j--) {\n\t\t\t\t\th = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test(e), namespace: p.join(\".\") }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g, !1)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0);\n\t\t\t\t}\n\t\t\t}\n\t\t}, remove: function remove(a, b, c, d, e) {\n\t\t\tvar f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    l,\n\t\t\t    m,\n\t\t\t    o,\n\t\t\t    p,\n\t\t\t    q,\n\t\t\t    r = O.hasData(a) && O.get(a);if (r && (i = r.events)) {\n\t\t\t\tb = (b || \"\").match(H) || [\"\"], j = b.length;while (j--) {\n\t\t\t\t\tif (h = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o) {\n\t\t\t\t\t\tl = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + p.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;while (f--) {\n\t\t\t\t\t\t\tk = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n\t\t\t\t\t\t}g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]);\n\t\t\t\t\t} else for (o in i) {\n\t\t\t\t\t\tn.event.remove(a, o + b[j], c, d, !0);\n\t\t\t\t\t}\n\t\t\t\t}n.isEmptyObject(i) && (delete r.handle, O.remove(a, \"events\"));\n\t\t\t}\n\t\t}, trigger: function trigger(b, c, d, e) {\n\t\t\tvar f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    k,\n\t\t\t    m,\n\t\t\t    o,\n\t\t\t    p = [d || l],\n\t\t\t    q = j.call(b, \"type\") ? b.type : b,\n\t\t\t    r = j.call(b, \"namespace\") ? b.namespace.split(\".\") : [];if (g = h = d = d || l, 3 !== d.nodeType && 8 !== d.nodeType && !$.test(q + n.event.triggered) && (q.indexOf(\".\") >= 0 && (r = q.split(\".\"), q = r.shift(), r.sort()), k = q.indexOf(\":\") < 0 && \"on\" + q, b = b[n.expando] ? b : new n.Event(q, \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b), b.isTrigger = e ? 2 : 3, b.namespace = r.join(\".\"), b.namespace_re = b.namespace ? new RegExp(\"(^|\\\\.)\" + r.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, e || !o.trigger || o.trigger.apply(d, c) !== !1)) {\n\t\t\t\tif (!e && !o.noBubble && !n.isWindow(d)) {\n\t\t\t\t\tfor (i = o.delegateType || q, $.test(i + q) || (g = g.parentNode); g; g = g.parentNode) {\n\t\t\t\t\t\tp.push(g), h = g;\n\t\t\t\t\t}h === (d.ownerDocument || l) && p.push(h.defaultView || h.parentWindow || a);\n\t\t\t\t}f = 0;while ((g = p[f++]) && !b.isPropagationStopped()) {\n\t\t\t\t\tb.type = f > 1 ? i : o.bindType || q, m = (O.get(g, \"events\") || {})[b.type] && O.get(g, \"handle\"), m && m.apply(g, c), m = k && g[k], m && m.apply && n.acceptData(g) && (b.result = m.apply(g, c), b.result === !1 && b.preventDefault());\n\t\t\t\t}return b.type = q, e || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !n.acceptData(d) || k && n.isFunction(d[q]) && !n.isWindow(d) && (h = d[k], h && (d[k] = null), n.event.triggered = q, d[q](), n.event.triggered = void 0, h && (d[k] = h)), b.result;\n\t\t\t}\n\t\t}, dispatch: function dispatch(a) {\n\t\t\ta = n.event.fix(a);var b,\n\t\t\t    c,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h = [],\n\t\t\t    i = d.call(arguments),\n\t\t\t    j = (O.get(this, \"events\") || {})[a.type] || [],\n\t\t\t    k = n.event.special[a.type] || {};if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n\t\t\t\th = n.event.handlers.call(this, a, j), b = 0;while ((f = h[b++]) && !a.isPropagationStopped()) {\n\t\t\t\t\ta.currentTarget = f.elem, c = 0;while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) {\n\t\t\t\t\t\t(!a.namespace_re || a.namespace_re.test(g.namespace)) && (a.handleObj = g, a.data = g.data, e = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (a.result = e) === !1 && (a.preventDefault(), a.stopPropagation()));\n\t\t\t\t\t}\n\t\t\t\t}return k.postDispatch && k.postDispatch.call(this, a), a.result;\n\t\t\t}\n\t\t}, handlers: function handlers(a, b) {\n\t\t\tvar c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g = [],\n\t\t\t    h = b.delegateCount,\n\t\t\t    i = a.target;if (h && i.nodeType && (!a.button || \"click\" !== a.type)) for (; i !== this; i = i.parentNode || this) {\n\t\t\t\tif (i.disabled !== !0 || \"click\" !== a.type) {\n\t\t\t\t\tfor (d = [], c = 0; h > c; c++) {\n\t\t\t\t\t\tf = b[c], e = f.selector + \" \", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) >= 0 : n.find(e, this, null, [i]).length), d[e] && d.push(f);\n\t\t\t\t\t}d.length && g.push({ elem: i, handlers: d });\n\t\t\t\t}\n\t\t\t}return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g;\n\t\t}, props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"), fixHooks: {}, keyHooks: { props: \"char charCode key keyCode\".split(\" \"), filter: function filter(a, b) {\n\t\t\t\treturn null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;\n\t\t\t} }, mouseHooks: { props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"), filter: function filter(a, b) {\n\t\t\t\tvar c,\n\t\t\t\t    d,\n\t\t\t\t    e,\n\t\t\t\t    f = b.button;return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || l, d = c.documentElement, e = c.body, a.pageX = b.clientX + (d && d.scrollLeft || e && e.scrollLeft || 0) - (d && d.clientLeft || e && e.clientLeft || 0), a.pageY = b.clientY + (d && d.scrollTop || e && e.scrollTop || 0) - (d && d.clientTop || e && e.clientTop || 0)), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a;\n\t\t\t} }, fix: function fix(a) {\n\t\t\tif (a[n.expando]) return a;var b,\n\t\t\t    c,\n\t\t\t    d,\n\t\t\t    e = a.type,\n\t\t\t    f = a,\n\t\t\t    g = this.fixHooks[e];g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new n.Event(f), b = d.length;while (b--) {\n\t\t\t\tc = d[b], a[c] = f[c];\n\t\t\t}return a.target || (a.target = l), 3 === a.target.nodeType && (a.target = a.target.parentNode), g.filter ? g.filter(a, f) : a;\n\t\t}, special: { load: { noBubble: !0 }, focus: { trigger: function trigger() {\n\t\t\t\t\treturn this !== cb() && this.focus ? (this.focus(), !1) : void 0;\n\t\t\t\t}, delegateType: \"focusin\" }, blur: { trigger: function trigger() {\n\t\t\t\t\treturn this === cb() && this.blur ? (this.blur(), !1) : void 0;\n\t\t\t\t}, delegateType: \"focusout\" }, click: { trigger: function trigger() {\n\t\t\t\t\treturn \"checkbox\" === this.type && this.click && n.nodeName(this, \"input\") ? (this.click(), !1) : void 0;\n\t\t\t\t}, _default: function _default(a) {\n\t\t\t\t\treturn n.nodeName(a.target, \"a\");\n\t\t\t\t} }, beforeunload: { postDispatch: function postDispatch(a) {\n\t\t\t\t\tvoid 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);\n\t\t\t\t} } }, simulate: function simulate(a, b, c, d) {\n\t\t\tvar e = n.extend(new n.Event(), c, { type: a, isSimulated: !0, originalEvent: {} });d ? n.event.trigger(e, null, b) : n.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault();\n\t\t} }, n.removeEvent = function (a, b, c) {\n\t\ta.removeEventListener && a.removeEventListener(b, c, !1);\n\t}, n.Event = function (a, b) {\n\t\treturn this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ab : bb) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b);\n\t}, n.Event.prototype = { isDefaultPrevented: bb, isPropagationStopped: bb, isImmediatePropagationStopped: bb, preventDefault: function preventDefault() {\n\t\t\tvar a = this.originalEvent;this.isDefaultPrevented = ab, a && a.preventDefault && a.preventDefault();\n\t\t}, stopPropagation: function stopPropagation() {\n\t\t\tvar a = this.originalEvent;this.isPropagationStopped = ab, a && a.stopPropagation && a.stopPropagation();\n\t\t}, stopImmediatePropagation: function stopImmediatePropagation() {\n\t\t\tvar a = this.originalEvent;this.isImmediatePropagationStopped = ab, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), this.stopPropagation();\n\t\t} }, n.each({ mouseenter: \"mouseover\", mouseleave: \"mouseout\", pointerenter: \"pointerover\", pointerleave: \"pointerout\" }, function (a, b) {\n\t\tn.event.special[a] = { delegateType: b, bindType: b, handle: function handle(a) {\n\t\t\t\tvar c,\n\t\t\t\t    d = this,\n\t\t\t\t    e = a.relatedTarget,\n\t\t\t\t    f = a.handleObj;return (!e || e !== d && !n.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;\n\t\t\t} };\n\t}), k.focusinBubbles || n.each({ focus: \"focusin\", blur: \"focusout\" }, function (a, b) {\n\t\tvar c = function c(a) {\n\t\t\tn.event.simulate(b, a.target, n.event.fix(a), !0);\n\t\t};n.event.special[b] = { setup: function setup() {\n\t\t\t\tvar d = this.ownerDocument || this,\n\t\t\t\t    e = O.access(d, b);e || d.addEventListener(a, c, !0), O.access(d, b, (e || 0) + 1);\n\t\t\t}, teardown: function teardown() {\n\t\t\t\tvar d = this.ownerDocument || this,\n\t\t\t\t    e = O.access(d, b) - 1;e ? O.access(d, b, e) : (d.removeEventListener(a, c, !0), O.remove(d, b));\n\t\t\t} };\n\t}), n.fn.extend({ on: function on(a, b, c, d, e) {\n\t\t\tvar f, g;if (\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a))) {\n\t\t\t\t\"string\" != typeof b && (c = c || b, b = void 0);for (g in a) {\n\t\t\t\t\tthis.on(g, b, c, a[g], e);\n\t\t\t\t}return this;\n\t\t\t}if (null == c && null == d ? (d = b, c = b = void 0) : null == d && (\"string\" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = bb;else if (!d) return this;return 1 === e && (f = d, d = function d(a) {\n\t\t\t\treturn n().off(a), f.apply(this, arguments);\n\t\t\t}, d.guid = f.guid || (f.guid = n.guid++)), this.each(function () {\n\t\t\t\tn.event.add(this, a, d, c, b);\n\t\t\t});\n\t\t}, one: function one(a, b, c, d) {\n\t\t\treturn this.on(a, b, c, d, 1);\n\t\t}, off: function off(a, b, c) {\n\t\t\tvar d, e;if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;if (\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a))) {\n\t\t\t\tfor (e in a) {\n\t\t\t\t\tthis.off(e, b, a[e]);\n\t\t\t\t}return this;\n\t\t\t}return (b === !1 || \"function\" == typeof b) && (c = b, b = void 0), c === !1 && (c = bb), this.each(function () {\n\t\t\t\tn.event.remove(this, a, c, b);\n\t\t\t});\n\t\t}, trigger: function trigger(a, b) {\n\t\t\treturn this.each(function () {\n\t\t\t\tn.event.trigger(a, b, this);\n\t\t\t});\n\t\t}, triggerHandler: function triggerHandler(a, b) {\n\t\t\tvar c = this[0];return c ? n.event.trigger(a, b, c, !0) : void 0;\n\t\t} });var db = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n\t    eb = /<([\\w:]+)/,\n\t    fb = /<|&#?\\w+;/,\n\t    gb = /<(?:script|style|link)/i,\n\t    hb = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t    ib = /^$|\\/(?:java|ecma)script/i,\n\t    jb = /^true\\/(.*)/,\n\t    kb = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\t    lb = { option: [1, \"<select multiple='multiple'>\", \"</select>\"], thead: [1, \"<table>\", \"</table>\"], col: [2, \"<table><colgroup>\", \"</colgroup></table>\"], tr: [2, \"<table><tbody>\", \"</tbody></table>\"], td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"], _default: [0, \"\", \"\"] };lb.optgroup = lb.option, lb.tbody = lb.tfoot = lb.colgroup = lb.caption = lb.thead, lb.th = lb.td;function mb(a, b) {\n\t\treturn n.nodeName(a, \"table\") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a;\n\t}function nb(a) {\n\t\treturn a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a;\n\t}function ob(a) {\n\t\tvar b = jb.exec(a.type);return b ? a.type = b[1] : a.removeAttribute(\"type\"), a;\n\t}function pb(a, b) {\n\t\tfor (var c = 0, d = a.length; d > c; c++) {\n\t\t\tO.set(a[c], \"globalEval\", !b || O.get(b[c], \"globalEval\"));\n\t\t}\n\t}function qb(a, b) {\n\t\tvar c, d, e, f, g, h, i, j;if (1 === b.nodeType) {\n\t\t\tif (O.hasData(a) && (f = O.access(a), g = O.set(b, f), j = f.events)) {\n\t\t\t\tdelete g.handle, g.events = {};for (e in j) {\n\t\t\t\t\tfor (c = 0, d = j[e].length; d > c; c++) {\n\t\t\t\t\t\tn.event.add(b, e, j[e][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}P.hasData(a) && (h = P.access(a), i = n.extend({}, h), P.set(b, i));\n\t\t}\n\t}function rb(a, b) {\n\t\tvar c = a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [];return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c;\n\t}function sb(a, b) {\n\t\tvar c = b.nodeName.toLowerCase();\"input\" === c && W.test(a.type) ? b.checked = a.checked : (\"input\" === c || \"textarea\" === c) && (b.defaultValue = a.defaultValue);\n\t}n.extend({ clone: function clone(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h = a.cloneNode(!0),\n\t\t\t    i = n.contains(a.ownerDocument, a);if (!(k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (g = rb(h), f = rb(a), d = 0, e = f.length; e > d; d++) {\n\t\t\t\tsb(f[d], g[d]);\n\t\t\t}if (b) if (c) for (f = f || rb(a), g = g || rb(h), d = 0, e = f.length; e > d; d++) {\n\t\t\t\tqb(f[d], g[d]);\n\t\t\t} else qb(a, h);return g = rb(h, \"script\"), g.length > 0 && pb(g, !i && rb(a, \"script\")), h;\n\t\t}, buildFragment: function buildFragment(a, b, c, d) {\n\t\t\tfor (var e, f, g, h, i, j, k = b.createDocumentFragment(), l = [], m = 0, o = a.length; o > m; m++) {\n\t\t\t\tif (e = a[m], e || 0 === e) if (\"object\" === n.type(e)) n.merge(l, e.nodeType ? [e] : e);else if (fb.test(e)) {\n\t\t\t\t\tf = f || k.appendChild(b.createElement(\"div\")), g = (eb.exec(e) || [\"\", \"\"])[1].toLowerCase(), h = lb[g] || lb._default, f.innerHTML = h[1] + e.replace(db, \"<$1></$2>\") + h[2], j = h[0];while (j--) {\n\t\t\t\t\t\tf = f.lastChild;\n\t\t\t\t\t}n.merge(l, f.childNodes), f = k.firstChild, f.textContent = \"\";\n\t\t\t\t} else l.push(b.createTextNode(e));\n\t\t\t}k.textContent = \"\", m = 0;while (e = l[m++]) {\n\t\t\t\tif ((!d || -1 === n.inArray(e, d)) && (i = n.contains(e.ownerDocument, e), f = rb(k.appendChild(e), \"script\"), i && pb(f), c)) {\n\t\t\t\t\tj = 0;while (e = f[j++]) {\n\t\t\t\t\t\tib.test(e.type || \"\") && c.push(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}return k;\n\t\t}, cleanData: function cleanData(a) {\n\t\t\tfor (var b, c, d, e, f = n.event.special, g = 0; void 0 !== (c = a[g]); g++) {\n\t\t\t\tif (n.acceptData(c) && (e = c[O.expando], e && (b = O.cache[e]))) {\n\t\t\t\t\tif (b.events) for (d in b.events) {\n\t\t\t\t\t\tf[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);\n\t\t\t\t\t}O.cache[e] && delete O.cache[e];\n\t\t\t\t}delete P.cache[c[P.expando]];\n\t\t\t}\n\t\t} }), n.fn.extend({ text: function text(a) {\n\t\t\treturn M(this, function (a) {\n\t\t\t\treturn void 0 === a ? n.text(this) : this.empty().each(function () {\n\t\t\t\t\t(1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = a);\n\t\t\t\t});\n\t\t\t}, null, a, arguments.length);\n\t\t}, append: function append() {\n\t\t\treturn this.domManip(arguments, function (a) {\n\t\t\t\tif (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n\t\t\t\t\tvar b = mb(this, a);b.appendChild(a);\n\t\t\t\t}\n\t\t\t});\n\t\t}, prepend: function prepend() {\n\t\t\treturn this.domManip(arguments, function (a) {\n\t\t\t\tif (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n\t\t\t\t\tvar b = mb(this, a);b.insertBefore(a, b.firstChild);\n\t\t\t\t}\n\t\t\t});\n\t\t}, before: function before() {\n\t\t\treturn this.domManip(arguments, function (a) {\n\t\t\t\tthis.parentNode && this.parentNode.insertBefore(a, this);\n\t\t\t});\n\t\t}, after: function after() {\n\t\t\treturn this.domManip(arguments, function (a) {\n\t\t\t\tthis.parentNode && this.parentNode.insertBefore(a, this.nextSibling);\n\t\t\t});\n\t\t}, remove: function remove(a, b) {\n\t\t\tfor (var c, d = a ? n.filter(a, this) : this, e = 0; null != (c = d[e]); e++) {\n\t\t\t\tb || 1 !== c.nodeType || n.cleanData(rb(c)), c.parentNode && (b && n.contains(c.ownerDocument, c) && pb(rb(c, \"script\")), c.parentNode.removeChild(c));\n\t\t\t}return this;\n\t\t}, empty: function empty() {\n\t\t\tfor (var a, b = 0; null != (a = this[b]); b++) {\n\t\t\t\t1 === a.nodeType && (n.cleanData(rb(a, !1)), a.textContent = \"\");\n\t\t\t}return this;\n\t\t}, clone: function clone(a, b) {\n\t\t\treturn a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {\n\t\t\t\treturn n.clone(this, a, b);\n\t\t\t});\n\t\t}, html: function html(a) {\n\t\t\treturn M(this, function (a) {\n\t\t\t\tvar b = this[0] || {},\n\t\t\t\t    c = 0,\n\t\t\t\t    d = this.length;if (void 0 === a && 1 === b.nodeType) return b.innerHTML;if (\"string\" == typeof a && !gb.test(a) && !lb[(eb.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n\t\t\t\t\ta = a.replace(db, \"<$1></$2>\");try {\n\t\t\t\t\t\tfor (; d > c; c++) {\n\t\t\t\t\t\t\tb = this[c] || {}, 1 === b.nodeType && (n.cleanData(rb(b, !1)), b.innerHTML = a);\n\t\t\t\t\t\t}b = 0;\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}b && this.empty().append(a);\n\t\t\t}, null, a, arguments.length);\n\t\t}, replaceWith: function replaceWith() {\n\t\t\tvar a = arguments[0];return this.domManip(arguments, function (b) {\n\t\t\t\ta = this.parentNode, n.cleanData(rb(this)), a && a.replaceChild(b, this);\n\t\t\t}), a && (a.length || a.nodeType) ? this : this.remove();\n\t\t}, detach: function detach(a) {\n\t\t\treturn this.remove(a, !0);\n\t\t}, domManip: function domManip(a, b) {\n\t\t\ta = e.apply([], a);var c,\n\t\t\t    d,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j = 0,\n\t\t\t    l = this.length,\n\t\t\t    m = this,\n\t\t\t    o = l - 1,\n\t\t\t    p = a[0],\n\t\t\t    q = n.isFunction(p);if (q || l > 1 && \"string\" == typeof p && !k.checkClone && hb.test(p)) return this.each(function (c) {\n\t\t\t\tvar d = m.eq(c);q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);\n\t\t\t});if (l && (c = n.buildFragment(a, this[0].ownerDocument, !1, this), d = c.firstChild, 1 === c.childNodes.length && (c = d), d)) {\n\t\t\t\tfor (f = n.map(rb(c, \"script\"), nb), g = f.length; l > j; j++) {\n\t\t\t\t\th = c, j !== o && (h = n.clone(h, !0, !0), g && n.merge(f, rb(h, \"script\"))), b.call(this[j], h, j);\n\t\t\t\t}if (g) for (i = f[f.length - 1].ownerDocument, n.map(f, ob), j = 0; g > j; j++) {\n\t\t\t\t\th = f[j], ib.test(h.type || \"\") && !O.access(h, \"globalEval\") && n.contains(i, h) && (h.src ? n._evalUrl && n._evalUrl(h.src) : n.globalEval(h.textContent.replace(kb, \"\")));\n\t\t\t\t}\n\t\t\t}return this;\n\t\t} }), n.each({ appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\" }, function (a, b) {\n\t\tn.fn[a] = function (a) {\n\t\t\tfor (var c, d = [], e = n(a), g = e.length - 1, h = 0; g >= h; h++) {\n\t\t\t\tc = h === g ? this : this.clone(!0), n(e[h])[b](c), f.apply(d, c.get());\n\t\t\t}return this.pushStack(d);\n\t\t};\n\t});var tb,\n\t    ub = {};function vb(b, c) {\n\t\tvar d,\n\t\t    e = n(c.createElement(b)).appendTo(c.body),\n\t\t    f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : n.css(e[0], \"display\");return e.detach(), f;\n\t}function wb(a) {\n\t\tvar b = l,\n\t\t    c = ub[a];return c || (c = vb(a, b), \"none\" !== c && c || (tb = (tb || n(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement), b = tb[0].contentDocument, b.write(), b.close(), c = vb(a, b), tb.detach()), ub[a] = c), c;\n\t}var xb = /^margin/,\n\t    yb = new RegExp(\"^(\" + T + \")(?!px)[a-z%]+$\", \"i\"),\n\t    zb = function zb(a) {\n\t\treturn a.ownerDocument.defaultView.getComputedStyle(a, null);\n\t};function Ab(a, b, c) {\n\t\tvar d,\n\t\t    e,\n\t\t    f,\n\t\t    g,\n\t\t    h = a.style;return c = c || zb(a), c && (g = c.getPropertyValue(b) || c[b]), c && (\"\" !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), yb.test(g) && xb.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + \"\" : g;\n\t}function Bb(a, b) {\n\t\treturn { get: function get() {\n\t\t\t\treturn a() ? void delete this.get : (this.get = b).apply(this, arguments);\n\t\t\t} };\n\t}!function () {\n\t\tvar b,\n\t\t    c,\n\t\t    d = l.documentElement,\n\t\t    e = l.createElement(\"div\"),\n\t\t    f = l.createElement(\"div\");if (f.style) {\n\t\t\tvar _g = function _g() {\n\t\t\t\tf.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute\", f.innerHTML = \"\", d.appendChild(e);var g = a.getComputedStyle(f, null);b = \"1%\" !== g.top, c = \"4px\" === g.width, d.removeChild(e);\n\t\t\t};\n\n\t\t\tf.style.backgroundClip = \"content-box\", f.cloneNode(!0).style.backgroundClip = \"\", k.clearCloneStyle = \"content-box\" === f.style.backgroundClip, e.style.cssText = \"border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute\", e.appendChild(f);a.getComputedStyle && n.extend(k, { pixelPosition: function pixelPosition() {\n\t\t\t\t\treturn _g(), b;\n\t\t\t\t}, boxSizingReliable: function boxSizingReliable() {\n\t\t\t\t\treturn null == c && _g(), c;\n\t\t\t\t}, reliableMarginRight: function reliableMarginRight() {\n\t\t\t\t\tvar b,\n\t\t\t\t\t    c = f.appendChild(l.createElement(\"div\"));return c.style.cssText = f.style.cssText = \"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\", c.style.marginRight = c.style.width = \"0\", f.style.width = \"1px\", d.appendChild(e), b = !parseFloat(a.getComputedStyle(c, null).marginRight), d.removeChild(e), b;\n\t\t\t\t} });\n\t\t}\n\t}(), n.swap = function (a, b, c, d) {\n\t\tvar e,\n\t\t    f,\n\t\t    g = {};for (f in b) {\n\t\t\tg[f] = a.style[f], a.style[f] = b[f];\n\t\t}e = c.apply(a, d || []);for (f in b) {\n\t\t\ta.style[f] = g[f];\n\t\t}return e;\n\t};var Cb = /^(none|table(?!-c[ea]).+)/,\n\t    Db = new RegExp(\"^(\" + T + \")(.*)$\", \"i\"),\n\t    Eb = new RegExp(\"^([+-])=(\" + T + \")\", \"i\"),\n\t    Fb = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t    Gb = { letterSpacing: \"0\", fontWeight: \"400\" },\n\t    Hb = [\"Webkit\", \"O\", \"Moz\", \"ms\"];function Ib(a, b) {\n\t\tif (b in a) return b;var c = b[0].toUpperCase() + b.slice(1),\n\t\t    d = b,\n\t\t    e = Hb.length;while (e--) {\n\t\t\tif (b = Hb[e] + c, b in a) return b;\n\t\t}return d;\n\t}function Jb(a, b, c) {\n\t\tvar d = Db.exec(b);return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || \"px\") : b;\n\t}function Kb(a, b, c, d, e) {\n\t\tfor (var f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0, g = 0; 4 > f; f += 2) {\n\t\t\t\"margin\" === c && (g += n.css(a, c + U[f], !0, e)), d ? (\"content\" === c && (g -= n.css(a, \"padding\" + U[f], !0, e)), \"margin\" !== c && (g -= n.css(a, \"border\" + U[f] + \"Width\", !0, e))) : (g += n.css(a, \"padding\" + U[f], !0, e), \"padding\" !== c && (g += n.css(a, \"border\" + U[f] + \"Width\", !0, e)));\n\t\t}return g;\n\t}function Lb(a, b, c) {\n\t\tvar d = !0,\n\t\t    e = \"width\" === b ? a.offsetWidth : a.offsetHeight,\n\t\t    f = zb(a),\n\t\t    g = \"border-box\" === n.css(a, \"boxSizing\", !1, f);if (0 >= e || null == e) {\n\t\t\tif (e = Ab(a, b, f), (0 > e || null == e) && (e = a.style[b]), yb.test(e)) return e;d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;\n\t\t}return e + Kb(a, b, c || (g ? \"border\" : \"content\"), d, f) + \"px\";\n\t}function Mb(a, b) {\n\t\tfor (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) {\n\t\t\td = a[g], d.style && (f[g] = O.get(d, \"olddisplay\"), c = d.style.display, b ? (f[g] || \"none\" !== c || (d.style.display = \"\"), \"\" === d.style.display && V(d) && (f[g] = O.access(d, \"olddisplay\", wb(d.nodeName)))) : (e = V(d), \"none\" === c && e || O.set(d, \"olddisplay\", e ? c : n.css(d, \"display\"))));\n\t\t}for (g = 0; h > g; g++) {\n\t\t\td = a[g], d.style && (b && \"none\" !== d.style.display && \"\" !== d.style.display || (d.style.display = b ? f[g] || \"\" : \"none\"));\n\t\t}return a;\n\t}n.extend({ cssHooks: { opacity: { get: function get(a, b) {\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\tvar c = Ab(a, \"opacity\");return \"\" === c ? \"1\" : c;\n\t\t\t\t\t}\n\t\t\t\t} } }, cssNumber: { columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { \"float\": \"cssFloat\" }, style: function style(a, b, c, d) {\n\t\t\tif (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n\t\t\t\tvar e,\n\t\t\t\t    f,\n\t\t\t\t    g,\n\t\t\t\t    h = n.camelCase(b),\n\t\t\t\t    i = a.style;return b = n.cssProps[h] || (n.cssProps[h] = Ib(i, h)), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c === \"undefined\" ? \"undefined\" : _typeof(c), \"string\" === f && (e = Eb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(n.css(a, b)), f = \"number\"), null != c && c === c && (\"number\" !== f || n.cssNumber[h] || (c += \"px\"), k.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (i[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);\n\t\t\t}\n\t\t}, css: function css(a, b, c, d) {\n\t\t\tvar e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h = n.camelCase(b);return b = n.cssProps[h] || (n.cssProps[h] = Ib(a.style, h)), g = n.cssHooks[b] || n.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Ab(a, b, d)), \"normal\" === e && b in Gb && (e = Gb[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || n.isNumeric(f) ? f || 0 : e) : e;\n\t\t} }), n.each([\"height\", \"width\"], function (a, b) {\n\t\tn.cssHooks[b] = { get: function get(a, c, d) {\n\t\t\t\treturn c ? Cb.test(n.css(a, \"display\")) && 0 === a.offsetWidth ? n.swap(a, Fb, function () {\n\t\t\t\t\treturn Lb(a, b, d);\n\t\t\t\t}) : Lb(a, b, d) : void 0;\n\t\t\t}, set: function set(a, c, d) {\n\t\t\t\tvar e = d && zb(a);return Jb(a, c, d ? Kb(a, b, d, \"border-box\" === n.css(a, \"boxSizing\", !1, e), e) : 0);\n\t\t\t} };\n\t}), n.cssHooks.marginRight = Bb(k.reliableMarginRight, function (a, b) {\n\t\treturn b ? n.swap(a, { display: \"inline-block\" }, Ab, [a, \"marginRight\"]) : void 0;\n\t}), n.each({ margin: \"\", padding: \"\", border: \"Width\" }, function (a, b) {\n\t\tn.cssHooks[a + b] = { expand: function expand(c) {\n\t\t\t\tfor (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; 4 > d; d++) {\n\t\t\t\t\te[a + U[d] + b] = f[d] || f[d - 2] || f[0];\n\t\t\t\t}return e;\n\t\t\t} }, xb.test(a) || (n.cssHooks[a + b].set = Jb);\n\t}), n.fn.extend({ css: function css(a, b) {\n\t\t\treturn M(this, function (a, b, c) {\n\t\t\t\tvar d,\n\t\t\t\t    e,\n\t\t\t\t    f = {},\n\t\t\t\t    g = 0;if (n.isArray(b)) {\n\t\t\t\t\tfor (d = zb(a), e = b.length; e > g; g++) {\n\t\t\t\t\t\tf[b[g]] = n.css(a, b[g], !1, d);\n\t\t\t\t\t}return f;\n\t\t\t\t}return void 0 !== c ? n.style(a, b, c) : n.css(a, b);\n\t\t\t}, a, b, arguments.length > 1);\n\t\t}, show: function show() {\n\t\t\treturn Mb(this, !0);\n\t\t}, hide: function hide() {\n\t\t\treturn Mb(this);\n\t\t}, toggle: function toggle(a) {\n\t\t\treturn \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function () {\n\t\t\t\tV(this) ? n(this).show() : n(this).hide();\n\t\t\t});\n\t\t} }), n.fn.delay = function (a, b) {\n\t\treturn a = n.fx ? n.fx.speeds[a] || a : a, b = b || \"fx\", this.queue(b, function (b, c) {\n\t\t\tvar d = setTimeout(b, a);c.stop = function () {\n\t\t\t\tclearTimeout(d);\n\t\t\t};\n\t\t});\n\t}, function () {\n\t\tvar a = l.createElement(\"input\"),\n\t\t    b = l.createElement(\"select\"),\n\t\t    c = b.appendChild(l.createElement(\"option\"));a.type = \"checkbox\", k.checkOn = \"\" !== a.value, k.optSelected = c.selected, b.disabled = !0, k.optDisabled = !c.disabled, a = l.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", k.radioValue = \"t\" === a.value;\n\t}();var Nb,\n\t    Ob,\n\t    Pb = n.expr.attrHandle;n.fn.extend({ attr: function attr(a, b) {\n\t\t\treturn M(this, n.attr, a, b, arguments.length > 1);\n\t\t}, removeAttr: function removeAttr(a) {\n\t\t\treturn this.each(function () {\n\t\t\t\tn.removeAttr(this, a);\n\t\t\t});\n\t\t} }), n.extend({ attr: function attr(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e,\n\t\t\t    f = a.nodeType;if (a && 3 !== f && 8 !== f && 2 !== f) return _typeof(a.getAttribute) === X ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), d = n.attrHooks[b] || (n.expr.match.bool.test(b) ? Ob : Nb)), void 0 === c ? d && \"get\" in d && null !== (e = d.get(a, b)) ? e : (e = n.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && \"set\" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + \"\"), c) : void n.removeAttr(a, b));\n\t\t}, removeAttr: function removeAttr(a, b) {\n\t\t\tvar c,\n\t\t\t    d,\n\t\t\t    e = 0,\n\t\t\t    f = b && b.match(H);if (f && 1 === a.nodeType) while (c = f[e++]) {\n\t\t\t\td = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c);\n\t\t\t}\n\t\t}, attrHooks: { type: { set: function set(a, b) {\n\t\t\t\t\tif (!k.radioValue && \"radio\" === b && n.nodeName(a, \"input\")) {\n\t\t\t\t\t\tvar c = a.value;return a.setAttribute(\"type\", b), c && (a.value = c), b;\n\t\t\t\t\t}\n\t\t\t\t} } } }), Ob = { set: function set(a, b, c) {\n\t\t\treturn b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;\n\t\t} }, n.each(n.expr.match.bool.source.match(/\\w+/g), function (a, b) {\n\t\tvar c = Pb[b] || n.find.attr;Pb[b] = function (a, b, d) {\n\t\t\tvar e, f;return d || (f = Pb[b], Pb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, Pb[b] = f), e;\n\t\t};\n\t});var Qb = /^(?:input|select|textarea|button)$/i;n.fn.extend({ prop: function prop(a, b) {\n\t\t\treturn M(this, n.prop, a, b, arguments.length > 1);\n\t\t}, removeProp: function removeProp(a) {\n\t\t\treturn this.each(function () {\n\t\t\t\tdelete this[n.propFix[a] || a];\n\t\t\t});\n\t\t} }), n.extend({ propFix: { \"for\": \"htmlFor\", \"class\": \"className\" }, prop: function prop(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g = a.nodeType;if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !n.isXMLDoc(a), f && (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b];\n\t\t}, propHooks: { tabIndex: { get: function get(a) {\n\t\t\t\t\treturn a.hasAttribute(\"tabindex\") || Qb.test(a.nodeName) || a.href ? a.tabIndex : -1;\n\t\t\t\t} } } }), k.optSelected || (n.propHooks.selected = { get: function get(a) {\n\t\t\tvar b = a.parentNode;return b && b.parentNode && b.parentNode.selectedIndex, null;\n\t\t} }), n.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n\t\tn.propFix[this.toLowerCase()] = this;\n\t});var Rb = /[\\t\\r\\n\\f]/g;n.fn.extend({ addClass: function addClass(a) {\n\t\t\tvar b,\n\t\t\t    c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h = \"string\" == typeof a && a,\n\t\t\t    i = 0,\n\t\t\t    j = this.length;if (n.isFunction(a)) return this.each(function (b) {\n\t\t\t\tn(this).addClass(a.call(this, b, this.className));\n\t\t\t});if (h) for (b = (a || \"\").match(H) || []; j > i; i++) {\n\t\t\t\tif (c = this[i], d = 1 === c.nodeType && (c.className ? (\" \" + c.className + \" \").replace(Rb, \" \") : \" \")) {\n\t\t\t\t\tf = 0;while (e = b[f++]) {\n\t\t\t\t\t\td.indexOf(\" \" + e + \" \") < 0 && (d += e + \" \");\n\t\t\t\t\t}g = n.trim(d), c.className !== g && (c.className = g);\n\t\t\t\t}\n\t\t\t}return this;\n\t\t}, removeClass: function removeClass(a) {\n\t\t\tvar b,\n\t\t\t    c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h = 0 === arguments.length || \"string\" == typeof a && a,\n\t\t\t    i = 0,\n\t\t\t    j = this.length;if (n.isFunction(a)) return this.each(function (b) {\n\t\t\t\tn(this).removeClass(a.call(this, b, this.className));\n\t\t\t});if (h) for (b = (a || \"\").match(H) || []; j > i; i++) {\n\t\t\t\tif (c = this[i], d = 1 === c.nodeType && (c.className ? (\" \" + c.className + \" \").replace(Rb, \" \") : \"\")) {\n\t\t\t\t\tf = 0;while (e = b[f++]) {\n\t\t\t\t\t\twhile (d.indexOf(\" \" + e + \" \") >= 0) {\n\t\t\t\t\t\t\td = d.replace(\" \" + e + \" \", \" \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}g = a ? n.trim(d) : \"\", c.className !== g && (c.className = g);\n\t\t\t\t}\n\t\t\t}return this;\n\t\t}, toggleClass: function toggleClass(a, b) {\n\t\t\tvar c = typeof a === \"undefined\" ? \"undefined\" : _typeof(a);return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(n.isFunction(a) ? function (c) {\n\t\t\t\tn(this).toggleClass(a.call(this, c, this.className, b), b);\n\t\t\t} : function () {\n\t\t\t\tif (\"string\" === c) {\n\t\t\t\t\tvar b,\n\t\t\t\t\t    d = 0,\n\t\t\t\t\t    e = n(this),\n\t\t\t\t\t    f = a.match(H) || [];while (b = f[d++]) {\n\t\t\t\t\t\te.hasClass(b) ? e.removeClass(b) : e.addClass(b);\n\t\t\t\t\t}\n\t\t\t\t} else (c === X || \"boolean\" === c) && (this.className && O.set(this, \"__className__\", this.className), this.className = this.className || a === !1 ? \"\" : O.get(this, \"__className__\") || \"\");\n\t\t\t});\n\t\t}, hasClass: function hasClass(a) {\n\t\t\tfor (var b = \" \" + a + \" \", c = 0, d = this.length; d > c; c++) {\n\t\t\t\tif (1 === this[c].nodeType && (\" \" + this[c].className + \" \").replace(Rb, \" \").indexOf(b) >= 0) return !0;\n\t\t\t}return !1;\n\t\t} });var Sb = /\\r/g;n.fn.extend({ val: function val(a) {\n\t\t\tvar b,\n\t\t\t    c,\n\t\t\t    d,\n\t\t\t    e = this[0];{\n\t\t\t\tif (arguments.length) return d = n.isFunction(a), this.each(function (c) {\n\t\t\t\t\tvar e;1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : n.isArray(e) && (e = n.map(e, function (a) {\n\t\t\t\t\t\treturn null == a ? \"\" : a + \"\";\n\t\t\t\t\t})), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e));\n\t\t\t\t});if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(Sb, \"\") : null == c ? \"\" : c);\n\t\t\t}\n\t\t} }), n.extend({ valHooks: { option: { get: function get(a) {\n\t\t\t\t\tvar b = n.find.attr(a, \"value\");return null != b ? b : n.trim(n.text(a));\n\t\t\t\t} }, select: { get: function get(a) {\n\t\t\t\t\tfor (var b, c, d = a.options, e = a.selectedIndex, f = \"select-one\" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) {\n\t\t\t\t\t\tif (c = d[i], !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute(\"disabled\")) || c.parentNode.disabled && n.nodeName(c.parentNode, \"optgroup\"))) {\n\t\t\t\t\t\t\tif (b = n(c).val(), f) return b;g.push(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}return g;\n\t\t\t\t}, set: function set(a, b) {\n\t\t\t\t\tvar c,\n\t\t\t\t\t    d,\n\t\t\t\t\t    e = a.options,\n\t\t\t\t\t    f = n.makeArray(b),\n\t\t\t\t\t    g = e.length;while (g--) {\n\t\t\t\t\t\td = e[g], (d.selected = n.inArray(d.value, f) >= 0) && (c = !0);\n\t\t\t\t\t}return c || (a.selectedIndex = -1), f;\n\t\t\t\t} } } }), n.each([\"radio\", \"checkbox\"], function () {\n\t\tn.valHooks[this] = { set: function set(a, b) {\n\t\t\t\treturn n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) >= 0 : void 0;\n\t\t\t} }, k.checkOn || (n.valHooks[this].get = function (a) {\n\t\t\treturn null === a.getAttribute(\"value\") ? \"on\" : a.value;\n\t\t});\n\t}), n.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function (a, b) {\n\t\tn.fn[b] = function (a, c) {\n\t\t\treturn arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);\n\t\t};\n\t}), n.fn.extend({ hover: function hover(a, b) {\n\t\t\treturn this.mouseenter(a).mouseleave(b || a);\n\t\t}, bind: function bind(a, b, c) {\n\t\t\treturn this.on(a, null, b, c);\n\t\t}, unbind: function unbind(a, b) {\n\t\t\treturn this.off(a, null, b);\n\t\t}, delegate: function delegate(a, b, c, d) {\n\t\t\treturn this.on(b, a, c, d);\n\t\t}, undelegate: function undelegate(a, b, c) {\n\t\t\treturn 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c);\n\t\t} });var Tb = n.now(),\n\t    Ub = /\\?/;n.parseJSON = function (a) {\n\t\treturn JSON.parse(a + \"\");\n\t}, n.parseXML = function (a) {\n\t\tvar b, c;if (!a || \"string\" != typeof a) return null;try {\n\t\t\tc = new DOMParser(), b = c.parseFromString(a, \"text/xml\");\n\t\t} catch (d) {\n\t\t\tb = void 0;\n\t\t}return (!b || b.getElementsByTagName(\"parsererror\").length) && n.error(\"Invalid XML: \" + a), b;\n\t};var Vb,\n\t    Wb,\n\t    Xb = /#.*$/,\n\t    Yb = /([?&])_=[^&]*/,\n\t    Zb = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n\t    $b = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t    _b = /^(?:GET|HEAD)$/,\n\t    ac = /^\\/\\//,\n\t    bc = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\t    cc = {},\n\t    dc = {},\n\t    ec = \"*/\".concat(\"*\");try {\n\t\tWb = location.href;\n\t} catch (fc) {\n\t\tWb = l.createElement(\"a\"), Wb.href = \"\", Wb = Wb.href;\n\t}Vb = bc.exec(Wb.toLowerCase()) || [];function gc(a) {\n\t\treturn function (b, c) {\n\t\t\t\"string\" != typeof b && (c = b, b = \"*\");var d,\n\t\t\t    e = 0,\n\t\t\t    f = b.toLowerCase().match(H) || [];if (n.isFunction(c)) while (d = f[e++]) {\n\t\t\t\t\"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);\n\t\t\t}\n\t\t};\n\t}function hc(a, b, c, d) {\n\t\tvar e = {},\n\t\t    f = a === dc;function g(h) {\n\t\t\tvar i;return e[h] = !0, n.each(a[h] || [], function (a, h) {\n\t\t\t\tvar j = h(b, c, d);return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);\n\t\t\t}), i;\n\t\t}return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\");\n\t}function ic(a, b) {\n\t\tvar c,\n\t\t    d,\n\t\t    e = n.ajaxSettings.flatOptions || {};for (c in b) {\n\t\t\tvoid 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n\t\t}return d && n.extend(!0, a, d), a;\n\t}function jc(a, b, c) {\n\t\tvar d,\n\t\t    e,\n\t\t    f,\n\t\t    g,\n\t\t    h = a.contents,\n\t\t    i = a.dataTypes;while (\"*\" === i[0]) {\n\t\t\ti.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n\t\t}if (d) for (e in h) {\n\t\t\tif (h[e] && h[e].test(d)) {\n\t\t\t\ti.unshift(e);break;\n\t\t\t}\n\t\t}if (i[0] in c) f = i[0];else {\n\t\t\tfor (e in c) {\n\t\t\t\tif (!i[0] || a.converters[e + \" \" + i[0]]) {\n\t\t\t\t\tf = e;break;\n\t\t\t\t}g || (g = e);\n\t\t\t}f = f || g;\n\t\t}return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;\n\t}function kc(a, b, c, d) {\n\t\tvar e,\n\t\t    f,\n\t\t    g,\n\t\t    h,\n\t\t    i,\n\t\t    j = {},\n\t\t    k = a.dataTypes.slice();if (k[1]) for (g in a.converters) {\n\t\t\tj[g.toLowerCase()] = a.converters[g];\n\t\t}f = k.shift();while (f) {\n\t\t\tif (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if (\"*\" === f) f = i;else if (\"*\" !== i && i !== f) {\n\t\t\t\tif (g = j[i + \" \" + f] || j[\"* \" + f], !g) for (e in j) {\n\t\t\t\t\tif (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n\t\t\t\t\t\tg === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));break;\n\t\t\t\t\t}\n\t\t\t\t}if (g !== !0) if (g && a[\"throws\"]) b = g(b);else try {\n\t\t\t\t\tb = g(b);\n\t\t\t\t} catch (l) {\n\t\t\t\t\treturn { state: \"parsererror\", error: g ? l : \"No conversion from \" + i + \" to \" + f };\n\t\t\t\t}\n\t\t\t}\n\t\t}return { state: \"success\", data: b };\n\t}n.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: Wb, type: \"GET\", isLocal: $b.test(Vb[1]), global: !0, processData: !0, async: !0, contentType: \"application/x-www-form-urlencoded; charset=UTF-8\", accepts: { \"*\": ec, text: \"text/plain\", html: \"text/html\", xml: \"application/xml, text/xml\", json: \"application/json, text/javascript\" }, contents: { xml: /xml/, html: /html/, json: /json/ }, responseFields: { xml: \"responseXML\", text: \"responseText\", json: \"responseJSON\" }, converters: { \"* text\": String, \"text html\": !0, \"text json\": n.parseJSON, \"text xml\": n.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function ajaxSetup(a, b) {\n\t\t\treturn b ? ic(ic(a, n.ajaxSettings), b) : ic(n.ajaxSettings, a);\n\t\t}, ajaxPrefilter: gc(cc), ajaxTransport: gc(dc), ajax: function ajax(a, b) {\n\t\t\t\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) && (b = a, a = void 0), b = b || {};var c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k = n.ajaxSetup({}, b),\n\t\t\t    l = k.context || k,\n\t\t\t    m = k.context && (l.nodeType || l.jquery) ? n(l) : n.event,\n\t\t\t    o = n.Deferred(),\n\t\t\t    p = n.Callbacks(\"once memory\"),\n\t\t\t    q = k.statusCode || {},\n\t\t\t    r = {},\n\t\t\t    s = {},\n\t\t\t    t = 0,\n\t\t\t    u = \"canceled\",\n\t\t\t    v = { readyState: 0, getResponseHeader: function getResponseHeader(a) {\n\t\t\t\t\tvar b;if (2 === t) {\n\t\t\t\t\t\tif (!f) {\n\t\t\t\t\t\t\tf = {};while (b = Zb.exec(e)) {\n\t\t\t\t\t\t\t\tf[b[1].toLowerCase()] = b[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}b = f[a.toLowerCase()];\n\t\t\t\t\t}return null == b ? null : b;\n\t\t\t\t}, getAllResponseHeaders: function getAllResponseHeaders() {\n\t\t\t\t\treturn 2 === t ? e : null;\n\t\t\t\t}, setRequestHeader: function setRequestHeader(a, b) {\n\t\t\t\t\tvar c = a.toLowerCase();return t || (a = s[c] = s[c] || a, r[a] = b), this;\n\t\t\t\t}, overrideMimeType: function overrideMimeType(a) {\n\t\t\t\t\treturn t || (k.mimeType = a), this;\n\t\t\t\t}, statusCode: function statusCode(a) {\n\t\t\t\t\tvar b;if (a) if (2 > t) for (b in a) {\n\t\t\t\t\t\tq[b] = [q[b], a[b]];\n\t\t\t\t\t} else v.always(a[v.status]);return this;\n\t\t\t\t}, abort: function abort(a) {\n\t\t\t\t\tvar b = a || u;return c && c.abort(b), x(0, b), this;\n\t\t\t\t} };if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || Wb) + \"\").replace(Xb, \"\").replace(ac, Vb[1] + \"//\"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = n.trim(k.dataType || \"*\").toLowerCase().match(H) || [\"\"], null == k.crossDomain && (h = bc.exec(k.url.toLowerCase()), k.crossDomain = !(!h || h[1] === Vb[1] && h[2] === Vb[2] && (h[3] || (\"http:\" === h[1] ? \"80\" : \"443\")) === (Vb[3] || (\"http:\" === Vb[1] ? \"80\" : \"443\")))), k.data && k.processData && \"string\" != typeof k.data && (k.data = n.param(k.data, k.traditional)), hc(cc, k, b, v), 2 === t) return v;i = k.global, i && 0 === n.active++ && n.event.trigger(\"ajaxStart\"), k.type = k.type.toUpperCase(), k.hasContent = !_b.test(k.type), d = k.url, k.hasContent || (k.data && (d = k.url += (Ub.test(d) ? \"&\" : \"?\") + k.data, delete k.data), k.cache === !1 && (k.url = Yb.test(d) ? d.replace(Yb, \"$1_=\" + Tb++) : d + (Ub.test(d) ? \"&\" : \"?\") + \"_=\" + Tb++)), k.ifModified && (n.lastModified[d] && v.setRequestHeader(\"If-Modified-Since\", n.lastModified[d]), n.etag[d] && v.setRequestHeader(\"If-None-Match\", n.etag[d])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader(\"Content-Type\", k.contentType), v.setRequestHeader(\"Accept\", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + (\"*\" !== k.dataTypes[0] ? \", \" + ec + \"; q=0.01\" : \"\") : k.accepts[\"*\"]);for (j in k.headers) {\n\t\t\t\tv.setRequestHeader(j, k.headers[j]);\n\t\t\t}if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();u = \"abort\";for (j in { success: 1, error: 1, complete: 1 }) {\n\t\t\t\tv[j](k[j]);\n\t\t\t}if (c = hc(dc, k, b, v)) {\n\t\t\t\tv.readyState = 1, i && m.trigger(\"ajaxSend\", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function () {\n\t\t\t\t\tv.abort(\"timeout\");\n\t\t\t\t}, k.timeout));try {\n\t\t\t\t\tt = 1, c.send(r, x);\n\t\t\t\t} catch (w) {\n\t\t\t\t\tif (!(2 > t)) throw w;x(-1, w);\n\t\t\t\t}\n\t\t\t} else x(-1, \"No Transport\");function x(a, b, f, h) {\n\t\t\t\tvar j,\n\t\t\t\t    r,\n\t\t\t\t    s,\n\t\t\t\t    u,\n\t\t\t\t    w,\n\t\t\t\t    x = b;2 !== t && (t = 2, g && clearTimeout(g), c = void 0, e = h || \"\", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, f && (u = jc(k, v, f)), u = kc(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader(\"Last-Modified\"), w && (n.lastModified[d] = w), w = v.getResponseHeader(\"etag\"), w && (n.etag[d] = w)), 204 === a || \"HEAD\" === k.type ? x = \"nocontent\" : 304 === a ? x = \"notmodified\" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = \"error\", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + \"\", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, i && m.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [v, k, j ? r : s]), p.fireWith(l, [v, x]), i && (m.trigger(\"ajaxComplete\", [v, k]), --n.active || n.event.trigger(\"ajaxStop\")));\n\t\t\t}return v;\n\t\t}, getJSON: function getJSON(a, b, c) {\n\t\t\treturn n.get(a, b, c, \"json\");\n\t\t}, getScript: function getScript(a, b) {\n\t\t\treturn n.get(a, void 0, b, \"script\");\n\t\t} }), n.each([\"get\", \"post\"], function (a, b) {\n\t\tn[b] = function (a, c, d, e) {\n\t\t\treturn n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax({ url: a, type: b, dataType: e, data: c, success: d });\n\t\t};\n\t}), n.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (a, b) {\n\t\tn.fn[b] = function (a) {\n\t\t\treturn this.on(b, a);\n\t\t};\n\t}), n._evalUrl = function (a) {\n\t\treturn n.ajax({ url: a, type: \"GET\", dataType: \"script\", async: !1, global: !1, \"throws\": !0 });\n\t};var lc = /%20/g,\n\t    mc = /\\[\\]$/,\n\t    nc = /\\r?\\n/g,\n\t    oc = /^(?:submit|button|image|reset|file)$/i,\n\t    pc = /^(?:input|select|textarea|keygen)/i;function qc(a, b, c, d) {\n\t\tvar e;if (n.isArray(b)) n.each(b, function (b, e) {\n\t\t\tc || mc.test(a) ? d(a, e) : qc(a + \"[\" + (\"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) ? b : \"\") + \"]\", e, c, d);\n\t\t});else if (c || \"object\" !== n.type(b)) d(a, b);else for (e in b) {\n\t\t\tqc(a + \"[\" + e + \"]\", b[e], c, d);\n\t\t}\n\t}n.param = function (a, b) {\n\t\tvar c,\n\t\t    d = [],\n\t\t    e = function e(a, b) {\n\t\t\tb = n.isFunction(b) ? b() : null == b ? \"\" : b, d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(b);\n\t\t};if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () {\n\t\t\te(this.name, this.value);\n\t\t});else for (c in a) {\n\t\t\tqc(c, a[c], b, e);\n\t\t}return d.join(\"&\").replace(lc, \"+\");\n\t}, n.fn.extend({ serialize: function serialize() {\n\t\t\treturn n.param(this.serializeArray());\n\t\t}, serializeArray: function serializeArray() {\n\t\t\treturn this.map(function () {\n\t\t\t\tvar a = n.prop(this, \"elements\");return a ? n.makeArray(a) : this;\n\t\t\t}).filter(function () {\n\t\t\t\tvar a = this.type;return this.name && !n(this).is(\":disabled\") && pc.test(this.nodeName) && !oc.test(a) && (this.checked || !W.test(a));\n\t\t\t}).map(function (a, b) {\n\t\t\t\tvar c = n(this).val();return null == c ? null : n.isArray(c) ? n.map(c, function (a) {\n\t\t\t\t\treturn { name: b.name, value: a.replace(nc, \"\\r\\n\") };\n\t\t\t\t}) : { name: b.name, value: c.replace(nc, \"\\r\\n\") };\n\t\t\t}).get();\n\t\t} }), n.ajaxSettings.xhr = function () {\n\t\ttry {\n\t\t\treturn new XMLHttpRequest();\n\t\t} catch (a) {}\n\t};var rc = 0,\n\t    sc = {},\n\t    tc = { 0: 200, 1223: 204 },\n\t    uc = n.ajaxSettings.xhr();a.ActiveXObject && n(a).on(\"unload\", function () {\n\t\tfor (var a in sc) {\n\t\t\tsc[a]();\n\t\t}\n\t}), k.cors = !!uc && \"withCredentials\" in uc, k.ajax = uc = !!uc, n.ajaxTransport(function (a) {\n\t\tvar _b3;return k.cors || uc && !a.crossDomain ? { send: function send(c, d) {\n\t\t\t\tvar e,\n\t\t\t\t    f = a.xhr(),\n\t\t\t\t    g = ++rc;if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) {\n\t\t\t\t\tf[e] = a.xhrFields[e];\n\t\t\t\t}a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c[\"X-Requested-With\"] || (c[\"X-Requested-With\"] = \"XMLHttpRequest\");for (e in c) {\n\t\t\t\t\tf.setRequestHeader(e, c[e]);\n\t\t\t\t}_b3 = function b(a) {\n\t\t\t\t\treturn function () {\n\t\t\t\t\t\t_b3 && (delete sc[g], _b3 = f.onload = f.onerror = null, \"abort\" === a ? f.abort() : \"error\" === a ? d(f.status, f.statusText) : d(tc[f.status] || f.status, f.statusText, \"string\" == typeof f.responseText ? { text: f.responseText } : void 0, f.getAllResponseHeaders()));\n\t\t\t\t\t};\n\t\t\t\t}, f.onload = _b3(), f.onerror = _b3(\"error\"), _b3 = sc[g] = _b3(\"abort\");try {\n\t\t\t\t\tf.send(a.hasContent && a.data || null);\n\t\t\t\t} catch (h) {\n\t\t\t\t\tif (_b3) throw h;\n\t\t\t\t}\n\t\t\t}, abort: function abort() {\n\t\t\t\t_b3 && _b3();\n\t\t\t} } : void 0;\n\t}), n.ajaxSetup({ accepts: { script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\" }, contents: { script: /(?:java|ecma)script/ }, converters: { \"text script\": function textScript(a) {\n\t\t\t\treturn n.globalEval(a), a;\n\t\t\t} } }), n.ajaxPrefilter(\"script\", function (a) {\n\t\tvoid 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\");\n\t}), n.ajaxTransport(\"script\", function (a) {\n\t\tif (a.crossDomain) {\n\t\t\tvar b, _c;return { send: function send(d, e) {\n\t\t\t\t\tb = n(\"<script>\").prop({ async: !0, charset: a.scriptCharset, src: a.url }).on(\"load error\", _c = function c(a) {\n\t\t\t\t\t\tb.remove(), _c = null, a && e(\"error\" === a.type ? 404 : 200, a.type);\n\t\t\t\t\t}), l.head.appendChild(b[0]);\n\t\t\t\t}, abort: function abort() {\n\t\t\t\t\t_c && _c();\n\t\t\t\t} };\n\t\t}\n\t});var vc = [],\n\t    wc = /(=)\\?(?=&|$)|\\?\\?/;n.ajaxSetup({ jsonp: \"callback\", jsonpCallback: function jsonpCallback() {\n\t\t\tvar a = vc.pop() || n.expando + \"_\" + Tb++;return this[a] = !0, a;\n\t\t} }), n.ajaxPrefilter(\"json jsonp\", function (b, c, d) {\n\t\tvar e,\n\t\t    f,\n\t\t    g,\n\t\t    h = b.jsonp !== !1 && (wc.test(b.url) ? \"url\" : \"string\" == typeof b.data && !(b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && wc.test(b.data) && \"data\");return h || \"jsonp\" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(wc, \"$1\" + e) : b.jsonp !== !1 && (b.url += (Ub.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function () {\n\t\t\treturn g || n.error(e + \" was not called\"), g[0];\n\t\t}, b.dataTypes[0] = \"json\", f = a[e], a[e] = function () {\n\t\t\tg = arguments;\n\t\t}, d.always(function () {\n\t\t\ta[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, vc.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0;\n\t\t}), \"script\") : void 0;\n\t}), n.parseHTML = function (a, b, c) {\n\t\tif (!a || \"string\" != typeof a) return null;\"boolean\" == typeof b && (c = b, b = !1), b = b || l;var d = y.exec(a),\n\t\t    e = !c && [];return d ? [b.createElement(d[1])] : (d = n.buildFragment([a], b, e), e && e.length && n(e).remove(), n.merge([], d.childNodes));\n\t};var xc = n.fn.load;n.fn.load = function (a, b, c) {\n\t\tif (\"string\" != typeof a && xc) return xc.apply(this, arguments);var d,\n\t\t    e,\n\t\t    f,\n\t\t    g = this,\n\t\t    h = a.indexOf(\" \");return h >= 0 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (e = \"POST\"), g.length > 0 && n.ajax({ url: a, type: e, dataType: \"html\", data: b }).done(function (a) {\n\t\t\tf = arguments, g.html(d ? n(\"<div>\").append(n.parseHTML(a)).find(d) : a);\n\t\t}).complete(c && function (a, b) {\n\t\t\tg.each(c, f || [a.responseText, b, a]);\n\t\t}), this;\n\t};var t = a.document.documentElement;function yc(a) {\n\t\treturn n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;\n\t}n.offset = { setOffset: function setOffset(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k = n.css(a, \"position\"),\n\t\t\t    l = n(a),\n\t\t\t    m = {};\"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = n.css(a, \"top\"), i = n.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m);\n\t\t} }, n.fn.extend({ offset: function offset(a) {\n\t\t\tif (arguments.length) return void 0 === a ? this : this.each(function (b) {\n\t\t\t\tn.offset.setOffset(this, a, b);\n\t\t\t});var b,\n\t\t\t    c,\n\t\t\t    d = this[0],\n\t\t\t    e = { top: 0, left: 0 },\n\t\t\t    f = d && d.ownerDocument;if (f) return b = f.documentElement, n.contains(b, d) ? (_typeof(d.getBoundingClientRect) !== X && (e = d.getBoundingClientRect()), c = yc(f), { top: e.top + c.pageYOffset - b.clientTop, left: e.left + c.pageXOffset - b.clientLeft }) : e;\n\t\t}, position: function position() {\n\t\t\tif (this[0]) {\n\t\t\t\tvar a,\n\t\t\t\t    b,\n\t\t\t\t    c = this[0],\n\t\t\t\t    d = { top: 0, left: 0 };return \"fixed\" === n.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], \"html\") || (d = a.offset()), d.top += n.css(a[0], \"borderTopWidth\", !0), d.left += n.css(a[0], \"borderLeftWidth\", !0)), { top: b.top - d.top - n.css(c, \"marginTop\", !0), left: b.left - d.left - n.css(c, \"marginLeft\", !0) };\n\t\t\t}\n\t\t}, offsetParent: function offsetParent() {\n\t\t\treturn this.map(function () {\n\t\t\t\tvar a = this.offsetParent || t;while (a && !n.nodeName(a, \"html\") && \"static\" === n.css(a, \"position\")) {\n\t\t\t\t\ta = a.offsetParent;\n\t\t\t\t}return a || t;\n\t\t\t});\n\t\t} }), n.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (b, c) {\n\t\tvar d = \"pageYOffset\" === c;n.fn[b] = function (e) {\n\t\t\treturn M(this, function (b, e, f) {\n\t\t\t\tvar g = yc(b);return void 0 === f ? g ? g[c] : b[e] : void (g ? g.scrollTo(d ? a.pageXOffset : f, d ? f : a.pageYOffset) : b[e] = f);\n\t\t\t}, b, e, arguments.length, null);\n\t\t};\n\t}), n.each([\"top\", \"left\"], function (a, b) {\n\t\tn.cssHooks[b] = Bb(k.pixelPosition, function (a, c) {\n\t\t\treturn c ? (c = Ab(a, b), yb.test(c) ? n(a).position()[b] + \"px\" : c) : void 0;\n\t\t});\n\t}), n.each({ Height: \"height\", Width: \"width\" }, function (a, b) {\n\t\tn.each({ padding: \"inner\" + a, content: b, \"\": \"outer\" + a }, function (c, d) {\n\t\t\tn.fn[d] = function (d, e) {\n\t\t\t\tvar f = arguments.length && (c || \"boolean\" != typeof d),\n\t\t\t\t    g = c || (d === !0 || e === !0 ? \"margin\" : \"border\");return M(this, function (b, c, d) {\n\t\t\t\t\tvar e;return n.isWindow(b) ? b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body[\"scroll\" + a], e[\"scroll\" + a], b.body[\"offset\" + a], e[\"offset\" + a], e[\"client\" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g);\n\t\t\t\t}, b, f ? d : void 0, f, null);\n\t\t\t};\n\t\t});\n\t}), \"function\" == \"function\" && __webpack_require__(/*! !webpack amd options */ 4) && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\treturn n;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));var zc = a.jQuery,\n\t    Ac = a.$;return n.noConflict = function (b) {\n\t\treturn a.$ === n && (a.$ = Ac), b && a.jQuery === n && (a.jQuery = zc), n;\n\t}, (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === X && (a.jQuery = a.$ = n), n;\n});\n//# sourceMappingURL=jquery.min.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ 3)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9wdWJsaWMvc2NyaXB0cy9saWIvanF1ZXJ5LmpzPzk3MmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGpRdWVyeSB2Mi4xLjEgLWRlcHJlY2F0ZWQsLWVmZmVjdHMsLWVmZmVjdHMvVHdlZW4sLWVmZmVjdHMvYW5pbWF0ZWRTZWxlY3RvciwtY3NzL2hpZGRlblZpc2libGVTZWxlY3RvcnMsLXdyYXAgfCAoYykgMjAwNSwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiB8IGpxdWVyeS5vcmcvbGljZW5zZSAqL1xuIWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZSYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZS5leHBvcnRzP21vZHVsZS5leHBvcnRzPWEuZG9jdW1lbnQ/YihhLCEwKTpmdW5jdGlvbihhKXtpZighYS5kb2N1bWVudCl0aHJvdyBuZXcgRXJyb3IoXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIpO3JldHVybiBiKGEpfTpiKGEpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp0aGlzLGZ1bmN0aW9uKGEsYil7dmFyIGM9W10sZD1jLnNsaWNlLGU9Yy5jb25jYXQsZj1jLnB1c2gsZz1jLmluZGV4T2YsaD17fSxpPWgudG9TdHJpbmcsaj1oLmhhc093blByb3BlcnR5LGs9e30sbD1hLmRvY3VtZW50LG09XCIyLjEuMSAtZGVwcmVjYXRlZCwtZWZmZWN0cywtZWZmZWN0cy9Ud2VlbiwtZWZmZWN0cy9hbmltYXRlZFNlbGVjdG9yLC1jc3MvaGlkZGVuVmlzaWJsZVNlbGVjdG9ycywtd3JhcFwiLG49ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IG4uZm4uaW5pdChhLGIpfSxvPS9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyxwPS9eLW1zLS8scT0vLShbXFxkYS16XSkvZ2kscj1mdW5jdGlvbihhLGIpe3JldHVybiBiLnRvVXBwZXJDYXNlKCl9O24uZm49bi5wcm90b3R5cGU9e2pxdWVyeTptLGNvbnN0cnVjdG9yOm4sc2VsZWN0b3I6XCJcIixsZW5ndGg6MCx0b0FycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIGQuY2FsbCh0aGlzKX0sZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hPzA+YT90aGlzW2ErdGhpcy5sZW5ndGhdOnRoaXNbYV06ZC5jYWxsKHRoaXMpfSxwdXNoU3RhY2s6ZnVuY3Rpb24oYSl7dmFyIGI9bi5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksYSk7cmV0dXJuIGIucHJldk9iamVjdD10aGlzLGIuY29udGV4dD10aGlzLmNvbnRleHQsYn0sZWFjaDpmdW5jdGlvbihhLGIpe3JldHVybiBuLmVhY2godGhpcyxhLGIpfSxtYXA6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKG4ubWFwKHRoaXMsZnVuY3Rpb24oYixjKXtyZXR1cm4gYS5jYWxsKGIsYyxiKX0pKX0sc2xpY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZC5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSxmaXJzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxsYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoLTEpfSxlcTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxlbmd0aCxjPSthKygwPmE/YjowKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soYz49MCYmYj5jP1t0aGlzW2NdXTpbXSl9LGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByZXZPYmplY3R8fHRoaXMuY29uc3RydWN0b3IobnVsbCl9LHB1c2g6Zixzb3J0OmMuc29ydCxzcGxpY2U6Yy5zcGxpY2V9LG4uZXh0ZW5kPW4uZm4uZXh0ZW5kPWZ1bmN0aW9uKCl7dmFyIGEsYixjLGQsZSxmLGc9YXJndW1lbnRzWzBdfHx7fSxoPTEsaT1hcmd1bWVudHMubGVuZ3RoLGo9ITE7Zm9yKFwiYm9vbGVhblwiPT10eXBlb2YgZyYmKGo9ZyxnPWFyZ3VtZW50c1toXXx8e30saCsrKSxcIm9iamVjdFwiPT10eXBlb2YgZ3x8bi5pc0Z1bmN0aW9uKGcpfHwoZz17fSksaD09PWkmJihnPXRoaXMsaC0tKTtpPmg7aCsrKWlmKG51bGwhPShhPWFyZ3VtZW50c1toXSkpZm9yKGIgaW4gYSljPWdbYl0sZD1hW2JdLGchPT1kJiYoaiYmZCYmKG4uaXNQbGFpbk9iamVjdChkKXx8KGU9bi5pc0FycmF5KGQpKSk/KGU/KGU9ITEsZj1jJiZuLmlzQXJyYXkoYyk/YzpbXSk6Zj1jJiZuLmlzUGxhaW5PYmplY3QoYyk/Yzp7fSxnW2JdPW4uZXh0ZW5kKGosZixkKSk6dm9pZCAwIT09ZCYmKGdbYl09ZCkpO3JldHVybiBnfSxuLmV4dGVuZCh7ZXhwYW5kbzpcImpRdWVyeVwiKyhtK01hdGgucmFuZG9tKCkpLnJlcGxhY2UoL1xcRC9nLFwiXCIpLGlzUmVhZHk6ITAsZXJyb3I6ZnVuY3Rpb24oYSl7dGhyb3cgbmV3IEVycm9yKGEpfSxub29wOmZ1bmN0aW9uKCl7fSxpc0Z1bmN0aW9uOmZ1bmN0aW9uKGEpe3JldHVyblwiZnVuY3Rpb25cIj09PW4udHlwZShhKX0saXNBcnJheTpBcnJheS5pc0FycmF5LGlzV2luZG93OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZhPT09YS53aW5kb3d9LGlzTnVtZXJpYzpmdW5jdGlvbihhKXtyZXR1cm4hbi5pc0FycmF5KGEpJiZhLXBhcnNlRmxvYXQoYSk+PTB9LGlzUGxhaW5PYmplY3Q6ZnVuY3Rpb24oYSl7cmV0dXJuXCJvYmplY3RcIiE9PW4udHlwZShhKXx8YS5ub2RlVHlwZXx8bi5pc1dpbmRvdyhhKT8hMTphLmNvbnN0cnVjdG9yJiYhai5jYWxsKGEuY29uc3RydWN0b3IucHJvdG90eXBlLFwiaXNQcm90b3R5cGVPZlwiKT8hMTohMH0saXNFbXB0eU9iamVjdDpmdW5jdGlvbihhKXt2YXIgYjtmb3IoYiBpbiBhKXJldHVybiExO3JldHVybiEwfSx0eXBlOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP2ErXCJcIjpcIm9iamVjdFwiPT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT10eXBlb2YgYT9oW2kuY2FsbChhKV18fFwib2JqZWN0XCI6dHlwZW9mIGF9LGdsb2JhbEV2YWw6ZnVuY3Rpb24oYSl7dmFyIGIsYz1ldmFsO2E9bi50cmltKGEpLGEmJigxPT09YS5pbmRleE9mKFwidXNlIHN0cmljdFwiKT8oYj1sLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiksYi50ZXh0PWEsbC5oZWFkLmFwcGVuZENoaWxkKGIpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYikpOmMoYSkpfSxjYW1lbENhc2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZShwLFwibXMtXCIpLnJlcGxhY2UocSxyKX0sbm9kZU5hbWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09Yi50b0xvd2VyQ2FzZSgpfSxlYWNoOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPTAsZj1hLmxlbmd0aCxnPXMoYSk7aWYoYyl7aWYoZyl7Zm9yKDtmPmU7ZSsrKWlmKGQ9Yi5hcHBseShhW2VdLGMpLGQ9PT0hMSlicmVha31lbHNlIGZvcihlIGluIGEpaWYoZD1iLmFwcGx5KGFbZV0sYyksZD09PSExKWJyZWFrfWVsc2UgaWYoZyl7Zm9yKDtmPmU7ZSsrKWlmKGQ9Yi5jYWxsKGFbZV0sZSxhW2VdKSxkPT09ITEpYnJlYWt9ZWxzZSBmb3IoZSBpbiBhKWlmKGQ9Yi5jYWxsKGFbZV0sZSxhW2VdKSxkPT09ITEpYnJlYWs7cmV0dXJuIGF9LHRyaW06ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/XCJcIjooYStcIlwiKS5yZXBsYWNlKG8sXCJcIil9LG1ha2VBcnJheTpmdW5jdGlvbihhLGIpe3ZhciBjPWJ8fFtdO3JldHVybiBudWxsIT1hJiYocyhPYmplY3QoYSkpP24ubWVyZ2UoYyxcInN0cmluZ1wiPT10eXBlb2YgYT9bYV06YSk6Zi5jYWxsKGMsYSkpLGN9LGluQXJyYXk6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBudWxsPT1iPy0xOmcuY2FsbChiLGEsYyl9LG1lcmdlOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPStiLmxlbmd0aCxkPTAsZT1hLmxlbmd0aDtjPmQ7ZCsrKWFbZSsrXT1iW2RdO3JldHVybiBhLmxlbmd0aD1lLGF9LGdyZXA6ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZCxlPVtdLGY9MCxnPWEubGVuZ3RoLGg9IWM7Zz5mO2YrKylkPSFiKGFbZl0sZiksZCE9PWgmJmUucHVzaChhW2ZdKTtyZXR1cm4gZX0sbWFwOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxmPTAsZz1hLmxlbmd0aCxoPXMoYSksaT1bXTtpZihoKWZvcig7Zz5mO2YrKylkPWIoYVtmXSxmLGMpLG51bGwhPWQmJmkucHVzaChkKTtlbHNlIGZvcihmIGluIGEpZD1iKGFbZl0sZixjKSxudWxsIT1kJiZpLnB1c2goZCk7cmV0dXJuIGUuYXBwbHkoW10saSl9LGd1aWQ6MSxwcm94eTpmdW5jdGlvbihhLGIpe3ZhciBjLGUsZjtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgYiYmKGM9YVtiXSxiPWEsYT1jKSxuLmlzRnVuY3Rpb24oYSk/KGU9ZC5jYWxsKGFyZ3VtZW50cywyKSxmPWZ1bmN0aW9uKCl7cmV0dXJuIGEuYXBwbHkoYnx8dGhpcyxlLmNvbmNhdChkLmNhbGwoYXJndW1lbnRzKSkpfSxmLmd1aWQ9YS5ndWlkPWEuZ3VpZHx8bi5ndWlkKyssZik6dm9pZCAwfSxub3c6RGF0ZS5ub3csc3VwcG9ydDprfSksbi5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhLGIpe2hbXCJbb2JqZWN0IFwiK2IrXCJdXCJdPWIudG9Mb3dlckNhc2UoKX0pO2Z1bmN0aW9uIHMoYSl7dmFyIGI9YS5sZW5ndGgsYz1uLnR5cGUoYSk7cmV0dXJuXCJmdW5jdGlvblwiPT09Y3x8bi5pc1dpbmRvdyhhKT8hMToxPT09YS5ub2RlVHlwZSYmYj8hMDpcImFycmF5XCI9PT1jfHwwPT09Ynx8XCJudW1iZXJcIj09dHlwZW9mIGImJmI+MCYmYi0xIGluIGF9dmFyIHQ9YS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsdSx2PXQubWF0Y2hlc3x8dC53ZWJraXRNYXRjaGVzU2VsZWN0b3J8fHQubW96TWF0Y2hlc1NlbGVjdG9yfHx0Lm9NYXRjaGVzU2VsZWN0b3J8fHQubXNNYXRjaGVzU2VsZWN0b3Isdz1mdW5jdGlvbihhLGIpe2lmKGE9PT1iKXJldHVybiB1PSEwLDA7dmFyIGM9Yi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiYmYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKTtyZXR1cm4gYz8xJmM/YT09PWx8fG4uY29udGFpbnMobCxhKT8tMTpiPT09bHx8bi5jb250YWlucyhsLGIpPzE6MDo0JmM/LTE6MTphLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uPy0xOjF9O24uZXh0ZW5kKHtmaW5kOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlLGYsZz0wO2lmKGM9Y3x8W10sYj1ifHxsLCFhfHxcInN0cmluZ1wiIT10eXBlb2YgYSlyZXR1cm4gYztpZigxIT09KGY9Yi5ub2RlVHlwZSkmJjkhPT1mKXJldHVybltdO2lmKGQpd2hpbGUoZT1kW2crK10pbi5maW5kLm1hdGNoZXNTZWxlY3RvcihlLGEpJiZjLnB1c2goZSk7ZWxzZSBuLm1lcmdlKGMsYi5xdWVyeVNlbGVjdG9yQWxsKGEpKTtyZXR1cm4gY30sdW5pcXVlOmZ1bmN0aW9uKGEpe3ZhciBiLGM9W10sZD0wLGU9MDtpZih1PSExLGEuc29ydCh3KSx1KXt3aGlsZShiPWFbZCsrXSliPT09YVtkXSYmKGU9Yy5wdXNoKGQpKTt3aGlsZShlLS0pYS5zcGxpY2UoY1tlXSwxKX1yZXR1cm4gYX0sdGV4dDpmdW5jdGlvbihhKXt2YXIgYixjPVwiXCIsZD0wLGU9YS5ub2RlVHlwZTtpZihlKXtpZigxPT09ZXx8OT09PWV8fDExPT09ZSlyZXR1cm4gYS50ZXh0Q29udGVudDtpZigzPT09ZXx8ND09PWUpcmV0dXJuIGEubm9kZVZhbHVlfWVsc2Ugd2hpbGUoYj1hW2QrK10pYys9bi50ZXh0KGIpO3JldHVybiBjfSxjb250YWluczpmdW5jdGlvbihhLGIpe3ZhciBjPTk9PT1hLm5vZGVUeXBlP2EuZG9jdW1lbnRFbGVtZW50OmEsZD1iJiZiLnBhcmVudE5vZGU7cmV0dXJuIGE9PT1kfHwhKCFkfHwxIT09ZC5ub2RlVHlwZXx8IWMuY29udGFpbnMoZCkpfSxpc1hNTERvYzpmdW5jdGlvbihhKXtyZXR1cm5cIkhUTUxcIiE9PShhLm93bmVyRG9jdW1lbnR8fGEpLmRvY3VtZW50RWxlbWVudC5ub2RlTmFtZX0sZXhwcjp7YXR0ckhhbmRsZTp7fSxtYXRjaDp7Ym9vbDovXig/OmNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkKSQvaSxuZWVkc0NvbnRleHQ6L15bXFx4MjBcXHRcXHJcXG5cXGZdKls+K35dL319fSksbi5leHRlbmQobi5maW5kLHttYXRjaGVzOmZ1bmN0aW9uKGEsYil7cmV0dXJuIG4uZmluZChhLG51bGwsbnVsbCxiKX0sbWF0Y2hlc1NlbGVjdG9yOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHYuY2FsbChhLGIpfSxhdHRyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuZ2V0QXR0cmlidXRlKGIpfX0pO3ZhciB4PW4uZXhwci5tYXRjaC5uZWVkc0NvbnRleHQseT0vXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPnwpJC8sej0vXi5bXjojXFxbXFwuLF0qJC87ZnVuY3Rpb24gQShhLGIsYyl7aWYobi5pc0Z1bmN0aW9uKGIpKXJldHVybiBuLmdyZXAoYSxmdW5jdGlvbihhLGQpe3JldHVybiEhYi5jYWxsKGEsZCxhKSE9PWN9KTtpZihiLm5vZGVUeXBlKXJldHVybiBuLmdyZXAoYSxmdW5jdGlvbihhKXtyZXR1cm4gYT09PWIhPT1jfSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGIpe2lmKHoudGVzdChiKSlyZXR1cm4gbi5maWx0ZXIoYixhLGMpO2I9bi5maWx0ZXIoYixhKX1yZXR1cm4gbi5ncmVwKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGcuY2FsbChiLGEpPj0wIT09Y30pfW4uZmlsdGVyPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iWzBdO3JldHVybiBjJiYoYT1cIjpub3QoXCIrYStcIilcIiksMT09PWIubGVuZ3RoJiYxPT09ZC5ub2RlVHlwZT9uLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGQsYSk/W2RdOltdOm4uZmluZC5tYXRjaGVzKGEsbi5ncmVwKGIsZnVuY3Rpb24oYSl7cmV0dXJuIDE9PT1hLm5vZGVUeXBlfSkpfSxuLmZuLmV4dGVuZCh7ZmluZDpmdW5jdGlvbihhKXt2YXIgYixjPXRoaXMubGVuZ3RoLGQ9W10sZT10aGlzO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBhKXJldHVybiB0aGlzLnB1c2hTdGFjayhuKGEpLmZpbHRlcihmdW5jdGlvbigpe2ZvcihiPTA7Yz5iO2IrKylpZihuLmNvbnRhaW5zKGVbYl0sdGhpcykpcmV0dXJuITB9KSk7Zm9yKGI9MDtjPmI7YisrKW4uZmluZChhLGVbYl0sZCk7cmV0dXJuIGQ9dGhpcy5wdXNoU3RhY2soYz4xP24udW5pcXVlKGQpOmQpLGQuc2VsZWN0b3I9dGhpcy5zZWxlY3Rvcj90aGlzLnNlbGVjdG9yK1wiIFwiK2E6YSxkfSxmaWx0ZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKEEodGhpcyxhfHxbXSwhMSkpfSxub3Q6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKEEodGhpcyxhfHxbXSwhMCkpfSxpczpmdW5jdGlvbihhKXtyZXR1cm4hIUEodGhpcyxcInN0cmluZ1wiPT10eXBlb2YgYSYmeC50ZXN0KGEpP24oYSk6YXx8W10sITEpLmxlbmd0aH19KTt2YXIgQixDPS9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSopKSQvLEQ9bi5mbi5pbml0PWZ1bmN0aW9uKGEsYil7dmFyIGMsZDtpZighYSlyZXR1cm4gdGhpcztpZihcInN0cmluZ1wiPT10eXBlb2YgYSl7aWYoYz1cIjxcIj09PWFbMF0mJlwiPlwiPT09YVthLmxlbmd0aC0xXSYmYS5sZW5ndGg+PTM/W251bGwsYSxudWxsXTpDLmV4ZWMoYSksIWN8fCFjWzFdJiZiKXJldHVybiFifHxiLmpxdWVyeT8oYnx8QikuZmluZChhKTp0aGlzLmNvbnN0cnVjdG9yKGIpLmZpbmQoYSk7aWYoY1sxXSl7aWYoYj1iIGluc3RhbmNlb2Ygbj9iWzBdOmIsbi5tZXJnZSh0aGlzLG4ucGFyc2VIVE1MKGNbMV0sYiYmYi5ub2RlVHlwZT9iLm93bmVyRG9jdW1lbnR8fGI6bCwhMCkpLHkudGVzdChjWzFdKSYmbi5pc1BsYWluT2JqZWN0KGIpKWZvcihjIGluIGIpbi5pc0Z1bmN0aW9uKHRoaXNbY10pP3RoaXNbY10oYltjXSk6dGhpcy5hdHRyKGMsYltjXSk7cmV0dXJuIHRoaXN9cmV0dXJuIGQ9bC5nZXRFbGVtZW50QnlJZChjWzJdKSxkJiZkLnBhcmVudE5vZGUmJih0aGlzLmxlbmd0aD0xLHRoaXNbMF09ZCksdGhpcy5jb250ZXh0PWwsdGhpcy5zZWxlY3Rvcj1hLHRoaXN9cmV0dXJuIGEubm9kZVR5cGU/KHRoaXMuY29udGV4dD10aGlzWzBdPWEsdGhpcy5sZW5ndGg9MSx0aGlzKTpuLmlzRnVuY3Rpb24oYSk/XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEIucmVhZHk/Qi5yZWFkeShhKTphKG4pOih2b2lkIDAhPT1hLnNlbGVjdG9yJiYodGhpcy5zZWxlY3Rvcj1hLnNlbGVjdG9yLHRoaXMuY29udGV4dD1hLmNvbnRleHQpLG4ubWFrZUFycmF5KGEsdGhpcykpfTtELnByb3RvdHlwZT1uLmZuLEI9bihsKTt2YXIgRT0vXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxGPXtjaGlsZHJlbjohMCxjb250ZW50czohMCxuZXh0OiEwLHByZXY6ITB9O24uZXh0ZW5kKHtkaXI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVtdLGU9dm9pZCAwIT09Yzt3aGlsZSgoYT1hW2JdKSYmOSE9PWEubm9kZVR5cGUpaWYoMT09PWEubm9kZVR5cGUpe2lmKGUmJm4oYSkuaXMoYykpYnJlYWs7ZC5wdXNoKGEpfXJldHVybiBkfSxzaWJsaW5nOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdO2E7YT1hLm5leHRTaWJsaW5nKTE9PT1hLm5vZGVUeXBlJiZhIT09YiYmYy5wdXNoKGEpO3JldHVybiBjfX0pLG4uZm4uZXh0ZW5kKHtoYXM6ZnVuY3Rpb24oYSl7dmFyIGI9bihhLHRoaXMpLGM9Yi5sZW5ndGg7cmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7Yz5hO2ErKylpZihuLmNvbnRhaW5zKHRoaXMsYlthXSkpcmV0dXJuITB9KX0sY2xvc2VzdDpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYyxkPTAsZT10aGlzLmxlbmd0aCxmPVtdLGc9eC50ZXN0KGEpfHxcInN0cmluZ1wiIT10eXBlb2YgYT9uKGEsYnx8dGhpcy5jb250ZXh0KTowO2U+ZDtkKyspZm9yKGM9dGhpc1tkXTtjJiZjIT09YjtjPWMucGFyZW50Tm9kZSlpZihjLm5vZGVUeXBlPDExJiYoZz9nLmluZGV4KGMpPi0xOjE9PT1jLm5vZGVUeXBlJiZuLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGMsYSkpKXtmLnB1c2goYyk7YnJlYWt9cmV0dXJuIHRoaXMucHVzaFN0YWNrKGYubGVuZ3RoPjE/bi51bmlxdWUoZik6Zil9LGluZGV4OmZ1bmN0aW9uKGEpe3JldHVybiBhP1wic3RyaW5nXCI9PXR5cGVvZiBhP2cuY2FsbChuKGEpLHRoaXNbMF0pOmcuY2FsbCh0aGlzLGEuanF1ZXJ5P2FbMF06YSk6dGhpc1swXSYmdGhpc1swXS5wYXJlbnROb2RlP3RoaXMuZmlyc3QoKS5wcmV2QWxsKCkubGVuZ3RoOi0xfSxhZGQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2sobi51bmlxdWUobi5tZXJnZSh0aGlzLmdldCgpLG4oYSxiKSkpKX0sYWRkQmFjazpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5hZGQobnVsbD09YT90aGlzLnByZXZPYmplY3Q6dGhpcy5wcmV2T2JqZWN0LmZpbHRlcihhKSl9fSk7ZnVuY3Rpb24gRyhhLGIpe3doaWxlKChhPWFbYl0pJiYxIT09YS5ub2RlVHlwZSk7cmV0dXJuIGF9bi5lYWNoKHtwYXJlbnQ6ZnVuY3Rpb24oYSl7dmFyIGI9YS5wYXJlbnROb2RlO3JldHVybiBiJiYxMSE9PWIubm9kZVR5cGU/YjpudWxsfSxwYXJlbnRzOmZ1bmN0aW9uKGEpe3JldHVybiBuLmRpcihhLFwicGFyZW50Tm9kZVwiKX0scGFyZW50c1VudGlsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbi5kaXIoYSxcInBhcmVudE5vZGVcIixjKX0sbmV4dDpmdW5jdGlvbihhKXtyZXR1cm4gRyhhLFwibmV4dFNpYmxpbmdcIil9LHByZXY6ZnVuY3Rpb24oYSl7cmV0dXJuIEcoYSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dEFsbDpmdW5jdGlvbihhKXtyZXR1cm4gbi5kaXIoYSxcIm5leHRTaWJsaW5nXCIpfSxwcmV2QWxsOmZ1bmN0aW9uKGEpe3JldHVybiBuLmRpcihhLFwicHJldmlvdXNTaWJsaW5nXCIpfSxuZXh0VW50aWw6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBuLmRpcihhLFwibmV4dFNpYmxpbmdcIixjKX0scHJldlVudGlsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbi5kaXIoYSxcInByZXZpb3VzU2libGluZ1wiLGMpfSxzaWJsaW5nczpmdW5jdGlvbihhKXtyZXR1cm4gbi5zaWJsaW5nKChhLnBhcmVudE5vZGV8fHt9KS5maXJzdENoaWxkLGEpfSxjaGlsZHJlbjpmdW5jdGlvbihhKXtyZXR1cm4gbi5zaWJsaW5nKGEuZmlyc3RDaGlsZCl9LGNvbnRlbnRzOmZ1bmN0aW9uKGEpe3JldHVybiBhLmNvbnRlbnREb2N1bWVudHx8bi5tZXJnZShbXSxhLmNoaWxkTm9kZXMpfX0sZnVuY3Rpb24oYSxiKXtuLmZuW2FdPWZ1bmN0aW9uKGMsZCl7dmFyIGU9bi5tYXAodGhpcyxiLGMpO3JldHVyblwiVW50aWxcIiE9PWEuc2xpY2UoLTUpJiYoZD1jKSxkJiZcInN0cmluZ1wiPT10eXBlb2YgZCYmKGU9bi5maWx0ZXIoZCxlKSksdGhpcy5sZW5ndGg+MSYmKEZbYV18fG4udW5pcXVlKGUpLEUudGVzdChhKSYmZS5yZXZlcnNlKCkpLHRoaXMucHVzaFN0YWNrKGUpfX0pO3ZhciBIPS9cXFMrL2csST17fTtmdW5jdGlvbiBKKGEpe3ZhciBiPUlbYV09e307cmV0dXJuIG4uZWFjaChhLm1hdGNoKEgpfHxbXSxmdW5jdGlvbihhLGMpe2JbY109ITB9KSxifW4uQ2FsbGJhY2tzPWZ1bmN0aW9uKGEpe2E9XCJzdHJpbmdcIj09dHlwZW9mIGE/SVthXXx8SihhKTpuLmV4dGVuZCh7fSxhKTt2YXIgYixjLGQsZSxmLGcsaD1bXSxpPSFhLm9uY2UmJltdLGo9ZnVuY3Rpb24obCl7Zm9yKGI9YS5tZW1vcnkmJmwsYz0hMCxnPWV8fDAsZT0wLGY9aC5sZW5ndGgsZD0hMDtoJiZmPmc7ZysrKWlmKGhbZ10uYXBwbHkobFswXSxsWzFdKT09PSExJiZhLnN0b3BPbkZhbHNlKXtiPSExO2JyZWFrfWQ9ITEsaCYmKGk/aS5sZW5ndGgmJmooaS5zaGlmdCgpKTpiP2g9W106ay5kaXNhYmxlKCkpfSxrPXthZGQ6ZnVuY3Rpb24oKXtpZihoKXt2YXIgYz1oLmxlbmd0aDshZnVuY3Rpb24gZyhiKXtuLmVhY2goYixmdW5jdGlvbihiLGMpe3ZhciBkPW4udHlwZShjKTtcImZ1bmN0aW9uXCI9PT1kP2EudW5pcXVlJiZrLmhhcyhjKXx8aC5wdXNoKGMpOmMmJmMubGVuZ3RoJiZcInN0cmluZ1wiIT09ZCYmZyhjKX0pfShhcmd1bWVudHMpLGQ/Zj1oLmxlbmd0aDpiJiYoZT1jLGooYikpfXJldHVybiB0aGlzfSxyZW1vdmU6ZnVuY3Rpb24oKXtyZXR1cm4gaCYmbi5lYWNoKGFyZ3VtZW50cyxmdW5jdGlvbihhLGIpe3ZhciBjO3doaWxlKChjPW4uaW5BcnJheShiLGgsYykpPi0xKWguc3BsaWNlKGMsMSksZCYmKGY+PWMmJmYtLSxnPj1jJiZnLS0pfSksdGhpc30saGFzOmZ1bmN0aW9uKGEpe3JldHVybiBhP24uaW5BcnJheShhLGgpPi0xOiEoIWh8fCFoLmxlbmd0aCl9LGVtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIGg9W10sZj0wLHRoaXN9LGRpc2FibGU6ZnVuY3Rpb24oKXtyZXR1cm4gaD1pPWI9dm9pZCAwLHRoaXN9LGRpc2FibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIWh9LGxvY2s6ZnVuY3Rpb24oKXtyZXR1cm4gaT12b2lkIDAsYnx8ay5kaXNhYmxlKCksdGhpc30sbG9ja2VkOmZ1bmN0aW9uKCl7cmV0dXJuIWl9LGZpcmVXaXRoOmZ1bmN0aW9uKGEsYil7cmV0dXJuIWh8fGMmJiFpfHwoYj1ifHxbXSxiPVthLGIuc2xpY2U/Yi5zbGljZSgpOmJdLGQ/aS5wdXNoKGIpOmooYikpLHRoaXN9LGZpcmU6ZnVuY3Rpb24oKXtyZXR1cm4gay5maXJlV2l0aCh0aGlzLGFyZ3VtZW50cyksdGhpc30sZmlyZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIWN9fTtyZXR1cm4ga30sbi5leHRlbmQoe0RlZmVycmVkOmZ1bmN0aW9uKGEpe3ZhciBiPVtbXCJyZXNvbHZlXCIsXCJkb25lXCIsbi5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcInJlc29sdmVkXCJdLFtcInJlamVjdFwiLFwiZmFpbFwiLG4uQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksXCJyZWplY3RlZFwiXSxbXCJub3RpZnlcIixcInByb2dyZXNzXCIsbi5DYWxsYmFja3MoXCJtZW1vcnlcIildXSxjPVwicGVuZGluZ1wiLGQ9e3N0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuIGN9LGFsd2F5czpmdW5jdGlvbigpe3JldHVybiBlLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyksdGhpc30sdGhlbjpmdW5jdGlvbigpe3ZhciBhPWFyZ3VtZW50cztyZXR1cm4gbi5EZWZlcnJlZChmdW5jdGlvbihjKXtuLmVhY2goYixmdW5jdGlvbihiLGYpe3ZhciBnPW4uaXNGdW5jdGlvbihhW2JdKSYmYVtiXTtlW2ZbMV1dKGZ1bmN0aW9uKCl7dmFyIGE9ZyYmZy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7YSYmbi5pc0Z1bmN0aW9uKGEucHJvbWlzZSk/YS5wcm9taXNlKCkuZG9uZShjLnJlc29sdmUpLmZhaWwoYy5yZWplY3QpLnByb2dyZXNzKGMubm90aWZ5KTpjW2ZbMF0rXCJXaXRoXCJdKHRoaXM9PT1kP2MucHJvbWlzZSgpOnRoaXMsZz9bYV06YXJndW1lbnRzKX0pfSksYT1udWxsfSkucHJvbWlzZSgpfSxwcm9taXNlOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hP24uZXh0ZW5kKGEsZCk6ZH19LGU9e307cmV0dXJuIGQucGlwZT1kLnRoZW4sbi5lYWNoKGIsZnVuY3Rpb24oYSxmKXt2YXIgZz1mWzJdLGg9ZlszXTtkW2ZbMV1dPWcuYWRkLGgmJmcuYWRkKGZ1bmN0aW9uKCl7Yz1ofSxiWzFeYV1bMl0uZGlzYWJsZSxiWzJdWzJdLmxvY2spLGVbZlswXV09ZnVuY3Rpb24oKXtyZXR1cm4gZVtmWzBdK1wiV2l0aFwiXSh0aGlzPT09ZT9kOnRoaXMsYXJndW1lbnRzKSx0aGlzfSxlW2ZbMF0rXCJXaXRoXCJdPWcuZmlyZVdpdGh9KSxkLnByb21pc2UoZSksYSYmYS5jYWxsKGUsZSksZX0sd2hlbjpmdW5jdGlvbihhKXt2YXIgYj0wLGM9ZC5jYWxsKGFyZ3VtZW50cyksZT1jLmxlbmd0aCxmPTEhPT1lfHxhJiZuLmlzRnVuY3Rpb24oYS5wcm9taXNlKT9lOjAsZz0xPT09Zj9hOm4uRGVmZXJyZWQoKSxoPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gZnVuY3Rpb24oZSl7YlthXT10aGlzLGNbYV09YXJndW1lbnRzLmxlbmd0aD4xP2QuY2FsbChhcmd1bWVudHMpOmUsYz09PWk/Zy5ub3RpZnlXaXRoKGIsYyk6LS1mfHxnLnJlc29sdmVXaXRoKGIsYyl9fSxpLGosaztpZihlPjEpZm9yKGk9bmV3IEFycmF5KGUpLGo9bmV3IEFycmF5KGUpLGs9bmV3IEFycmF5KGUpO2U+YjtiKyspY1tiXSYmbi5pc0Z1bmN0aW9uKGNbYl0ucHJvbWlzZSk/Y1tiXS5wcm9taXNlKCkuZG9uZShoKGIsayxjKSkuZmFpbChnLnJlamVjdCkucHJvZ3Jlc3MoaChiLGosaSkpOi0tZjtyZXR1cm4gZnx8Zy5yZXNvbHZlV2l0aChrLGMpLGcucHJvbWlzZSgpfX0pO3ZhciBLO24uZm4ucmVhZHk9ZnVuY3Rpb24oYSl7cmV0dXJuIG4ucmVhZHkucHJvbWlzZSgpLmRvbmUoYSksdGhpc30sbi5leHRlbmQoe2lzUmVhZHk6ITEscmVhZHlXYWl0OjEsaG9sZFJlYWR5OmZ1bmN0aW9uKGEpe2E/bi5yZWFkeVdhaXQrKzpuLnJlYWR5KCEwKX0scmVhZHk6ZnVuY3Rpb24oYSl7KGE9PT0hMD8tLW4ucmVhZHlXYWl0Om4uaXNSZWFkeSl8fChuLmlzUmVhZHk9ITAsYSE9PSEwJiYtLW4ucmVhZHlXYWl0PjB8fChLLnJlc29sdmVXaXRoKGwsW25dKSxuLmZuLnRyaWdnZXJIYW5kbGVyJiYobihsKS50cmlnZ2VySGFuZGxlcihcInJlYWR5XCIpLG4obCkub2ZmKFwicmVhZHlcIikpKSl9fSk7ZnVuY3Rpb24gTCgpe2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixMLCExKSxhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsTCwhMSksbi5yZWFkeSgpfW4ucmVhZHkucHJvbWlzZT1mdW5jdGlvbihiKXtyZXR1cm4gS3x8KEs9bi5EZWZlcnJlZCgpLFwiY29tcGxldGVcIj09PWwucmVhZHlTdGF0ZT9zZXRUaW1lb3V0KG4ucmVhZHkpOihsLmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsTCwhMSksYS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLEwsITEpKSksSy5wcm9taXNlKGIpfSxuLnJlYWR5LnByb21pc2UoKTt2YXIgTT1uLmFjY2Vzcz1mdW5jdGlvbihhLGIsYyxkLGUsZixnKXt2YXIgaD0wLGk9YS5sZW5ndGgsaj1udWxsPT1jO2lmKFwib2JqZWN0XCI9PT1uLnR5cGUoYykpe2U9ITA7Zm9yKGggaW4gYyluLmFjY2VzcyhhLGIsaCxjW2hdLCEwLGYsZyl9ZWxzZSBpZih2b2lkIDAhPT1kJiYoZT0hMCxuLmlzRnVuY3Rpb24oZCl8fChnPSEwKSxqJiYoZz8oYi5jYWxsKGEsZCksYj1udWxsKTooaj1iLGI9ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBqLmNhbGwobihhKSxjKX0pKSxiKSlmb3IoO2k+aDtoKyspYihhW2hdLGMsZz9kOmQuY2FsbChhW2hdLGgsYihhW2hdLGMpKSk7cmV0dXJuIGU/YTpqP2IuY2FsbChhKTppP2IoYVswXSxjKTpmfTtuLmFjY2VwdERhdGE9ZnVuY3Rpb24oYSl7cmV0dXJuIDE9PT1hLm5vZGVUeXBlfHw5PT09YS5ub2RlVHlwZXx8ISthLm5vZGVUeXBlfTtmdW5jdGlvbiBOKCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuY2FjaGU9e30sMCx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJue319fSksdGhpcy5leHBhbmRvPW4uZXhwYW5kbytNYXRoLnJhbmRvbSgpfU4udWlkPTEsTi5hY2NlcHRzPW4uYWNjZXB0RGF0YSxOLnByb3RvdHlwZT17a2V5OmZ1bmN0aW9uKGEpe2lmKCFOLmFjY2VwdHMoYSkpcmV0dXJuIDA7dmFyIGI9e30sYz1hW3RoaXMuZXhwYW5kb107aWYoIWMpe2M9Ti51aWQrKzt0cnl7Ylt0aGlzLmV4cGFuZG9dPXt2YWx1ZTpjfSxPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhLGIpfWNhdGNoKGQpe2JbdGhpcy5leHBhbmRvXT1jLG4uZXh0ZW5kKGEsYil9fXJldHVybiB0aGlzLmNhY2hlW2NdfHwodGhpcy5jYWNoZVtjXT17fSksY30sc2V0OmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlPXRoaXMua2V5KGEpLGY9dGhpcy5jYWNoZVtlXTtpZihcInN0cmluZ1wiPT10eXBlb2YgYilmW2JdPWM7ZWxzZSBpZihuLmlzRW1wdHlPYmplY3QoZikpbi5leHRlbmQodGhpcy5jYWNoZVtlXSxiKTtlbHNlIGZvcihkIGluIGIpZltkXT1iW2RdO3JldHVybiBmfSxnZXQ6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLmNhY2hlW3RoaXMua2V5KGEpXTtyZXR1cm4gdm9pZCAwPT09Yj9jOmNbYl19LGFjY2VzczpmdW5jdGlvbihhLGIsYyl7dmFyIGQ7cmV0dXJuIHZvaWQgMD09PWJ8fGImJlwic3RyaW5nXCI9PXR5cGVvZiBiJiZ2b2lkIDA9PT1jPyhkPXRoaXMuZ2V0KGEsYiksdm9pZCAwIT09ZD9kOnRoaXMuZ2V0KGEsbi5jYW1lbENhc2UoYikpKToodGhpcy5zZXQoYSxiLGMpLHZvaWQgMCE9PWM/YzpiKX0scmVtb3ZlOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY9dGhpcy5rZXkoYSksZz10aGlzLmNhY2hlW2ZdO2lmKHZvaWQgMD09PWIpdGhpcy5jYWNoZVtmXT17fTtlbHNle24uaXNBcnJheShiKT9kPWIuY29uY2F0KGIubWFwKG4uY2FtZWxDYXNlKSk6KGU9bi5jYW1lbENhc2UoYiksYiBpbiBnP2Q9W2IsZV06KGQ9ZSxkPWQgaW4gZz9bZF06ZC5tYXRjaChIKXx8W10pKSxjPWQubGVuZ3RoO3doaWxlKGMtLSlkZWxldGUgZ1tkW2NdXX19LGhhc0RhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuIW4uaXNFbXB0eU9iamVjdCh0aGlzLmNhY2hlW2FbdGhpcy5leHBhbmRvXV18fHt9KX0sZGlzY2FyZDpmdW5jdGlvbihhKXthW3RoaXMuZXhwYW5kb10mJmRlbGV0ZSB0aGlzLmNhY2hlW2FbdGhpcy5leHBhbmRvXV19fTt2YXIgTz1uZXcgTixQPW5ldyBOLFE9L14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFI9LyhbQS1aXSkvZztmdW5jdGlvbiBTKGEsYixjKXt2YXIgZDtpZih2b2lkIDA9PT1jJiYxPT09YS5ub2RlVHlwZSlpZihkPVwiZGF0YS1cIitiLnJlcGxhY2UoUixcIi0kMVwiKS50b0xvd2VyQ2FzZSgpLGM9YS5nZXRBdHRyaWJ1dGUoZCksXCJzdHJpbmdcIj09dHlwZW9mIGMpe3RyeXtjPVwidHJ1ZVwiPT09Yz8hMDpcImZhbHNlXCI9PT1jPyExOlwibnVsbFwiPT09Yz9udWxsOitjK1wiXCI9PT1jPytjOlEudGVzdChjKT9uLnBhcnNlSlNPTihjKTpjfWNhdGNoKGUpe31QLnNldChhLGIsYyl9ZWxzZSBjPXZvaWQgMDtyZXR1cm4gY31uLmV4dGVuZCh7aGFzRGF0YTpmdW5jdGlvbihhKXtyZXR1cm4gUC5oYXNEYXRhKGEpfHxPLmhhc0RhdGEoYSl9LGRhdGE6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBQLmFjY2VzcyhhLGIsYyl9LHJlbW92ZURhdGE6ZnVuY3Rpb24oYSxiKXtQLnJlbW92ZShhLGIpfSxfZGF0YTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIE8uYWNjZXNzKGEsYixjKX0sX3JlbW92ZURhdGE6ZnVuY3Rpb24oYSxiKXtPLnJlbW92ZShhLGIpfX0pLG4uZm4uZXh0ZW5kKHtkYXRhOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGY9dGhpc1swXSxnPWYmJmYuYXR0cmlidXRlcztpZih2b2lkIDA9PT1hKXtpZih0aGlzLmxlbmd0aCYmKGU9UC5nZXQoZiksMT09PWYubm9kZVR5cGUmJiFPLmdldChmLFwiaGFzRGF0YUF0dHJzXCIpKSl7Yz1nLmxlbmd0aDt3aGlsZShjLS0pZ1tjXSYmKGQ9Z1tjXS5uYW1lLDA9PT1kLmluZGV4T2YoXCJkYXRhLVwiKSYmKGQ9bi5jYW1lbENhc2UoZC5zbGljZSg1KSksUyhmLGQsZVtkXSkpKTtPLnNldChmLFwiaGFzRGF0YUF0dHJzXCIsITApfXJldHVybiBlfXJldHVyblwib2JqZWN0XCI9PXR5cGVvZiBhP3RoaXMuZWFjaChmdW5jdGlvbigpe1Auc2V0KHRoaXMsYSl9KTpNKHRoaXMsZnVuY3Rpb24oYil7dmFyIGMsZD1uLmNhbWVsQ2FzZShhKTtpZihmJiZ2b2lkIDA9PT1iKXtpZihjPVAuZ2V0KGYsYSksdm9pZCAwIT09YylyZXR1cm4gYztpZihjPVAuZ2V0KGYsZCksdm9pZCAwIT09YylyZXR1cm4gYztpZihjPVMoZixkLHZvaWQgMCksdm9pZCAwIT09YylyZXR1cm4gY31lbHNlIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPVAuZ2V0KHRoaXMsZCk7UC5zZXQodGhpcyxkLGIpLC0xIT09YS5pbmRleE9mKFwiLVwiKSYmdm9pZCAwIT09YyYmUC5zZXQodGhpcyxhLGIpfSl9LG51bGwsYixhcmd1bWVudHMubGVuZ3RoPjEsbnVsbCwhMCl9LHJlbW92ZURhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1AucmVtb3ZlKHRoaXMsYSl9KX19KSxuLmV4dGVuZCh7cXVldWU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO3JldHVybiBhPyhiPShifHxcImZ4XCIpK1wicXVldWVcIixkPU8uZ2V0KGEsYiksYyYmKCFkfHxuLmlzQXJyYXkoYyk/ZD1PLmFjY2VzcyhhLGIsbi5tYWtlQXJyYXkoYykpOmQucHVzaChjKSksZHx8W10pOnZvaWQgMH0sZGVxdWV1ZTpmdW5jdGlvbihhLGIpe2I9Ynx8XCJmeFwiO3ZhciBjPW4ucXVldWUoYSxiKSxkPWMubGVuZ3RoLGU9Yy5zaGlmdCgpLGY9bi5fcXVldWVIb29rcyhhLGIpLGc9ZnVuY3Rpb24oKXtuLmRlcXVldWUoYSxiKX07XCJpbnByb2dyZXNzXCI9PT1lJiYoZT1jLnNoaWZ0KCksZC0tKSxlJiYoXCJmeFwiPT09YiYmYy51bnNoaWZ0KFwiaW5wcm9ncmVzc1wiKSxkZWxldGUgZi5zdG9wLGUuY2FsbChhLGcsZikpLCFkJiZmJiZmLmVtcHR5LmZpcmUoKX0sX3F1ZXVlSG9va3M6ZnVuY3Rpb24oYSxiKXt2YXIgYz1iK1wicXVldWVIb29rc1wiO3JldHVybiBPLmdldChhLGMpfHxPLmFjY2VzcyhhLGMse2VtcHR5Om4uQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCl7Ty5yZW1vdmUoYSxbYitcInF1ZXVlXCIsY10pfSl9KX19KSxuLmZuLmV4dGVuZCh7cXVldWU6ZnVuY3Rpb24oYSxiKXt2YXIgYz0yO3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBhJiYoYj1hLGE9XCJmeFwiLGMtLSksYXJndW1lbnRzLmxlbmd0aDxjP24ucXVldWUodGhpc1swXSxhKTp2b2lkIDA9PT1iP3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9bi5xdWV1ZSh0aGlzLGEsYik7bi5fcXVldWVIb29rcyh0aGlzLGEpLFwiZnhcIj09PWEmJlwiaW5wcm9ncmVzc1wiIT09Y1swXSYmbi5kZXF1ZXVlKHRoaXMsYSl9KX0sZGVxdWV1ZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7bi5kZXF1ZXVlKHRoaXMsYSl9KX0sY2xlYXJRdWV1ZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5xdWV1ZShhfHxcImZ4XCIsW10pfSxwcm9taXNlOmZ1bmN0aW9uKGEsYil7dmFyIGMsZD0xLGU9bi5EZWZlcnJlZCgpLGY9dGhpcyxnPXRoaXMubGVuZ3RoLGg9ZnVuY3Rpb24oKXstLWR8fGUucmVzb2x2ZVdpdGgoZixbZl0pfTtcInN0cmluZ1wiIT10eXBlb2YgYSYmKGI9YSxhPXZvaWQgMCksYT1hfHxcImZ4XCI7d2hpbGUoZy0tKWM9Ty5nZXQoZltnXSxhK1wicXVldWVIb29rc1wiKSxjJiZjLmVtcHR5JiYoZCsrLGMuZW1wdHkuYWRkKGgpKTtyZXR1cm4gaCgpLGUucHJvbWlzZShiKX19KTt2YXIgVD0vWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLy5zb3VyY2UsVT1bXCJUb3BcIixcIlJpZ2h0XCIsXCJCb3R0b21cIixcIkxlZnRcIl0sVj1mdW5jdGlvbihhLGIpe3JldHVybiBhPWJ8fGEsXCJub25lXCI9PT1uLmNzcyhhLFwiZGlzcGxheVwiKXx8IW4uY29udGFpbnMoYS5vd25lckRvY3VtZW50LGEpfSxXPS9eKD86Y2hlY2tib3h8cmFkaW8pJC9pOyFmdW5jdGlvbigpe3ZhciBhPWwuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLGI9YS5hcHBlbmRDaGlsZChsLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLGM9bC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7Yy5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJyYWRpb1wiKSxjLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIixcImNoZWNrZWRcIiksYy5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJ0XCIpLGIuYXBwZW5kQ2hpbGQoYyksay5jaGVja0Nsb25lPWIuY2xvbmVOb2RlKCEwKS5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5jaGVja2VkLGIuaW5uZXJIVE1MPVwiPHRleHRhcmVhPng8L3RleHRhcmVhPlwiLGsubm9DbG9uZUNoZWNrZWQ9ISFiLmNsb25lTm9kZSghMCkubGFzdENoaWxkLmRlZmF1bHRWYWx1ZX0oKTt2YXIgWD1cInVuZGVmaW5lZFwiO2suZm9jdXNpbkJ1YmJsZXM9XCJvbmZvY3VzaW5cImluIGE7dmFyIFk9L15rZXkvLFo9L14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51KXxjbGljay8sJD0vXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXz0vXihbXi5dKikoPzpcXC4oLispfCkkLztmdW5jdGlvbiBhYigpe3JldHVybiEwfWZ1bmN0aW9uIGJiKCl7cmV0dXJuITF9ZnVuY3Rpb24gY2IoKXt0cnl7cmV0dXJuIGwuYWN0aXZlRWxlbWVudH1jYXRjaChhKXt9fW4uZXZlbnQ9e2dsb2JhbDp7fSxhZGQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZixnLGgsaSxqLGssbCxtLG8scCxxLHI9Ty5nZXQoYSk7aWYocil7Yy5oYW5kbGVyJiYoZj1jLGM9Zi5oYW5kbGVyLGU9Zi5zZWxlY3RvciksYy5ndWlkfHwoYy5ndWlkPW4uZ3VpZCsrKSwoaT1yLmV2ZW50cyl8fChpPXIuZXZlbnRzPXt9KSwoZz1yLmhhbmRsZSl8fChnPXIuaGFuZGxlPWZ1bmN0aW9uKGIpe3JldHVybiB0eXBlb2YgbiE9PVgmJm4uZXZlbnQudHJpZ2dlcmVkIT09Yi50eXBlP24uZXZlbnQuZGlzcGF0Y2guYXBwbHkoYSxhcmd1bWVudHMpOnZvaWQgMH0pLGI9KGJ8fFwiXCIpLm1hdGNoKEgpfHxbXCJcIl0saj1iLmxlbmd0aDt3aGlsZShqLS0paD1fLmV4ZWMoYltqXSl8fFtdLG89cT1oWzFdLHA9KGhbMl18fFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksbyYmKGw9bi5ldmVudC5zcGVjaWFsW29dfHx7fSxvPShlP2wuZGVsZWdhdGVUeXBlOmwuYmluZFR5cGUpfHxvLGw9bi5ldmVudC5zcGVjaWFsW29dfHx7fSxrPW4uZXh0ZW5kKHt0eXBlOm8sb3JpZ1R5cGU6cSxkYXRhOmQsaGFuZGxlcjpjLGd1aWQ6Yy5ndWlkLHNlbGVjdG9yOmUsbmVlZHNDb250ZXh0OmUmJm4uZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChlKSxuYW1lc3BhY2U6cC5qb2luKFwiLlwiKX0sZiksKG09aVtvXSl8fChtPWlbb109W10sbS5kZWxlZ2F0ZUNvdW50PTAsbC5zZXR1cCYmbC5zZXR1cC5jYWxsKGEsZCxwLGcpIT09ITF8fGEuYWRkRXZlbnRMaXN0ZW5lciYmYS5hZGRFdmVudExpc3RlbmVyKG8sZywhMSkpLGwuYWRkJiYobC5hZGQuY2FsbChhLGspLGsuaGFuZGxlci5ndWlkfHwoay5oYW5kbGVyLmd1aWQ9Yy5ndWlkKSksZT9tLnNwbGljZShtLmRlbGVnYXRlQ291bnQrKywwLGspOm0ucHVzaChrKSxuLmV2ZW50Lmdsb2JhbFtvXT0hMCl9fSxyZW1vdmU6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZixnLGgsaSxqLGssbCxtLG8scCxxLHI9Ty5oYXNEYXRhKGEpJiZPLmdldChhKTtpZihyJiYoaT1yLmV2ZW50cykpe2I9KGJ8fFwiXCIpLm1hdGNoKEgpfHxbXCJcIl0saj1iLmxlbmd0aDt3aGlsZShqLS0paWYoaD1fLmV4ZWMoYltqXSl8fFtdLG89cT1oWzFdLHA9KGhbMl18fFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksbyl7bD1uLmV2ZW50LnNwZWNpYWxbb118fHt9LG89KGQ/bC5kZWxlZ2F0ZVR5cGU6bC5iaW5kVHlwZSl8fG8sbT1pW29dfHxbXSxoPWhbMl0mJm5ldyBSZWdFeHAoXCIoXnxcXFxcLilcIitwLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKStcIihcXFxcLnwkKVwiKSxnPWY9bS5sZW5ndGg7d2hpbGUoZi0tKWs9bVtmXSwhZSYmcSE9PWsub3JpZ1R5cGV8fGMmJmMuZ3VpZCE9PWsuZ3VpZHx8aCYmIWgudGVzdChrLm5hbWVzcGFjZSl8fGQmJmQhPT1rLnNlbGVjdG9yJiYoXCIqKlwiIT09ZHx8IWsuc2VsZWN0b3IpfHwobS5zcGxpY2UoZiwxKSxrLnNlbGVjdG9yJiZtLmRlbGVnYXRlQ291bnQtLSxsLnJlbW92ZSYmbC5yZW1vdmUuY2FsbChhLGspKTtnJiYhbS5sZW5ndGgmJihsLnRlYXJkb3duJiZsLnRlYXJkb3duLmNhbGwoYSxwLHIuaGFuZGxlKSE9PSExfHxuLnJlbW92ZUV2ZW50KGEsbyxyLmhhbmRsZSksZGVsZXRlIGlbb10pfWVsc2UgZm9yKG8gaW4gaSluLmV2ZW50LnJlbW92ZShhLG8rYltqXSxjLGQsITApO24uaXNFbXB0eU9iamVjdChpKSYmKGRlbGV0ZSByLmhhbmRsZSxPLnJlbW92ZShhLFwiZXZlbnRzXCIpKX19LHRyaWdnZXI6ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGYsZyxoLGksayxtLG8scD1bZHx8bF0scT1qLmNhbGwoYixcInR5cGVcIik/Yi50eXBlOmIscj1qLmNhbGwoYixcIm5hbWVzcGFjZVwiKT9iLm5hbWVzcGFjZS5zcGxpdChcIi5cIik6W107aWYoZz1oPWQ9ZHx8bCwzIT09ZC5ub2RlVHlwZSYmOCE9PWQubm9kZVR5cGUmJiEkLnRlc3QocStuLmV2ZW50LnRyaWdnZXJlZCkmJihxLmluZGV4T2YoXCIuXCIpPj0wJiYocj1xLnNwbGl0KFwiLlwiKSxxPXIuc2hpZnQoKSxyLnNvcnQoKSksaz1xLmluZGV4T2YoXCI6XCIpPDAmJlwib25cIitxLGI9YltuLmV4cGFuZG9dP2I6bmV3IG4uRXZlbnQocSxcIm9iamVjdFwiPT10eXBlb2YgYiYmYiksYi5pc1RyaWdnZXI9ZT8yOjMsYi5uYW1lc3BhY2U9ci5qb2luKFwiLlwiKSxiLm5hbWVzcGFjZV9yZT1iLm5hbWVzcGFjZT9uZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIrci5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikrXCIoXFxcXC58JClcIik6bnVsbCxiLnJlc3VsdD12b2lkIDAsYi50YXJnZXR8fChiLnRhcmdldD1kKSxjPW51bGw9PWM/W2JdOm4ubWFrZUFycmF5KGMsW2JdKSxvPW4uZXZlbnQuc3BlY2lhbFtxXXx8e30sZXx8IW8udHJpZ2dlcnx8by50cmlnZ2VyLmFwcGx5KGQsYykhPT0hMSkpe2lmKCFlJiYhby5ub0J1YmJsZSYmIW4uaXNXaW5kb3coZCkpe2ZvcihpPW8uZGVsZWdhdGVUeXBlfHxxLCQudGVzdChpK3EpfHwoZz1nLnBhcmVudE5vZGUpO2c7Zz1nLnBhcmVudE5vZGUpcC5wdXNoKGcpLGg9ZztoPT09KGQub3duZXJEb2N1bWVudHx8bCkmJnAucHVzaChoLmRlZmF1bHRWaWV3fHxoLnBhcmVudFdpbmRvd3x8YSl9Zj0wO3doaWxlKChnPXBbZisrXSkmJiFiLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpYi50eXBlPWY+MT9pOm8uYmluZFR5cGV8fHEsbT0oTy5nZXQoZyxcImV2ZW50c1wiKXx8e30pW2IudHlwZV0mJk8uZ2V0KGcsXCJoYW5kbGVcIiksbSYmbS5hcHBseShnLGMpLG09ayYmZ1trXSxtJiZtLmFwcGx5JiZuLmFjY2VwdERhdGEoZykmJihiLnJlc3VsdD1tLmFwcGx5KGcsYyksYi5yZXN1bHQ9PT0hMSYmYi5wcmV2ZW50RGVmYXVsdCgpKTtyZXR1cm4gYi50eXBlPXEsZXx8Yi5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8by5fZGVmYXVsdCYmby5fZGVmYXVsdC5hcHBseShwLnBvcCgpLGMpIT09ITF8fCFuLmFjY2VwdERhdGEoZCl8fGsmJm4uaXNGdW5jdGlvbihkW3FdKSYmIW4uaXNXaW5kb3coZCkmJihoPWRba10saCYmKGRba109bnVsbCksbi5ldmVudC50cmlnZ2VyZWQ9cSxkW3FdKCksbi5ldmVudC50cmlnZ2VyZWQ9dm9pZCAwLGgmJihkW2tdPWgpKSxiLnJlc3VsdH19LGRpc3BhdGNoOmZ1bmN0aW9uKGEpe2E9bi5ldmVudC5maXgoYSk7dmFyIGIsYyxlLGYsZyxoPVtdLGk9ZC5jYWxsKGFyZ3VtZW50cyksaj0oTy5nZXQodGhpcyxcImV2ZW50c1wiKXx8e30pW2EudHlwZV18fFtdLGs9bi5ldmVudC5zcGVjaWFsW2EudHlwZV18fHt9O2lmKGlbMF09YSxhLmRlbGVnYXRlVGFyZ2V0PXRoaXMsIWsucHJlRGlzcGF0Y2h8fGsucHJlRGlzcGF0Y2guY2FsbCh0aGlzLGEpIT09ITEpe2g9bi5ldmVudC5oYW5kbGVycy5jYWxsKHRoaXMsYSxqKSxiPTA7d2hpbGUoKGY9aFtiKytdKSYmIWEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSl7YS5jdXJyZW50VGFyZ2V0PWYuZWxlbSxjPTA7d2hpbGUoKGc9Zi5oYW5kbGVyc1tjKytdKSYmIWEuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkoIWEubmFtZXNwYWNlX3JlfHxhLm5hbWVzcGFjZV9yZS50ZXN0KGcubmFtZXNwYWNlKSkmJihhLmhhbmRsZU9iaj1nLGEuZGF0YT1nLmRhdGEsZT0oKG4uZXZlbnQuc3BlY2lhbFtnLm9yaWdUeXBlXXx8e30pLmhhbmRsZXx8Zy5oYW5kbGVyKS5hcHBseShmLmVsZW0saSksdm9pZCAwIT09ZSYmKGEucmVzdWx0PWUpPT09ITEmJihhLnByZXZlbnREZWZhdWx0KCksYS5zdG9wUHJvcGFnYXRpb24oKSkpfXJldHVybiBrLnBvc3REaXNwYXRjaCYmay5wb3N0RGlzcGF0Y2guY2FsbCh0aGlzLGEpLGEucmVzdWx0fX0saGFuZGxlcnM6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZixnPVtdLGg9Yi5kZWxlZ2F0ZUNvdW50LGk9YS50YXJnZXQ7aWYoaCYmaS5ub2RlVHlwZSYmKCFhLmJ1dHRvbnx8XCJjbGlja1wiIT09YS50eXBlKSlmb3IoO2khPT10aGlzO2k9aS5wYXJlbnROb2RlfHx0aGlzKWlmKGkuZGlzYWJsZWQhPT0hMHx8XCJjbGlja1wiIT09YS50eXBlKXtmb3IoZD1bXSxjPTA7aD5jO2MrKylmPWJbY10sZT1mLnNlbGVjdG9yK1wiIFwiLHZvaWQgMD09PWRbZV0mJihkW2VdPWYubmVlZHNDb250ZXh0P24oZSx0aGlzKS5pbmRleChpKT49MDpuLmZpbmQoZSx0aGlzLG51bGwsW2ldKS5sZW5ndGgpLGRbZV0mJmQucHVzaChmKTtkLmxlbmd0aCYmZy5wdXNoKHtlbGVtOmksaGFuZGxlcnM6ZH0pfXJldHVybiBoPGIubGVuZ3RoJiZnLnB1c2goe2VsZW06dGhpcyxoYW5kbGVyczpiLnNsaWNlKGgpfSksZ30scHJvcHM6XCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBldmVudFBoYXNlIG1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIi5zcGxpdChcIiBcIiksZml4SG9va3M6e30sa2V5SG9va3M6e3Byb3BzOlwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVwiLnNwbGl0KFwiIFwiKSxmaWx0ZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbnVsbD09YS53aGljaCYmKGEud2hpY2g9bnVsbCE9Yi5jaGFyQ29kZT9iLmNoYXJDb2RlOmIua2V5Q29kZSksYX19LG1vdXNlSG9va3M6e3Byb3BzOlwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBzY3JlZW5YIHNjcmVlblkgdG9FbGVtZW50XCIuc3BsaXQoXCIgXCIpLGZpbHRlcjpmdW5jdGlvbihhLGIpe3ZhciBjLGQsZSxmPWIuYnV0dG9uO3JldHVybiBudWxsPT1hLnBhZ2VYJiZudWxsIT1iLmNsaWVudFgmJihjPWEudGFyZ2V0Lm93bmVyRG9jdW1lbnR8fGwsZD1jLmRvY3VtZW50RWxlbWVudCxlPWMuYm9keSxhLnBhZ2VYPWIuY2xpZW50WCsoZCYmZC5zY3JvbGxMZWZ0fHxlJiZlLnNjcm9sbExlZnR8fDApLShkJiZkLmNsaWVudExlZnR8fGUmJmUuY2xpZW50TGVmdHx8MCksYS5wYWdlWT1iLmNsaWVudFkrKGQmJmQuc2Nyb2xsVG9wfHxlJiZlLnNjcm9sbFRvcHx8MCktKGQmJmQuY2xpZW50VG9wfHxlJiZlLmNsaWVudFRvcHx8MCkpLGEud2hpY2h8fHZvaWQgMD09PWZ8fChhLndoaWNoPTEmZj8xOjImZj8zOjQmZj8yOjApLGF9fSxmaXg6ZnVuY3Rpb24oYSl7aWYoYVtuLmV4cGFuZG9dKXJldHVybiBhO3ZhciBiLGMsZCxlPWEudHlwZSxmPWEsZz10aGlzLmZpeEhvb2tzW2VdO2d8fCh0aGlzLmZpeEhvb2tzW2VdPWc9Wi50ZXN0KGUpP3RoaXMubW91c2VIb29rczpZLnRlc3QoZSk/dGhpcy5rZXlIb29rczp7fSksZD1nLnByb3BzP3RoaXMucHJvcHMuY29uY2F0KGcucHJvcHMpOnRoaXMucHJvcHMsYT1uZXcgbi5FdmVudChmKSxiPWQubGVuZ3RoO3doaWxlKGItLSljPWRbYl0sYVtjXT1mW2NdO3JldHVybiBhLnRhcmdldHx8KGEudGFyZ2V0PWwpLDM9PT1hLnRhcmdldC5ub2RlVHlwZSYmKGEudGFyZ2V0PWEudGFyZ2V0LnBhcmVudE5vZGUpLGcuZmlsdGVyP2cuZmlsdGVyKGEsZik6YX0sc3BlY2lhbDp7bG9hZDp7bm9CdWJibGU6ITB9LGZvY3VzOnt0cmlnZ2VyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMhPT1jYigpJiZ0aGlzLmZvY3VzPyh0aGlzLmZvY3VzKCksITEpOnZvaWQgMH0sZGVsZWdhdGVUeXBlOlwiZm9jdXNpblwifSxibHVyOnt0cmlnZ2VyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXM9PT1jYigpJiZ0aGlzLmJsdXI/KHRoaXMuYmx1cigpLCExKTp2b2lkIDB9LGRlbGVnYXRlVHlwZTpcImZvY3Vzb3V0XCJ9LGNsaWNrOnt0cmlnZ2VyOmZ1bmN0aW9uKCl7cmV0dXJuXCJjaGVja2JveFwiPT09dGhpcy50eXBlJiZ0aGlzLmNsaWNrJiZuLm5vZGVOYW1lKHRoaXMsXCJpbnB1dFwiKT8odGhpcy5jbGljaygpLCExKTp2b2lkIDB9LF9kZWZhdWx0OmZ1bmN0aW9uKGEpe3JldHVybiBuLm5vZGVOYW1lKGEudGFyZ2V0LFwiYVwiKX19LGJlZm9yZXVubG9hZDp7cG9zdERpc3BhdGNoOmZ1bmN0aW9uKGEpe3ZvaWQgMCE9PWEucmVzdWx0JiZhLm9yaWdpbmFsRXZlbnQmJihhLm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWU9YS5yZXN1bHQpfX19LHNpbXVsYXRlOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPW4uZXh0ZW5kKG5ldyBuLkV2ZW50LGMse3R5cGU6YSxpc1NpbXVsYXRlZDohMCxvcmlnaW5hbEV2ZW50Ont9fSk7ZD9uLmV2ZW50LnRyaWdnZXIoZSxudWxsLGIpOm4uZXZlbnQuZGlzcGF0Y2guY2FsbChiLGUpLGUuaXNEZWZhdWx0UHJldmVudGVkKCkmJmMucHJldmVudERlZmF1bHQoKX19LG4ucmVtb3ZlRXZlbnQ9ZnVuY3Rpb24oYSxiLGMpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lciYmYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsYywhMSl9LG4uRXZlbnQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIG4uRXZlbnQ/KGEmJmEudHlwZT8odGhpcy5vcmlnaW5hbEV2ZW50PWEsdGhpcy50eXBlPWEudHlwZSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1hLmRlZmF1bHRQcmV2ZW50ZWR8fHZvaWQgMD09PWEuZGVmYXVsdFByZXZlbnRlZCYmYS5yZXR1cm5WYWx1ZT09PSExP2FiOmJiKTp0aGlzLnR5cGU9YSxiJiZuLmV4dGVuZCh0aGlzLGIpLHRoaXMudGltZVN0YW1wPWEmJmEudGltZVN0YW1wfHxuLm5vdygpLHZvaWQodGhpc1tuLmV4cGFuZG9dPSEwKSk6bmV3IG4uRXZlbnQoYSxiKX0sbi5FdmVudC5wcm90b3R5cGU9e2lzRGVmYXVsdFByZXZlbnRlZDpiYixpc1Byb3BhZ2F0aW9uU3RvcHBlZDpiYixpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDpiYixwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1hYixhJiZhLnByZXZlbnREZWZhdWx0JiZhLnByZXZlbnREZWZhdWx0KCl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPWFiLGEmJmEuc3RvcFByb3BhZ2F0aW9uJiZhLnN0b3BQcm9wYWdhdGlvbigpfSxzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZD1hYixhJiZhLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiYmYS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSx0aGlzLnN0b3BQcm9wYWdhdGlvbigpfX0sbi5lYWNoKHttb3VzZWVudGVyOlwibW91c2VvdmVyXCIsbW91c2VsZWF2ZTpcIm1vdXNlb3V0XCIscG9pbnRlcmVudGVyOlwicG9pbnRlcm92ZXJcIixwb2ludGVybGVhdmU6XCJwb2ludGVyb3V0XCJ9LGZ1bmN0aW9uKGEsYil7bi5ldmVudC5zcGVjaWFsW2FdPXtkZWxlZ2F0ZVR5cGU6YixiaW5kVHlwZTpiLGhhbmRsZTpmdW5jdGlvbihhKXt2YXIgYyxkPXRoaXMsZT1hLnJlbGF0ZWRUYXJnZXQsZj1hLmhhbmRsZU9iajtyZXR1cm4oIWV8fGUhPT1kJiYhbi5jb250YWlucyhkLGUpKSYmKGEudHlwZT1mLm9yaWdUeXBlLGM9Zi5oYW5kbGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxhLnR5cGU9YiksY319fSksay5mb2N1c2luQnViYmxlc3x8bi5lYWNoKHtmb2N1czpcImZvY3VzaW5cIixibHVyOlwiZm9jdXNvdXRcIn0sZnVuY3Rpb24oYSxiKXt2YXIgYz1mdW5jdGlvbihhKXtuLmV2ZW50LnNpbXVsYXRlKGIsYS50YXJnZXQsbi5ldmVudC5maXgoYSksITApfTtuLmV2ZW50LnNwZWNpYWxbYl09e3NldHVwOmZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5vd25lckRvY3VtZW50fHx0aGlzLGU9Ty5hY2Nlc3MoZCxiKTtlfHxkLmFkZEV2ZW50TGlzdGVuZXIoYSxjLCEwKSxPLmFjY2VzcyhkLGIsKGV8fDApKzEpfSx0ZWFyZG93bjpmdW5jdGlvbigpe3ZhciBkPXRoaXMub3duZXJEb2N1bWVudHx8dGhpcyxlPU8uYWNjZXNzKGQsYiktMTtlP08uYWNjZXNzKGQsYixlKTooZC5yZW1vdmVFdmVudExpc3RlbmVyKGEsYywhMCksTy5yZW1vdmUoZCxiKSl9fX0pLG4uZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmLGc7aWYoXCJvYmplY3RcIj09dHlwZW9mIGEpe1wic3RyaW5nXCIhPXR5cGVvZiBiJiYoYz1jfHxiLGI9dm9pZCAwKTtmb3IoZyBpbiBhKXRoaXMub24oZyxiLGMsYVtnXSxlKTtyZXR1cm4gdGhpc31pZihudWxsPT1jJiZudWxsPT1kPyhkPWIsYz1iPXZvaWQgMCk6bnVsbD09ZCYmKFwic3RyaW5nXCI9PXR5cGVvZiBiPyhkPWMsYz12b2lkIDApOihkPWMsYz1iLGI9dm9pZCAwKSksZD09PSExKWQ9YmI7ZWxzZSBpZighZClyZXR1cm4gdGhpcztyZXR1cm4gMT09PWUmJihmPWQsZD1mdW5jdGlvbihhKXtyZXR1cm4gbigpLm9mZihhKSxmLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZC5ndWlkPWYuZ3VpZHx8KGYuZ3VpZD1uLmd1aWQrKykpLHRoaXMuZWFjaChmdW5jdGlvbigpe24uZXZlbnQuYWRkKHRoaXMsYSxkLGMsYil9KX0sb25lOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLm9uKGEsYixjLGQsMSl9LG9mZjpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZTtpZihhJiZhLnByZXZlbnREZWZhdWx0JiZhLmhhbmRsZU9iailyZXR1cm4gZD1hLmhhbmRsZU9iaixuKGEuZGVsZWdhdGVUYXJnZXQpLm9mZihkLm5hbWVzcGFjZT9kLm9yaWdUeXBlK1wiLlwiK2QubmFtZXNwYWNlOmQub3JpZ1R5cGUsZC5zZWxlY3RvcixkLmhhbmRsZXIpLHRoaXM7aWYoXCJvYmplY3RcIj09dHlwZW9mIGEpe2ZvcihlIGluIGEpdGhpcy5vZmYoZSxiLGFbZV0pO3JldHVybiB0aGlzfXJldHVybihiPT09ITF8fFwiZnVuY3Rpb25cIj09dHlwZW9mIGIpJiYoYz1iLGI9dm9pZCAwKSxjPT09ITEmJihjPWJiKSx0aGlzLmVhY2goZnVuY3Rpb24oKXtuLmV2ZW50LnJlbW92ZSh0aGlzLGEsYyxiKX0pfSx0cmlnZ2VyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe24uZXZlbnQudHJpZ2dlcihhLGIsdGhpcyl9KX0sdHJpZ2dlckhhbmRsZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzWzBdO3JldHVybiBjP24uZXZlbnQudHJpZ2dlcihhLGIsYywhMCk6dm9pZCAwfX0pO3ZhciBkYj0vPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vZ2ksZWI9LzwoW1xcdzpdKykvLGZiPS88fCYjP1xcdys7LyxnYj0vPCg/OnNjcmlwdHxzdHlsZXxsaW5rKS9pLGhiPS9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksaWI9L14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxqYj0vXnRydWVcXC8oLiopLyxrYj0vXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2csbGI9e29wdGlvbjpbMSxcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIixcIjwvc2VsZWN0PlwiXSx0aGVhZDpbMSxcIjx0YWJsZT5cIixcIjwvdGFibGU+XCJdLGNvbDpbMixcIjx0YWJsZT48Y29sZ3JvdXA+XCIsXCI8L2NvbGdyb3VwPjwvdGFibGU+XCJdLHRyOlsyLFwiPHRhYmxlPjx0Ym9keT5cIixcIjwvdGJvZHk+PC90YWJsZT5cIl0sdGQ6WzMsXCI8dGFibGU+PHRib2R5Pjx0cj5cIixcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSxfZGVmYXVsdDpbMCxcIlwiLFwiXCJdfTtsYi5vcHRncm91cD1sYi5vcHRpb24sbGIudGJvZHk9bGIudGZvb3Q9bGIuY29sZ3JvdXA9bGIuY2FwdGlvbj1sYi50aGVhZCxsYi50aD1sYi50ZDtmdW5jdGlvbiBtYihhLGIpe3JldHVybiBuLm5vZGVOYW1lKGEsXCJ0YWJsZVwiKSYmbi5ub2RlTmFtZSgxMSE9PWIubm9kZVR5cGU/YjpiLmZpcnN0Q2hpbGQsXCJ0clwiKT9hLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGJvZHlcIilbMF18fGEuYXBwZW5kQ2hpbGQoYS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0Ym9keVwiKSk6YX1mdW5jdGlvbiBuYihhKXtyZXR1cm4gYS50eXBlPShudWxsIT09YS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKStcIi9cIithLnR5cGUsYX1mdW5jdGlvbiBvYihhKXt2YXIgYj1qYi5leGVjKGEudHlwZSk7cmV0dXJuIGI/YS50eXBlPWJbMV06YS5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpLGF9ZnVuY3Rpb24gcGIoYSxiKXtmb3IodmFyIGM9MCxkPWEubGVuZ3RoO2Q+YztjKyspTy5zZXQoYVtjXSxcImdsb2JhbEV2YWxcIiwhYnx8Ty5nZXQoYltjXSxcImdsb2JhbEV2YWxcIikpfWZ1bmN0aW9uIHFiKGEsYil7dmFyIGMsZCxlLGYsZyxoLGksajtpZigxPT09Yi5ub2RlVHlwZSl7aWYoTy5oYXNEYXRhKGEpJiYoZj1PLmFjY2VzcyhhKSxnPU8uc2V0KGIsZiksaj1mLmV2ZW50cykpe2RlbGV0ZSBnLmhhbmRsZSxnLmV2ZW50cz17fTtmb3IoZSBpbiBqKWZvcihjPTAsZD1qW2VdLmxlbmd0aDtkPmM7YysrKW4uZXZlbnQuYWRkKGIsZSxqW2VdW2NdKX1QLmhhc0RhdGEoYSkmJihoPVAuYWNjZXNzKGEpLGk9bi5leHRlbmQoe30saCksUC5zZXQoYixpKSl9fWZ1bmN0aW9uIHJiKGEsYil7dmFyIGM9YS5nZXRFbGVtZW50c0J5VGFnTmFtZT9hLmdldEVsZW1lbnRzQnlUYWdOYW1lKGJ8fFwiKlwiKTphLnF1ZXJ5U2VsZWN0b3JBbGw/YS5xdWVyeVNlbGVjdG9yQWxsKGJ8fFwiKlwiKTpbXTtyZXR1cm4gdm9pZCAwPT09Ynx8YiYmbi5ub2RlTmFtZShhLGIpP24ubWVyZ2UoW2FdLGMpOmN9ZnVuY3Rpb24gc2IoYSxiKXt2YXIgYz1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XCJpbnB1dFwiPT09YyYmVy50ZXN0KGEudHlwZSk/Yi5jaGVja2VkPWEuY2hlY2tlZDooXCJpbnB1dFwiPT09Y3x8XCJ0ZXh0YXJlYVwiPT09YykmJihiLmRlZmF1bHRWYWx1ZT1hLmRlZmF1bHRWYWx1ZSl9bi5leHRlbmQoe2Nsb25lOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZyxoPWEuY2xvbmVOb2RlKCEwKSxpPW4uY29udGFpbnMoYS5vd25lckRvY3VtZW50LGEpO2lmKCEoay5ub0Nsb25lQ2hlY2tlZHx8MSE9PWEubm9kZVR5cGUmJjExIT09YS5ub2RlVHlwZXx8bi5pc1hNTERvYyhhKSkpZm9yKGc9cmIoaCksZj1yYihhKSxkPTAsZT1mLmxlbmd0aDtlPmQ7ZCsrKXNiKGZbZF0sZ1tkXSk7aWYoYilpZihjKWZvcihmPWZ8fHJiKGEpLGc9Z3x8cmIoaCksZD0wLGU9Zi5sZW5ndGg7ZT5kO2QrKylxYihmW2RdLGdbZF0pO2Vsc2UgcWIoYSxoKTtyZXR1cm4gZz1yYihoLFwic2NyaXB0XCIpLGcubGVuZ3RoPjAmJnBiKGcsIWkmJnJiKGEsXCJzY3JpcHRcIikpLGh9LGJ1aWxkRnJhZ21lbnQ6ZnVuY3Rpb24oYSxiLGMsZCl7Zm9yKHZhciBlLGYsZyxoLGksaixrPWIuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLGw9W10sbT0wLG89YS5sZW5ndGg7bz5tO20rKylpZihlPWFbbV0sZXx8MD09PWUpaWYoXCJvYmplY3RcIj09PW4udHlwZShlKSluLm1lcmdlKGwsZS5ub2RlVHlwZT9bZV06ZSk7ZWxzZSBpZihmYi50ZXN0KGUpKXtmPWZ8fGsuYXBwZW5kQ2hpbGQoYi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxnPShlYi5leGVjKGUpfHxbXCJcIixcIlwiXSlbMV0udG9Mb3dlckNhc2UoKSxoPWxiW2ddfHxsYi5fZGVmYXVsdCxmLmlubmVySFRNTD1oWzFdK2UucmVwbGFjZShkYixcIjwkMT48LyQyPlwiKStoWzJdLGo9aFswXTt3aGlsZShqLS0pZj1mLmxhc3RDaGlsZDtuLm1lcmdlKGwsZi5jaGlsZE5vZGVzKSxmPWsuZmlyc3RDaGlsZCxmLnRleHRDb250ZW50PVwiXCJ9ZWxzZSBsLnB1c2goYi5jcmVhdGVUZXh0Tm9kZShlKSk7ay50ZXh0Q29udGVudD1cIlwiLG09MDt3aGlsZShlPWxbbSsrXSlpZigoIWR8fC0xPT09bi5pbkFycmF5KGUsZCkpJiYoaT1uLmNvbnRhaW5zKGUub3duZXJEb2N1bWVudCxlKSxmPXJiKGsuYXBwZW5kQ2hpbGQoZSksXCJzY3JpcHRcIiksaSYmcGIoZiksYykpe2o9MDt3aGlsZShlPWZbaisrXSlpYi50ZXN0KGUudHlwZXx8XCJcIikmJmMucHVzaChlKX1yZXR1cm4ga30sY2xlYW5EYXRhOmZ1bmN0aW9uKGEpe2Zvcih2YXIgYixjLGQsZSxmPW4uZXZlbnQuc3BlY2lhbCxnPTA7dm9pZCAwIT09KGM9YVtnXSk7ZysrKXtpZihuLmFjY2VwdERhdGEoYykmJihlPWNbTy5leHBhbmRvXSxlJiYoYj1PLmNhY2hlW2VdKSkpe2lmKGIuZXZlbnRzKWZvcihkIGluIGIuZXZlbnRzKWZbZF0/bi5ldmVudC5yZW1vdmUoYyxkKTpuLnJlbW92ZUV2ZW50KGMsZCxiLmhhbmRsZSk7Ty5jYWNoZVtlXSYmZGVsZXRlIE8uY2FjaGVbZV19ZGVsZXRlIFAuY2FjaGVbY1tQLmV4cGFuZG9dXX19fSksbi5mbi5leHRlbmQoe3RleHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIE0odGhpcyxmdW5jdGlvbihhKXtyZXR1cm4gdm9pZCAwPT09YT9uLnRleHQodGhpcyk6dGhpcy5lbXB0eSgpLmVhY2goZnVuY3Rpb24oKXsoMT09PXRoaXMubm9kZVR5cGV8fDExPT09dGhpcy5ub2RlVHlwZXx8OT09PXRoaXMubm9kZVR5cGUpJiYodGhpcy50ZXh0Q29udGVudD1hKX0pfSxudWxsLGEsYXJndW1lbnRzLmxlbmd0aCl9LGFwcGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRvbU1hbmlwKGFyZ3VtZW50cyxmdW5jdGlvbihhKXtpZigxPT09dGhpcy5ub2RlVHlwZXx8MTE9PT10aGlzLm5vZGVUeXBlfHw5PT09dGhpcy5ub2RlVHlwZSl7dmFyIGI9bWIodGhpcyxhKTtiLmFwcGVuZENoaWxkKGEpfX0pfSxwcmVwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLGZ1bmN0aW9uKGEpe2lmKDE9PT10aGlzLm5vZGVUeXBlfHwxMT09PXRoaXMubm9kZVR5cGV8fDk9PT10aGlzLm5vZGVUeXBlKXt2YXIgYj1tYih0aGlzLGEpO2IuaW5zZXJ0QmVmb3JlKGEsYi5maXJzdENoaWxkKX19KX0sYmVmb3JlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLGZ1bmN0aW9uKGEpe3RoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLHRoaXMpfSl9LGFmdGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLGZ1bmN0aW9uKGEpe3RoaXMucGFyZW50Tm9kZSYmdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLHRoaXMubmV4dFNpYmxpbmcpfSl9LHJlbW92ZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYyxkPWE/bi5maWx0ZXIoYSx0aGlzKTp0aGlzLGU9MDtudWxsIT0oYz1kW2VdKTtlKyspYnx8MSE9PWMubm9kZVR5cGV8fG4uY2xlYW5EYXRhKHJiKGMpKSxjLnBhcmVudE5vZGUmJihiJiZuLmNvbnRhaW5zKGMub3duZXJEb2N1bWVudCxjKSYmcGIocmIoYyxcInNjcmlwdFwiKSksYy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpKTtyZXR1cm4gdGhpc30sZW1wdHk6ZnVuY3Rpb24oKXtmb3IodmFyIGEsYj0wO251bGwhPShhPXRoaXNbYl0pO2IrKykxPT09YS5ub2RlVHlwZSYmKG4uY2xlYW5EYXRhKHJiKGEsITEpKSxhLnRleHRDb250ZW50PVwiXCIpO3JldHVybiB0aGlzfSxjbG9uZTpmdW5jdGlvbihhLGIpe3JldHVybiBhPW51bGw9PWE/ITE6YSxiPW51bGw9PWI/YTpiLHRoaXMubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIG4uY2xvbmUodGhpcyxhLGIpfSl9LGh0bWw6ZnVuY3Rpb24oYSl7cmV0dXJuIE0odGhpcyxmdW5jdGlvbihhKXt2YXIgYj10aGlzWzBdfHx7fSxjPTAsZD10aGlzLmxlbmd0aDtpZih2b2lkIDA9PT1hJiYxPT09Yi5ub2RlVHlwZSlyZXR1cm4gYi5pbm5lckhUTUw7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGEmJiFnYi50ZXN0KGEpJiYhbGJbKGViLmV4ZWMoYSl8fFtcIlwiLFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpXSl7YT1hLnJlcGxhY2UoZGIsXCI8JDE+PC8kMj5cIik7dHJ5e2Zvcig7ZD5jO2MrKyliPXRoaXNbY118fHt9LDE9PT1iLm5vZGVUeXBlJiYobi5jbGVhbkRhdGEocmIoYiwhMSkpLGIuaW5uZXJIVE1MPWEpO2I9MH1jYXRjaChlKXt9fWImJnRoaXMuZW1wdHkoKS5hcHBlbmQoYSl9LG51bGwsYSxhcmd1bWVudHMubGVuZ3RoKX0scmVwbGFjZVdpdGg6ZnVuY3Rpb24oKXt2YXIgYT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZG9tTWFuaXAoYXJndW1lbnRzLGZ1bmN0aW9uKGIpe2E9dGhpcy5wYXJlbnROb2RlLG4uY2xlYW5EYXRhKHJiKHRoaXMpKSxhJiZhLnJlcGxhY2VDaGlsZChiLHRoaXMpfSksYSYmKGEubGVuZ3RofHxhLm5vZGVUeXBlKT90aGlzOnRoaXMucmVtb3ZlKCl9LGRldGFjaDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5yZW1vdmUoYSwhMCl9LGRvbU1hbmlwOmZ1bmN0aW9uKGEsYil7YT1lLmFwcGx5KFtdLGEpO3ZhciBjLGQsZixnLGgsaSxqPTAsbD10aGlzLmxlbmd0aCxtPXRoaXMsbz1sLTEscD1hWzBdLHE9bi5pc0Z1bmN0aW9uKHApO2lmKHF8fGw+MSYmXCJzdHJpbmdcIj09dHlwZW9mIHAmJiFrLmNoZWNrQ2xvbmUmJmhiLnRlc3QocCkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjKXt2YXIgZD1tLmVxKGMpO3EmJihhWzBdPXAuY2FsbCh0aGlzLGMsZC5odG1sKCkpKSxkLmRvbU1hbmlwKGEsYil9KTtpZihsJiYoYz1uLmJ1aWxkRnJhZ21lbnQoYSx0aGlzWzBdLm93bmVyRG9jdW1lbnQsITEsdGhpcyksZD1jLmZpcnN0Q2hpbGQsMT09PWMuY2hpbGROb2Rlcy5sZW5ndGgmJihjPWQpLGQpKXtmb3IoZj1uLm1hcChyYihjLFwic2NyaXB0XCIpLG5iKSxnPWYubGVuZ3RoO2w+ajtqKyspaD1jLGohPT1vJiYoaD1uLmNsb25lKGgsITAsITApLGcmJm4ubWVyZ2UoZixyYihoLFwic2NyaXB0XCIpKSksYi5jYWxsKHRoaXNbal0saCxqKTtcblx0aWYoZylmb3IoaT1mW2YubGVuZ3RoLTFdLm93bmVyRG9jdW1lbnQsbi5tYXAoZixvYiksaj0wO2c+ajtqKyspaD1mW2pdLGliLnRlc3QoaC50eXBlfHxcIlwiKSYmIU8uYWNjZXNzKGgsXCJnbG9iYWxFdmFsXCIpJiZuLmNvbnRhaW5zKGksaCkmJihoLnNyYz9uLl9ldmFsVXJsJiZuLl9ldmFsVXJsKGguc3JjKTpuLmdsb2JhbEV2YWwoaC50ZXh0Q29udGVudC5yZXBsYWNlKGtiLFwiXCIpKSl9cmV0dXJuIHRoaXN9fSksbi5lYWNoKHthcHBlbmRUbzpcImFwcGVuZFwiLHByZXBlbmRUbzpcInByZXBlbmRcIixpbnNlcnRCZWZvcmU6XCJiZWZvcmVcIixpbnNlcnRBZnRlcjpcImFmdGVyXCIscmVwbGFjZUFsbDpcInJlcGxhY2VXaXRoXCJ9LGZ1bmN0aW9uKGEsYil7bi5mblthXT1mdW5jdGlvbihhKXtmb3IodmFyIGMsZD1bXSxlPW4oYSksZz1lLmxlbmd0aC0xLGg9MDtnPj1oO2grKyljPWg9PT1nP3RoaXM6dGhpcy5jbG9uZSghMCksbihlW2hdKVtiXShjKSxmLmFwcGx5KGQsYy5nZXQoKSk7cmV0dXJuIHRoaXMucHVzaFN0YWNrKGQpfX0pO3ZhciB0Yix1Yj17fTtmdW5jdGlvbiB2YihiLGMpe3ZhciBkLGU9bihjLmNyZWF0ZUVsZW1lbnQoYikpLmFwcGVuZFRvKGMuYm9keSksZj1hLmdldERlZmF1bHRDb21wdXRlZFN0eWxlJiYoZD1hLmdldERlZmF1bHRDb21wdXRlZFN0eWxlKGVbMF0pKT9kLmRpc3BsYXk6bi5jc3MoZVswXSxcImRpc3BsYXlcIik7cmV0dXJuIGUuZGV0YWNoKCksZn1mdW5jdGlvbiB3YihhKXt2YXIgYj1sLGM9dWJbYV07cmV0dXJuIGN8fChjPXZiKGEsYiksXCJub25lXCIhPT1jJiZjfHwodGI9KHRifHxuKFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlwiKSkuYXBwZW5kVG8oYi5kb2N1bWVudEVsZW1lbnQpLGI9dGJbMF0uY29udGVudERvY3VtZW50LGIud3JpdGUoKSxiLmNsb3NlKCksYz12YihhLGIpLHRiLmRldGFjaCgpKSx1YlthXT1jKSxjfXZhciB4Yj0vXm1hcmdpbi8seWI9bmV3IFJlZ0V4cChcIl4oXCIrVCtcIikoPyFweClbYS16JV0rJFwiLFwiaVwiKSx6Yj1mdW5jdGlvbihhKXtyZXR1cm4gYS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoYSxudWxsKX07ZnVuY3Rpb24gQWIoYSxiLGMpe3ZhciBkLGUsZixnLGg9YS5zdHlsZTtyZXR1cm4gYz1jfHx6YihhKSxjJiYoZz1jLmdldFByb3BlcnR5VmFsdWUoYil8fGNbYl0pLGMmJihcIlwiIT09Z3x8bi5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsYSl8fChnPW4uc3R5bGUoYSxiKSkseWIudGVzdChnKSYmeGIudGVzdChiKSYmKGQ9aC53aWR0aCxlPWgubWluV2lkdGgsZj1oLm1heFdpZHRoLGgubWluV2lkdGg9aC5tYXhXaWR0aD1oLndpZHRoPWcsZz1jLndpZHRoLGgud2lkdGg9ZCxoLm1pbldpZHRoPWUsaC5tYXhXaWR0aD1mKSksdm9pZCAwIT09Zz9nK1wiXCI6Z31mdW5jdGlvbiBCYihhLGIpe3JldHVybntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYSgpP3ZvaWQgZGVsZXRlIHRoaXMuZ2V0Oih0aGlzLmdldD1iKS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fX0hZnVuY3Rpb24oKXt2YXIgYixjLGQ9bC5kb2N1bWVudEVsZW1lbnQsZT1sLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZj1sLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aWYoZi5zdHlsZSl7Zi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcD1cImNvbnRlbnQtYm94XCIsZi5jbG9uZU5vZGUoITApLnN0eWxlLmJhY2tncm91bmRDbGlwPVwiXCIsay5jbGVhckNsb25lU3R5bGU9XCJjb250ZW50LWJveFwiPT09Zi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCxlLnN0eWxlLmNzc1RleHQ9XCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVwiLGUuYXBwZW5kQ2hpbGQoZik7ZnVuY3Rpb24gZygpe2Yuc3R5bGUuY3NzVGV4dD1cIi13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbi10b3A6MSU7dG9wOjElO2JvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NHB4O3Bvc2l0aW9uOmFic29sdXRlXCIsZi5pbm5lckhUTUw9XCJcIixkLmFwcGVuZENoaWxkKGUpO3ZhciBnPWEuZ2V0Q29tcHV0ZWRTdHlsZShmLG51bGwpO2I9XCIxJVwiIT09Zy50b3AsYz1cIjRweFwiPT09Zy53aWR0aCxkLnJlbW92ZUNoaWxkKGUpfWEuZ2V0Q29tcHV0ZWRTdHlsZSYmbi5leHRlbmQoayx7cGl4ZWxQb3NpdGlvbjpmdW5jdGlvbigpe3JldHVybiBnKCksYn0sYm94U2l6aW5nUmVsaWFibGU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09YyYmZygpLGN9LHJlbGlhYmxlTWFyZ2luUmlnaHQ6ZnVuY3Rpb24oKXt2YXIgYixjPWYuYXBwZW5kQ2hpbGQobC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtyZXR1cm4gYy5zdHlsZS5jc3NUZXh0PWYuc3R5bGUuY3NzVGV4dD1cIi13ZWJraXQtYm94LXNpemluZzpjb250ZW50LWJveDstbW96LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtkaXNwbGF5OmJsb2NrO21hcmdpbjowO2JvcmRlcjowO3BhZGRpbmc6MFwiLGMuc3R5bGUubWFyZ2luUmlnaHQ9Yy5zdHlsZS53aWR0aD1cIjBcIixmLnN0eWxlLndpZHRoPVwiMXB4XCIsZC5hcHBlbmRDaGlsZChlKSxiPSFwYXJzZUZsb2F0KGEuZ2V0Q29tcHV0ZWRTdHlsZShjLG51bGwpLm1hcmdpblJpZ2h0KSxkLnJlbW92ZUNoaWxkKGUpLGJ9fSl9fSgpLG4uc3dhcD1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZSxmLGc9e307Zm9yKGYgaW4gYilnW2ZdPWEuc3R5bGVbZl0sYS5zdHlsZVtmXT1iW2ZdO2U9Yy5hcHBseShhLGR8fFtdKTtmb3IoZiBpbiBiKWEuc3R5bGVbZl09Z1tmXTtyZXR1cm4gZX07dmFyIENiPS9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxEYj1uZXcgUmVnRXhwKFwiXihcIitUK1wiKSguKikkXCIsXCJpXCIpLEViPW5ldyBSZWdFeHAoXCJeKFsrLV0pPShcIitUK1wiKVwiLFwiaVwiKSxGYj17cG9zaXRpb246XCJhYnNvbHV0ZVwiLHZpc2liaWxpdHk6XCJoaWRkZW5cIixkaXNwbGF5OlwiYmxvY2tcIn0sR2I9e2xldHRlclNwYWNpbmc6XCIwXCIsZm9udFdlaWdodDpcIjQwMFwifSxIYj1bXCJXZWJraXRcIixcIk9cIixcIk1velwiLFwibXNcIl07ZnVuY3Rpb24gSWIoYSxiKXtpZihiIGluIGEpcmV0dXJuIGI7dmFyIGM9YlswXS50b1VwcGVyQ2FzZSgpK2Iuc2xpY2UoMSksZD1iLGU9SGIubGVuZ3RoO3doaWxlKGUtLSlpZihiPUhiW2VdK2MsYiBpbiBhKXJldHVybiBiO3JldHVybiBkfWZ1bmN0aW9uIEpiKGEsYixjKXt2YXIgZD1EYi5leGVjKGIpO3JldHVybiBkP01hdGgubWF4KDAsZFsxXS0oY3x8MCkpKyhkWzJdfHxcInB4XCIpOmJ9ZnVuY3Rpb24gS2IoYSxiLGMsZCxlKXtmb3IodmFyIGY9Yz09PShkP1wiYm9yZGVyXCI6XCJjb250ZW50XCIpPzQ6XCJ3aWR0aFwiPT09Yj8xOjAsZz0wOzQ+ZjtmKz0yKVwibWFyZ2luXCI9PT1jJiYoZys9bi5jc3MoYSxjK1VbZl0sITAsZSkpLGQ/KFwiY29udGVudFwiPT09YyYmKGctPW4uY3NzKGEsXCJwYWRkaW5nXCIrVVtmXSwhMCxlKSksXCJtYXJnaW5cIiE9PWMmJihnLT1uLmNzcyhhLFwiYm9yZGVyXCIrVVtmXStcIldpZHRoXCIsITAsZSkpKTooZys9bi5jc3MoYSxcInBhZGRpbmdcIitVW2ZdLCEwLGUpLFwicGFkZGluZ1wiIT09YyYmKGcrPW4uY3NzKGEsXCJib3JkZXJcIitVW2ZdK1wiV2lkdGhcIiwhMCxlKSkpO3JldHVybiBnfWZ1bmN0aW9uIExiKGEsYixjKXt2YXIgZD0hMCxlPVwid2lkdGhcIj09PWI/YS5vZmZzZXRXaWR0aDphLm9mZnNldEhlaWdodCxmPXpiKGEpLGc9XCJib3JkZXItYm94XCI9PT1uLmNzcyhhLFwiYm94U2l6aW5nXCIsITEsZik7aWYoMD49ZXx8bnVsbD09ZSl7aWYoZT1BYihhLGIsZiksKDA+ZXx8bnVsbD09ZSkmJihlPWEuc3R5bGVbYl0pLHliLnRlc3QoZSkpcmV0dXJuIGU7ZD1nJiYoay5ib3hTaXppbmdSZWxpYWJsZSgpfHxlPT09YS5zdHlsZVtiXSksZT1wYXJzZUZsb2F0KGUpfHwwfXJldHVybiBlK0tiKGEsYixjfHwoZz9cImJvcmRlclwiOlwiY29udGVudFwiKSxkLGYpK1wicHhcIn1mdW5jdGlvbiBNYihhLGIpe2Zvcih2YXIgYyxkLGUsZj1bXSxnPTAsaD1hLmxlbmd0aDtoPmc7ZysrKWQ9YVtnXSxkLnN0eWxlJiYoZltnXT1PLmdldChkLFwib2xkZGlzcGxheVwiKSxjPWQuc3R5bGUuZGlzcGxheSxiPyhmW2ddfHxcIm5vbmVcIiE9PWN8fChkLnN0eWxlLmRpc3BsYXk9XCJcIiksXCJcIj09PWQuc3R5bGUuZGlzcGxheSYmVihkKSYmKGZbZ109Ty5hY2Nlc3MoZCxcIm9sZGRpc3BsYXlcIix3YihkLm5vZGVOYW1lKSkpKTooZT1WKGQpLFwibm9uZVwiPT09YyYmZXx8Ty5zZXQoZCxcIm9sZGRpc3BsYXlcIixlP2M6bi5jc3MoZCxcImRpc3BsYXlcIikpKSk7Zm9yKGc9MDtoPmc7ZysrKWQ9YVtnXSxkLnN0eWxlJiYoYiYmXCJub25lXCIhPT1kLnN0eWxlLmRpc3BsYXkmJlwiXCIhPT1kLnN0eWxlLmRpc3BsYXl8fChkLnN0eWxlLmRpc3BsYXk9Yj9mW2ddfHxcIlwiOlwibm9uZVwiKSk7cmV0dXJuIGF9bi5leHRlbmQoe2Nzc0hvb2tzOntvcGFjaXR5OntnZXQ6ZnVuY3Rpb24oYSxiKXtpZihiKXt2YXIgYz1BYihhLFwib3BhY2l0eVwiKTtyZXR1cm5cIlwiPT09Yz9cIjFcIjpjfX19fSxjc3NOdW1iZXI6e2NvbHVtbkNvdW50OiEwLGZpbGxPcGFjaXR5OiEwLGZsZXhHcm93OiEwLGZsZXhTaHJpbms6ITAsZm9udFdlaWdodDohMCxsaW5lSGVpZ2h0OiEwLG9wYWNpdHk6ITAsb3JkZXI6ITAsb3JwaGFuczohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITB9LGNzc1Byb3BzOntcImZsb2F0XCI6XCJjc3NGbG9hdFwifSxzdHlsZTpmdW5jdGlvbihhLGIsYyxkKXtpZihhJiYzIT09YS5ub2RlVHlwZSYmOCE9PWEubm9kZVR5cGUmJmEuc3R5bGUpe3ZhciBlLGYsZyxoPW4uY2FtZWxDYXNlKGIpLGk9YS5zdHlsZTtyZXR1cm4gYj1uLmNzc1Byb3BzW2hdfHwobi5jc3NQcm9wc1toXT1JYihpLGgpKSxnPW4uY3NzSG9va3NbYl18fG4uY3NzSG9va3NbaF0sdm9pZCAwPT09Yz9nJiZcImdldFwiaW4gZyYmdm9pZCAwIT09KGU9Zy5nZXQoYSwhMSxkKSk/ZTppW2JdOihmPXR5cGVvZiBjLFwic3RyaW5nXCI9PT1mJiYoZT1FYi5leGVjKGMpKSYmKGM9KGVbMV0rMSkqZVsyXStwYXJzZUZsb2F0KG4uY3NzKGEsYikpLGY9XCJudW1iZXJcIiksbnVsbCE9YyYmYz09PWMmJihcIm51bWJlclwiIT09Znx8bi5jc3NOdW1iZXJbaF18fChjKz1cInB4XCIpLGsuY2xlYXJDbG9uZVN0eWxlfHxcIlwiIT09Y3x8MCE9PWIuaW5kZXhPZihcImJhY2tncm91bmRcIil8fChpW2JdPVwiaW5oZXJpdFwiKSxnJiZcInNldFwiaW4gZyYmdm9pZCAwPT09KGM9Zy5zZXQoYSxjLGQpKXx8KGlbYl09YykpLHZvaWQgMCl9fSxjc3M6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGUsZixnLGg9bi5jYW1lbENhc2UoYik7cmV0dXJuIGI9bi5jc3NQcm9wc1toXXx8KG4uY3NzUHJvcHNbaF09SWIoYS5zdHlsZSxoKSksZz1uLmNzc0hvb2tzW2JdfHxuLmNzc0hvb2tzW2hdLGcmJlwiZ2V0XCJpbiBnJiYoZT1nLmdldChhLCEwLGMpKSx2b2lkIDA9PT1lJiYoZT1BYihhLGIsZCkpLFwibm9ybWFsXCI9PT1lJiZiIGluIEdiJiYoZT1HYltiXSksXCJcIj09PWN8fGM/KGY9cGFyc2VGbG9hdChlKSxjPT09ITB8fG4uaXNOdW1lcmljKGYpP2Z8fDA6ZSk6ZX19KSxuLmVhY2goW1wiaGVpZ2h0XCIsXCJ3aWR0aFwiXSxmdW5jdGlvbihhLGIpe24uY3NzSG9va3NbYl09e2dldDpmdW5jdGlvbihhLGMsZCl7cmV0dXJuIGM/Q2IudGVzdChuLmNzcyhhLFwiZGlzcGxheVwiKSkmJjA9PT1hLm9mZnNldFdpZHRoP24uc3dhcChhLEZiLGZ1bmN0aW9uKCl7cmV0dXJuIExiKGEsYixkKX0pOkxiKGEsYixkKTp2b2lkIDB9LHNldDpmdW5jdGlvbihhLGMsZCl7dmFyIGU9ZCYmemIoYSk7cmV0dXJuIEpiKGEsYyxkP0tiKGEsYixkLFwiYm9yZGVyLWJveFwiPT09bi5jc3MoYSxcImJveFNpemluZ1wiLCExLGUpLGUpOjApfX19KSxuLmNzc0hvb2tzLm1hcmdpblJpZ2h0PUJiKGsucmVsaWFibGVNYXJnaW5SaWdodCxmdW5jdGlvbihhLGIpe3JldHVybiBiP24uc3dhcChhLHtkaXNwbGF5OlwiaW5saW5lLWJsb2NrXCJ9LEFiLFthLFwibWFyZ2luUmlnaHRcIl0pOnZvaWQgMH0pLG4uZWFjaCh7bWFyZ2luOlwiXCIscGFkZGluZzpcIlwiLGJvcmRlcjpcIldpZHRoXCJ9LGZ1bmN0aW9uKGEsYil7bi5jc3NIb29rc1thK2JdPXtleHBhbmQ6ZnVuY3Rpb24oYyl7Zm9yKHZhciBkPTAsZT17fSxmPVwic3RyaW5nXCI9PXR5cGVvZiBjP2Muc3BsaXQoXCIgXCIpOltjXTs0PmQ7ZCsrKWVbYStVW2RdK2JdPWZbZF18fGZbZC0yXXx8ZlswXTtyZXR1cm4gZX19LHhiLnRlc3QoYSl8fChuLmNzc0hvb2tzW2ErYl0uc2V0PUpiKX0pLG4uZm4uZXh0ZW5kKHtjc3M6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gTSh0aGlzLGZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9e30sZz0wO2lmKG4uaXNBcnJheShiKSl7Zm9yKGQ9emIoYSksZT1iLmxlbmd0aDtlPmc7ZysrKWZbYltnXV09bi5jc3MoYSxiW2ddLCExLGQpO3JldHVybiBmfXJldHVybiB2b2lkIDAhPT1jP24uc3R5bGUoYSxiLGMpOm4uY3NzKGEsYil9LGEsYixhcmd1bWVudHMubGVuZ3RoPjEpfSxzaG93OmZ1bmN0aW9uKCl7cmV0dXJuIE1iKHRoaXMsITApfSxoaWRlOmZ1bmN0aW9uKCl7cmV0dXJuIE1iKHRoaXMpfSx0b2dnbGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBhP2E/dGhpcy5zaG93KCk6dGhpcy5oaWRlKCk6dGhpcy5lYWNoKGZ1bmN0aW9uKCl7Vih0aGlzKT9uKHRoaXMpLnNob3coKTpuKHRoaXMpLmhpZGUoKX0pfX0pLG4uZm4uZGVsYXk9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT1uLmZ4P24uZnguc3BlZWRzW2FdfHxhOmEsYj1ifHxcImZ4XCIsdGhpcy5xdWV1ZShiLGZ1bmN0aW9uKGIsYyl7dmFyIGQ9c2V0VGltZW91dChiLGEpO2Muc3RvcD1mdW5jdGlvbigpe2NsZWFyVGltZW91dChkKX19KX0sZnVuY3Rpb24oKXt2YXIgYT1sLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxiPWwuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKSxjPWIuYXBwZW5kQ2hpbGQobC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpKTthLnR5cGU9XCJjaGVja2JveFwiLGsuY2hlY2tPbj1cIlwiIT09YS52YWx1ZSxrLm9wdFNlbGVjdGVkPWMuc2VsZWN0ZWQsYi5kaXNhYmxlZD0hMCxrLm9wdERpc2FibGVkPSFjLmRpc2FibGVkLGE9bC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksYS52YWx1ZT1cInRcIixhLnR5cGU9XCJyYWRpb1wiLGsucmFkaW9WYWx1ZT1cInRcIj09PWEudmFsdWV9KCk7dmFyIE5iLE9iLFBiPW4uZXhwci5hdHRySGFuZGxlO24uZm4uZXh0ZW5kKHthdHRyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIE0odGhpcyxuLmF0dHIsYSxiLGFyZ3VtZW50cy5sZW5ndGg+MSl9LHJlbW92ZUF0dHI6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe24ucmVtb3ZlQXR0cih0aGlzLGEpfSl9fSksbi5leHRlbmQoe2F0dHI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZj1hLm5vZGVUeXBlO2lmKGEmJjMhPT1mJiY4IT09ZiYmMiE9PWYpcmV0dXJuIHR5cGVvZiBhLmdldEF0dHJpYnV0ZT09PVg/bi5wcm9wKGEsYixjKTooMT09PWYmJm4uaXNYTUxEb2MoYSl8fChiPWIudG9Mb3dlckNhc2UoKSxkPW4uYXR0ckhvb2tzW2JdfHwobi5leHByLm1hdGNoLmJvb2wudGVzdChiKT9PYjpOYikpLHZvaWQgMD09PWM/ZCYmXCJnZXRcImluIGQmJm51bGwhPT0oZT1kLmdldChhLGIpKT9lOihlPW4uZmluZC5hdHRyKGEsYiksbnVsbD09ZT92b2lkIDA6ZSk6bnVsbCE9PWM/ZCYmXCJzZXRcImluIGQmJnZvaWQgMCE9PShlPWQuc2V0KGEsYyxiKSk/ZTooYS5zZXRBdHRyaWJ1dGUoYixjK1wiXCIpLGMpOnZvaWQgbi5yZW1vdmVBdHRyKGEsYikpfSxyZW1vdmVBdHRyOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPTAsZj1iJiZiLm1hdGNoKEgpO2lmKGYmJjE9PT1hLm5vZGVUeXBlKXdoaWxlKGM9ZltlKytdKWQ9bi5wcm9wRml4W2NdfHxjLG4uZXhwci5tYXRjaC5ib29sLnRlc3QoYykmJihhW2RdPSExKSxhLnJlbW92ZUF0dHJpYnV0ZShjKX0sYXR0ckhvb2tzOnt0eXBlOntzZXQ6ZnVuY3Rpb24oYSxiKXtpZighay5yYWRpb1ZhbHVlJiZcInJhZGlvXCI9PT1iJiZuLm5vZGVOYW1lKGEsXCJpbnB1dFwiKSl7dmFyIGM9YS52YWx1ZTtyZXR1cm4gYS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsYiksYyYmKGEudmFsdWU9YyksYn19fX19KSxPYj17c2V0OmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYj09PSExP24ucmVtb3ZlQXR0cihhLGMpOmEuc2V0QXR0cmlidXRlKGMsYyksY319LG4uZWFjaChuLmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksZnVuY3Rpb24oYSxiKXt2YXIgYz1QYltiXXx8bi5maW5kLmF0dHI7UGJbYl09ZnVuY3Rpb24oYSxiLGQpe3ZhciBlLGY7cmV0dXJuIGR8fChmPVBiW2JdLFBiW2JdPWUsZT1udWxsIT1jKGEsYixkKT9iLnRvTG93ZXJDYXNlKCk6bnVsbCxQYltiXT1mKSxlfX0pO3ZhciBRYj0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pO24uZm4uZXh0ZW5kKHtwcm9wOmZ1bmN0aW9uKGEsYil7cmV0dXJuIE0odGhpcyxuLnByb3AsYSxiLGFyZ3VtZW50cy5sZW5ndGg+MSl9LHJlbW92ZVByb3A6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe2RlbGV0ZSB0aGlzW24ucHJvcEZpeFthXXx8YV19KX19KSxuLmV4dGVuZCh7cHJvcEZpeDp7XCJmb3JcIjpcImh0bWxGb3JcIixcImNsYXNzXCI6XCJjbGFzc05hbWVcIn0scHJvcDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGc9YS5ub2RlVHlwZTtpZihhJiYzIT09ZyYmOCE9PWcmJjIhPT1nKXJldHVybiBmPTEhPT1nfHwhbi5pc1hNTERvYyhhKSxmJiYoYj1uLnByb3BGaXhbYl18fGIsZT1uLnByb3BIb29rc1tiXSksdm9pZCAwIT09Yz9lJiZcInNldFwiaW4gZSYmdm9pZCAwIT09KGQ9ZS5zZXQoYSxjLGIpKT9kOmFbYl09YzplJiZcImdldFwiaW4gZSYmbnVsbCE9PShkPWUuZ2V0KGEsYikpP2Q6YVtiXX0scHJvcEhvb2tzOnt0YWJJbmRleDp7Z2V0OmZ1bmN0aW9uKGEpe3JldHVybiBhLmhhc0F0dHJpYnV0ZShcInRhYmluZGV4XCIpfHxRYi50ZXN0KGEubm9kZU5hbWUpfHxhLmhyZWY/YS50YWJJbmRleDotMX19fX0pLGsub3B0U2VsZWN0ZWR8fChuLnByb3BIb29rcy5zZWxlY3RlZD17Z2V0OmZ1bmN0aW9uKGEpe3ZhciBiPWEucGFyZW50Tm9kZTtyZXR1cm4gYiYmYi5wYXJlbnROb2RlJiZiLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCxudWxsfX0pLG4uZWFjaChbXCJ0YWJJbmRleFwiLFwicmVhZE9ubHlcIixcIm1heExlbmd0aFwiLFwiY2VsbFNwYWNpbmdcIixcImNlbGxQYWRkaW5nXCIsXCJyb3dTcGFuXCIsXCJjb2xTcGFuXCIsXCJ1c2VNYXBcIixcImZyYW1lQm9yZGVyXCIsXCJjb250ZW50RWRpdGFibGVcIl0sZnVuY3Rpb24oKXtuLnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXT10aGlzfSk7dmFyIFJiPS9bXFx0XFxyXFxuXFxmXS9nO24uZm4uZXh0ZW5kKHthZGRDbGFzczpmdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGcsaD1cInN0cmluZ1wiPT10eXBlb2YgYSYmYSxpPTAsaj10aGlzLmxlbmd0aDtpZihuLmlzRnVuY3Rpb24oYSkpcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihiKXtuKHRoaXMpLmFkZENsYXNzKGEuY2FsbCh0aGlzLGIsdGhpcy5jbGFzc05hbWUpKX0pO2lmKGgpZm9yKGI9KGF8fFwiXCIpLm1hdGNoKEgpfHxbXTtqPmk7aSsrKWlmKGM9dGhpc1tpXSxkPTE9PT1jLm5vZGVUeXBlJiYoYy5jbGFzc05hbWU/KFwiIFwiK2MuY2xhc3NOYW1lK1wiIFwiKS5yZXBsYWNlKFJiLFwiIFwiKTpcIiBcIikpe2Y9MDt3aGlsZShlPWJbZisrXSlkLmluZGV4T2YoXCIgXCIrZStcIiBcIik8MCYmKGQrPWUrXCIgXCIpO2c9bi50cmltKGQpLGMuY2xhc3NOYW1lIT09ZyYmKGMuY2xhc3NOYW1lPWcpfXJldHVybiB0aGlzfSxyZW1vdmVDbGFzczpmdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGcsaD0wPT09YXJndW1lbnRzLmxlbmd0aHx8XCJzdHJpbmdcIj09dHlwZW9mIGEmJmEsaT0wLGo9dGhpcy5sZW5ndGg7aWYobi5pc0Z1bmN0aW9uKGEpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYil7bih0aGlzKS5yZW1vdmVDbGFzcyhhLmNhbGwodGhpcyxiLHRoaXMuY2xhc3NOYW1lKSl9KTtpZihoKWZvcihiPShhfHxcIlwiKS5tYXRjaChIKXx8W107aj5pO2krKylpZihjPXRoaXNbaV0sZD0xPT09Yy5ub2RlVHlwZSYmKGMuY2xhc3NOYW1lPyhcIiBcIitjLmNsYXNzTmFtZStcIiBcIikucmVwbGFjZShSYixcIiBcIik6XCJcIikpe2Y9MDt3aGlsZShlPWJbZisrXSl3aGlsZShkLmluZGV4T2YoXCIgXCIrZStcIiBcIik+PTApZD1kLnJlcGxhY2UoXCIgXCIrZStcIiBcIixcIiBcIik7Zz1hP24udHJpbShkKTpcIlwiLGMuY2xhc3NOYW1lIT09ZyYmKGMuY2xhc3NOYW1lPWcpfXJldHVybiB0aGlzfSx0b2dnbGVDbGFzczpmdW5jdGlvbihhLGIpe3ZhciBjPXR5cGVvZiBhO3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgYiYmXCJzdHJpbmdcIj09PWM/Yj90aGlzLmFkZENsYXNzKGEpOnRoaXMucmVtb3ZlQ2xhc3MoYSk6dGhpcy5lYWNoKG4uaXNGdW5jdGlvbihhKT9mdW5jdGlvbihjKXtuKHRoaXMpLnRvZ2dsZUNsYXNzKGEuY2FsbCh0aGlzLGMsdGhpcy5jbGFzc05hbWUsYiksYil9OmZ1bmN0aW9uKCl7aWYoXCJzdHJpbmdcIj09PWMpe3ZhciBiLGQ9MCxlPW4odGhpcyksZj1hLm1hdGNoKEgpfHxbXTt3aGlsZShiPWZbZCsrXSllLmhhc0NsYXNzKGIpP2UucmVtb3ZlQ2xhc3MoYik6ZS5hZGRDbGFzcyhiKX1lbHNlKGM9PT1YfHxcImJvb2xlYW5cIj09PWMpJiYodGhpcy5jbGFzc05hbWUmJk8uc2V0KHRoaXMsXCJfX2NsYXNzTmFtZV9fXCIsdGhpcy5jbGFzc05hbWUpLHRoaXMuY2xhc3NOYW1lPXRoaXMuY2xhc3NOYW1lfHxhPT09ITE/XCJcIjpPLmdldCh0aGlzLFwiX19jbGFzc05hbWVfX1wiKXx8XCJcIil9KX0saGFzQ2xhc3M6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVwiIFwiK2ErXCIgXCIsYz0wLGQ9dGhpcy5sZW5ndGg7ZD5jO2MrKylpZigxPT09dGhpc1tjXS5ub2RlVHlwZSYmKFwiIFwiK3RoaXNbY10uY2xhc3NOYW1lK1wiIFwiKS5yZXBsYWNlKFJiLFwiIFwiKS5pbmRleE9mKGIpPj0wKXJldHVybiEwO3JldHVybiExfX0pO3ZhciBTYj0vXFxyL2c7bi5mbi5leHRlbmQoe3ZhbDpmdW5jdGlvbihhKXt2YXIgYixjLGQsZT10aGlzWzBdO3tpZihhcmd1bWVudHMubGVuZ3RoKXJldHVybiBkPW4uaXNGdW5jdGlvbihhKSx0aGlzLmVhY2goZnVuY3Rpb24oYyl7dmFyIGU7MT09PXRoaXMubm9kZVR5cGUmJihlPWQ/YS5jYWxsKHRoaXMsYyxuKHRoaXMpLnZhbCgpKTphLG51bGw9PWU/ZT1cIlwiOlwibnVtYmVyXCI9PXR5cGVvZiBlP2UrPVwiXCI6bi5pc0FycmF5KGUpJiYoZT1uLm1hcChlLGZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP1wiXCI6YStcIlwifSkpLGI9bi52YWxIb29rc1t0aGlzLnR5cGVdfHxuLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sYiYmXCJzZXRcImluIGImJnZvaWQgMCE9PWIuc2V0KHRoaXMsZSxcInZhbHVlXCIpfHwodGhpcy52YWx1ZT1lKSl9KTtpZihlKXJldHVybiBiPW4udmFsSG9va3NbZS50eXBlXXx8bi52YWxIb29rc1tlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldLGImJlwiZ2V0XCJpbiBiJiZ2b2lkIDAhPT0oYz1iLmdldChlLFwidmFsdWVcIikpP2M6KGM9ZS52YWx1ZSxcInN0cmluZ1wiPT10eXBlb2YgYz9jLnJlcGxhY2UoU2IsXCJcIik6bnVsbD09Yz9cIlwiOmMpfX19KSxuLmV4dGVuZCh7dmFsSG9va3M6e29wdGlvbjp7Z2V0OmZ1bmN0aW9uKGEpe3ZhciBiPW4uZmluZC5hdHRyKGEsXCJ2YWx1ZVwiKTtyZXR1cm4gbnVsbCE9Yj9iOm4udHJpbShuLnRleHQoYSkpfX0sc2VsZWN0OntnZXQ6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiLGMsZD1hLm9wdGlvbnMsZT1hLnNlbGVjdGVkSW5kZXgsZj1cInNlbGVjdC1vbmVcIj09PWEudHlwZXx8MD5lLGc9Zj9udWxsOltdLGg9Zj9lKzE6ZC5sZW5ndGgsaT0wPmU/aDpmP2U6MDtoPmk7aSsrKWlmKGM9ZFtpXSwhKCFjLnNlbGVjdGVkJiZpIT09ZXx8KGsub3B0RGlzYWJsZWQ/Yy5kaXNhYmxlZDpudWxsIT09Yy5nZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSl8fGMucGFyZW50Tm9kZS5kaXNhYmxlZCYmbi5ub2RlTmFtZShjLnBhcmVudE5vZGUsXCJvcHRncm91cFwiKSkpe2lmKGI9bihjKS52YWwoKSxmKXJldHVybiBiO2cucHVzaChiKX1yZXR1cm4gZ30sc2V0OmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPWEub3B0aW9ucyxmPW4ubWFrZUFycmF5KGIpLGc9ZS5sZW5ndGg7d2hpbGUoZy0tKWQ9ZVtnXSwoZC5zZWxlY3RlZD1uLmluQXJyYXkoZC52YWx1ZSxmKT49MCkmJihjPSEwKTtyZXR1cm4gY3x8KGEuc2VsZWN0ZWRJbmRleD0tMSksZn19fX0pLG4uZWFjaChbXCJyYWRpb1wiLFwiY2hlY2tib3hcIl0sZnVuY3Rpb24oKXtuLnZhbEhvb2tzW3RoaXNdPXtzZXQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbi5pc0FycmF5KGIpP2EuY2hlY2tlZD1uLmluQXJyYXkobihhKS52YWwoKSxiKT49MDp2b2lkIDB9fSxrLmNoZWNrT258fChuLnZhbEhvb2tzW3RoaXNdLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09PWEuZ2V0QXR0cmlidXRlKFwidmFsdWVcIik/XCJvblwiOmEudmFsdWV9KX0pLG4uZWFjaChcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrIG1vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZSBtb3VzZW92ZXIgbW91c2VvdXQgbW91c2VlbnRlciBtb3VzZWxlYXZlIGNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIi5zcGxpdChcIiBcIiksZnVuY3Rpb24oYSxiKXtuLmZuW2JdPWZ1bmN0aW9uKGEsYyl7cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGg+MD90aGlzLm9uKGIsbnVsbCxhLGMpOnRoaXMudHJpZ2dlcihiKX19KSxuLmZuLmV4dGVuZCh7aG92ZXI6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5tb3VzZWVudGVyKGEpLm1vdXNlbGVhdmUoYnx8YSl9LGJpbmQ6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLm9uKGEsbnVsbCxiLGMpfSx1bmJpbmQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5vZmYoYSxudWxsLGIpfSxkZWxlZ2F0ZTpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5vbihiLGEsYyxkKX0sdW5kZWxlZ2F0ZTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMub2ZmKGEsXCIqKlwiKTp0aGlzLm9mZihiLGF8fFwiKipcIixjKX19KTt2YXIgVGI9bi5ub3coKSxVYj0vXFw/LztuLnBhcnNlSlNPTj1mdW5jdGlvbihhKXtyZXR1cm4gSlNPTi5wYXJzZShhK1wiXCIpfSxuLnBhcnNlWE1MPWZ1bmN0aW9uKGEpe3ZhciBiLGM7aWYoIWF8fFwic3RyaW5nXCIhPXR5cGVvZiBhKXJldHVybiBudWxsO3RyeXtjPW5ldyBET01QYXJzZXIsYj1jLnBhcnNlRnJvbVN0cmluZyhhLFwidGV4dC94bWxcIil9Y2F0Y2goZCl7Yj12b2lkIDB9cmV0dXJuKCFifHxiLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwicGFyc2VyZXJyb3JcIikubGVuZ3RoKSYmbi5lcnJvcihcIkludmFsaWQgWE1MOiBcIithKSxifTt2YXIgVmIsV2IsWGI9LyMuKiQvLFliPS8oWz8mXSlfPVteJl0qLyxaYj0vXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL2dtLCRiPS9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLF9iPS9eKD86R0VUfEhFQUQpJC8sYWM9L15cXC9cXC8vLGJjPS9eKFtcXHcuKy1dKzopKD86XFwvXFwvKD86W15cXC8/I10qQHwpKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLGNjPXt9LGRjPXt9LGVjPVwiKi9cIi5jb25jYXQoXCIqXCIpO3RyeXtXYj1sb2NhdGlvbi5ocmVmfWNhdGNoKGZjKXtXYj1sLmNyZWF0ZUVsZW1lbnQoXCJhXCIpLFdiLmhyZWY9XCJcIixXYj1XYi5ocmVmfVZiPWJjLmV4ZWMoV2IudG9Mb3dlckNhc2UoKSl8fFtdO2Z1bmN0aW9uIGdjKGEpe3JldHVybiBmdW5jdGlvbihiLGMpe1wic3RyaW5nXCIhPXR5cGVvZiBiJiYoYz1iLGI9XCIqXCIpO3ZhciBkLGU9MCxmPWIudG9Mb3dlckNhc2UoKS5tYXRjaChIKXx8W107aWYobi5pc0Z1bmN0aW9uKGMpKXdoaWxlKGQ9ZltlKytdKVwiK1wiPT09ZFswXT8oZD1kLnNsaWNlKDEpfHxcIipcIiwoYVtkXT1hW2RdfHxbXSkudW5zaGlmdChjKSk6KGFbZF09YVtkXXx8W10pLnB1c2goYyl9fWZ1bmN0aW9uIGhjKGEsYixjLGQpe3ZhciBlPXt9LGY9YT09PWRjO2Z1bmN0aW9uIGcoaCl7dmFyIGk7cmV0dXJuIGVbaF09ITAsbi5lYWNoKGFbaF18fFtdLGZ1bmN0aW9uKGEsaCl7dmFyIGo9aChiLGMsZCk7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGp8fGZ8fGVbal0/Zj8hKGk9aik6dm9pZCAwOihiLmRhdGFUeXBlcy51bnNoaWZ0KGopLGcoaiksITEpfSksaX1yZXR1cm4gZyhiLmRhdGFUeXBlc1swXSl8fCFlW1wiKlwiXSYmZyhcIipcIil9ZnVuY3Rpb24gaWMoYSxiKXt2YXIgYyxkLGU9bi5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnN8fHt9O2ZvcihjIGluIGIpdm9pZCAwIT09YltjXSYmKChlW2NdP2E6ZHx8KGQ9e30pKVtjXT1iW2NdKTtyZXR1cm4gZCYmbi5leHRlbmQoITAsYSxkKSxhfWZ1bmN0aW9uIGpjKGEsYixjKXt2YXIgZCxlLGYsZyxoPWEuY29udGVudHMsaT1hLmRhdGFUeXBlczt3aGlsZShcIipcIj09PWlbMF0paS5zaGlmdCgpLHZvaWQgMD09PWQmJihkPWEubWltZVR5cGV8fGIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpO2lmKGQpZm9yKGUgaW4gaClpZihoW2VdJiZoW2VdLnRlc3QoZCkpe2kudW5zaGlmdChlKTticmVha31pZihpWzBdaW4gYylmPWlbMF07ZWxzZXtmb3IoZSBpbiBjKXtpZighaVswXXx8YS5jb252ZXJ0ZXJzW2UrXCIgXCIraVswXV0pe2Y9ZTticmVha31nfHwoZz1lKX1mPWZ8fGd9cmV0dXJuIGY/KGYhPT1pWzBdJiZpLnVuc2hpZnQoZiksY1tmXSk6dm9pZCAwfWZ1bmN0aW9uIGtjKGEsYixjLGQpe3ZhciBlLGYsZyxoLGksaj17fSxrPWEuZGF0YVR5cGVzLnNsaWNlKCk7aWYoa1sxXSlmb3IoZyBpbiBhLmNvbnZlcnRlcnMpaltnLnRvTG93ZXJDYXNlKCldPWEuY29udmVydGVyc1tnXTtmPWsuc2hpZnQoKTt3aGlsZShmKWlmKGEucmVzcG9uc2VGaWVsZHNbZl0mJihjW2EucmVzcG9uc2VGaWVsZHNbZl1dPWIpLCFpJiZkJiZhLmRhdGFGaWx0ZXImJihiPWEuZGF0YUZpbHRlcihiLGEuZGF0YVR5cGUpKSxpPWYsZj1rLnNoaWZ0KCkpaWYoXCIqXCI9PT1mKWY9aTtlbHNlIGlmKFwiKlwiIT09aSYmaSE9PWYpe2lmKGc9altpK1wiIFwiK2ZdfHxqW1wiKiBcIitmXSwhZylmb3IoZSBpbiBqKWlmKGg9ZS5zcGxpdChcIiBcIiksaFsxXT09PWYmJihnPWpbaStcIiBcIitoWzBdXXx8altcIiogXCIraFswXV0pKXtnPT09ITA/Zz1qW2VdOmpbZV0hPT0hMCYmKGY9aFswXSxrLnVuc2hpZnQoaFsxXSkpO2JyZWFrfWlmKGchPT0hMClpZihnJiZhW1widGhyb3dzXCJdKWI9ZyhiKTtlbHNlIHRyeXtiPWcoYil9Y2F0Y2gobCl7cmV0dXJue3N0YXRlOlwicGFyc2VyZXJyb3JcIixlcnJvcjpnP2w6XCJObyBjb252ZXJzaW9uIGZyb20gXCIraStcIiB0byBcIitmfX19cmV0dXJue3N0YXRlOlwic3VjY2Vzc1wiLGRhdGE6Yn19bi5leHRlbmQoe2FjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9LGFqYXhTZXR0aW5nczp7dXJsOldiLHR5cGU6XCJHRVRcIixpc0xvY2FsOiRiLnRlc3QoVmJbMV0pLGdsb2JhbDohMCxwcm9jZXNzRGF0YTohMCxhc3luYzohMCxjb250ZW50VHlwZTpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLGFjY2VwdHM6e1wiKlwiOmVjLHRleHQ6XCJ0ZXh0L3BsYWluXCIsaHRtbDpcInRleHQvaHRtbFwiLHhtbDpcImFwcGxpY2F0aW9uL3htbCwgdGV4dC94bWxcIixqc29uOlwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJ9LGNvbnRlbnRzOnt4bWw6L3htbC8saHRtbDovaHRtbC8sanNvbjovanNvbi99LHJlc3BvbnNlRmllbGRzOnt4bWw6XCJyZXNwb25zZVhNTFwiLHRleHQ6XCJyZXNwb25zZVRleHRcIixqc29uOlwicmVzcG9uc2VKU09OXCJ9LGNvbnZlcnRlcnM6e1wiKiB0ZXh0XCI6U3RyaW5nLFwidGV4dCBodG1sXCI6ITAsXCJ0ZXh0IGpzb25cIjpuLnBhcnNlSlNPTixcInRleHQgeG1sXCI6bi5wYXJzZVhNTH0sZmxhdE9wdGlvbnM6e3VybDohMCxjb250ZXh0OiEwfX0sYWpheFNldHVwOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGI/aWMoaWMoYSxuLmFqYXhTZXR0aW5ncyksYik6aWMobi5hamF4U2V0dGluZ3MsYSl9LGFqYXhQcmVmaWx0ZXI6Z2MoY2MpLGFqYXhUcmFuc3BvcnQ6Z2MoZGMpLGFqYXg6ZnVuY3Rpb24oYSxiKXtcIm9iamVjdFwiPT10eXBlb2YgYSYmKGI9YSxhPXZvaWQgMCksYj1ifHx7fTt2YXIgYyxkLGUsZixnLGgsaSxqLGs9bi5hamF4U2V0dXAoe30sYiksbD1rLmNvbnRleHR8fGssbT1rLmNvbnRleHQmJihsLm5vZGVUeXBlfHxsLmpxdWVyeSk/bihsKTpuLmV2ZW50LG89bi5EZWZlcnJlZCgpLHA9bi5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxxPWsuc3RhdHVzQ29kZXx8e30scj17fSxzPXt9LHQ9MCx1PVwiY2FuY2VsZWRcIix2PXtyZWFkeVN0YXRlOjAsZ2V0UmVzcG9uc2VIZWFkZXI6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoMj09PXQpe2lmKCFmKXtmPXt9O3doaWxlKGI9WmIuZXhlYyhlKSlmW2JbMV0udG9Mb3dlckNhc2UoKV09YlsyXX1iPWZbYS50b0xvd2VyQ2FzZSgpXX1yZXR1cm4gbnVsbD09Yj9udWxsOmJ9LGdldEFsbFJlc3BvbnNlSGVhZGVyczpmdW5jdGlvbigpe3JldHVybiAyPT09dD9lOm51bGx9LHNldFJlcXVlc3RIZWFkZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnRvTG93ZXJDYXNlKCk7cmV0dXJuIHR8fChhPXNbY109c1tjXXx8YSxyW2FdPWIpLHRoaXN9LG92ZXJyaWRlTWltZVR5cGU6ZnVuY3Rpb24oYSl7cmV0dXJuIHR8fChrLm1pbWVUeXBlPWEpLHRoaXN9LHN0YXR1c0NvZGU6ZnVuY3Rpb24oYSl7dmFyIGI7aWYoYSlpZigyPnQpZm9yKGIgaW4gYSlxW2JdPVtxW2JdLGFbYl1dO2Vsc2Ugdi5hbHdheXMoYVt2LnN0YXR1c10pO3JldHVybiB0aGlzfSxhYm9ydDpmdW5jdGlvbihhKXt2YXIgYj1hfHx1O3JldHVybiBjJiZjLmFib3J0KGIpLHgoMCxiKSx0aGlzfX07aWYoby5wcm9taXNlKHYpLmNvbXBsZXRlPXAuYWRkLHYuc3VjY2Vzcz12LmRvbmUsdi5lcnJvcj12LmZhaWwsay51cmw9KChhfHxrLnVybHx8V2IpK1wiXCIpLnJlcGxhY2UoWGIsXCJcIikucmVwbGFjZShhYyxWYlsxXStcIi8vXCIpLGsudHlwZT1iLm1ldGhvZHx8Yi50eXBlfHxrLm1ldGhvZHx8ay50eXBlLGsuZGF0YVR5cGVzPW4udHJpbShrLmRhdGFUeXBlfHxcIipcIikudG9Mb3dlckNhc2UoKS5tYXRjaChIKXx8W1wiXCJdLG51bGw9PWsuY3Jvc3NEb21haW4mJihoPWJjLmV4ZWMoay51cmwudG9Mb3dlckNhc2UoKSksay5jcm9zc0RvbWFpbj0hKCFofHxoWzFdPT09VmJbMV0mJmhbMl09PT1WYlsyXSYmKGhbM118fChcImh0dHA6XCI9PT1oWzFdP1wiODBcIjpcIjQ0M1wiKSk9PT0oVmJbM118fChcImh0dHA6XCI9PT1WYlsxXT9cIjgwXCI6XCI0NDNcIikpKSksay5kYXRhJiZrLnByb2Nlc3NEYXRhJiZcInN0cmluZ1wiIT10eXBlb2Ygay5kYXRhJiYoay5kYXRhPW4ucGFyYW0oay5kYXRhLGsudHJhZGl0aW9uYWwpKSxoYyhjYyxrLGIsdiksMj09PXQpcmV0dXJuIHY7aT1rLmdsb2JhbCxpJiYwPT09bi5hY3RpdmUrKyYmbi5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpLGsudHlwZT1rLnR5cGUudG9VcHBlckNhc2UoKSxrLmhhc0NvbnRlbnQ9IV9iLnRlc3Qoay50eXBlKSxkPWsudXJsLGsuaGFzQ29udGVudHx8KGsuZGF0YSYmKGQ9ay51cmwrPShVYi50ZXN0KGQpP1wiJlwiOlwiP1wiKStrLmRhdGEsZGVsZXRlIGsuZGF0YSksay5jYWNoZT09PSExJiYoay51cmw9WWIudGVzdChkKT9kLnJlcGxhY2UoWWIsXCIkMV89XCIrVGIrKyk6ZCsoVWIudGVzdChkKT9cIiZcIjpcIj9cIikrXCJfPVwiK1RiKyspKSxrLmlmTW9kaWZpZWQmJihuLmxhc3RNb2RpZmllZFtkXSYmdi5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTW9kaWZpZWQtU2luY2VcIixuLmxhc3RNb2RpZmllZFtkXSksbi5ldGFnW2RdJiZ2LnNldFJlcXVlc3RIZWFkZXIoXCJJZi1Ob25lLU1hdGNoXCIsbi5ldGFnW2RdKSksKGsuZGF0YSYmay5oYXNDb250ZW50JiZrLmNvbnRlbnRUeXBlIT09ITF8fGIuY29udGVudFR5cGUpJiZ2LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIixrLmNvbnRlbnRUeXBlKSx2LnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIixrLmRhdGFUeXBlc1swXSYmay5hY2NlcHRzW2suZGF0YVR5cGVzWzBdXT9rLmFjY2VwdHNbay5kYXRhVHlwZXNbMF1dKyhcIipcIiE9PWsuZGF0YVR5cGVzWzBdP1wiLCBcIitlYytcIjsgcT0wLjAxXCI6XCJcIik6ay5hY2NlcHRzW1wiKlwiXSk7Zm9yKGogaW4gay5oZWFkZXJzKXYuc2V0UmVxdWVzdEhlYWRlcihqLGsuaGVhZGVyc1tqXSk7aWYoay5iZWZvcmVTZW5kJiYoay5iZWZvcmVTZW5kLmNhbGwobCx2LGspPT09ITF8fDI9PT10KSlyZXR1cm4gdi5hYm9ydCgpO3U9XCJhYm9ydFwiO2ZvcihqIGlue3N1Y2Nlc3M6MSxlcnJvcjoxLGNvbXBsZXRlOjF9KXZbal0oa1tqXSk7aWYoYz1oYyhkYyxrLGIsdikpe3YucmVhZHlTdGF0ZT0xLGkmJm0udHJpZ2dlcihcImFqYXhTZW5kXCIsW3Ysa10pLGsuYXN5bmMmJmsudGltZW91dD4wJiYoZz1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7di5hYm9ydChcInRpbWVvdXRcIil9LGsudGltZW91dCkpO3RyeXt0PTEsYy5zZW5kKHIseCl9Y2F0Y2godyl7aWYoISgyPnQpKXRocm93IHc7eCgtMSx3KX19ZWxzZSB4KC0xLFwiTm8gVHJhbnNwb3J0XCIpO2Z1bmN0aW9uIHgoYSxiLGYsaCl7dmFyIGoscixzLHUsdyx4PWI7MiE9PXQmJih0PTIsZyYmY2xlYXJUaW1lb3V0KGcpLGM9dm9pZCAwLGU9aHx8XCJcIix2LnJlYWR5U3RhdGU9YT4wPzQ6MCxqPWE+PTIwMCYmMzAwPmF8fDMwND09PWEsZiYmKHU9amMoayx2LGYpKSx1PWtjKGssdSx2LGopLGo/KGsuaWZNb2RpZmllZCYmKHc9di5nZXRSZXNwb25zZUhlYWRlcihcIkxhc3QtTW9kaWZpZWRcIiksdyYmKG4ubGFzdE1vZGlmaWVkW2RdPXcpLHc9di5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIiksdyYmKG4uZXRhZ1tkXT13KSksMjA0PT09YXx8XCJIRUFEXCI9PT1rLnR5cGU/eD1cIm5vY29udGVudFwiOjMwND09PWE/eD1cIm5vdG1vZGlmaWVkXCI6KHg9dS5zdGF0ZSxyPXUuZGF0YSxzPXUuZXJyb3Isaj0hcykpOihzPXgsKGF8fCF4KSYmKHg9XCJlcnJvclwiLDA+YSYmKGE9MCkpKSx2LnN0YXR1cz1hLHYuc3RhdHVzVGV4dD0oYnx8eCkrXCJcIixqP28ucmVzb2x2ZVdpdGgobCxbcix4LHZdKTpvLnJlamVjdFdpdGgobCxbdix4LHNdKSx2LnN0YXR1c0NvZGUocSkscT12b2lkIDAsaSYmbS50cmlnZ2VyKGo/XCJhamF4U3VjY2Vzc1wiOlwiYWpheEVycm9yXCIsW3YsayxqP3I6c10pLHAuZmlyZVdpdGgobCxbdix4XSksaSYmKG0udHJpZ2dlcihcImFqYXhDb21wbGV0ZVwiLFt2LGtdKSwtLW4uYWN0aXZlfHxuLmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKSkpfXJldHVybiB2fSxnZXRKU09OOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbi5nZXQoYSxiLGMsXCJqc29uXCIpfSxnZXRTY3JpcHQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbi5nZXQoYSx2b2lkIDAsYixcInNjcmlwdFwiKX19KSxuLmVhY2goW1wiZ2V0XCIsXCJwb3N0XCJdLGZ1bmN0aW9uKGEsYil7bltiXT1mdW5jdGlvbihhLGMsZCxlKXtyZXR1cm4gbi5pc0Z1bmN0aW9uKGMpJiYoZT1lfHxkLGQ9YyxjPXZvaWQgMCksbi5hamF4KHt1cmw6YSx0eXBlOmIsZGF0YVR5cGU6ZSxkYXRhOmMsc3VjY2VzczpkfSl9fSksbi5lYWNoKFtcImFqYXhTdGFydFwiLFwiYWpheFN0b3BcIixcImFqYXhDb21wbGV0ZVwiLFwiYWpheEVycm9yXCIsXCJhamF4U3VjY2Vzc1wiLFwiYWpheFNlbmRcIl0sZnVuY3Rpb24oYSxiKXtuLmZuW2JdPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm9uKGIsYSl9fSksbi5fZXZhbFVybD1mdW5jdGlvbihhKXtyZXR1cm4gbi5hamF4KHt1cmw6YSx0eXBlOlwiR0VUXCIsZGF0YVR5cGU6XCJzY3JpcHRcIixhc3luYzohMSxnbG9iYWw6ITEsXCJ0aHJvd3NcIjohMH0pfTt2YXIgbGM9LyUyMC9nLG1jPS9cXFtcXF0kLyxuYz0vXFxyP1xcbi9nLG9jPS9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxwYz0vXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7ZnVuY3Rpb24gcWMoYSxiLGMsZCl7dmFyIGU7aWYobi5pc0FycmF5KGIpKW4uZWFjaChiLGZ1bmN0aW9uKGIsZSl7Y3x8bWMudGVzdChhKT9kKGEsZSk6cWMoYStcIltcIisoXCJvYmplY3RcIj09dHlwZW9mIGU/YjpcIlwiKStcIl1cIixlLGMsZCl9KTtlbHNlIGlmKGN8fFwib2JqZWN0XCIhPT1uLnR5cGUoYikpZChhLGIpO2Vsc2UgZm9yKGUgaW4gYilxYyhhK1wiW1wiK2UrXCJdXCIsYltlXSxjLGQpfW4ucGFyYW09ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPVtdLGU9ZnVuY3Rpb24oYSxiKXtiPW4uaXNGdW5jdGlvbihiKT9iKCk6bnVsbD09Yj9cIlwiOmIsZFtkLmxlbmd0aF09ZW5jb2RlVVJJQ29tcG9uZW50KGEpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChiKX07aWYodm9pZCAwPT09YiYmKGI9bi5hamF4U2V0dGluZ3MmJm4uYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKSxuLmlzQXJyYXkoYSl8fGEuanF1ZXJ5JiYhbi5pc1BsYWluT2JqZWN0KGEpKW4uZWFjaChhLGZ1bmN0aW9uKCl7ZSh0aGlzLm5hbWUsdGhpcy52YWx1ZSl9KTtlbHNlIGZvcihjIGluIGEpcWMoYyxhW2NdLGIsZSk7cmV0dXJuIGQuam9pbihcIiZcIikucmVwbGFjZShsYyxcIitcIil9LG4uZm4uZXh0ZW5kKHtzZXJpYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gbi5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpfSxzZXJpYWxpemVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPW4ucHJvcCh0aGlzLFwiZWxlbWVudHNcIik7cmV0dXJuIGE/bi5tYWtlQXJyYXkoYSk6dGhpc30pLmZpbHRlcihmdW5jdGlvbigpe3ZhciBhPXRoaXMudHlwZTtyZXR1cm4gdGhpcy5uYW1lJiYhbih0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSYmcGMudGVzdCh0aGlzLm5vZGVOYW1lKSYmIW9jLnRlc3QoYSkmJih0aGlzLmNoZWNrZWR8fCFXLnRlc3QoYSkpfSkubWFwKGZ1bmN0aW9uKGEsYil7dmFyIGM9bih0aGlzKS52YWwoKTtyZXR1cm4gbnVsbD09Yz9udWxsOm4uaXNBcnJheShjKT9uLm1hcChjLGZ1bmN0aW9uKGEpe3JldHVybntuYW1lOmIubmFtZSx2YWx1ZTphLnJlcGxhY2UobmMsXCJcXHJcXG5cIil9fSk6e25hbWU6Yi5uYW1lLHZhbHVlOmMucmVwbGFjZShuYyxcIlxcclxcblwiKX19KS5nZXQoKX19KSxuLmFqYXhTZXR0aW5ncy54aHI9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdH1jYXRjaChhKXt9fTt2YXIgcmM9MCxzYz17fSx0Yz17MDoyMDAsMTIyMzoyMDR9LHVjPW4uYWpheFNldHRpbmdzLnhocigpO2EuQWN0aXZlWE9iamVjdCYmbihhKS5vbihcInVubG9hZFwiLGZ1bmN0aW9uKCl7Zm9yKHZhciBhIGluIHNjKXNjW2FdKCl9KSxrLmNvcnM9ISF1YyYmXCJ3aXRoQ3JlZGVudGlhbHNcImluIHVjLGsuYWpheD11Yz0hIXVjLG4uYWpheFRyYW5zcG9ydChmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gay5jb3JzfHx1YyYmIWEuY3Jvc3NEb21haW4/e3NlbmQ6ZnVuY3Rpb24oYyxkKXt2YXIgZSxmPWEueGhyKCksZz0rK3JjO2lmKGYub3BlbihhLnR5cGUsYS51cmwsYS5hc3luYyxhLnVzZXJuYW1lLGEucGFzc3dvcmQpLGEueGhyRmllbGRzKWZvcihlIGluIGEueGhyRmllbGRzKWZbZV09YS54aHJGaWVsZHNbZV07YS5taW1lVHlwZSYmZi5vdmVycmlkZU1pbWVUeXBlJiZmLm92ZXJyaWRlTWltZVR5cGUoYS5taW1lVHlwZSksYS5jcm9zc0RvbWFpbnx8Y1tcIlgtUmVxdWVzdGVkLVdpdGhcIl18fChjW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXT1cIlhNTEh0dHBSZXF1ZXN0XCIpO2ZvcihlIGluIGMpZi5zZXRSZXF1ZXN0SGVhZGVyKGUsY1tlXSk7Yj1mdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oKXtiJiYoZGVsZXRlIHNjW2ddLGI9Zi5vbmxvYWQ9Zi5vbmVycm9yPW51bGwsXCJhYm9ydFwiPT09YT9mLmFib3J0KCk6XCJlcnJvclwiPT09YT9kKGYuc3RhdHVzLGYuc3RhdHVzVGV4dCk6ZCh0Y1tmLnN0YXR1c118fGYuc3RhdHVzLGYuc3RhdHVzVGV4dCxcInN0cmluZ1wiPT10eXBlb2YgZi5yZXNwb25zZVRleHQ/e3RleHQ6Zi5yZXNwb25zZVRleHR9OnZvaWQgMCxmLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSl9fSxmLm9ubG9hZD1iKCksZi5vbmVycm9yPWIoXCJlcnJvclwiKSxiPXNjW2ddPWIoXCJhYm9ydFwiKTt0cnl7Zi5zZW5kKGEuaGFzQ29udGVudCYmYS5kYXRhfHxudWxsKX1jYXRjaChoKXtpZihiKXRocm93IGh9fSxhYm9ydDpmdW5jdGlvbigpe2ImJmIoKX19OnZvaWQgMH0pLG4uYWpheFNldHVwKHthY2NlcHRzOntzY3JpcHQ6XCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwifSxjb250ZW50czp7c2NyaXB0Oi8oPzpqYXZhfGVjbWEpc2NyaXB0L30sY29udmVydGVyczp7XCJ0ZXh0IHNjcmlwdFwiOmZ1bmN0aW9uKGEpe3JldHVybiBuLmdsb2JhbEV2YWwoYSksYX19fSksbi5hamF4UHJlZmlsdGVyKFwic2NyaXB0XCIsZnVuY3Rpb24oYSl7dm9pZCAwPT09YS5jYWNoZSYmKGEuY2FjaGU9ITEpLGEuY3Jvc3NEb21haW4mJihhLnR5cGU9XCJHRVRcIil9KSxuLmFqYXhUcmFuc3BvcnQoXCJzY3JpcHRcIixmdW5jdGlvbihhKXtpZihhLmNyb3NzRG9tYWluKXt2YXIgYixjO3JldHVybntzZW5kOmZ1bmN0aW9uKGQsZSl7Yj1uKFwiPHNjcmlwdD5cIikucHJvcCh7YXN5bmM6ITAsY2hhcnNldDphLnNjcmlwdENoYXJzZXQsc3JjOmEudXJsfSkub24oXCJsb2FkIGVycm9yXCIsYz1mdW5jdGlvbihhKXtiLnJlbW92ZSgpLGM9bnVsbCxhJiZlKFwiZXJyb3JcIj09PWEudHlwZT80MDQ6MjAwLGEudHlwZSl9KSxsLmhlYWQuYXBwZW5kQ2hpbGQoYlswXSl9LGFib3J0OmZ1bmN0aW9uKCl7YyYmYygpfX19fSk7dmFyIHZjPVtdLHdjPS8oPSlcXD8oPz0mfCQpfFxcP1xcPy87bi5hamF4U2V0dXAoe2pzb25wOlwiY2FsbGJhY2tcIixqc29ucENhbGxiYWNrOmZ1bmN0aW9uKCl7dmFyIGE9dmMucG9wKCl8fG4uZXhwYW5kbytcIl9cIitUYisrO3JldHVybiB0aGlzW2FdPSEwLGF9fSksbi5hamF4UHJlZmlsdGVyKFwianNvbiBqc29ucFwiLGZ1bmN0aW9uKGIsYyxkKXt2YXIgZSxmLGcsaD1iLmpzb25wIT09ITEmJih3Yy50ZXN0KGIudXJsKT9cInVybFwiOlwic3RyaW5nXCI9PXR5cGVvZiBiLmRhdGEmJiEoYi5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmd2MudGVzdChiLmRhdGEpJiZcImRhdGFcIik7cmV0dXJuIGh8fFwianNvbnBcIj09PWIuZGF0YVR5cGVzWzBdPyhlPWIuanNvbnBDYWxsYmFjaz1uLmlzRnVuY3Rpb24oYi5qc29ucENhbGxiYWNrKT9iLmpzb25wQ2FsbGJhY2soKTpiLmpzb25wQ2FsbGJhY2ssaD9iW2hdPWJbaF0ucmVwbGFjZSh3YyxcIiQxXCIrZSk6Yi5qc29ucCE9PSExJiYoYi51cmwrPShVYi50ZXN0KGIudXJsKT9cIiZcIjpcIj9cIikrYi5qc29ucCtcIj1cIitlKSxiLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXT1mdW5jdGlvbigpe3JldHVybiBnfHxuLmVycm9yKGUrXCIgd2FzIG5vdCBjYWxsZWRcIiksZ1swXX0sYi5kYXRhVHlwZXNbMF09XCJqc29uXCIsZj1hW2VdLGFbZV09ZnVuY3Rpb24oKXtnPWFyZ3VtZW50c30sZC5hbHdheXMoZnVuY3Rpb24oKXthW2VdPWYsYltlXSYmKGIuanNvbnBDYWxsYmFjaz1jLmpzb25wQ2FsbGJhY2ssdmMucHVzaChlKSksZyYmbi5pc0Z1bmN0aW9uKGYpJiZmKGdbMF0pLGc9Zj12b2lkIDB9KSxcInNjcmlwdFwiKTp2b2lkIDB9KSxuLnBhcnNlSFRNTD1mdW5jdGlvbihhLGIsYyl7aWYoIWF8fFwic3RyaW5nXCIhPXR5cGVvZiBhKXJldHVybiBudWxsO1wiYm9vbGVhblwiPT10eXBlb2YgYiYmKGM9YixiPSExKSxiPWJ8fGw7dmFyIGQ9eS5leGVjKGEpLGU9IWMmJltdO3JldHVybiBkP1tiLmNyZWF0ZUVsZW1lbnQoZFsxXSldOihkPW4uYnVpbGRGcmFnbWVudChbYV0sYixlKSxlJiZlLmxlbmd0aCYmbihlKS5yZW1vdmUoKSxuLm1lcmdlKFtdLGQuY2hpbGROb2RlcykpfTt2YXIgeGM9bi5mbi5sb2FkO24uZm4ubG9hZD1mdW5jdGlvbihhLGIsYyl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGEmJnhjKXJldHVybiB4Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIGQsZSxmLGc9dGhpcyxoPWEuaW5kZXhPZihcIiBcIik7cmV0dXJuIGg+PTAmJihkPW4udHJpbShhLnNsaWNlKGgpKSxhPWEuc2xpY2UoMCxoKSksbi5pc0Z1bmN0aW9uKGIpPyhjPWIsYj12b2lkIDApOmImJlwib2JqZWN0XCI9PXR5cGVvZiBiJiYoZT1cIlBPU1RcIiksZy5sZW5ndGg+MCYmbi5hamF4KHt1cmw6YSx0eXBlOmUsZGF0YVR5cGU6XCJodG1sXCIsZGF0YTpifSkuZG9uZShmdW5jdGlvbihhKXtmPWFyZ3VtZW50cyxnLmh0bWwoZD9uKFwiPGRpdj5cIikuYXBwZW5kKG4ucGFyc2VIVE1MKGEpKS5maW5kKGQpOmEpfSkuY29tcGxldGUoYyYmZnVuY3Rpb24oYSxiKXtnLmVhY2goYyxmfHxbYS5yZXNwb25zZVRleHQsYixhXSl9KSx0aGlzfTt2YXIgdD1hLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtmdW5jdGlvbiB5YyhhKXtyZXR1cm4gbi5pc1dpbmRvdyhhKT9hOjk9PT1hLm5vZGVUeXBlJiZhLmRlZmF1bHRWaWV3fW4ub2Zmc2V0PXtzZXRPZmZzZXQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnLGgsaSxqLGs9bi5jc3MoYSxcInBvc2l0aW9uXCIpLGw9bihhKSxtPXt9O1wic3RhdGljXCI9PT1rJiYoYS5zdHlsZS5wb3NpdGlvbj1cInJlbGF0aXZlXCIpLGg9bC5vZmZzZXQoKSxmPW4uY3NzKGEsXCJ0b3BcIiksaT1uLmNzcyhhLFwibGVmdFwiKSxqPShcImFic29sdXRlXCI9PT1rfHxcImZpeGVkXCI9PT1rKSYmKGYraSkuaW5kZXhPZihcImF1dG9cIik+LTEsaj8oZD1sLnBvc2l0aW9uKCksZz1kLnRvcCxlPWQubGVmdCk6KGc9cGFyc2VGbG9hdChmKXx8MCxlPXBhcnNlRmxvYXQoaSl8fDApLG4uaXNGdW5jdGlvbihiKSYmKGI9Yi5jYWxsKGEsYyxoKSksbnVsbCE9Yi50b3AmJihtLnRvcD1iLnRvcC1oLnRvcCtnKSxudWxsIT1iLmxlZnQmJihtLmxlZnQ9Yi5sZWZ0LWgubGVmdCtlKSxcInVzaW5nXCJpbiBiP2IudXNpbmcuY2FsbChhLG0pOmwuY3NzKG0pfX0sbi5mbi5leHRlbmQoe29mZnNldDpmdW5jdGlvbihhKXtpZihhcmd1bWVudHMubGVuZ3RoKXJldHVybiB2b2lkIDA9PT1hP3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKGIpe24ub2Zmc2V0LnNldE9mZnNldCh0aGlzLGEsYil9KTt2YXIgYixjLGQ9dGhpc1swXSxlPXt0b3A6MCxsZWZ0OjB9LGY9ZCYmZC5vd25lckRvY3VtZW50O2lmKGYpcmV0dXJuIGI9Zi5kb2N1bWVudEVsZW1lbnQsbi5jb250YWlucyhiLGQpPyh0eXBlb2YgZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QhPT1YJiYoZT1kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxjPXljKGYpLHt0b3A6ZS50b3ArYy5wYWdlWU9mZnNldC1iLmNsaWVudFRvcCxsZWZ0OmUubGVmdCtjLnBhZ2VYT2Zmc2V0LWIuY2xpZW50TGVmdH0pOmV9LHBvc2l0aW9uOmZ1bmN0aW9uKCl7aWYodGhpc1swXSl7dmFyIGEsYixjPXRoaXNbMF0sZD17dG9wOjAsbGVmdDowfTtyZXR1cm5cImZpeGVkXCI9PT1uLmNzcyhjLFwicG9zaXRpb25cIik/Yj1jLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOihhPXRoaXMub2Zmc2V0UGFyZW50KCksYj10aGlzLm9mZnNldCgpLG4ubm9kZU5hbWUoYVswXSxcImh0bWxcIil8fChkPWEub2Zmc2V0KCkpLGQudG9wKz1uLmNzcyhhWzBdLFwiYm9yZGVyVG9wV2lkdGhcIiwhMCksZC5sZWZ0Kz1uLmNzcyhhWzBdLFwiYm9yZGVyTGVmdFdpZHRoXCIsITApKSx7dG9wOmIudG9wLWQudG9wLW4uY3NzKGMsXCJtYXJnaW5Ub3BcIiwhMCksbGVmdDpiLmxlZnQtZC5sZWZ0LW4uY3NzKGMsXCJtYXJnaW5MZWZ0XCIsITApfX19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPXRoaXMub2Zmc2V0UGFyZW50fHx0O3doaWxlKGEmJiFuLm5vZGVOYW1lKGEsXCJodG1sXCIpJiZcInN0YXRpY1wiPT09bi5jc3MoYSxcInBvc2l0aW9uXCIpKWE9YS5vZmZzZXRQYXJlbnQ7cmV0dXJuIGF8fHR9KX19KSxuLmVhY2goe3Njcm9sbExlZnQ6XCJwYWdlWE9mZnNldFwiLHNjcm9sbFRvcDpcInBhZ2VZT2Zmc2V0XCJ9LGZ1bmN0aW9uKGIsYyl7dmFyIGQ9XCJwYWdlWU9mZnNldFwiPT09YztuLmZuW2JdPWZ1bmN0aW9uKGUpe3JldHVybiBNKHRoaXMsZnVuY3Rpb24oYixlLGYpe3ZhciBnPXljKGIpO3JldHVybiB2b2lkIDA9PT1mP2c/Z1tjXTpiW2VdOnZvaWQoZz9nLnNjcm9sbFRvKGQ/YS5wYWdlWE9mZnNldDpmLGQ/ZjphLnBhZ2VZT2Zmc2V0KTpiW2VdPWYpfSxiLGUsYXJndW1lbnRzLmxlbmd0aCxudWxsKX19KSxuLmVhY2goW1widG9wXCIsXCJsZWZ0XCJdLGZ1bmN0aW9uKGEsYil7bi5jc3NIb29rc1tiXT1CYihrLnBpeGVsUG9zaXRpb24sZnVuY3Rpb24oYSxjKXtyZXR1cm4gYz8oYz1BYihhLGIpLHliLnRlc3QoYyk/bihhKS5wb3NpdGlvbigpW2JdK1wicHhcIjpjKTp2b2lkIDB9KX0pLG4uZWFjaCh7SGVpZ2h0OlwiaGVpZ2h0XCIsV2lkdGg6XCJ3aWR0aFwifSxmdW5jdGlvbihhLGIpe24uZWFjaCh7cGFkZGluZzpcImlubmVyXCIrYSxjb250ZW50OmIsXCJcIjpcIm91dGVyXCIrYX0sZnVuY3Rpb24oYyxkKXtuLmZuW2RdPWZ1bmN0aW9uKGQsZSl7dmFyIGY9YXJndW1lbnRzLmxlbmd0aCYmKGN8fFwiYm9vbGVhblwiIT10eXBlb2YgZCksZz1jfHwoZD09PSEwfHxlPT09ITA/XCJtYXJnaW5cIjpcImJvcmRlclwiKTtyZXR1cm4gTSh0aGlzLGZ1bmN0aW9uKGIsYyxkKXt2YXIgZTtyZXR1cm4gbi5pc1dpbmRvdyhiKT9iLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiK2FdOjk9PT1iLm5vZGVUeXBlPyhlPWIuZG9jdW1lbnRFbGVtZW50LE1hdGgubWF4KGIuYm9keVtcInNjcm9sbFwiK2FdLGVbXCJzY3JvbGxcIithXSxiLmJvZHlbXCJvZmZzZXRcIithXSxlW1wib2Zmc2V0XCIrYV0sZVtcImNsaWVudFwiK2FdKSk6dm9pZCAwPT09ZD9uLmNzcyhiLGMsZyk6bi5zdHlsZShiLGMsZCxnKX0sYixmP2Q6dm9pZCAwLGYsbnVsbCl9fSl9KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQmJmRlZmluZShcImpxdWVyeVwiLFtdLGZ1bmN0aW9uKCl7cmV0dXJuIG59KTt2YXIgemM9YS5qUXVlcnksQWM9YS4kO3JldHVybiBuLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oYil7cmV0dXJuIGEuJD09PW4mJihhLiQ9QWMpLGImJmEualF1ZXJ5PT09biYmKGEualF1ZXJ5PXpjKSxufSx0eXBlb2YgYj09PVgmJihhLmpRdWVyeT1hLiQ9biksbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anF1ZXJ5Lm1pbi5tYXBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcHVibGljL3NjcmlwdHMvbGliL2pxdWVyeS5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n");

/***/ }),

/***/ 1:
/*!*****************************************!*\
  !*** ./public/scripts/widget/lizard.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar $ = __webpack_require__(/*! ../lib/jquery */ 0);\n\nvar Lizard = {\n\n\tprompt: function prompt(obj, determine, cancel) {\n\n\t\tvar tips = obj.tips;\n\n\t\tvar btn = obj.btn;\n\n\t\tvar tpl = '\\\n\t\t\t  <div class=\"layui-poup\"></div>\\\n\t\t\t\t<div class=\"layui-layer\">\\\n\t\t\t\t\t<div class=\"layui-layer-title\"></div>\\\n\t\t\t\t\t<div class=\"layui-layer-content\">' + tips + '</div>\\\n\t\t\t\t\t<span class=\"layui-layer-setwin J_close\"></span>\\\n\t\t\t\t\t<div class=\"layui-layer-btn layui-layer-btn-\">\\\n\t\t\t\t\t\t<a href=\"javascript:;\" class=\"layui-layer-btn0\">' + btn[0] + '</a>\\\n\t\t\t\t\t\t<a href=\"javascript:;\" class=\"layui-layer-btn1 J_close\">' + btn[1] + '</a>\\\n\t\t\t\t\t</div>\\\n\t\t\t</div>';\n\n\t\t$('body').append(tpl);\n\n\t\t$('.layui-layer-btn0').click(function () {\n\n\t\t\tdetermine();\n\n\t\t\t$('.layui-poup').remove();\n\n\t\t\t$('.layui-layer').remove();\n\t\t});\n\n\t\t$('.J_close').click(function () {\n\n\t\t\tcancel && cancel();\n\n\t\t\t$('.layui-poup').remove();\n\n\t\t\t$('.layui-layer').remove();\n\t\t});\n\t},\n\tshowToast: function showToast(value) {\n\n\t\tvar tpl = '<div class=\"mask\"></div> <div class=\"mask-ui\"><span>' + value + '</span></div>';\n\n\t\tif ($('.mask').length) {\n\t\t\treturn;\n\t\t}\n\n\t\t$('body').append(tpl);\n\n\t\tsetTimeout(function () {\n\n\t\t\t$('.mask-ui').remove();\n\n\t\t\t$('.mask').remove();\n\t\t}, 2000);\n\t},\n\tcheckNumber: function checkNumber(theObj) {\n\t\tvar reg = /^[0-9]+.?[0-9]*$/;\n\t\tif (reg.test(theObj)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\tquery: function query() {\n\n\t\tvar strParame = arguments[0];\n\n\t\tvar args = new Object();\n\n\t\tvar query = location.search.substring(1).toLowerCase(); // Get query string\n\n\t\tvar pairs = query.split(\"&\"); // Break at ampersand\n\n\t\tfor (var i = 0; i < pairs.length; i++) {\n\n\t\t\tvar pos = pairs[i].indexOf('='); // Look for \"name=value\"\n\n\t\t\tif (pos == -1) continue; // If not found, skip\n\n\t\t\tvar argname = pairs[i].substring(0, pos); // Extract the name\n\n\t\t\tvar value = pairs[i].substring(pos + 1); // Extract the value\n\n\t\t\tvalue = decodeURIComponent(value); // Decode it, if needed\n\n\t\t\targs[argname] = value; // Store as a property\n\t\t}\n\t\tif (strParame == undefined) {\n\n\t\t\treturn args;\n\t\t} else {\n\n\t\t\treturn args[strParame.toLowerCase()]; // Return the object\n\t\t}\n\t},\n\n\tdiffArray: function diffArray(arr1, arr2) {\n\n\t\tvar arr = arr1.filter(function (item) {\n\n\t\t\treturn arr2.indexOf(item) < 0;\n\t\t});\n\n\t\treturn arr;\n\t},\n\tqueryStringify: function queryStringify(obj) {\n\n\t\tfunction toQueryPair(key, value) {\n\t\t\tif (typeof value == 'undefined') {\n\t\t\t\treturn key;\n\t\t\t}\n\t\t\treturn key + '=' + encodeURIComponent(value === null ? '' : String(value));\n\t\t}\n\t\tvar ret = [];\n\t\tfor (var key in obj) {\n\t\t\tkey = encodeURIComponent(key);\n\t\t\tvar values = obj[key];\n\t\t\tif (values && values.constructor == Array) {\n\t\t\t\t//\n\t\t\t\tvar queryValues = [];\n\n\t\t\t\tfor (var i = 0, len = values.length, value; i < len; i++) {\n\t\t\t\t\tvalue = values[i];\n\t\t\t\t\tqueryValues.push(toQueryPair(key, value));\n\t\t\t\t}\n\t\t\t\tret = ret.concat(queryValues);\n\t\t\t} else {\n\t\t\t\t//\n\t\t\t\tret.push(toQueryPair(key, values));\n\t\t\t}\n\t\t}\n\t\treturn ret.join('&');\n\t},\n\n\tajax: function ajax(obj) {\n\n\t\tvar resData = obj.data;\n\n\t\tvar jwt = Lizard.getCookie('jwt');\n\n\t\tvar org_id = Lizard.getCookie('org_id');\n\n\t\tvar async = obj.async == false ? obj.async : true;\n\n\t\t$.ajax({\n\t\t\ttype: obj.type,\n\t\t\tdataType: 'json',\n\t\t\turl: obj.url,\n\t\t\tasync: async,\n\t\t\tdata: resData,\n\t\t\tbeforeSend: function beforeSend(xhr) {\n\t\t\t\txhr.setRequestHeader(\"Authorization\", 'Bearer ' + jwt);\n\t\t\t\txhr.setRequestHeader('X-Org', org_id);\n\t\t\t},\n\t\t\tsuccess: function success(data) {\n\n\t\t\t\tobj.success(data);\n\t\t\t},\n\t\t\terror: function error(_error) {\n\n\t\t\t\tif (_error) {\n\n\t\t\t\t\tvar msg = JSON.parse(_error.responseText);\n\n\t\t\t\t\tLizard.showToast(msg.error.message);\n\n\t\t\t\t\tobj.error && obj.error();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\tgetDateDiff: function getDateDiff(dateTimeStamp) {\n\n\t\tdateTimeStamp = Date.parse(dateTimeStamp.replace(/-/gi, \"/\"));\n\t\tvar minute = 1000 * 60;\n\t\tvar hour = minute * 60;\n\t\tvar day = hour * 24;\n\t\tvar halfamonth = day * 15;\n\t\tvar month = day * 30;\n\t\tvar now = new Date().getTime();\n\t\tvar diffValue = now - dateTimeStamp;\n\t\tif (diffValue < 0) {\n\t\t\treturn;\n\t\t}\n\t\tvar monthC = diffValue / month;\n\t\tvar weekC = diffValue / (7 * day);\n\t\tvar dayC = diffValue / day;\n\t\tvar hourC = diffValue / hour;\n\t\tvar minC = diffValue / minute;\n\n\t\tvar result = \"\";\n\t\tif (monthC >= 1) {\n\t\t\tresult += parseInt(monthC) + \"\";\n\t\t} else if (weekC >= 1) {\n\t\t\tresult += parseInt(weekC) + \"\";\n\t\t} else if (dayC >= 1) {\n\t\t\tresult += parseInt(dayC) + \"\";\n\t\t} else if (hourC >= 1) {\n\t\t\tresult += parseInt(hourC) + \"\";\n\t\t} else if (minC >= 1) {\n\t\t\tresult += parseInt(minC) + \"\";\n\t\t} else result = \"\";\n\t\treturn result;\n\t},\n\tgetPathName: function getPathName() {\n\n\t\tvar strUrl = document.location.toString();\n\n\t\tvar arrObj = strUrl.split('//');\n\n\t\tvar start = arrObj[1].indexOf('/');\n\n\t\treturn arrObj[1].substring(start);\n\t},\n\n\t/**\n  * Date Date String\n  * (M)(d)12(h)24(H)(m)(s)(E)(q)  1-2 \n  * (y) 1-4 (S) 1 ( 1-3 )\n  * eg:\n  * (new Date().getTime(,\"yyyy-MM-dd hh:mm:ss.S\") ==> 2006-07-02 08:09:04.423\n  * (new Date().getTime(,\"yyyy-MM-dd E HH:mm:ss\") ==> 2009-03-10  20:09:04\n  * (new Date().getTime(,\"yyyy-MM-dd EE hh:mm:ss\") ==> 2009-03-10  08:09:04\n  * (new Date().getTime(,\"yyyy-MM-dd EEE hh:mm:ss\") ==> 2009-03-10  08:09:04\n  * (new Date().getTime(,\"yyyy-M-d h:m:s.S\") ==> 2006-7-2 8:9:4.18\n  */\n\tdateFormat: function dateFormat(tiems, fmt) {\n\n\t\tvar date = new Date(tiems);\n\n\t\tvar o = {\n\t\t\t\"M+\": date.getMonth() + 1, //\n\t\t\t\"d+\": date.getDate(), //\n\t\t\t\"h+\": date.getHours() % 12 == 0 ? 12 : date.getHours() % 12, //\n\t\t\t\"H+\": date.getHours(), //\n\t\t\t\"m+\": date.getMinutes(), //\n\t\t\t\"s+\": date.getSeconds(), //\n\t\t\t\"q+\": Math.floor((date.getMonth() + 3) / 3), //\n\t\t\t\"S\": date.getMilliseconds() //\n\t\t};\n\t\tvar week = {\n\t\t\t\"0\": '\\u65E5',\n\t\t\t\"1\": '\\u4E00',\n\t\t\t\"2\": '\\u4E8C',\n\t\t\t\"3\": '\\u4E09',\n\t\t\t\"4\": '\\u56DB',\n\t\t\t\"5\": '\\u4E94',\n\t\t\t\"6\": '\\u516D'\n\t\t};\n\t\tif (/(y+)/.test(fmt)) {\n\t\t\tfmt = fmt.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n\t\t}\n\t\tif (/(E+)/.test(fmt)) {\n\t\t\tfmt = fmt.replace(RegExp.$1, (RegExp.$1.length > 1 ? RegExp.$1.length > 2 ? '\\u661F\\u671F' : '\\u5468' : \"\") + week[date.getDay() + \"\"]);\n\t\t}\n\t\tfor (var k in o) {\n\t\t\tif (new RegExp(\"(\" + k + \")\").test(fmt)) {\n\t\t\t\tfmt = fmt.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n\t\t\t}\n\t\t}\n\t\treturn fmt;\n\t},\n\t//cookies\n\tsetCookie: function setCookie(name, value, times) {\n\t\tvar exp = new Date();\n\t\texp.setTime(exp.getTime() + times);\n\t\tdocument.cookie = name + \"=\" + escape(value) + \";expires=\" + exp.toGMTString() + \";path=/\";\n\t},\n\t//cookies\n\tgetCookie: function getCookie(name) {\n\t\tvar arr,\n\t\t    reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n\t\tif (arr = document.cookie.match(reg)) {\n\t\t\treturn unescape(arr[2]);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\n\t//cookies\n\tremoveCookie: function removeCookie(name) {\n\t\tvar exp = new Date();\n\t\texp.setTime(exp.getTime() - 1);\n\t\tvar cval = this.getCookie(name);\n\t\tif (cval !== null) document.cookie = name + \"=\" + cval + \";expires=\" + exp.toGMTString() + \";path=/\";\n\t},\n\n\tclearCookie: function clearCookie() {\n\t\tvar keys = document.cookie.match(/[^ =;]+(?=\\=)/g);\n\t\tif (keys) {\n\t\t\tfor (var i = keys.length; i--;) {\n\t\t\t\tdocument.cookie = keys[i] + '=0;expires=' + new Date().toGMTString() + \";path=/\";\n\t\t\t}\n\t\t}\n\t},\n\tthrottle: function throttle(func, wait, mustRun) {\n\t\tvar timeout,\n\t\t    startTime = new Date();\n\n\t\treturn function () {\n\t\t\tvar context = this,\n\t\t\t    args = arguments,\n\t\t\t    curTime = new Date();\n\n\t\t\tclearTimeout(timeout);\n\t\t\t//  handler\n\t\t\tif (curTime - startTime >= mustRun) {\n\n\t\t\t\tfunc.apply(context, args);\n\n\t\t\t\tstartTime = curTime;\n\n\t\t\t\t// \n\t\t\t} else {\n\n\t\t\t\ttimeout = setTimeout(func, wait);\n\t\t\t}\n\t\t};\n\t}\n};\nwindow.Lizard = Lizard;\nmodule.exports = Lizard;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9wdWJsaWMvc2NyaXB0cy93aWRnZXQvbGl6YXJkLmpzP2Q1NDkiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cblx0dmFyICQgPSByZXF1aXJlKCcuLi9saWIvanF1ZXJ5Jyk7XG5cblx0dmFyIExpemFyZCA9IHtcblxuXHRcdHByb21wdDogZnVuY3Rpb24gKG9iaixkZXRlcm1pbmUsY2FuY2VsKXtcblxuXHRcdFx0dmFyIHRpcHMgPSBvYmoudGlwcztcblxuXHRcdFx0dmFyIGJ0biA9IG9iai5idG47XG5cblx0XHRcdHZhciB0cGwgPSAnXFxcblx0XHRcdCAgPGRpdiBjbGFzcz1cImxheXVpLXBvdXBcIj48L2Rpdj5cXFxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwibGF5dWktbGF5ZXJcIj5cXFxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJsYXl1aS1sYXllci10aXRsZVwiPuaPkOekujwvZGl2PlxcXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImxheXVpLWxheWVyLWNvbnRlbnRcIj4nKyB0aXBzICsnPC9kaXY+XFxcblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImxheXVpLWxheWVyLXNldHdpbiBKX2Nsb3NlXCI+PC9zcGFuPlxcXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImxheXVpLWxheWVyLWJ0biBsYXl1aS1sYXllci1idG4tXCI+XFxcblx0XHRcdFx0XHRcdDxhIGhyZWY9XCJqYXZhc2NyaXB0OjtcIiBjbGFzcz1cImxheXVpLWxheWVyLWJ0bjBcIj4nKyBidG5bMF0rJzwvYT5cXFxuXHRcdFx0XHRcdFx0PGEgaHJlZj1cImphdmFzY3JpcHQ6O1wiIGNsYXNzPVwibGF5dWktbGF5ZXItYnRuMSBKX2Nsb3NlXCI+JysgYnRuIFsxXSsnPC9hPlxcXG5cdFx0XHRcdFx0PC9kaXY+XFxcblx0XHRcdDwvZGl2Pic7XG5cblx0XHRcdCQoJ2JvZHknKS5hcHBlbmQodHBsKTtcblxuXHRcdFx0JCgnLmxheXVpLWxheWVyLWJ0bjAnKS5jbGljayhmdW5jdGlvbigpe1xuXG5cdFx0XHRcdGRldGVybWluZSgpO1xuXG5cdFx0XHRcdCQoJy5sYXl1aS1wb3VwJykucmVtb3ZlKCk7XG5cblx0XHRcdFx0JCgnLmxheXVpLWxheWVyJykucmVtb3ZlKCk7XG5cblx0XHRcdH0pXG5cblx0XHRcdCQoJy5KX2Nsb3NlJykuY2xpY2soZnVuY3Rpb24oKXtcblxuXHRcdFx0XHRjYW5jZWwgJiYgY2FuY2VsKCk7XG5cblx0XHRcdFx0JCgnLmxheXVpLXBvdXAnKS5yZW1vdmUoKTtcblxuXHRcdFx0XHQkKCcubGF5dWktbGF5ZXInKS5yZW1vdmUoKTtcblxuXHRcdFx0fSlcblx0XHR9LFxuXHRcdHNob3dUb2FzdDpmdW5jdGlvbih2YWx1ZSl7XG5cblx0XHRcdHZhciB0cGw9JzxkaXYgY2xhc3M9XCJtYXNrXCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJtYXNrLXVpXCI+PHNwYW4+Jyt2YWx1ZSsnPC9zcGFuPjwvZGl2Pic7XG5cblx0XHRcdGlmICgkKCcubWFzaycpLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdCQoJ2JvZHknKS5hcHBlbmQodHBsKTtcblxuXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cblx0XHRcdFx0JCgnLm1hc2stdWknKS5yZW1vdmUoKTtcblxuXHRcdFx0XHQkKCcubWFzaycpLnJlbW92ZSgpO1xuXG5cdFx0XHR9LDIwMDApXG5cdFx0fSxcblx0XHRjaGVja051bWJlcjogZnVuY3Rpb24gKHRoZU9iaikge1xuXHRcdCAgdmFyIHJlZyA9IC9eWzAtOV0rLj9bMC05XSokLztcblx0XHQgIGlmIChyZWcudGVzdCh0aGVPYmopKSB7XG5cdFx0ICAgIHJldHVybiB0cnVlO1xuXHRcdCAgfVxuXHRcdCAgcmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRxdWVyeTogZnVuY3Rpb24oKXtcblxuXHRcdFx0dmFyIHN0clBhcmFtZSA9IGFyZ3VtZW50c1swXTtcblxuXHRcdFx0dmFyIGFyZ3MgPSBuZXcgT2JqZWN0KCk7XG5cblx0XHRcdHZhciBxdWVyeSA9IGxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkudG9Mb3dlckNhc2UoKTsgLy8gR2V0IHF1ZXJ5IHN0cmluZ1xuXG5cdFx0XHR2YXIgcGFpcnMgPSBxdWVyeS5zcGxpdChcIiZcIik7IC8vIEJyZWFrIGF0IGFtcGVyc2FuZFxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG5cblx0XHRcdFx0dmFyIHBvcyA9IHBhaXJzW2ldLmluZGV4T2YoJz0nKTsgLy8gTG9vayBmb3IgXCJuYW1lPXZhbHVlXCJcblxuXHRcdFx0XHRpZiAocG9zID09IC0xKSBjb250aW51ZTsgLy8gSWYgbm90IGZvdW5kLCBza2lwXG5cblx0XHRcdFx0dmFyIGFyZ25hbWUgPSBwYWlyc1tpXS5zdWJzdHJpbmcoMCwgcG9zKTsgLy8gRXh0cmFjdCB0aGUgbmFtZVxuXG5cdFx0XHRcdHZhciB2YWx1ZSA9IHBhaXJzW2ldLnN1YnN0cmluZyhwb3MgKyAxKTsgLy8gRXh0cmFjdCB0aGUgdmFsdWVcblxuXHRcdFx0XHR2YWx1ZT1kZWNvZGVVUklDb21wb25lbnQodmFsdWUpOyAvLyBEZWNvZGUgaXQsIGlmIG5lZWRlZFxuXG5cdFx0XHRcdGFyZ3NbYXJnbmFtZV0gPSB2YWx1ZTsgLy8gU3RvcmUgYXMgYSBwcm9wZXJ0eVxuXHRcdFx0fVxuXHRcdFx0aWYgKHN0clBhcmFtZSA9PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRyZXR1cm4gYXJncztcblxuXHRcdFx0fWVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBhcmdzW3N0clBhcmFtZS50b0xvd2VyQ2FzZSgpXTsgLy8gUmV0dXJuIHRoZSBvYmplY3Rcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZGlmZkFycmF5OiBmdW5jdGlvbihhcnIxLGFycjIpe1xuXG5cdFx0XHR2YXIgYXJyICA9IGFycjEuZmlsdGVyKGZ1bmN0aW9uKGl0ZW0pIHtcblxuXHRcdFx0XHRyZXR1cm4gYXJyMi5pbmRleE9mKGl0ZW0pIDwgMDtcblxuXHRcdFx0fSlcblxuXHRcdFx0cmV0dXJuIGFycjtcblxuXHRcdH0sXG5cdFx0cXVlcnlTdHJpbmdpZnk6IGZ1bmN0aW9uIChvYmopIHtcblxuXHRcdFx0XHRmdW5jdGlvbiB0b1F1ZXJ5UGFpcihrZXksIHZhbHVlKSB7XG5cdFx0XHQgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0ICAgICAgICByZXR1cm4ga2V5O1xuXHRcdFx0ICAgIH1cblx0XHQgICAgXHRyZXR1cm4ga2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlID09PSBudWxsID8gJyc6IFN0cmluZyh2YWx1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciByZXQgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdFx0XHQgICAga2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KGtleSk7XG5cdFx0XHRcdCAgICB2YXIgdmFsdWVzID0gb2JqW2tleV07XG5cdFx0XHRcdCAgICBpZiAodmFsdWVzICYmIHZhbHVlcy5jb25zdHJ1Y3RvciA9PSBBcnJheSkgeyAvL+aVsOe7hFxuXHRcdFx0XHQgICAgICAgIHZhciBxdWVyeVZhbHVlcyA9IFtdO1xuXG5cdFx0XHRcdCAgICAgICAgZm9yICh2YXIgaSA9IDAsXG5cdFx0XHRcdCAgICAgICAgbGVuID0gdmFsdWVzLmxlbmd0aCxcblx0XHRcdFx0ICAgICAgICB2YWx1ZTsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdCAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuXHRcdFx0XHQgICAgICAgICAgICBxdWVyeVZhbHVlcy5wdXNoKHRvUXVlcnlQYWlyKGtleSwgdmFsdWUpKTtcblx0XHRcdFx0ICAgICAgICB9XG5cdFx0XHRcdCAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChxdWVyeVZhbHVlcyk7XG5cblx0XHRcdFx0ICAgIH0gZWxzZSB7IC8v5a2X56ym5LiyXG5cdFx0XHRcdCAgICAgICAgcmV0LnB1c2godG9RdWVyeVBhaXIoa2V5LCB2YWx1ZXMpKTtcblx0XHRcdFx0ICAgIH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmV0LmpvaW4oJyYnKTtcblxuXHRcdH0sXG5cblx0XHRhamF4OiBmdW5jdGlvbihvYmopIHtcblxuXHRcdFx0dmFyIHJlc0RhdGEgPSBvYmouZGF0YTtcblxuXHRcdFx0dmFyIGp3dCA9IExpemFyZC5nZXRDb29raWUoJ2p3dCcpO1xuXG5cdFx0XHR2YXIgb3JnX2lkID0gTGl6YXJkLmdldENvb2tpZSgnb3JnX2lkJyk7XG5cblx0XHRcdHZhciBhc3luYyA9IG9iai5hc3luYyA9PSBmYWxzZSA/IG9iai5hc3luYyA6IHRydWU7XG5cblx0XHRcdCQuYWpheCh7XG5cdFx0XHRcdHR5cGU6b2JqLnR5cGUsXG5cdFx0XHRcdGRhdGFUeXBlOiAnanNvbicsXG5cdFx0XHRcdHVybDogb2JqLnVybCxcblx0XHRcdFx0YXN5bmM6YXN5bmMsXG5cdFx0XHRcdGRhdGE6cmVzRGF0YSxcblx0XHRcdFx0YmVmb3JlU2VuZDogZnVuY3Rpb24oeGhyKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJBdXRob3JpemF0aW9uXCIsICdCZWFyZXIgJyArIGp3dCk7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtT3JnJyxvcmdfaWQpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN1Y2Nlc3M6ZnVuY3Rpb24oZGF0YSl7XG5cblx0XHRcdFx0XHRvYmouc3VjY2VzcyhkYXRhKTtcblxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oZXJyb3Ipe1xuXG5cdFx0XHRcdFx0aWYgKGVycm9yKSB7XG5cblx0XHRcdFx0XHRcdHZhciBtc2cgPSBKU09OLnBhcnNlKGVycm9yLnJlc3BvbnNlVGV4dCk7XG5cblx0XHRcdFx0XHRcdExpemFyZC5zaG93VG9hc3QobXNnLmVycm9yLm1lc3NhZ2UpO1xuXG5cdFx0XHRcdFx0XHRvYmouZXJyb3IgJiYgb2JqLmVycm9yKCk7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fSxcblx0XHRnZXREYXRlRGlmZjogZnVuY3Rpb24gKGRhdGVUaW1lU3RhbXApe1xuXG5cdFx0XHRkYXRlVGltZVN0YW1wID0gRGF0ZS5wYXJzZShkYXRlVGltZVN0YW1wLnJlcGxhY2UoLy0vZ2ksXCIvXCIpKTtcblx0XHRcdHZhciBtaW51dGUgPSAxMDAwICogNjA7XG5cdFx0XHR2YXIgaG91ciA9IG1pbnV0ZSAqIDYwO1xuXHRcdFx0dmFyIGRheSA9IGhvdXIgKiAyNDtcblx0XHRcdHZhciBoYWxmYW1vbnRoID0gZGF5ICogMTU7XG5cdFx0XHR2YXIgbW9udGggPSBkYXkgKiAzMDtcblx0XHRcdHZhciBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRcdHZhciBkaWZmVmFsdWUgPSBub3cgLSBkYXRlVGltZVN0YW1wO1xuXHRcdFx0aWYgKGRpZmZWYWx1ZSA8IDApIHsgcmV0dXJuOyB9XG5cdFx0XHR2YXIgbW9udGhDID0gZGlmZlZhbHVlL21vbnRoO1xuXHRcdFx0dmFyIHdlZWtDID0gZGlmZlZhbHVlLyg3KmRheSk7XG5cdFx0XHR2YXIgZGF5QyA9IGRpZmZWYWx1ZS9kYXk7XG5cdFx0XHR2YXIgaG91ckMgPSBkaWZmVmFsdWUvaG91cjtcblx0XHRcdHZhciBtaW5DID0gZGlmZlZhbHVlL21pbnV0ZTtcblxuXHRcdFx0dmFyIHJlc3VsdCA9IFwiXCI7XG5cdFx0XHRpZihtb250aEMgPj0gMSl7XG5cdFx0XHRcdHJlc3VsdCArPSBwYXJzZUludChtb250aEMpICsgXCLmnIjliY1cIjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYod2Vla0MgPj0gMSl7XG5cdFx0XHRcdHJlc3VsdCArPSBwYXJzZUludCh3ZWVrQykgKyBcIuWRqOWJjVwiO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihkYXlDID49IDEpe1xuXHRcdFx0XHRyZXN1bHQgKz0gcGFyc2VJbnQoZGF5QykgK1wi5aSp5YmNXCI7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGhvdXJDID49IDEpe1xuXHRcdFx0XHRyZXN1bHQgKz0gcGFyc2VJbnQoaG91ckMpICtcIuWwj+aXtuWJjVwiO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihtaW5DPj0xKXtcblx0XHRcdFx0cmVzdWx0ICs9IHBhcnNlSW50KG1pbkMpICtcIuWIhumSn+WJjVwiO1xuXHRcdFx0fWVsc2Vcblx0XHRcdHJlc3VsdCA9IFwi5Yia5YiaXCI7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH0sXG5cdFx0Z2V0UGF0aE5hbWU6ZnVuY3Rpb24oKXtcblxuXHRcdFx0dmFyIHN0clVybCA9IGRvY3VtZW50LmxvY2F0aW9uLnRvU3RyaW5nKCk7XG5cblx0XHRcdHZhciBhcnJPYmogPSBzdHJVcmwuc3BsaXQoJy8vJyk7XG5cblx0XHRcdHZhciBzdGFydCA9IGFyck9ialsxXS5pbmRleE9mKCcvJyk7XG5cblx0XHRcdHJldHVybiBhcnJPYmpbMV0uc3Vic3RyaW5nKHN0YXJ0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICog5a+5RGF0ZeeahOaJqeWxle+8jOWwhiBEYXRlIOi9rOWMluS4uuaMh+WumuagvOW8j+eahFN0cmluZ1xuXHRcdCAqIOaciChNKeOAgeaXpShkKeOAgTEy5bCP5pe2KGgp44CBMjTlsI/ml7YoSCnjgIHliIYobSnjgIHnp5IocynjgIHlkagoRSnjgIHlraPluqYocSkg5Y+v5Lul55SoIDEtMiDkuKrljaDkvY3nrKZcblx0XHQgKiDlubQoeSnlj6/ku6XnlKggMS00IOS4quWNoOS9jeespu+8jOavq+enkihTKeWPquiDveeUqCAxIOS4quWNoOS9jeespijmmK8gMS0zIOS9jeeahOaVsOWtlylcblx0XHQgKiBlZzpcblx0XHQgKiAobmV3IERhdGUoKS5nZXRUaW1lKCxcInl5eXktTU0tZGQgaGg6bW06c3MuU1wiKSA9PT4gMjAwNi0wNy0wMiAwODowOTowNC40MjNcblx0XHQgKiAobmV3IERhdGUoKS5nZXRUaW1lKCxcInl5eXktTU0tZGQgRSBISDptbTpzc1wiKSA9PT4gMjAwOS0wMy0xMCDkuowgMjA6MDk6MDRcblx0XHQgKiAobmV3IERhdGUoKS5nZXRUaW1lKCxcInl5eXktTU0tZGQgRUUgaGg6bW06c3NcIikgPT0+IDIwMDktMDMtMTAg5ZGo5LqMIDA4OjA5OjA0XG5cdFx0ICogKG5ldyBEYXRlKCkuZ2V0VGltZSgsXCJ5eXl5LU1NLWRkIEVFRSBoaDptbTpzc1wiKSA9PT4gMjAwOS0wMy0xMCDmmJ/mnJ/kuowgMDg6MDk6MDRcblx0XHQgKiAobmV3IERhdGUoKS5nZXRUaW1lKCxcInl5eXktTS1kIGg6bTpzLlNcIikgPT0+IDIwMDYtNy0yIDg6OTo0LjE4XG5cdFx0ICovXG5cdFx0ZGF0ZUZvcm1hdDpmdW5jdGlvbih0aWVtcyxmbXQpe1xuXG5cdFx0XHR2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpZW1zKTtcblxuXHRcdFx0dmFyIG8gPSB7XG5cdFx0XHRcdFwiTStcIiA6IGRhdGUuZ2V0TW9udGgoKSsxLCAvL+aciOS7vVxuXHRcdFx0XHRcImQrXCIgOiBkYXRlLmdldERhdGUoKSwgLy/ml6Vcblx0XHRcdFx0XCJoK1wiIDogZGF0ZS5nZXRIb3VycygpJTEyID09IDAgPyAxMiA6IGRhdGUuZ2V0SG91cnMoKSUxMiwgLy/lsI/ml7Zcblx0XHRcdFx0XCJIK1wiIDogZGF0ZS5nZXRIb3VycygpLCAvL+Wwj+aXtlxuXHRcdFx0XHRcIm0rXCIgOiBkYXRlLmdldE1pbnV0ZXMoKSwgLy/liIZcblx0XHRcdFx0XCJzK1wiIDogZGF0ZS5nZXRTZWNvbmRzKCksIC8v56eSXG5cdFx0XHRcdFwicStcIiA6IE1hdGguZmxvb3IoKGRhdGUuZ2V0TW9udGgoKSszKS8zKSwgLy/lraPluqZcblx0XHRcdFx0XCJTXCIgOiAgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAvL+avq+enklxuXHRcdFx0fTtcblx0XHRcdHZhciB3ZWVrID0ge1xuXHRcdFx0XHRcIjBcIiA6IFwiXFx1NjVlNVwiLFxuXHRcdFx0XHRcIjFcIiA6IFwiXFx1NGUwMFwiLFxuXHRcdFx0XHRcIjJcIiA6IFwiXFx1NGU4Y1wiLFxuXHRcdFx0XHRcIjNcIiA6IFwiXFx1NGUwOVwiLFxuXHRcdFx0XHRcIjRcIiA6IFwiXFx1NTZkYlwiLFxuXHRcdFx0XHRcIjVcIiA6IFwiXFx1NGU5NFwiLFxuXHRcdFx0XHRcIjZcIiA6IFwiXFx1NTE2ZFwiXG5cdFx0XHR9O1xuXHRcdFx0aWYoLyh5KykvLnRlc3QoZm10KSl7XG5cdFx0XHRcdGZtdD1mbXQucmVwbGFjZShSZWdFeHAuJDEsIChkYXRlLmdldEZ1bGxZZWFyKCkrXCJcIikuc3Vic3RyKDQgLSBSZWdFeHAuJDEubGVuZ3RoKSk7XG5cdFx0XHR9XG5cdFx0XHRpZigvKEUrKS8udGVzdChmbXQpKXtcblx0XHRcdFx0Zm10PWZtdC5yZXBsYWNlKFJlZ0V4cC4kMSwgKChSZWdFeHAuJDEubGVuZ3RoPjEpID8gKFJlZ0V4cC4kMS5sZW5ndGg+MiA/IFwiXFx1NjYxZlxcdTY3MWZcIiA6IFwiXFx1NTQ2OFwiKSA6IFwiXCIpK3dlZWtbZGF0ZS5nZXREYXkoKStcIlwiXSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IodmFyIGsgaW4gbyl7XG5cdFx0XHRcdGlmKG5ldyBSZWdFeHAoXCIoXCIrIGsgK1wiKVwiKS50ZXN0KGZtdCkpe1xuXHRcdFx0XHRcdGZtdCA9IGZtdC5yZXBsYWNlKFJlZ0V4cC4kMSwgKFJlZ0V4cC4kMS5sZW5ndGg9PTEpID8gKG9ba10pIDogKChcIjAwXCIrIG9ba10pLnN1YnN0cigoXCJcIisgb1trXSkubGVuZ3RoKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZm10O1xuXHRcdH0sXG5cdFx0Ly/orr7nva5jb29raWVzXG5cdFx0c2V0Q29va2llOmZ1bmN0aW9uIChuYW1lLHZhbHVlLHRpbWVzKSB7XG5cdFx0XHR2YXIgZXhwID0gbmV3IERhdGUoKTtcblx0XHRcdGV4cC5zZXRUaW1lKGV4cC5nZXRUaW1lKCkgK3RpbWVzKTtcblx0XHRcdGRvY3VtZW50LmNvb2tpZSA9IG5hbWUgKyBcIj1cIisgZXNjYXBlICh2YWx1ZSkgKyBcIjtleHBpcmVzPVwiICsgZXhwLnRvR01UU3RyaW5nKCkrXCI7cGF0aD0vXCI7XG5cdFx0fSxcblx0XHQvL+ivu+WPlmNvb2tpZXNcblx0XHRnZXRDb29raWU6IGZ1bmN0aW9uIChuYW1lKXtcblx0XHRcdHZhciBhcnIscmVnID0gbmV3IFJlZ0V4cChcIihefCApXCIrbmFtZStcIj0oW147XSopKDt8JClcIik7XG5cdFx0XHRpZihhcnIgPSBkb2N1bWVudC5jb29raWUubWF0Y2gocmVnKSl7XG5cdFx0XHRcdHJldHVybiB1bmVzY2FwZShhcnJbMl0pO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly/liKDpmaRjb29raWVzXG5cdFx0cmVtb3ZlQ29va2llOmZ1bmN0aW9uIChuYW1lKXtcblx0XHRcdHZhciBleHAgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0ZXhwLnNldFRpbWUoZXhwLmdldFRpbWUoKSAtIDEpO1xuXHRcdFx0dmFyIGN2YWwgPSB0aGlzLmdldENvb2tpZShuYW1lKTtcbiAgICAgIGlmKGN2YWwhPT0gbnVsbCkgZG9jdW1lbnQuY29va2llPSBuYW1lICsgXCI9XCIrY3ZhbCtcIjtleHBpcmVzPVwiK2V4cC50b0dNVFN0cmluZygpK1wiO3BhdGg9L1wiO1xuXHRcdH0sXG5cblx0XHRjbGVhckNvb2tpZTpmdW5jdGlvbiAoKXtcblx0XHRcdHZhciBrZXlzPWRvY3VtZW50LmNvb2tpZS5tYXRjaCgvW14gPTtdKyg/PVxcPSkvZyk7XG5cdFx0XHRpZiAoa2V5cykge1xuXHRcdFx0XHRmb3IgKHZhciBpID0ga2V5cy5sZW5ndGg7IGktLTspXG5cdFx0XHRcdFx0ZG9jdW1lbnQuY29va2llPWtleXNbaV0rJz0wO2V4cGlyZXM9JyArIG5ldyBEYXRlKCkudG9HTVRTdHJpbmcoKStcIjtwYXRoPS9cIjtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHRocm90dGxlOiBmdW5jdGlvbiAoZnVuYywgd2FpdCwgbXVzdFJ1bikge1xuXHRcdFx0dmFyIHRpbWVvdXQsXG5cdFx0XHRcdHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG5cblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGNvbnRleHQgPSB0aGlzLFxuXHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0Y3VyVGltZSA9IG5ldyBEYXRlKCk7XG5cblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdFx0XHQvLyDlpoLmnpzovr7liLDkuobop4TlrprnmoTop6blj5Hml7bpl7Tpl7TpmpTvvIzop6blj5EgaGFuZGxlclxuXHRcdFx0XHRpZihjdXJUaW1lIC0gc3RhcnRUaW1lID49IG11c3RSdW4pe1xuXG5cdFx0XHRcdFx0ZnVuYy5hcHBseShjb250ZXh0LGFyZ3MpO1xuXG5cdFx0XHRcdFx0c3RhcnRUaW1lID0gY3VyVGltZTtcblxuXHRcdFx0XHRcdC8vIOayoei+vuWIsOinpuWPkemXtOmalO+8jOmHjeaWsOiuvuWumuWumuaXtuWZqFxuXHRcdFx0XHR9ZWxzZXtcblxuXHRcdFx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0d2luZG93LkxpemFyZCA9IExpemFyZDtcblx0bW9kdWxlLmV4cG9ydHMgPSBMaXphcmQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcHVibGljL3NjcmlwdHMvd2lkZ2V0L2xpemFyZC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQUE7OztBQUFBO0FBQUE7O0FBQUE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBMUJBO0FBNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQTlVQTtBQWdWQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),

/***/ 10:
/*!****************************************!*\
  !*** ./public/scripts/widget/popup.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar $ = __webpack_require__(/*! ../lib/jquery */ 0);\n\nvar popup = {\n\tshowContent: function showContent(ele) {\n\t\t//\n\n\t\t$('.popup_mask').addClass('active');\n\n\t\t$(ele).addClass('active');\n\n\t\t$('body').addClass('overflow');\n\t},\n\thideContent: function hideContent(ele) {\n\t\t//\n\n\t\t$('.popup_mask').removeClass('active');\n\n\t\t$(ele).removeClass('active');\n\n\t\t$('body').removeClass('overflow');\n\t}\n};\n\nmodule.exports = popup;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcHVibGljL3NjcmlwdHMvd2lkZ2V0L3BvcHVwLmpzPzU2MjEiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgJCA9IHJlcXVpcmUoJy4uL2xpYi9qcXVlcnknKTtcblxudmFyIHBvcHVwID0ge1xuXG5cdHNob3dDb250ZW50IChlbGUpeyAvL+aYvuekuuW8ueWxglxuXG5cdFx0JCgnLnBvcHVwX21hc2snKS5hZGRDbGFzcygnYWN0aXZlJyk7XG5cblx0XHQkKGVsZSkuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXG5cdFx0JCgnYm9keScpLmFkZENsYXNzKCdvdmVyZmxvdycpO1xuXG4gfSxcblxuXHRoaWRlQ29udGVudCAoZWxlKXsgLy/pmpDol4/lvLnlsYJcblxuXHRcdCQoJy5wb3B1cF9tYXNrJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXG5cdFx0JChlbGUpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcblxuXHRcdCQoJ2JvZHknKS5yZW1vdmVDbGFzcygnb3ZlcmZsb3cnKTtcblxuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcG9wdXA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHB1YmxpYy9zY3JpcHRzL3dpZGdldC9wb3B1cC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFwQkE7QUFDQTtBQXNCQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10\n");

/***/ }),

/***/ 2:
/*!**********************************!*\
  !*** ./public/scripts/common.js ***!
  \**********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar $ = __webpack_require__(/*! ./lib/jquery */ 0);\n\nvar Lizard = __webpack_require__(/*! ./widget/lizard */ 1);\n\nvar common = {\n\n\theaderMenu: function headerMenu() {\n\n\t\t$('.js_narrow').click(function () {\n\n\t\t\t$('.header-logo').toggleClass('header_menu_scale');\n\n\t\t\t$('.aside-menu').toggleClass('header_menu_scale');\n\n\t\t\t$('.header_logo_img').toggle();\n\n\t\t\t$('.js_nav_link').toggle();\n\n\t\t\t$('.header-top').toggleClass('header_menu_toggle');\n\n\t\t\t$('.right-container').toggleClass('header_menu_toggle');\n\t\t});\n\n\t\tdocument.querySelector('.container').style.height = $(window).height() + 'px';\n\n\t\tdocument.querySelector('.right-container').style.minHeight = $(window).height() + 'px';\n\n\t\t$('.header_message_list li').click(function () {\n\n\t\t\t$('.header_notice').toggle();\n\t\t});\n\n\t\t//\n\n\t\t$('.js_logout').click(function () {\n\n\t\t\tLizard.clearCookie();\n\n\t\t\tlocation.href = '/user/login';\n\t\t});\n\n\t\t//\n\n\t\t$('.js_user').click(function () {\n\n\t\t\t$('.user_info').toggle();\n\t\t});\n\n\t\tgetMessage();\n\n\t\tfunction getMessage() {\n\n\t\t\tvar userName = $('.authority_name').text();\n\n\t\t\tLizard.ajax({\n\t\t\t\ttype: 'POST',\n\t\t\t\turl: '/user/message',\n\t\t\t\tsuccess: function success(data) {\n\n\t\t\t\t\tvar msgList = data.content;\n\n\t\t\t\t\tif (data && msgList.length) {\n\n\t\t\t\t\t\tvar getDateDiff = Lizard.getDateDiff;\n\n\t\t\t\t\t\tvar html = msgList.map(function (item) {\n\t\t\t\t\t\t\treturn '\\n\\t\\t\\t\\t\\t\\t\\t<dd>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<img src=\"https://imgthisisdashcdn-83chedai-com.alikunlun.com/identicons/135.png\" class=\"notice_img fl\"/>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<div class=\"notice_cont fr\">\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<div class=\"notice_txt\">\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<strong>' + userName + '</strong>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<time>' + getDateDiff(item.created_at) + '</time>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<p>' + item.content + '</p>\\n\\t\\t\\t\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t\\t\\t\\t\\t</dd>';\n\t\t\t\t\t\t}).join('');\n\n\t\t\t\t\t\t$('.notice_list').html(html);\n\n\t\t\t\t\t\t$('.js_msgNume').show();\n\n\t\t\t\t\t\t$('.js_msgNume').text(msgList.length);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t$('.js_msgNume').text('0');\n\n\t\t\t\t\t\t$('.notice_list').html('<dd><p></p></dd>');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tgetVerify: function getVerify() {\n\t\t//\n\n\t\t$('#captcha-img').click(function () {\n\n\t\t\tcommon.updateVerify();\n\t\t});\n\t},\n\tgetPage: function getPage(page, showPage) {\n\n\t\tvar iPage = 0;\n\n\t\tif (page % showPage == 0) {\n\n\t\t\tiPage = Math.floor(page / showPage - 1) * showPage;\n\t\t} else {\n\n\t\t\tiPage = Math.floor(page / showPage) * showPage;\n\t\t}\n\n\t\treturn iPage;\n\t},\n\tdropMenu: function dropMenu() {\n\n\t\t$('.js_select').click(function (e) {\n\n\t\t\te.stopPropagation();\n\n\t\t\t$(this).toggleClass('active');\n\n\t\t\t$(this).parent('.drop_menu').toggleClass('active');\n\t\t});\n\n\t\t$('.drop_menu_list').on('click', 'li', function (e) {\n\n\t\t\te.stopPropagation();\n\n\t\t\tvar value = $(this).data('value');\n\n\t\t\t$(this).parent().prev('.js_select').text($(this).text()).data('value', value).addClass('active').parents('.drop_menu').removeClass('active');\n\t\t});\n\n\t\t$(document).click(function () {\n\n\t\t\t$('.drop_menu').removeClass('active');\n\t\t});\n\t},\n\n\tclearForm: function clearForm() {\n\n\t\t$('.js_select').data('value', 0).text('');\n\t},\n\n\tupdateVerify: function updateVerify() {\n\t\tLizard.ajax({\n\t\t\ttype: 'POST',\n\t\t\tgateway: 'gatewayExt',\n\t\t\turl: '/user/verify',\n\t\t\tsuccess: function success(data) {\n\n\t\t\t\t$('#captcha-img').attr('src', data.img_url);\n\n\t\t\t\t$('#captcha_key').val(data.key);\n\t\t\t}\n\t\t});\n\t},\n\tisEmptyObject: function isEmptyObject(value) {\n\n\t\tfor (var attr in value) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\tdeleteEmptyProperty: function deleteEmptyProperty(object) {\n\n\t\tfor (var attr in object) {\n\n\t\t\tvar value = object[attr];\n\n\t\t\tif (value === '' || value === null || value === undefined) {\n\n\t\t\t\tdelete object[attr];\n\t\t\t}\n\t\t}\n\n\t\treturn object;\n\t}\n};\n\nmodule.exports = common;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9wdWJsaWMvc2NyaXB0cy9jb21tb24uanM/ZGYzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJCA9IHJlcXVpcmUoJy4vbGliL2pxdWVyeScpO1xuXG52YXIgTGl6YXJkID0gcmVxdWlyZSgnLi93aWRnZXQvbGl6YXJkJyk7XG5cbnZhciBjb21tb24gPSB7XG5cblx0aGVhZGVyTWVudTogZnVuY3Rpb24oKXtcblxuXHRcdCQoJy5qc19uYXJyb3cnKS5jbGljayhmdW5jdGlvbigpe1xuXG5cdFx0XHQkKCcuaGVhZGVyLWxvZ28nKS50b2dnbGVDbGFzcygnaGVhZGVyX21lbnVfc2NhbGUnKTtcblxuXHRcdFx0JCgnLmFzaWRlLW1lbnUnKS50b2dnbGVDbGFzcygnaGVhZGVyX21lbnVfc2NhbGUnKTtcblxuXHRcdFx0JCgnLmhlYWRlcl9sb2dvX2ltZycpLnRvZ2dsZSgpO1xuXG5cdFx0XHQkKCcuanNfbmF2X2xpbmsnKS50b2dnbGUoKTtcblxuXHRcdFx0JCgnLmhlYWRlci10b3AnKS50b2dnbGVDbGFzcygnaGVhZGVyX21lbnVfdG9nZ2xlJyk7XG5cblx0XHRcdCQoJy5yaWdodC1jb250YWluZXInKS50b2dnbGVDbGFzcygnaGVhZGVyX21lbnVfdG9nZ2xlJyk7XG5cblx0XHR9KVxuXG5cblx0XHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyJykuc3R5bGUuaGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpICsgJ3B4JztcblxuXHRcdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5yaWdodC1jb250YWluZXInKS5zdHlsZS5taW5IZWlnaHQgPSAkKHdpbmRvdykuaGVpZ2h0KCkgKyAncHgnO1xuXG5cdFx0JCgnLmhlYWRlcl9tZXNzYWdlX2xpc3QgbGknKS5jbGljayhmdW5jdGlvbigpe1xuXG5cdFx0XHQkKCcuaGVhZGVyX25vdGljZScpLnRvZ2dsZSgpO1xuXG5cdFx0fSlcblxuXHRcdC8v6YCA5Ye655m75b2VXG5cblx0XHQkKCcuanNfbG9nb3V0JykuY2xpY2soZnVuY3Rpb24oKXtcblxuXHRcdFx0TGl6YXJkLmNsZWFyQ29va2llKCk7XG5cblx0XHRcdGxvY2F0aW9uLmhyZWYgPSAnL3VzZXIvbG9naW4nO1xuXG5cdFx0fSlcblxuXHRcdC8v55So5oi35L+h5oGvXG5cblx0XHQkKCcuanNfdXNlcicpLmNsaWNrKGZ1bmN0aW9uKCl7XG5cblx0XHRcdCQoJy51c2VyX2luZm8nKS50b2dnbGUoKTtcblxuXHRcdH0pXG5cblx0XHRnZXRNZXNzYWdlKCk7XG5cblx0XHRmdW5jdGlvbiBnZXRNZXNzYWdlKCl7XG5cblx0XHRcdHZhciB1c2VyTmFtZSA9ICQoJy5hdXRob3JpdHlfbmFtZScpLnRleHQoKTtcblxuXHRcdFx0TGl6YXJkLmFqYXgoe1xuXHRcdFx0XHR0eXBlOidQT1NUJyxcblx0XHRcdFx0dXJsOicvdXNlci9tZXNzYWdlJyxcblx0XHRcdFx0c3VjY2VzczpmdW5jdGlvbihkYXRhKXtcblxuXHRcdFx0XHRcdHZhciBtc2dMaXN0ID0gZGF0YS5jb250ZW50O1xuXG5cdFx0XHRcdFx0aWYoZGF0YSAmJiBtc2dMaXN0Lmxlbmd0aCl7XG5cblx0XHRcdFx0XHRcdHZhciBnZXREYXRlRGlmZiA9IExpemFyZC5nZXREYXRlRGlmZjtcblxuXHRcdFx0XHRcdFx0dmFyIGh0bWwgPSBtc2dMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYFxuXHRcdFx0XHRcdFx0XHQ8ZGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8aW1nIHNyYz1cImh0dHBzOi8vaW1ndGhpc2lzZGFzaGNkbi04M2NoZWRhaS1jb20uYWxpa3VubHVuLmNvbS9pZGVudGljb25zLzEzNS5wbmdcIiBjbGFzcz1cIm5vdGljZV9pbWcgZmxcIi8+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibm90aWNlX2NvbnQgZnJcIj5cblx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJub3RpY2VfdHh0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3Ryb25nPiR7dXNlck5hbWV9PC9zdHJvbmc+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8dGltZT4ke2dldERhdGVEaWZmKGl0ZW0uY3JlYXRlZF9hdCl9PC90aW1lPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8cD4ke2l0ZW0uY29udGVudH08L3A+XG5cdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0PC9kZD5gXG5cdFx0XHRcdFx0XHR9KS5qb2luKCcnKTtcblxuXHRcdFx0XHRcdFx0JCgnLm5vdGljZV9saXN0JykuaHRtbChodG1sKTtcblxuXHRcdFx0XHRcdFx0JCgnLmpzX21zZ051bWUnKS5zaG93KCk7XG5cblx0XHRcdFx0XHRcdCQoJy5qc19tc2dOdW1lJykudGV4dChtc2dMaXN0Lmxlbmd0aCk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQkKCcuanNfbXNnTnVtZScpLnRleHQoJzAnKTtcblxuXHRcdFx0XHRcdFx0JCgnLm5vdGljZV9saXN0JykuaHRtbCgnPGRkPjxwPuW9k+WJjeaXoOS/oeaBrzwvcD48L2RkPicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHRcdH1cblx0fSxcblx0Z2V0VmVyaWZ5OiBmdW5jdGlvbiAoKSB7IC8v6I635Y+W6aqM6K+B56CBXG5cblx0XHQkKCcjY2FwdGNoYS1pbWcnKS5jbGljayhmdW5jdGlvbigpe1xuXG5cblx0XHRcdGNvbW1vbi51cGRhdGVWZXJpZnkoKTtcblxuXHRcdH0pXG5cdH0sXG5cdGdldFBhZ2U6IGZ1bmN0aW9uIChwYWdlLHNob3dQYWdlKSB7XG5cblx0XHR2YXIgaVBhZ2UgPSAwO1xuXG5cdFx0aWYgKChwYWdlICUgc2hvd1BhZ2UpID09IDApe1xuXG5cdFx0XHRpUGFnZSA9IE1hdGguZmxvb3IoKHBhZ2UgLyBzaG93UGFnZSAtMSkpICogc2hvd1BhZ2U7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRpUGFnZSA9IE1hdGguZmxvb3IocGFnZSAvIHNob3dQYWdlKSAqIHNob3dQYWdlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGlQYWdlXG5cblx0fSxcblx0ZHJvcE1lbnU6IGZ1bmN0aW9uICAoKSB7XG5cblx0XHQkKCcuanNfc2VsZWN0JykuY2xpY2soZnVuY3Rpb24oZSl7XG5cblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblxuXHRcdFx0JCh0aGlzKS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XG5cblx0XHRcdCQodGhpcykucGFyZW50KCcuZHJvcF9tZW51JykudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuXG5cdFx0fSlcblxuXHRcdCQoJy5kcm9wX21lbnVfbGlzdCcpLm9uKCdjbGljaycsJ2xpJyxmdW5jdGlvbihlKXtcblxuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0dmFyIHZhbHVlID0gJCh0aGlzKS5kYXRhKCd2YWx1ZScpO1xuXG5cdFx0XHQkKHRoaXMpLnBhcmVudCgpLnByZXYoJy5qc19zZWxlY3QnKS50ZXh0KCQodGhpcykudGV4dCgpKS5kYXRhKCd2YWx1ZScsdmFsdWUpLmFkZENsYXNzKCdhY3RpdmUnKS5wYXJlbnRzKCcuZHJvcF9tZW51JykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXG5cdFx0fSlcblxuXHRcdCQoZG9jdW1lbnQpLmNsaWNrKGZ1bmN0aW9uKCl7XG5cblx0XHRcdCQoJy5kcm9wX21lbnUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cblx0XHR9KVxuXHR9LFxuXG5cdGNsZWFyRm9ybSgpe1xuXG5cdFx0JCgnLmpzX3NlbGVjdCcpLmRhdGEoJ3ZhbHVlJywwKS50ZXh0KCfor7fpgInmi6knKTtcblxuXG5cdH0sXG5cdHVwZGF0ZVZlcmlmeTogZnVuY3Rpb24oKXtcblx0XHRMaXphcmQuYWpheCh7XG5cdFx0XHR0eXBlOiAnUE9TVCcsXG5cdFx0XHRnYXRld2F5OidnYXRld2F5RXh0Jyxcblx0XHRcdHVybDogJy91c2VyL3ZlcmlmeScsXG5cdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuXG5cdFx0XHRcdCQoJyNjYXB0Y2hhLWltZycpLmF0dHIoJ3NyYycsZGF0YS5pbWdfdXJsKTtcblxuXHRcdFx0XHQkKCcjY2FwdGNoYV9rZXknKS52YWwoZGF0YS5rZXkpO1xuXG5cdFx0XHR9XG5cdFx0fSlcblx0fSxcblx0aXNFbXB0eU9iamVjdCAodmFsdWUpe1xuXG5cdFx0Zm9yICh2YXIgYXR0ciBpbiB2YWx1ZSkge1xuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdGRlbGV0ZUVtcHR5UHJvcGVydHkob2JqZWN0KXtcblxuXHRcdGZvciAodmFyIGF0dHIgaW4gb2JqZWN0KSB7XG5cblx0XHRcdHZhciB2YWx1ZSA9IG9iamVjdFthdHRyXTtcblxuXHRcdFx0aWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cblx0XHRcdFx0ZGVsZXRlIG9iamVjdFthdHRyXTtcblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBvYmplY3Q7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21tb247XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcHVibGljL3NjcmlwdHMvY29tbW9uLmpzIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJDQTtBQXdDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQXBNQTtBQUNBO0FBc01BIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),

/***/ 3:
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/YzNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIDIzIDI0IDI1IDI2Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),

/***/ 4:
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcz81ZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIDIzIDI0IDI1IDI2Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),

/***/ 51:
/*!*****************************************!*\
  !*** ./public/scripts/account/index.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar $ = __webpack_require__(/*! ../lib/jquery */ 0);\n\nvar common = __webpack_require__(/*! ../common */ 2);\n\nvar Lizard = __webpack_require__(/*! ../widget/lizard */ 1);\n\nvar popup = __webpack_require__(/*! ../widget/popup */ 10);\n\nvar Vue = __webpack_require__(/*! ../lib/vue */ 8);\n\nvar recharge = new Vue({\n\n\tel: '#rechargePopup',\n\n\tdata: {\n\n\t\tsaveBtn: false,\n\t\trechargeAmount: '',\n\t\tsinaPayLink: '',\n\t\tformData: {}\n\t},\n\tmethods: {\n\t\thidePopup: function hidePopup() {\n\n\t\t\tpopup.hideContent('#rechargePopup');\n\t\t},\n\t\tsaveRecharge: function saveRecharge() {\n\t\t\tvar _this = this;\n\n\t\t\tthis.saveBtn = true;\n\n\t\t\tLizard.ajax({\n\t\t\t\ttype: \"POST\",\n\t\t\t\turl: '/account/recharge',\n\t\t\t\tdata: {\n\t\t\t\t\tamount: this.rechargeAmount,\n\t\t\t\t\tpay_method: '0'\n\t\t\t\t},\n\t\t\t\tsuccess: function success(data) {\n\n\t\t\t\t\t_this.rechargeAmount = '';\n\n\t\t\t\t\tpopup.hideContent('#rechargePopup');\n\n\t\t\t\t\tvar formData = {};\n\n\t\t\t\t\tObject.keys(data).forEach(function (item) {\n\n\t\t\t\t\t\tif (item !== 'sina_pay_online_pay_gate') {\n\n\t\t\t\t\t\t\tformData[item] = data[item];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t_this.formData = formData;\n\n\t\t\t\t\t_this.sinaPayLink = data.sina_pay_online_pay_gate;\n\n\t\t\t\t\tVue.nextTick(function () {\n\n\t\t\t\t\t\t$('#recharge').submit();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terror: function error() {\n\n\t\t\t\t\t_this.saveBtn = false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n});\n\nvar cashPopup = new Vue({\n\n\tel: '#cashPopup',\n\n\tdata: {\n\n\t\tsaveBtn: false,\n\t\twithdrawalAmount: ''\n\t},\n\tmethods: {\n\t\thidePopup: function hidePopup() {\n\n\t\t\tpopup.hideContent('#cashPopup');\n\t\t},\n\t\tsaveRecharge: function saveRecharge() {\n\n\t\t\t$('#cashForm').submit();\n\t\t}\n\t}\n});\n\nvar vueConfig = new Vue({\n\n\tel: '#app',\n\n\tmounted: function mounted() {\n\n\t\tcommon.headerMenu();\n\t},\n\n\tmethods: {\n\t\taccountAction: function accountAction(url) {\n\n\t\t\tLizard.ajax({\n\t\t\t\ttype: \"POST\",\n\t\t\t\turl: url,\n\t\t\t\tsuccess: function success(data) {\n\n\t\t\t\t\tif (data) {\n\n\t\t\t\t\t\tlocation.href = data.redirect_url;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tshowPopup: function showPopup(ele) {\n\n\t\t\tpopup.showContent(ele);\n\t\t}\n\t}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcHVibGljL3NjcmlwdHMvYWNjb3VudC9pbmRleC5qcz8yNGNlIl0sInNvdXJjZXNDb250ZW50IjpbIlxudmFyICQgPSByZXF1aXJlKCcuLi9saWIvanF1ZXJ5Jyk7XG5cbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcblxudmFyIExpemFyZCA9IHJlcXVpcmUoJy4uL3dpZGdldC9saXphcmQnKTtcblxudmFyIHBvcHVwID0gcmVxdWlyZSgnLi4vd2lkZ2V0L3BvcHVwJyk7XG5cbnZhciBWdWUgPSByZXF1aXJlKCcuLi9saWIvdnVlJyk7XG5cblxudmFyIHJlY2hhcmdlID0gbmV3IFZ1ZSh7XG5cblx0ZWw6ICcjcmVjaGFyZ2VQb3B1cCcsXG5cblx0ZGF0YToge1xuXG5cdFx0c2F2ZUJ0bjpmYWxzZSxcblx0XHRyZWNoYXJnZUFtb3VudDonJyxcblx0XHRzaW5hUGF5TGluazonJyxcblx0XHRmb3JtRGF0YToge31cblx0fSxcblx0bWV0aG9kczoge1xuXHRcdGhpZGVQb3B1cCAoKSB7XG5cblx0XHRcdHBvcHVwLmhpZGVDb250ZW50KCcjcmVjaGFyZ2VQb3B1cCcpO1xuXG5cblx0XHR9LFxuXHRcdHNhdmVSZWNoYXJnZSgpe1xuXG5cdFx0XHR0aGlzLnNhdmVCdG4gPSB0cnVlO1xuXG5cdFx0XHRMaXphcmQuYWpheCh7XG5cdFx0XHRcdHR5cGU6IFwiUE9TVFwiLFxuXHRcdFx0XHR1cmw6ICcvYWNjb3VudC9yZWNoYXJnZScsXG5cdFx0XHRcdGRhdGE6e1xuXHRcdFx0XHRcdGFtb3VudDogdGhpcy5yZWNoYXJnZUFtb3VudCxcblx0XHRcdFx0XHRwYXlfbWV0aG9kOiAnMCdcblx0XHRcdFx0fSxcblx0XHRcdFx0c3VjY2VzczooZGF0YSkgPT4ge1xuXG5cdFx0XHRcdFx0dGhpcy5yZWNoYXJnZUFtb3VudCA9ICcnO1xuXG5cdFx0XHRcdFx0cG9wdXAuaGlkZUNvbnRlbnQoJyNyZWNoYXJnZVBvcHVwJyk7XG5cblx0XHRcdFx0XHR2YXIgZm9ybURhdGEgPSB7fVxuXG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaCgoaXRlbSkgPT57XG5cblx0XHRcdFx0XHRcdGlmIChpdGVtICE9PSAnc2luYV9wYXlfb25saW5lX3BheV9nYXRlJykge1xuXG5cdFx0XHRcdFx0XHRcdGZvcm1EYXRhW2l0ZW1dID0gZGF0YVtpdGVtXTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSlcblxuXHRcdFx0XHRcdHRoaXMuZm9ybURhdGEgPSBmb3JtRGF0YTtcblxuXHRcdFx0XHRcdHRoaXMuc2luYVBheUxpbmsgPSBkYXRhLnNpbmFfcGF5X29ubGluZV9wYXlfZ2F0ZTtcblxuXHRcdFx0XHRcdFZ1ZS5uZXh0VGljayggKCk9PntcblxuXHRcdFx0XHRcdFx0JCgnI3JlY2hhcmdlJykuc3VibWl0KCk7XG5cblx0XHRcdFx0XHR9KVxuXG5cblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6ICgpID0+e1xuXG5cdFx0XHRcdFx0dGhpcy5zYXZlQnRuID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fVxuXG5cdH1cbn0pXG5cbnZhciBjYXNoUG9wdXAgPSBuZXcgVnVlKHtcblxuXHRlbDogJyNjYXNoUG9wdXAnLFxuXG5cdGRhdGE6IHtcblxuXHRcdHNhdmVCdG46ZmFsc2UsXG5cdFx0d2l0aGRyYXdhbEFtb3VudDonJ1xuXHR9LFxuXHRtZXRob2RzOiB7XG5cblx0XHRoaWRlUG9wdXAgKCkge1xuXG5cdFx0XHRwb3B1cC5oaWRlQ29udGVudCgnI2Nhc2hQb3B1cCcpO1xuXG5cblx0XHR9LFxuXHRcdHNhdmVSZWNoYXJnZSgpe1xuXG5cdFx0XHQkKCcjY2FzaEZvcm0nKS5zdWJtaXQoKTtcblx0XHR9XG5cblx0fVxufSlcblxuXG52YXIgdnVlQ29uZmlnID0gbmV3IFZ1ZSh7XG5cblx0ZWw6JyNhcHAnLFxuXG5cdG1vdW50ZWQoKXtcblxuXHRcdGNvbW1vbi5oZWFkZXJNZW51KCk7XG5cdH0sXG5cdG1ldGhvZHM6IHtcblxuXHRcdGFjY291bnRBY3Rpb24gKHVybCkge1xuXG5cdFx0XHRMaXphcmQuYWpheCh7XG5cdFx0XHRcdHR5cGU6IFwiUE9TVFwiLFxuXHRcdFx0XHR1cmw6dXJsLFxuXHRcdFx0XHRzdWNjZXNzKGRhdGEpIHtcblxuXHRcdFx0XHRcdGlmIChkYXRhKSB7XG5cblx0XHRcdFx0XHRcdGxvY2F0aW9uLmhyZWYgPSBkYXRhLnJlZGlyZWN0X3VybDtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0pXG5cdFx0fSxcblx0XHRzaG93UG9wdXAgKGVsZSkge1xuXG5cdFx0XHRwb3B1cC5zaG93Q29udGVudChlbGUpO1xuXG5cdFx0fVxuXHR9XG59KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHB1YmxpYy9zY3JpcHRzL2FjY291bnQvaW5kZXguanMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4Q0E7QUEwQ0E7QUFyREE7QUFYQTtBQUNBO0FBb0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBRUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhBO0FBVEE7QUFDQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQVhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQXZCQTtBQVJBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51\n");

/***/ }),

/***/ 8:
/*!***********************************!*\
  !*** ./public/scripts/lib/vue.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * Vue.js v2.3.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n\t( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Vue = factory();\n})(undefined, function () {\n\t'use strict';\n\n\t/*  */\n\n\t// these helpers produces better vm code in JS engines due to their\n\t// explicitness and function inlining\n\n\tfunction isUndef(v) {\n\t\treturn v === undefined || v === null;\n\t}\n\n\tfunction isDef(v) {\n\t\treturn v !== undefined && v !== null;\n\t}\n\n\tfunction isTrue(v) {\n\t\treturn v === true;\n\t}\n\n\tfunction isFalse(v) {\n\t\treturn v === false;\n\t}\n\t/**\n  * Check if value is primitive\n  */\n\tfunction isPrimitive(value) {\n\t\treturn typeof value === 'string' || typeof value === 'number';\n\t}\n\n\t/**\n  * Quick object check - this is primarily used to tell\n  * Objects from primitive values when we know the value\n  * is a JSON-compliant type.\n  */\n\tfunction isObject(obj) {\n\t\treturn obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n\t}\n\n\tvar _toString = Object.prototype.toString;\n\n\t/**\n  * Strict object type check. Only returns true\n  * for plain JavaScript objects.\n  */\n\tfunction isPlainObject(obj) {\n\t\treturn _toString.call(obj) === '[object Object]';\n\t}\n\n\tfunction isRegExp(v) {\n\t\treturn _toString.call(v) === '[object RegExp]';\n\t}\n\n\t/**\n  * Convert a value to a string that is actually rendered.\n  */\n\tfunction toString(val) {\n\t\treturn val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);\n\t}\n\n\t/**\n  * Convert a input value to a number for persistence.\n  * If the conversion fails, return original string.\n  */\n\tfunction toNumber(val) {\n\t\tvar n = parseFloat(val);\n\t\treturn isNaN(n) ? val : n;\n\t}\n\n\t/**\n  * Make a map and return a function for checking if a key\n  * is in that map.\n  */\n\tfunction makeMap(str, expectsLowerCase) {\n\t\tvar map = Object.create(null);\n\t\tvar list = str.split(',');\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tmap[list[i]] = true;\n\t\t}\n\t\treturn expectsLowerCase ? function (val) {\n\t\t\treturn map[val.toLowerCase()];\n\t\t} : function (val) {\n\t\t\treturn map[val];\n\t\t};\n\t}\n\n\t/**\n  * Check if a tag is a built-in tag.\n  */\n\tvar isBuiltInTag = makeMap('slot,component', true);\n\n\t/**\n  * Remove an item from an array\n  */\n\tfunction remove(arr, item) {\n\t\tif (arr.length) {\n\t\t\tvar index = arr.indexOf(item);\n\t\t\tif (index > -1) {\n\t\t\t\treturn arr.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Check whether the object has the property.\n  */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tfunction hasOwn(obj, key) {\n\t\treturn hasOwnProperty.call(obj, key);\n\t}\n\n\t/**\n  * Create a cached version of a pure function.\n  */\n\tfunction cached(fn) {\n\t\tvar cache = Object.create(null);\n\t\treturn function cachedFn(str) {\n\t\t\tvar hit = cache[str];\n\t\t\treturn hit || (cache[str] = fn(str));\n\t\t};\n\t}\n\n\t/**\n  * Camelize a hyphen-delimited string.\n  */\n\tvar camelizeRE = /-(\\w)/g;\n\tvar camelize = cached(function (str) {\n\t\treturn str.replace(camelizeRE, function (_, c) {\n\t\t\treturn c ? c.toUpperCase() : '';\n\t\t});\n\t});\n\n\t/**\n  * Capitalize a string.\n  */\n\tvar capitalize = cached(function (str) {\n\t\treturn str.charAt(0).toUpperCase() + str.slice(1);\n\t});\n\n\t/**\n  * Hyphenate a camelCase string.\n  */\n\tvar hyphenateRE = /([^-])([A-Z])/g;\n\tvar hyphenate = cached(function (str) {\n\t\treturn str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\n\t});\n\n\t/**\n  * Simple bind, faster than native\n  */\n\tfunction bind(fn, ctx) {\n\t\tfunction boundFn(a) {\n\t\t\tvar l = arguments.length;\n\t\t\treturn l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n\t\t}\n\t\t// record original fn length\n\t\tboundFn._length = fn.length;\n\t\treturn boundFn;\n\t}\n\n\t/**\n  * Convert an Array-like object to a real Array.\n  */\n\tfunction toArray(list, start) {\n\t\tstart = start || 0;\n\t\tvar i = list.length - start;\n\t\tvar ret = new Array(i);\n\t\twhile (i--) {\n\t\t\tret[i] = list[i + start];\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/**\n  * Mix properties into target object.\n  */\n\tfunction extend(to, _from) {\n\t\tfor (var key in _from) {\n\t\t\tto[key] = _from[key];\n\t\t}\n\t\treturn to;\n\t}\n\n\t/**\n  * Merge an Array of Objects into a single Object.\n  */\n\tfunction toObject(arr) {\n\t\tvar res = {};\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i]) {\n\t\t\t\textend(res, arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t/**\n  * Perform no operation.\n  */\n\tfunction noop() {}\n\n\t/**\n  * Always return false.\n  */\n\tvar no = function no() {\n\t\treturn false;\n\t};\n\n\t/**\n  * Return same value\n  */\n\tvar identity = function identity(_) {\n\t\treturn _;\n\t};\n\n\t/**\n  * Generate a static keys string from compiler modules.\n  */\n\tfunction genStaticKeys(modules) {\n\t\treturn modules.reduce(function (keys, m) {\n\t\t\treturn keys.concat(m.staticKeys || []);\n\t\t}, []).join(',');\n\t}\n\n\t/**\n  * Check if two values are loosely equal - that is,\n  * if they are plain objects, do they have the same shape?\n  */\n\tfunction looseEqual(a, b) {\n\t\tvar isObjectA = isObject(a);\n\t\tvar isObjectB = isObject(b);\n\t\tif (isObjectA && isObjectB) {\n\t\t\ttry {\n\t\t\t\treturn JSON.stringify(a) === JSON.stringify(b);\n\t\t\t} catch (e) {\n\t\t\t\t// possible circular reference\n\t\t\t\treturn a === b;\n\t\t\t}\n\t\t} else if (!isObjectA && !isObjectB) {\n\t\t\treturn String(a) === String(b);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction looseIndexOf(arr, val) {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (looseEqual(arr[i], val)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n  * Ensure a function is called only once.\n  */\n\tfunction once(fn) {\n\t\tvar called = false;\n\t\treturn function () {\n\t\t\tif (!called) {\n\t\t\t\tcalled = true;\n\t\t\t\tfn.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}\n\n\tvar SSR_ATTR = 'data-server-rendered';\n\n\tvar ASSET_TYPES = ['component', 'directive', 'filter'];\n\n\tvar LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];\n\n\t/*  */\n\n\tvar config = {\n\t\t/**\n   * Option merge strategies (used in core/util/options)\n   */\n\t\toptionMergeStrategies: Object.create(null),\n\n\t\t/**\n   * Whether to suppress warnings.\n   */\n\t\tsilent: false,\n\n\t\t/**\n   * Show production mode tip message on boot?\n   */\n\t\tproductionTip: \"development\" !== 'production',\n\n\t\t/**\n   * Whether to enable devtools\n   */\n\t\tdevtools: \"development\" !== 'production',\n\n\t\t/**\n   * Whether to record perf\n   */\n\t\tperformance: false,\n\n\t\t/**\n   * Error handler for watcher errors\n   */\n\t\terrorHandler: null,\n\n\t\t/**\n   * Ignore certain custom elements\n   */\n\t\tignoredElements: [],\n\n\t\t/**\n   * Custom user key aliases for v-on\n   */\n\t\tkeyCodes: Object.create(null),\n\n\t\t/**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n\t\tisReservedTag: no,\n\n\t\t/**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n\t\tisReservedAttr: no,\n\n\t\t/**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n\t\tisUnknownElement: no,\n\n\t\t/**\n   * Get the namespace of an element\n   */\n\t\tgetTagNamespace: noop,\n\n\t\t/**\n   * Parse the real tag name for the specific platform.\n   */\n\t\tparsePlatformTagName: identity,\n\n\t\t/**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n\t\tmustUseProp: no,\n\n\t\t/**\n   * Exposed for legacy reasons\n   */\n\t\t_lifecycleHooks: LIFECYCLE_HOOKS\n\t};\n\n\t/*  */\n\n\tvar emptyObject = Object.freeze({});\n\n\t/**\n  * Check if a string starts with $ or _\n  */\n\tfunction isReserved(str) {\n\t\tvar c = (str + '').charCodeAt(0);\n\t\treturn c === 0x24 || c === 0x5F;\n\t}\n\n\t/**\n  * Define a property.\n  */\n\tfunction def(obj, key, val, enumerable) {\n\t\tObject.defineProperty(obj, key, {\n\t\t\tvalue: val,\n\t\t\tenumerable: !!enumerable,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t}\n\n\t/**\n  * Parse simple path.\n  */\n\tvar bailRE = /[^\\w.$]/;\n\tfunction parsePath(path) {\n\t\tif (bailRE.test(path)) {\n\t\t\treturn;\n\t\t}\n\t\tvar segments = path.split('.');\n\t\treturn function (obj) {\n\t\t\tfor (var i = 0; i < segments.length; i++) {\n\t\t\t\tif (!obj) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobj = obj[segments[i]];\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t}\n\n\t/*  */\n\n\tvar warn = noop;\n\tvar tip = noop;\n\tvar formatComponentName = null; // work around flow check\n\n\t{\n\t\tvar hasConsole = typeof console !== 'undefined';\n\t\tvar classifyRE = /(?:^|[-_])(\\w)/g;\n\t\tvar classify = function classify(str) {\n\t\t\treturn str.replace(classifyRE, function (c) {\n\t\t\t\treturn c.toUpperCase();\n\t\t\t}).replace(/[-_]/g, '');\n\t\t};\n\n\t\twarn = function warn(msg, vm) {\n\t\t\tif (hasConsole && !config.silent) {\n\t\t\t\tconsole.error(\"[Vue warn]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n\t\t\t}\n\t\t};\n\n\t\ttip = function tip(msg, vm) {\n\t\t\tif (hasConsole && !config.silent) {\n\t\t\t\tconsole.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n\t\t\t}\n\t\t};\n\n\t\tformatComponentName = function formatComponentName(vm, includeFile) {\n\t\t\tif (vm.$root === vm) {\n\t\t\t\treturn '<Root>';\n\t\t\t}\n\t\t\tvar name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n\n\t\t\tvar file = vm._isVue && vm.$options.__file;\n\t\t\tif (!name && file) {\n\t\t\t\tvar match = file.match(/([^/\\\\]+)\\.vue$/);\n\t\t\t\tname = match && match[1];\n\t\t\t}\n\n\t\t\treturn (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n\t\t};\n\n\t\tvar repeat = function repeat(str, n) {\n\t\t\tvar res = '';\n\t\t\twhile (n) {\n\t\t\t\tif (n % 2 === 1) {\n\t\t\t\t\tres += str;\n\t\t\t\t}\n\t\t\t\tif (n > 1) {\n\t\t\t\t\tstr += str;\n\t\t\t\t}\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\n\t\tvar generateComponentTrace = function generateComponentTrace(vm) {\n\t\t\tif (vm._isVue && vm.$parent) {\n\t\t\t\tvar tree = [];\n\t\t\t\tvar currentRecursiveSequence = 0;\n\t\t\t\twhile (vm) {\n\t\t\t\t\tif (tree.length > 0) {\n\t\t\t\t\t\tvar last = tree[tree.length - 1];\n\t\t\t\t\t\tif (last.constructor === vm.constructor) {\n\t\t\t\t\t\t\tcurrentRecursiveSequence++;\n\t\t\t\t\t\t\tvm = vm.$parent;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (currentRecursiveSequence > 0) {\n\t\t\t\t\t\t\ttree[tree.length - 1] = [last, currentRecursiveSequence];\n\t\t\t\t\t\t\tcurrentRecursiveSequence = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttree.push(vm);\n\t\t\t\t\tvm = vm.$parent;\n\t\t\t\t}\n\t\t\t\treturn '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n\t\t\t\t\treturn \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n\t\t\t\t}).join('\\n');\n\t\t\t} else {\n\t\t\t\treturn \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n\t\t\t}\n\t\t};\n\t}\n\n\t/*  */\n\n\tfunction handleError(err, vm, info) {\n\t\tif (config.errorHandler) {\n\t\t\tconfig.errorHandler.call(null, err, vm, info);\n\t\t} else {\n\t\t\t{\n\t\t\t\twarn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n\t\t\t}\n\t\t\t/* istanbul ignore else */\n\t\t\tif (inBrowser && typeof console !== 'undefined') {\n\t\t\t\tconsole.error(err);\n\t\t\t} else {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\t/* globals MutationObserver */\n\n\t// can we use __proto__?\n\tvar hasProto = '__proto__' in {};\n\n\t// Browser environment sniffing\n\tvar inBrowser = typeof window !== 'undefined';\n\tvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\n\tvar isIE = UA && /msie|trident/.test(UA);\n\tvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n\tvar isEdge = UA && UA.indexOf('edge/') > 0;\n\tvar isAndroid = UA && UA.indexOf('android') > 0;\n\tvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\tvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n\tvar supportsPassive = false;\n\tif (inBrowser) {\n\t\ttry {\n\t\t\tvar opts = {};\n\t\t\tObject.defineProperty(opts, 'passive', {\n\t\t\t\tget: function get() {\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tsupportsPassive = true;\n\t\t\t\t}\n\t\t\t}); // https://github.com/facebook/flow/issues/285\n\t\t\twindow.addEventListener('test-passive', null, opts);\n\t\t} catch (e) {}\n\t}\n\n\t// this needs to be lazy-evaled because vue may be required before\n\t// vue-server-renderer can set VUE_ENV\n\tvar _isServer;\n\tvar isServerRendering = function isServerRendering() {\n\t\tif (_isServer === undefined) {\n\t\t\t/* istanbul ignore if */\n\t\t\tif (!inBrowser && typeof global !== 'undefined') {\n\t\t\t\t// detect presence of vue-server-renderer and avoid\n\t\t\t\t// Webpack shimming the process\n\t\t\t\t_isServer = global['process'].env.VUE_ENV === 'server';\n\t\t\t} else {\n\t\t\t\t_isServer = false;\n\t\t\t}\n\t\t}\n\t\treturn _isServer;\n\t};\n\n\t// detect devtools\n\tvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n\t/* istanbul ignore next */\n\tfunction isNative(Ctor) {\n\t\treturn typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n\t}\n\n\tvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n\t/**\n  * Defer a task to execute it asynchronously.\n  */\n\tvar nextTick = function () {\n\t\tvar callbacks = [];\n\t\tvar pending = false;\n\t\tvar timerFunc;\n\n\t\tfunction nextTickHandler() {\n\t\t\tpending = false;\n\t\t\tvar copies = callbacks.slice(0);\n\t\t\tcallbacks.length = 0;\n\t\t\tfor (var i = 0; i < copies.length; i++) {\n\t\t\t\tcopies[i]();\n\t\t\t}\n\t\t}\n\n\t\t// the nextTick behavior leverages the microtask queue, which can be accessed\n\t\t// via either native Promise.then or MutationObserver.\n\t\t// MutationObserver has wider support, however it is seriously bugged in\n\t\t// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n\t\t// completely stops working after triggering a few times... so, if native\n\t\t// Promise is available, we will use it:\n\t\t/* istanbul ignore if */\n\t\tif (typeof Promise !== 'undefined' && isNative(Promise)) {\n\t\t\tvar p = Promise.resolve();\n\t\t\tvar logError = function logError(err) {\n\t\t\t\tconsole.error(err);\n\t\t\t};\n\t\t\ttimerFunc = function timerFunc() {\n\t\t\t\tp.then(nextTickHandler).catch(logError);\n\t\t\t\t// in problematic UIWebViews, Promise.then doesn't completely break, but\n\t\t\t\t// it can get stuck in a weird state where callbacks are pushed into the\n\t\t\t\t// microtask queue but the queue isn't being flushed, until the browser\n\t\t\t\t// needs to do some other work, e.g. handle a timer. Therefore we can\n\t\t\t\t// \"force\" the microtask queue to be flushed by adding an empty timer.\n\t\t\t\tif (isIOS) {\n\t\t\t\t\tsetTimeout(noop);\n\t\t\t\t}\n\t\t\t};\n\t\t} else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||\n\t\t// PhantomJS and iOS 7.x\n\t\tMutationObserver.toString() === '[object MutationObserverConstructor]')) {\n\t\t\t// use MutationObserver where native Promise is not available,\n\t\t\t// e.g. PhantomJS IE11, iOS7, Android 4.4\n\t\t\tvar counter = 1;\n\t\t\tvar observer = new MutationObserver(nextTickHandler);\n\t\t\tvar textNode = document.createTextNode(String(counter));\n\t\t\tobserver.observe(textNode, {\n\t\t\t\tcharacterData: true\n\t\t\t});\n\t\t\ttimerFunc = function timerFunc() {\n\t\t\t\tcounter = (counter + 1) % 2;\n\t\t\t\ttextNode.data = String(counter);\n\t\t\t};\n\t\t} else {\n\t\t\t// fallback to setTimeout\n\t\t\t/* istanbul ignore next */\n\t\t\ttimerFunc = function timerFunc() {\n\t\t\t\tsetTimeout(nextTickHandler, 0);\n\t\t\t};\n\t\t}\n\n\t\treturn function queueNextTick(cb, ctx) {\n\t\t\tvar _resolve;\n\t\t\tcallbacks.push(function () {\n\t\t\t\tif (cb) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcb.call(ctx);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\thandleError(e, ctx, 'nextTick');\n\t\t\t\t\t}\n\t\t\t\t} else if (_resolve) {\n\t\t\t\t\t_resolve(ctx);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!pending) {\n\t\t\t\tpending = true;\n\t\t\t\ttimerFunc();\n\t\t\t}\n\t\t\tif (!cb && typeof Promise !== 'undefined') {\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t_resolve = resolve;\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}();\n\n\tvar _Set;\n\t/* istanbul ignore if */\n\tif (typeof Set !== 'undefined' && isNative(Set)) {\n\t\t// use native Set when available.\n\t\t_Set = Set;\n\t} else {\n\t\t// a non-standard Set polyfill that only works with primitive keys.\n\t\t_Set = function () {\n\t\t\tfunction Set() {\n\t\t\t\tthis.set = Object.create(null);\n\t\t\t}\n\t\t\tSet.prototype.has = function has(key) {\n\t\t\t\treturn this.set[key] === true;\n\t\t\t};\n\t\t\tSet.prototype.add = function add(key) {\n\t\t\t\tthis.set[key] = true;\n\t\t\t};\n\t\t\tSet.prototype.clear = function clear() {\n\t\t\t\tthis.set = Object.create(null);\n\t\t\t};\n\n\t\t\treturn Set;\n\t\t}();\n\t}\n\n\t/*  */\n\n\tvar uid = 0;\n\n\t/**\n  * A dep is an observable that can have multiple\n  * directives subscribing to it.\n  */\n\tvar Dep = function Dep() {\n\t\tthis.id = uid++;\n\t\tthis.subs = [];\n\t};\n\n\tDep.prototype.addSub = function addSub(sub) {\n\t\tthis.subs.push(sub);\n\t};\n\n\tDep.prototype.removeSub = function removeSub(sub) {\n\t\tremove(this.subs, sub);\n\t};\n\n\tDep.prototype.depend = function depend() {\n\t\tif (Dep.target) {\n\t\t\tDep.target.addDep(this);\n\t\t}\n\t};\n\n\tDep.prototype.notify = function notify() {\n\t\t// stabilize the subscriber list first\n\t\tvar subs = this.subs.slice();\n\t\tfor (var i = 0, l = subs.length; i < l; i++) {\n\t\t\tsubs[i].update();\n\t\t}\n\t};\n\n\t// the current target watcher being evaluated.\n\t// this is globally unique because there could be only one\n\t// watcher being evaluated at any time.\n\tDep.target = null;\n\tvar targetStack = [];\n\n\tfunction pushTarget(_target) {\n\t\tif (Dep.target) {\n\t\t\ttargetStack.push(Dep.target);\n\t\t}\n\t\tDep.target = _target;\n\t}\n\n\tfunction popTarget() {\n\t\tDep.target = targetStack.pop();\n\t}\n\n\t/*\n  * not type checking this file because flow doesn't play well with\n  * dynamically accessing methods on Array prototype\n  */\n\n\tvar arrayProto = Array.prototype;\n\tvar arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n\t\t// cache original method\n\t\tvar original = arrayProto[method];\n\t\tdef(arrayMethods, method, function mutator() {\n\t\t\tvar arguments$1 = arguments;\n\n\t\t\t// avoid leaking arguments:\n\t\t\t// http://jsperf.com/closure-with-arguments\n\t\t\tvar i = arguments.length;\n\t\t\tvar args = new Array(i);\n\t\t\twhile (i--) {\n\t\t\t\targs[i] = arguments$1[i];\n\t\t\t}\n\t\t\tvar result = original.apply(this, args);\n\t\t\tvar ob = this.__ob__;\n\t\t\tvar inserted;\n\t\t\tswitch (method) {\n\t\t\t\tcase 'push':\n\t\t\t\t\tinserted = args;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'unshift':\n\t\t\t\t\tinserted = args;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'splice':\n\t\t\t\t\tinserted = args.slice(2);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (inserted) {\n\t\t\t\tob.observeArray(inserted);\n\t\t\t}\n\t\t\t// notify change\n\t\t\tob.dep.notify();\n\t\t\treturn result;\n\t\t});\n\t});\n\n\t/*  */\n\n\tvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n\t/**\n  * By default, when a reactive property is set, the new value is\n  * also converted to become reactive. However when passing down props,\n  * we don't want to force conversion because the value may be a nested value\n  * under a frozen data structure. Converting it would defeat the optimization.\n  */\n\tvar observerState = {\n\t\tshouldConvert: true,\n\t\tisSettingProps: false\n\t};\n\n\t/**\n  * Observer class that are attached to each observed\n  * object. Once attached, the observer converts target\n  * object's property keys into getter/setters that\n  * collect dependencies and dispatches updates.\n  */\n\tvar Observer = function Observer(value) {\n\t\tthis.value = value;\n\t\tthis.dep = new Dep();\n\t\tthis.vmCount = 0;\n\t\tdef(value, '__ob__', this);\n\t\tif (Array.isArray(value)) {\n\t\t\tvar augment = hasProto ? protoAugment : copyAugment;\n\t\t\taugment(value, arrayMethods, arrayKeys);\n\t\t\tthis.observeArray(value);\n\t\t} else {\n\t\t\tthis.walk(value);\n\t\t}\n\t};\n\n\t/**\n  * Walk through each property and convert them into\n  * getter/setters. This method should only be called when\n  * value type is Object.\n  */\n\tObserver.prototype.walk = function walk(obj) {\n\t\tvar keys = Object.keys(obj);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tdefineReactive$$1(obj, keys[i], obj[keys[i]]);\n\t\t}\n\t};\n\n\t/**\n  * Observe a list of Array items.\n  */\n\tObserver.prototype.observeArray = function observeArray(items) {\n\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\tobserve(items[i]);\n\t\t}\n\t};\n\n\t// helpers\n\n\t/**\n  * Augment an target Object or Array by intercepting\n  * the prototype chain using __proto__\n  */\n\tfunction protoAugment(target, src) {\n\t\t/* eslint-disable no-proto */\n\t\ttarget.__proto__ = src;\n\t\t/* eslint-enable no-proto */\n\t}\n\n\t/**\n  * Augment an target Object or Array by defining\n  * hidden properties.\n  */\n\t/* istanbul ignore next */\n\tfunction copyAugment(target, src, keys) {\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tdef(target, key, src[key]);\n\t\t}\n\t}\n\n\t/**\n  * Attempt to create an observer instance for a value,\n  * returns the new observer if successfully observed,\n  * or the existing observer if the value already has one.\n  */\n\tfunction observe(value, asRootData) {\n\t\tif (!isObject(value)) {\n\t\t\treturn;\n\t\t}\n\t\tvar ob;\n\t\tif (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t\t\tob = value.__ob__;\n\t\t} else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n\t\t\tob = new Observer(value);\n\t\t}\n\t\tif (asRootData && ob) {\n\t\t\tob.vmCount++;\n\t\t}\n\t\treturn ob;\n\t}\n\n\t/**\n  * Define a reactive property on an Object.\n  */\n\tfunction defineReactive$$1(obj, key, val, customSetter) {\n\t\tvar dep = new Dep();\n\n\t\tvar property = Object.getOwnPropertyDescriptor(obj, key);\n\t\tif (property && property.configurable === false) {\n\t\t\treturn;\n\t\t}\n\n\t\t// cater for pre-defined getter/setters\n\t\tvar getter = property && property.get;\n\t\tvar setter = property && property.set;\n\n\t\tvar childOb = observe(val);\n\t\tObject.defineProperty(obj, key, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tget: function reactiveGetter() {\n\t\t\t\tvar value = getter ? getter.call(obj) : val;\n\t\t\t\tif (Dep.target) {\n\t\t\t\t\tdep.depend();\n\t\t\t\t\tif (childOb) {\n\t\t\t\t\t\tchildOb.dep.depend();\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\tdependArray(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tset: function reactiveSetter(newVal) {\n\t\t\t\tvar value = getter ? getter.call(obj) : val;\n\t\t\t\t/* eslint-disable no-self-compare */\n\t\t\t\tif (newVal === value || newVal !== newVal && value !== value) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t/* eslint-enable no-self-compare */\n\t\t\t\tif (\"development\" !== 'production' && customSetter) {\n\t\t\t\t\tcustomSetter();\n\t\t\t\t}\n\t\t\t\tif (setter) {\n\t\t\t\t\tsetter.call(obj, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tval = newVal;\n\t\t\t\t}\n\t\t\t\tchildOb = observe(newVal);\n\t\t\t\tdep.notify();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n  * Set a property on an object. Adds the new property and\n  * triggers change notification if the property doesn't\n  * already exist.\n  */\n\tfunction set(target, key, val) {\n\t\tif (Array.isArray(target) && typeof key === 'number') {\n\t\t\ttarget.length = Math.max(target.length, key);\n\t\t\ttarget.splice(key, 1, val);\n\t\t\treturn val;\n\t\t}\n\t\tif (hasOwn(target, key)) {\n\t\t\ttarget[key] = val;\n\t\t\treturn val;\n\t\t}\n\t\tvar ob = target.__ob__;\n\t\tif (target._isVue || ob && ob.vmCount) {\n\t\t\t\"development\" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n\t\t\treturn val;\n\t\t}\n\t\tif (!ob) {\n\t\t\ttarget[key] = val;\n\t\t\treturn val;\n\t\t}\n\t\tdefineReactive$$1(ob.value, key, val);\n\t\tob.dep.notify();\n\t\treturn val;\n\t}\n\n\t/**\n  * Delete a property and trigger change if necessary.\n  */\n\tfunction del(target, key) {\n\t\tif (Array.isArray(target) && typeof key === 'number') {\n\t\t\ttarget.splice(key, 1);\n\t\t\treturn;\n\t\t}\n\t\tvar ob = target.__ob__;\n\t\tif (target._isVue || ob && ob.vmCount) {\n\t\t\t\"development\" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n\t\t\treturn;\n\t\t}\n\t\tif (!hasOwn(target, key)) {\n\t\t\treturn;\n\t\t}\n\t\tdelete target[key];\n\t\tif (!ob) {\n\t\t\treturn;\n\t\t}\n\t\tob.dep.notify();\n\t}\n\n\t/**\n  * Collect dependencies on array elements when the array is touched, since\n  * we cannot intercept array element access like property getters.\n  */\n\tfunction dependArray(value) {\n\t\tfor (var e = void 0, i = 0, l = value.length; i < l; i++) {\n\t\t\te = value[i];\n\t\t\te && e.__ob__ && e.__ob__.dep.depend();\n\t\t\tif (Array.isArray(e)) {\n\t\t\t\tdependArray(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\t/**\n  * Option overwriting strategies are functions that handle\n  * how to merge a parent option value and a child option\n  * value into the final value.\n  */\n\tvar strats = config.optionMergeStrategies;\n\n\t/**\n  * Options with restrictions\n  */\n\t{\n\t\tstrats.el = strats.propsData = function (parent, child, vm, key) {\n\t\t\tif (!vm) {\n\t\t\t\twarn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n\t\t\t}\n\t\t\treturn defaultStrat(parent, child);\n\t\t};\n\t}\n\n\t/**\n  * Helper that recursively merges two data objects together.\n  */\n\tfunction mergeData(to, from) {\n\t\tif (!from) {\n\t\t\treturn to;\n\t\t}\n\t\tvar key, toVal, fromVal;\n\t\tvar keys = Object.keys(from);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tkey = keys[i];\n\t\t\ttoVal = to[key];\n\t\t\tfromVal = from[key];\n\t\t\tif (!hasOwn(to, key)) {\n\t\t\t\tset(to, key, fromVal);\n\t\t\t} else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n\t\t\t\tmergeData(toVal, fromVal);\n\t\t\t}\n\t\t}\n\t\treturn to;\n\t}\n\n\t/**\n  * Data\n  */\n\tstrats.data = function (parentVal, childVal, vm) {\n\t\tif (!vm) {\n\t\t\t// in a Vue.extend merge, both should be functions\n\t\t\tif (!childVal) {\n\t\t\t\treturn parentVal;\n\t\t\t}\n\t\t\tif (typeof childVal !== 'function') {\n\t\t\t\t\"development\" !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\t\t\t\treturn parentVal;\n\t\t\t}\n\t\t\tif (!parentVal) {\n\t\t\t\treturn childVal;\n\t\t\t}\n\t\t\t// when parentVal & childVal are both present,\n\t\t\t// we need to return a function that returns the\n\t\t\t// merged result of both functions... no need to\n\t\t\t// check if parentVal is a function here because\n\t\t\t// it has to be a function to pass previous merges.\n\t\t\treturn function mergedDataFn() {\n\t\t\t\treturn mergeData(childVal.call(this), parentVal.call(this));\n\t\t\t};\n\t\t} else if (parentVal || childVal) {\n\t\t\treturn function mergedInstanceDataFn() {\n\t\t\t\t// instance merge\n\t\t\t\tvar instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n\t\t\t\tvar defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n\t\t\t\tif (instanceData) {\n\t\t\t\t\treturn mergeData(instanceData, defaultData);\n\t\t\t\t} else {\n\t\t\t\t\treturn defaultData;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n  * Hooks and props are merged as arrays.\n  */\n\tfunction mergeHook(parentVal, childVal) {\n\t\treturn childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n\t}\n\n\tLIFECYCLE_HOOKS.forEach(function (hook) {\n\t\tstrats[hook] = mergeHook;\n\t});\n\n\t/**\n  * Assets\n  *\n  * When a vm is present (instance creation), we need to do\n  * a three-way merge between constructor options, instance\n  * options and parent options.\n  */\n\tfunction mergeAssets(parentVal, childVal) {\n\t\tvar res = Object.create(parentVal || null);\n\t\treturn childVal ? extend(res, childVal) : res;\n\t}\n\n\tASSET_TYPES.forEach(function (type) {\n\t\tstrats[type + 's'] = mergeAssets;\n\t});\n\n\t/**\n  * Watchers.\n  *\n  * Watchers hashes should not overwrite one\n  * another, so we merge them as arrays.\n  */\n\tstrats.watch = function (parentVal, childVal) {\n\t\t/* istanbul ignore if */\n\t\tif (!childVal) {\n\t\t\treturn Object.create(parentVal || null);\n\t\t}\n\t\tif (!parentVal) {\n\t\t\treturn childVal;\n\t\t}\n\t\tvar ret = {};\n\t\textend(ret, parentVal);\n\t\tfor (var key in childVal) {\n\t\t\tvar parent = ret[key];\n\t\t\tvar child = childVal[key];\n\t\t\tif (parent && !Array.isArray(parent)) {\n\t\t\t\tparent = [parent];\n\t\t\t}\n\t\t\tret[key] = parent ? parent.concat(child) : [child];\n\t\t}\n\t\treturn ret;\n\t};\n\n\t/**\n  * Other object hashes.\n  */\n\tstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n\t\tif (!childVal) {\n\t\t\treturn Object.create(parentVal || null);\n\t\t}\n\t\tif (!parentVal) {\n\t\t\treturn childVal;\n\t\t}\n\t\tvar ret = Object.create(null);\n\t\textend(ret, parentVal);\n\t\textend(ret, childVal);\n\t\treturn ret;\n\t};\n\n\t/**\n  * Default strategy.\n  */\n\tvar defaultStrat = function defaultStrat(parentVal, childVal) {\n\t\treturn childVal === undefined ? parentVal : childVal;\n\t};\n\n\t/**\n  * Validate component names\n  */\n\tfunction checkComponents(options) {\n\t\tfor (var key in options.components) {\n\t\t\tvar lower = key.toLowerCase();\n\t\t\tif (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n\t\t\t\twarn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Ensure all props option syntax are normalized into the\n  * Object-based format.\n  */\n\tfunction normalizeProps(options) {\n\t\tvar props = options.props;\n\t\tif (!props) {\n\t\t\treturn;\n\t\t}\n\t\tvar res = {};\n\t\tvar i, val, name;\n\t\tif (Array.isArray(props)) {\n\t\t\ti = props.length;\n\t\t\twhile (i--) {\n\t\t\t\tval = props[i];\n\t\t\t\tif (typeof val === 'string') {\n\t\t\t\t\tname = camelize(val);\n\t\t\t\t\tres[name] = { type: null };\n\t\t\t\t} else {\n\t\t\t\t\twarn('props must be strings when using array syntax.');\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPlainObject(props)) {\n\t\t\tfor (var key in props) {\n\t\t\t\tval = props[key];\n\t\t\t\tname = camelize(key);\n\t\t\t\tres[name] = isPlainObject(val) ? val : { type: val };\n\t\t\t}\n\t\t}\n\t\toptions.props = res;\n\t}\n\n\t/**\n  * Normalize raw function directives into object format.\n  */\n\tfunction normalizeDirectives(options) {\n\t\tvar dirs = options.directives;\n\t\tif (dirs) {\n\t\t\tfor (var key in dirs) {\n\t\t\t\tvar def = dirs[key];\n\t\t\t\tif (typeof def === 'function') {\n\t\t\t\t\tdirs[key] = { bind: def, update: def };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Merge two option objects into a new one.\n  * Core utility used in both instantiation and inheritance.\n  */\n\tfunction mergeOptions(parent, child, vm) {\n\t\t{\n\t\t\tcheckComponents(child);\n\t\t}\n\n\t\tif (typeof child === 'function') {\n\t\t\tchild = child.options;\n\t\t}\n\n\t\tnormalizeProps(child);\n\t\tnormalizeDirectives(child);\n\t\tvar extendsFrom = child.extends;\n\t\tif (extendsFrom) {\n\t\t\tparent = mergeOptions(parent, extendsFrom, vm);\n\t\t}\n\t\tif (child.mixins) {\n\t\t\tfor (var i = 0, l = child.mixins.length; i < l; i++) {\n\t\t\t\tparent = mergeOptions(parent, child.mixins[i], vm);\n\t\t\t}\n\t\t}\n\t\tvar options = {};\n\t\tvar key;\n\t\tfor (key in parent) {\n\t\t\tmergeField(key);\n\t\t}\n\t\tfor (key in child) {\n\t\t\tif (!hasOwn(parent, key)) {\n\t\t\t\tmergeField(key);\n\t\t\t}\n\t\t}\n\t\tfunction mergeField(key) {\n\t\t\tvar strat = strats[key] || defaultStrat;\n\t\t\toptions[key] = strat(parent[key], child[key], vm, key);\n\t\t}\n\t\treturn options;\n\t}\n\n\t/**\n  * Resolve an asset.\n  * This function is used because child instances need access\n  * to assets defined in its ancestor chain.\n  */\n\tfunction resolveAsset(options, type, id, warnMissing) {\n\t\t/* istanbul ignore if */\n\t\tif (typeof id !== 'string') {\n\t\t\treturn;\n\t\t}\n\t\tvar assets = options[type];\n\t\t// check local registration variations first\n\t\tif (hasOwn(assets, id)) {\n\t\t\treturn assets[id];\n\t\t}\n\t\tvar camelizedId = camelize(id);\n\t\tif (hasOwn(assets, camelizedId)) {\n\t\t\treturn assets[camelizedId];\n\t\t}\n\t\tvar PascalCaseId = capitalize(camelizedId);\n\t\tif (hasOwn(assets, PascalCaseId)) {\n\t\t\treturn assets[PascalCaseId];\n\t\t}\n\t\t// fallback to prototype chain\n\t\tvar res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\t\tif (\"development\" !== 'production' && warnMissing && !res) {\n\t\t\twarn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n\t\t}\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tfunction validateProp(key, propOptions, propsData, vm) {\n\t\tvar prop = propOptions[key];\n\t\tvar absent = !hasOwn(propsData, key);\n\t\tvar value = propsData[key];\n\t\t// handle boolean props\n\t\tif (isType(Boolean, prop.type)) {\n\t\t\tif (absent && !hasOwn(prop, 'default')) {\n\t\t\t\tvalue = false;\n\t\t\t} else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n\t\t\t\tvalue = true;\n\t\t\t}\n\t\t}\n\t\t// check default value\n\t\tif (value === undefined) {\n\t\t\tvalue = getPropDefaultValue(vm, prop, key);\n\t\t\t// since the default value is a fresh copy,\n\t\t\t// make sure to observe it.\n\t\t\tvar prevShouldConvert = observerState.shouldConvert;\n\t\t\tobserverState.shouldConvert = true;\n\t\t\tobserve(value);\n\t\t\tobserverState.shouldConvert = prevShouldConvert;\n\t\t}\n\t\t{\n\t\t\tassertProp(prop, key, value, vm, absent);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n  * Get the default value of a prop.\n  */\n\tfunction getPropDefaultValue(vm, prop, key) {\n\t\t// no default, return undefined\n\t\tif (!hasOwn(prop, 'default')) {\n\t\t\treturn undefined;\n\t\t}\n\t\tvar def = prop.default;\n\t\t// warn against non-factory defaults for Object & Array\n\t\tif (\"development\" !== 'production' && isObject(def)) {\n\t\t\twarn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n\t\t}\n\t\t// the raw prop value was also undefined from previous render,\n\t\t// return previous default value to avoid unnecessary watcher trigger\n\t\tif (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n\t\t\treturn vm._props[key];\n\t\t}\n\t\t// call factory function for non-Function types\n\t\t// a value is Function if its prototype is function even across different execution context\n\t\treturn typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n\t}\n\n\t/**\n  * Assert whether a prop is valid.\n  */\n\tfunction assertProp(prop, name, value, vm, absent) {\n\t\tif (prop.required && absent) {\n\t\t\twarn('Missing required prop: \"' + name + '\"', vm);\n\t\t\treturn;\n\t\t}\n\t\tif (value == null && !prop.required) {\n\t\t\treturn;\n\t\t}\n\t\tvar type = prop.type;\n\t\tvar valid = !type || type === true;\n\t\tvar expectedTypes = [];\n\t\tif (type) {\n\t\t\tif (!Array.isArray(type)) {\n\t\t\t\ttype = [type];\n\t\t\t}\n\t\t\tfor (var i = 0; i < type.length && !valid; i++) {\n\t\t\t\tvar assertedType = assertType(value, type[i]);\n\t\t\t\texpectedTypes.push(assertedType.expectedType || '');\n\t\t\t\tvalid = assertedType.valid;\n\t\t\t}\n\t\t}\n\t\tif (!valid) {\n\t\t\twarn('Invalid prop: type check failed for prop \"' + name + '\".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);\n\t\t\treturn;\n\t\t}\n\t\tvar validator = prop.validator;\n\t\tif (validator) {\n\t\t\tif (!validator(value)) {\n\t\t\t\twarn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n\tfunction assertType(value, type) {\n\t\tvar valid;\n\t\tvar expectedType = getType(type);\n\t\tif (simpleCheckRE.test(expectedType)) {\n\t\t\tvalid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();\n\t\t} else if (expectedType === 'Object') {\n\t\t\tvalid = isPlainObject(value);\n\t\t} else if (expectedType === 'Array') {\n\t\t\tvalid = Array.isArray(value);\n\t\t} else {\n\t\t\tvalid = value instanceof type;\n\t\t}\n\t\treturn {\n\t\t\tvalid: valid,\n\t\t\texpectedType: expectedType\n\t\t};\n\t}\n\n\t/**\n  * Use function string name to check built-in types,\n  * because a simple equality check will fail when running\n  * across different vms / iframes.\n  */\n\tfunction getType(fn) {\n\t\tvar match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n\t\treturn match ? match[1] : '';\n\t}\n\n\tfunction isType(type, fn) {\n\t\tif (!Array.isArray(fn)) {\n\t\t\treturn getType(fn) === getType(type);\n\t\t}\n\t\tfor (var i = 0, len = fn.length; i < len; i++) {\n\t\t\tif (getType(fn[i]) === getType(type)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn false;\n\t}\n\n\t/*  */\n\n\tvar mark;\n\tvar measure;\n\n\t{\n\t\tvar perf = inBrowser && window.performance;\n\t\t/* istanbul ignore if */\n\t\tif (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n\t\t\tmark = function mark(tag) {\n\t\t\t\treturn perf.mark(tag);\n\t\t\t};\n\t\t\tmeasure = function measure(name, startTag, endTag) {\n\t\t\t\tperf.measure(name, startTag, endTag);\n\t\t\t\tperf.clearMarks(startTag);\n\t\t\t\tperf.clearMarks(endTag);\n\t\t\t\tperf.clearMeasures(name);\n\t\t\t};\n\t\t}\n\t}\n\n\t/* not type checking this file because flow doesn't play well with Proxy */\n\n\tvar initProxy;\n\n\t{\n\t\tvar allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n\t\t);\n\n\t\tvar warnNonPresent = function warnNonPresent(target, key) {\n\t\t\twarn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + \"referenced during render. Make sure to declare reactive data \" + \"properties in the data option.\", target);\n\t\t};\n\n\t\tvar hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);\n\n\t\tif (hasProxy) {\n\t\t\tvar isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n\t\t\tconfig.keyCodes = new Proxy(config.keyCodes, {\n\t\t\t\tset: function set(target, key, value) {\n\t\t\t\t\tif (isBuiltInModifier(key)) {\n\t\t\t\t\t\twarn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[key] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar hasHandler = {\n\t\t\thas: function has(target, key) {\n\t\t\t\tvar has = key in target;\n\t\t\t\tvar isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n\t\t\t\tif (!has && !isAllowed) {\n\t\t\t\t\twarnNonPresent(target, key);\n\t\t\t\t}\n\t\t\t\treturn has || !isAllowed;\n\t\t\t}\n\t\t};\n\n\t\tvar getHandler = {\n\t\t\tget: function get(target, key) {\n\t\t\t\tif (typeof key === 'string' && !(key in target)) {\n\t\t\t\t\twarnNonPresent(target, key);\n\t\t\t\t}\n\t\t\t\treturn target[key];\n\t\t\t}\n\t\t};\n\n\t\tinitProxy = function initProxy(vm) {\n\t\t\tif (hasProxy) {\n\t\t\t\t// determine which proxy handler to use\n\t\t\t\tvar options = vm.$options;\n\t\t\t\tvar handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n\t\t\t\tvm._renderProxy = new Proxy(vm, handlers);\n\t\t\t} else {\n\t\t\t\tvm._renderProxy = vm;\n\t\t\t}\n\t\t};\n\t}\n\n\t/*  */\n\n\tvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {\n\t\tthis.tag = tag;\n\t\tthis.data = data;\n\t\tthis.children = children;\n\t\tthis.text = text;\n\t\tthis.elm = elm;\n\t\tthis.ns = undefined;\n\t\tthis.context = context;\n\t\tthis.functionalContext = undefined;\n\t\tthis.key = data && data.key;\n\t\tthis.componentOptions = componentOptions;\n\t\tthis.componentInstance = undefined;\n\t\tthis.parent = undefined;\n\t\tthis.raw = false;\n\t\tthis.isStatic = false;\n\t\tthis.isRootInsert = true;\n\t\tthis.isComment = false;\n\t\tthis.isCloned = false;\n\t\tthis.isOnce = false;\n\t};\n\n\tvar prototypeAccessors = { child: {} };\n\n\t// DEPRECATED: alias for componentInstance for backwards compat.\n\t/* istanbul ignore next */\n\tprototypeAccessors.child.get = function () {\n\t\treturn this.componentInstance;\n\t};\n\n\tObject.defineProperties(VNode.prototype, prototypeAccessors);\n\n\tvar createEmptyVNode = function createEmptyVNode() {\n\t\tvar node = new VNode();\n\t\tnode.text = '';\n\t\tnode.isComment = true;\n\t\treturn node;\n\t};\n\n\tfunction createTextVNode(val) {\n\t\treturn new VNode(undefined, undefined, undefined, String(val));\n\t}\n\n\t// optimized shallow clone\n\t// used for static nodes and slot nodes because they may be reused across\n\t// multiple renders, cloning them avoids errors when DOM manipulations rely\n\t// on their elm reference.\n\tfunction cloneVNode(vnode) {\n\t\tvar cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);\n\t\tcloned.ns = vnode.ns;\n\t\tcloned.isStatic = vnode.isStatic;\n\t\tcloned.key = vnode.key;\n\t\tcloned.isComment = vnode.isComment;\n\t\tcloned.isCloned = true;\n\t\treturn cloned;\n\t}\n\n\tfunction cloneVNodes(vnodes) {\n\t\tvar len = vnodes.length;\n\t\tvar res = new Array(len);\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tres[i] = cloneVNode(vnodes[i]);\n\t\t}\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tvar normalizeEvent = cached(function (name) {\n\t\tvar passive = name.charAt(0) === '&';\n\t\tname = passive ? name.slice(1) : name;\n\t\tvar once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\t\tname = once$$1 ? name.slice(1) : name;\n\t\tvar capture = name.charAt(0) === '!';\n\t\tname = capture ? name.slice(1) : name;\n\t\treturn {\n\t\t\tname: name,\n\t\t\tonce: once$$1,\n\t\t\tcapture: capture,\n\t\t\tpassive: passive\n\t\t};\n\t});\n\n\tfunction createFnInvoker(fns) {\n\t\tfunction invoker() {\n\t\t\tvar arguments$1 = arguments;\n\n\t\t\tvar fns = invoker.fns;\n\t\t\tif (Array.isArray(fns)) {\n\t\t\t\tfor (var i = 0; i < fns.length; i++) {\n\t\t\t\t\tfns[i].apply(null, arguments$1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// return handler return value for single handlers\n\t\t\t\treturn fns.apply(null, arguments);\n\t\t\t}\n\t\t}\n\t\tinvoker.fns = fns;\n\t\treturn invoker;\n\t}\n\n\tfunction updateListeners(on, oldOn, add, remove$$1, vm) {\n\t\tvar name, cur, old, event;\n\t\tfor (name in on) {\n\t\t\tcur = on[name];\n\t\t\told = oldOn[name];\n\t\t\tevent = normalizeEvent(name);\n\t\t\tif (isUndef(cur)) {\n\t\t\t\t\"development\" !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n\t\t\t} else if (isUndef(old)) {\n\t\t\t\tif (isUndef(cur.fns)) {\n\t\t\t\t\tcur = on[name] = createFnInvoker(cur);\n\t\t\t\t}\n\t\t\t\tadd(event.name, cur, event.once, event.capture, event.passive);\n\t\t\t} else if (cur !== old) {\n\t\t\t\told.fns = cur;\n\t\t\t\ton[name] = old;\n\t\t\t}\n\t\t}\n\t\tfor (name in oldOn) {\n\t\t\tif (isUndef(on[name])) {\n\t\t\t\tevent = normalizeEvent(name);\n\t\t\t\tremove$$1(event.name, oldOn[name], event.capture);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction mergeVNodeHook(def, hookKey, hook) {\n\t\tvar invoker;\n\t\tvar oldHook = def[hookKey];\n\n\t\tfunction wrappedHook() {\n\t\t\thook.apply(this, arguments);\n\t\t\t// important: remove merged hook to ensure it's called only once\n\t\t\t// and prevent memory leak\n\t\t\tremove(invoker.fns, wrappedHook);\n\t\t}\n\n\t\tif (isUndef(oldHook)) {\n\t\t\t// no existing hook\n\t\t\tinvoker = createFnInvoker([wrappedHook]);\n\t\t} else {\n\t\t\t/* istanbul ignore if */\n\t\t\tif (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n\t\t\t\t// already a merged invoker\n\t\t\t\tinvoker = oldHook;\n\t\t\t\tinvoker.fns.push(wrappedHook);\n\t\t\t} else {\n\t\t\t\t// existing plain hook\n\t\t\t\tinvoker = createFnInvoker([oldHook, wrappedHook]);\n\t\t\t}\n\t\t}\n\n\t\tinvoker.merged = true;\n\t\tdef[hookKey] = invoker;\n\t}\n\n\t/*  */\n\n\tfunction extractPropsFromVNodeData(data, Ctor, tag) {\n\t\t// we are only extracting raw values here.\n\t\t// validation and default values are handled in the child\n\t\t// component itself.\n\t\tvar propOptions = Ctor.options.props;\n\t\tif (isUndef(propOptions)) {\n\t\t\treturn;\n\t\t}\n\t\tvar res = {};\n\t\tvar attrs = data.attrs;\n\t\tvar props = data.props;\n\t\tif (isDef(attrs) || isDef(props)) {\n\t\t\tfor (var key in propOptions) {\n\t\t\t\tvar altKey = hyphenate(key);\n\t\t\t\t{\n\t\t\t\t\tvar keyInLowerCase = key.toLowerCase();\n\t\t\t\t\tif (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n\t\t\t\t\t\ttip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcheckProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction checkProp(res, hash, key, altKey, preserve) {\n\t\tif (isDef(hash)) {\n\t\t\tif (hasOwn(hash, key)) {\n\t\t\t\tres[key] = hash[key];\n\t\t\t\tif (!preserve) {\n\t\t\t\t\tdelete hash[key];\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (hasOwn(hash, altKey)) {\n\t\t\t\tres[key] = hash[altKey];\n\t\t\t\tif (!preserve) {\n\t\t\t\t\tdelete hash[altKey];\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*  */\n\n\t// The template compiler attempts to minimize the need for normalization by\n\t// statically analyzing the template at compile time.\n\t//\n\t// For plain HTML markup, normalization can be completely skipped because the\n\t// generated render function is guaranteed to return Array<VNode>. There are\n\t// two cases where extra normalization is needed:\n\n\t// 1. When the children contains components - because a functional component\n\t// may return an Array instead of a single root. In this case, just a simple\n\t// normalization is needed - if any child is an Array, we flatten the whole\n\t// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n\t// because functional components already normalize their own children.\n\tfunction simpleNormalizeChildren(children) {\n\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\tif (Array.isArray(children[i])) {\n\t\t\t\treturn Array.prototype.concat.apply([], children);\n\t\t\t}\n\t\t}\n\t\treturn children;\n\t}\n\n\t// 2. When the children contains constructs that always generated nested Arrays,\n\t// e.g. <template>, <slot>, v-for, or when the children is provided by user\n\t// with hand-written render functions / JSX. In such cases a full normalization\n\t// is needed to cater to all possible types of children values.\n\tfunction normalizeChildren(children) {\n\t\treturn isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n\t}\n\n\tfunction isTextNode(node) {\n\t\treturn isDef(node) && isDef(node.text) && isFalse(node.isComment);\n\t}\n\n\tfunction normalizeArrayChildren(children, nestedIndex) {\n\t\tvar res = [];\n\t\tvar i, c, last;\n\t\tfor (i = 0; i < children.length; i++) {\n\t\t\tc = children[i];\n\t\t\tif (isUndef(c) || typeof c === 'boolean') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlast = res[res.length - 1];\n\t\t\t//  nested\n\t\t\tif (Array.isArray(c)) {\n\t\t\t\tres.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i));\n\t\t\t} else if (isPrimitive(c)) {\n\t\t\t\tif (isTextNode(last)) {\n\t\t\t\t\t// merge adjacent text nodes\n\t\t\t\t\t// this is necessary for SSR hydration because text nodes are\n\t\t\t\t\t// essentially merged when rendered to HTML strings\n\t\t\t\t\tlast.text += String(c);\n\t\t\t\t} else if (c !== '') {\n\t\t\t\t\t// convert primitive to vnode\n\t\t\t\t\tres.push(createTextVNode(c));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isTextNode(c) && isTextNode(last)) {\n\t\t\t\t\t// merge adjacent text nodes\n\t\t\t\t\tres[res.length - 1] = createTextVNode(last.text + c.text);\n\t\t\t\t} else {\n\t\t\t\t\t// default key for nested array children (likely generated by v-for)\n\t\t\t\t\tif (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n\t\t\t\t\t\tc.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n\t\t\t\t\t}\n\t\t\t\t\tres.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tfunction ensureCtor(comp, base) {\n\t\treturn isObject(comp) ? base.extend(comp) : comp;\n\t}\n\n\tfunction resolveAsyncComponent(factory, baseCtor, context) {\n\t\tif (isTrue(factory.error) && isDef(factory.errorComp)) {\n\t\t\treturn factory.errorComp;\n\t\t}\n\n\t\tif (isDef(factory.resolved)) {\n\t\t\treturn factory.resolved;\n\t\t}\n\n\t\tif (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n\t\t\treturn factory.loadingComp;\n\t\t}\n\n\t\tif (isDef(factory.contexts)) {\n\t\t\t// already pending\n\t\t\tfactory.contexts.push(context);\n\t\t} else {\n\t\t\tvar contexts = factory.contexts = [context];\n\t\t\tvar sync = true;\n\n\t\t\tvar forceRender = function forceRender() {\n\t\t\t\tfor (var i = 0, l = contexts.length; i < l; i++) {\n\t\t\t\t\tcontexts[i].$forceUpdate();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar resolve = once(function (res) {\n\t\t\t\t// cache resolved\n\t\t\t\tfactory.resolved = ensureCtor(res, baseCtor);\n\t\t\t\t// invoke callbacks only if this is not a synchronous resolve\n\t\t\t\t// (async resolves are shimmed as synchronous during SSR)\n\t\t\t\tif (!sync) {\n\t\t\t\t\tforceRender();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar reject = once(function (reason) {\n\t\t\t\t\"development\" !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\t\t\t\tif (isDef(factory.errorComp)) {\n\t\t\t\t\tfactory.error = true;\n\t\t\t\t\tforceRender();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar res = factory(resolve, reject);\n\n\t\t\tif (isObject(res)) {\n\t\t\t\tif (typeof res.then === 'function') {\n\t\t\t\t\t// () => Promise\n\t\t\t\t\tif (isUndef(factory.resolved)) {\n\t\t\t\t\t\tres.then(resolve, reject);\n\t\t\t\t\t}\n\t\t\t\t} else if (isDef(res.component) && typeof res.component.then === 'function') {\n\t\t\t\t\tres.component.then(resolve, reject);\n\n\t\t\t\t\tif (isDef(res.error)) {\n\t\t\t\t\t\tfactory.errorComp = ensureCtor(res.error, baseCtor);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isDef(res.loading)) {\n\t\t\t\t\t\tfactory.loadingComp = ensureCtor(res.loading, baseCtor);\n\t\t\t\t\t\tif (res.delay === 0) {\n\t\t\t\t\t\t\tfactory.loading = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\tif (isUndef(factory.resolved) && isUndef(factory.error)) {\n\t\t\t\t\t\t\t\t\tfactory.loading = true;\n\t\t\t\t\t\t\t\t\tforceRender();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, res.delay || 200);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isDef(res.timeout)) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tif (isUndef(factory.resolved)) {\n\t\t\t\t\t\t\t\treject(\"timeout (\" + res.timeout + \"ms)\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, res.timeout);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsync = false;\n\t\t\t// return in case resolved synchronously\n\t\t\treturn factory.loading ? factory.loadingComp : factory.resolved;\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction getFirstComponentChild(children) {\n\t\tif (Array.isArray(children)) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar c = children[i];\n\t\t\t\tif (isDef(c) && isDef(c.componentOptions)) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\t/*  */\n\n\tfunction initEvents(vm) {\n\t\tvm._events = Object.create(null);\n\t\tvm._hasHookEvent = false;\n\t\t// init parent attached events\n\t\tvar listeners = vm.$options._parentListeners;\n\t\tif (listeners) {\n\t\t\tupdateComponentListeners(vm, listeners);\n\t\t}\n\t}\n\n\tvar target;\n\n\tfunction add(event, fn, once$$1) {\n\t\tif (once$$1) {\n\t\t\ttarget.$once(event, fn);\n\t\t} else {\n\t\t\ttarget.$on(event, fn);\n\t\t}\n\t}\n\n\tfunction remove$1(event, fn) {\n\t\ttarget.$off(event, fn);\n\t}\n\n\tfunction updateComponentListeners(vm, listeners, oldListeners) {\n\t\ttarget = vm;\n\t\tupdateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n\t}\n\n\tfunction eventsMixin(Vue) {\n\t\tvar hookRE = /^hook:/;\n\t\tVue.prototype.$on = function (event, fn) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar vm = this;\n\t\t\tif (Array.isArray(event)) {\n\t\t\t\tfor (var i = 0, l = event.length; i < l; i++) {\n\t\t\t\t\tthis$1.$on(event[i], fn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t(vm._events[event] || (vm._events[event] = [])).push(fn);\n\t\t\t\t// optimize hook:event cost by using a boolean flag marked at registration\n\t\t\t\t// instead of a hash lookup\n\t\t\t\tif (hookRE.test(event)) {\n\t\t\t\t\tvm._hasHookEvent = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vm;\n\t\t};\n\n\t\tVue.prototype.$once = function (event, fn) {\n\t\t\tvar vm = this;\n\t\t\tfunction on() {\n\t\t\t\tvm.$off(event, on);\n\t\t\t\tfn.apply(vm, arguments);\n\t\t\t}\n\t\t\ton.fn = fn;\n\t\t\tvm.$on(event, on);\n\t\t\treturn vm;\n\t\t};\n\n\t\tVue.prototype.$off = function (event, fn) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar vm = this;\n\t\t\t// all\n\t\t\tif (!arguments.length) {\n\t\t\t\tvm._events = Object.create(null);\n\t\t\t\treturn vm;\n\t\t\t}\n\t\t\t// array of events\n\t\t\tif (Array.isArray(event)) {\n\t\t\t\tfor (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n\t\t\t\t\tthis$1.$off(event[i$1], fn);\n\t\t\t\t}\n\t\t\t\treturn vm;\n\t\t\t}\n\t\t\t// specific event\n\t\t\tvar cbs = vm._events[event];\n\t\t\tif (!cbs) {\n\t\t\t\treturn vm;\n\t\t\t}\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tvm._events[event] = null;\n\t\t\t\treturn vm;\n\t\t\t}\n\t\t\t// specific handler\n\t\t\tvar cb;\n\t\t\tvar i = cbs.length;\n\t\t\twhile (i--) {\n\t\t\t\tcb = cbs[i];\n\t\t\t\tif (cb === fn || cb.fn === fn) {\n\t\t\t\t\tcbs.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vm;\n\t\t};\n\n\t\tVue.prototype.$emit = function (event) {\n\t\t\tvar vm = this;\n\t\t\t{\n\t\t\t\tvar lowerCaseEvent = event.toLowerCase();\n\t\t\t\tif (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n\t\t\t\t\ttip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar cbs = vm._events[event];\n\t\t\tif (cbs) {\n\t\t\t\tcbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t\t\t\tvar args = toArray(arguments, 1);\n\t\t\t\tfor (var i = 0, l = cbs.length; i < l; i++) {\n\t\t\t\t\tcbs[i].apply(vm, args);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vm;\n\t\t};\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for resolving raw children VNodes into a slot object.\n  */\n\tfunction resolveSlots(children, context) {\n\t\tvar slots = {};\n\t\tif (!children) {\n\t\t\treturn slots;\n\t\t}\n\t\tvar defaultSlot = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\t// named slots should only be respected if the vnode was rendered in the\n\t\t\t// same context.\n\t\t\tif ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {\n\t\t\t\tvar name = child.data.slot;\n\t\t\t\tvar slot = slots[name] || (slots[name] = []);\n\t\t\t\tif (child.tag === 'template') {\n\t\t\t\t\tslot.push.apply(slot, child.children);\n\t\t\t\t} else {\n\t\t\t\t\tslot.push(child);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdefaultSlot.push(child);\n\t\t\t}\n\t\t}\n\t\t// ignore whitespace\n\t\tif (!defaultSlot.every(isWhitespace)) {\n\t\t\tslots.default = defaultSlot;\n\t\t}\n\t\treturn slots;\n\t}\n\n\tfunction isWhitespace(node) {\n\t\treturn node.isComment || node.text === ' ';\n\t}\n\n\tfunction resolveScopedSlots(fns, // see flow/vnode\n\tres) {\n\t\tres = res || {};\n\t\tfor (var i = 0; i < fns.length; i++) {\n\t\t\tif (Array.isArray(fns[i])) {\n\t\t\t\tresolveScopedSlots(fns[i], res);\n\t\t\t} else {\n\t\t\t\tres[fns[i].key] = fns[i].fn;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tvar activeInstance = null;\n\n\tfunction initLifecycle(vm) {\n\t\tvar options = vm.$options;\n\n\t\t// locate first non-abstract parent\n\t\tvar parent = options.parent;\n\t\tif (parent && !options.abstract) {\n\t\t\twhile (parent.$options.abstract && parent.$parent) {\n\t\t\t\tparent = parent.$parent;\n\t\t\t}\n\t\t\tparent.$children.push(vm);\n\t\t}\n\n\t\tvm.$parent = parent;\n\t\tvm.$root = parent ? parent.$root : vm;\n\n\t\tvm.$children = [];\n\t\tvm.$refs = {};\n\n\t\tvm._watcher = null;\n\t\tvm._inactive = null;\n\t\tvm._directInactive = false;\n\t\tvm._isMounted = false;\n\t\tvm._isDestroyed = false;\n\t\tvm._isBeingDestroyed = false;\n\t}\n\n\tfunction lifecycleMixin(Vue) {\n\t\tVue.prototype._update = function (vnode, hydrating) {\n\t\t\tvar vm = this;\n\t\t\tif (vm._isMounted) {\n\t\t\t\tcallHook(vm, 'beforeUpdate');\n\t\t\t}\n\t\t\tvar prevEl = vm.$el;\n\t\t\tvar prevVnode = vm._vnode;\n\t\t\tvar prevActiveInstance = activeInstance;\n\t\t\tactiveInstance = vm;\n\t\t\tvm._vnode = vnode;\n\t\t\t// Vue.prototype.__patch__ is injected in entry points\n\t\t\t// based on the rendering backend used.\n\t\t\tif (!prevVnode) {\n\t\t\t\t// initial render\n\t\t\t\tvm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */\n\t\t\t\t, vm.$options._parentElm, vm.$options._refElm);\n\t\t\t} else {\n\t\t\t\t// updates\n\t\t\t\tvm.$el = vm.__patch__(prevVnode, vnode);\n\t\t\t}\n\t\t\tactiveInstance = prevActiveInstance;\n\t\t\t// update __vue__ reference\n\t\t\tif (prevEl) {\n\t\t\t\tprevEl.__vue__ = null;\n\t\t\t}\n\t\t\tif (vm.$el) {\n\t\t\t\tvm.$el.__vue__ = vm;\n\t\t\t}\n\t\t\t// if parent is an HOC, update its $el as well\n\t\t\tif (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n\t\t\t\tvm.$parent.$el = vm.$el;\n\t\t\t}\n\t\t\t// updated hook is called by the scheduler to ensure that children are\n\t\t\t// updated in a parent's updated hook.\n\t\t};\n\n\t\tVue.prototype.$forceUpdate = function () {\n\t\t\tvar vm = this;\n\t\t\tif (vm._watcher) {\n\t\t\t\tvm._watcher.update();\n\t\t\t}\n\t\t};\n\n\t\tVue.prototype.$destroy = function () {\n\t\t\tvar vm = this;\n\t\t\tif (vm._isBeingDestroyed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcallHook(vm, 'beforeDestroy');\n\t\t\tvm._isBeingDestroyed = true;\n\t\t\t// remove self from parent\n\t\t\tvar parent = vm.$parent;\n\t\t\tif (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n\t\t\t\tremove(parent.$children, vm);\n\t\t\t}\n\t\t\t// teardown watchers\n\t\t\tif (vm._watcher) {\n\t\t\t\tvm._watcher.teardown();\n\t\t\t}\n\t\t\tvar i = vm._watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tvm._watchers[i].teardown();\n\t\t\t}\n\t\t\t// remove reference from data ob\n\t\t\t// frozen object may not have observer.\n\t\t\tif (vm._data.__ob__) {\n\t\t\t\tvm._data.__ob__.vmCount--;\n\t\t\t}\n\t\t\t// call the last hook...\n\t\t\tvm._isDestroyed = true;\n\t\t\t// invoke destroy hooks on current rendered tree\n\t\t\tvm.__patch__(vm._vnode, null);\n\t\t\t// fire destroyed hook\n\t\t\tcallHook(vm, 'destroyed');\n\t\t\t// turn off all instance listeners.\n\t\t\tvm.$off();\n\t\t\t// remove __vue__ reference\n\t\t\tif (vm.$el) {\n\t\t\t\tvm.$el.__vue__ = null;\n\t\t\t}\n\t\t\t// remove reference to DOM nodes (prevents leak)\n\t\t\tvm.$options._parentElm = vm.$options._refElm = null;\n\t\t};\n\t}\n\n\tfunction mountComponent(vm, el, hydrating) {\n\t\tvm.$el = el;\n\t\tif (!vm.$options.render) {\n\t\t\tvm.$options.render = createEmptyVNode;\n\t\t\t{\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n\t\t\t\t\twarn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n\t\t\t\t} else {\n\t\t\t\t\twarn('Failed to mount component: template or render function not defined.', vm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallHook(vm, 'beforeMount');\n\n\t\tvar updateComponent;\n\t\t/* istanbul ignore if */\n\t\tif (\"development\" !== 'production' && config.performance && mark) {\n\t\t\tupdateComponent = function updateComponent() {\n\t\t\t\tvar name = vm._name;\n\t\t\t\tvar id = vm._uid;\n\t\t\t\tvar startTag = \"vue-perf-start:\" + id;\n\t\t\t\tvar endTag = \"vue-perf-end:\" + id;\n\n\t\t\t\tmark(startTag);\n\t\t\t\tvar vnode = vm._render();\n\t\t\t\tmark(endTag);\n\t\t\t\tmeasure(name + \" render\", startTag, endTag);\n\n\t\t\t\tmark(startTag);\n\t\t\t\tvm._update(vnode, hydrating);\n\t\t\t\tmark(endTag);\n\t\t\t\tmeasure(name + \" patch\", startTag, endTag);\n\t\t\t};\n\t\t} else {\n\t\t\tupdateComponent = function updateComponent() {\n\t\t\t\tvm._update(vm._render(), hydrating);\n\t\t\t};\n\t\t}\n\n\t\tvm._watcher = new Watcher(vm, updateComponent, noop);\n\t\thydrating = false;\n\n\t\t// manually mounted instance, call mounted on self\n\t\t// mounted is called for render-created child components in its inserted hook\n\t\tif (vm.$vnode == null) {\n\t\t\tvm._isMounted = true;\n\t\t\tcallHook(vm, 'mounted');\n\t\t}\n\t\treturn vm;\n\t}\n\n\tfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n\t\t// determine whether component has slot children\n\t\t// we need to do this before overwriting $options._renderChildren\n\t\tvar hasChildren = !!(renderChildren || // has new static slots\n\t\tvm.$options._renderChildren || // has old static slots\n\t\tparentVnode.data.scopedSlots || // has new scoped slots\n\t\tvm.$scopedSlots !== emptyObject // has old scoped slots\n\t\t);\n\n\t\tvm.$options._parentVnode = parentVnode;\n\t\tvm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\t\tif (vm._vnode) {\n\t\t\t// update child tree's parent\n\t\t\tvm._vnode.parent = parentVnode;\n\t\t}\n\t\tvm.$options._renderChildren = renderChildren;\n\n\t\t// update props\n\t\tif (propsData && vm.$options.props) {\n\t\t\tobserverState.shouldConvert = false;\n\t\t\t{\n\t\t\t\tobserverState.isSettingProps = true;\n\t\t\t}\n\t\t\tvar props = vm._props;\n\t\t\tvar propKeys = vm.$options._propKeys || [];\n\t\t\tfor (var i = 0; i < propKeys.length; i++) {\n\t\t\t\tvar key = propKeys[i];\n\t\t\t\tprops[key] = validateProp(key, vm.$options.props, propsData, vm);\n\t\t\t}\n\t\t\tobserverState.shouldConvert = true;\n\t\t\t{\n\t\t\t\tobserverState.isSettingProps = false;\n\t\t\t}\n\t\t\t// keep a copy of raw propsData\n\t\t\tvm.$options.propsData = propsData;\n\t\t}\n\t\t// update listeners\n\t\tif (listeners) {\n\t\t\tvar oldListeners = vm.$options._parentListeners;\n\t\t\tvm.$options._parentListeners = listeners;\n\t\t\tupdateComponentListeners(vm, listeners, oldListeners);\n\t\t}\n\t\t// resolve slots + force update if has children\n\t\tif (hasChildren) {\n\t\t\tvm.$slots = resolveSlots(renderChildren, parentVnode.context);\n\t\t\tvm.$forceUpdate();\n\t\t}\n\t}\n\n\tfunction isInInactiveTree(vm) {\n\t\twhile (vm && (vm = vm.$parent)) {\n\t\t\tif (vm._inactive) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction activateChildComponent(vm, direct) {\n\t\tif (direct) {\n\t\t\tvm._directInactive = false;\n\t\t\tif (isInInactiveTree(vm)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (vm._directInactive) {\n\t\t\treturn;\n\t\t}\n\t\tif (vm._inactive || vm._inactive === null) {\n\t\t\tvm._inactive = false;\n\t\t\tfor (var i = 0; i < vm.$children.length; i++) {\n\t\t\t\tactivateChildComponent(vm.$children[i]);\n\t\t\t}\n\t\t\tcallHook(vm, 'activated');\n\t\t}\n\t}\n\n\tfunction deactivateChildComponent(vm, direct) {\n\t\tif (direct) {\n\t\t\tvm._directInactive = true;\n\t\t\tif (isInInactiveTree(vm)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!vm._inactive) {\n\t\t\tvm._inactive = true;\n\t\t\tfor (var i = 0; i < vm.$children.length; i++) {\n\t\t\t\tdeactivateChildComponent(vm.$children[i]);\n\t\t\t}\n\t\t\tcallHook(vm, 'deactivated');\n\t\t}\n\t}\n\n\tfunction callHook(vm, hook) {\n\t\tvar handlers = vm.$options[hook];\n\t\tif (handlers) {\n\t\t\tfor (var i = 0, j = handlers.length; i < j; i++) {\n\t\t\t\ttry {\n\t\t\t\t\thandlers[i].call(vm);\n\t\t\t\t} catch (e) {\n\t\t\t\t\thandleError(e, vm, hook + \" hook\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (vm._hasHookEvent) {\n\t\t\tvm.$emit('hook:' + hook);\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar MAX_UPDATE_COUNT = 100;\n\n\tvar queue = [];\n\tvar activatedChildren = [];\n\tvar has = {};\n\tvar circular = {};\n\tvar waiting = false;\n\tvar flushing = false;\n\tvar index = 0;\n\n\t/**\n  * Reset the scheduler's state.\n  */\n\tfunction resetSchedulerState() {\n\t\tindex = queue.length = activatedChildren.length = 0;\n\t\thas = {};\n\t\t{\n\t\t\tcircular = {};\n\t\t}\n\t\twaiting = flushing = false;\n\t}\n\n\t/**\n  * Flush both queues and run the watchers.\n  */\n\tfunction flushSchedulerQueue() {\n\t\tflushing = true;\n\t\tvar watcher, id;\n\n\t\t// Sort queue before flush.\n\t\t// This ensures that:\n\t\t// 1. Components are updated from parent to child. (because parent is always\n\t\t//    created before the child)\n\t\t// 2. A component's user watchers are run before its render watcher (because\n\t\t//    user watchers are created before the render watcher)\n\t\t// 3. If a component is destroyed during a parent component's watcher run,\n\t\t//    its watchers can be skipped.\n\t\tqueue.sort(function (a, b) {\n\t\t\treturn a.id - b.id;\n\t\t});\n\n\t\t// do not cache length because more watchers might be pushed\n\t\t// as we run existing watchers\n\t\tfor (index = 0; index < queue.length; index++) {\n\t\t\twatcher = queue[index];\n\t\t\tid = watcher.id;\n\t\t\thas[id] = null;\n\t\t\twatcher.run();\n\t\t\t// in dev build, check and stop circular updates.\n\t\t\tif (\"development\" !== 'production' && has[id] != null) {\n\t\t\t\tcircular[id] = (circular[id] || 0) + 1;\n\t\t\t\tif (circular[id] > MAX_UPDATE_COUNT) {\n\t\t\t\t\twarn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// keep copies of post queues before resetting state\n\t\tvar activatedQueue = activatedChildren.slice();\n\t\tvar updatedQueue = queue.slice();\n\n\t\tresetSchedulerState();\n\n\t\t// call component updated and activated hooks\n\t\tcallActivatedHooks(activatedQueue);\n\t\tcallUpdateHooks(updatedQueue);\n\n\t\t// devtool hook\n\t\t/* istanbul ignore if */\n\t\tif (devtools && config.devtools) {\n\t\t\tdevtools.emit('flush');\n\t\t}\n\t}\n\n\tfunction callUpdateHooks(queue) {\n\t\tvar i = queue.length;\n\t\twhile (i--) {\n\t\t\tvar watcher = queue[i];\n\t\t\tvar vm = watcher.vm;\n\t\t\tif (vm._watcher === watcher && vm._isMounted) {\n\t\t\t\tcallHook(vm, 'updated');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Queue a kept-alive component that was activated during patch.\n  * The queue will be processed after the entire tree has been patched.\n  */\n\tfunction queueActivatedComponent(vm) {\n\t\t// setting _inactive to false here so that a render function can\n\t\t// rely on checking whether it's in an inactive tree (e.g. router-view)\n\t\tvm._inactive = false;\n\t\tactivatedChildren.push(vm);\n\t}\n\n\tfunction callActivatedHooks(queue) {\n\t\tfor (var i = 0; i < queue.length; i++) {\n\t\t\tqueue[i]._inactive = true;\n\t\t\tactivateChildComponent(queue[i], true /* true */);\n\t\t}\n\t}\n\n\t/**\n  * Push a watcher into the watcher queue.\n  * Jobs with duplicate IDs will be skipped unless it's\n  * pushed when the queue is being flushed.\n  */\n\tfunction queueWatcher(watcher) {\n\t\tvar id = watcher.id;\n\t\tif (has[id] == null) {\n\t\t\thas[id] = true;\n\t\t\tif (!flushing) {\n\t\t\t\tqueue.push(watcher);\n\t\t\t} else {\n\t\t\t\t// if already flushing, splice the watcher based on its id\n\t\t\t\t// if already past its id, it will be run next immediately.\n\t\t\t\tvar i = queue.length - 1;\n\t\t\t\twhile (i > index && queue[i].id > watcher.id) {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tqueue.splice(i + 1, 0, watcher);\n\t\t\t}\n\t\t\t// queue the flush\n\t\t\tif (!waiting) {\n\t\t\t\twaiting = true;\n\t\t\t\tnextTick(flushSchedulerQueue);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar uid$2 = 0;\n\n\t/**\n  * A watcher parses an expression, collects dependencies,\n  * and fires callback when the expression value changes.\n  * This is used for both the $watch() api and directives.\n  */\n\tvar Watcher = function Watcher(vm, expOrFn, cb, options) {\n\t\tthis.vm = vm;\n\t\tvm._watchers.push(this);\n\t\t// options\n\t\tif (options) {\n\t\t\tthis.deep = !!options.deep;\n\t\t\tthis.user = !!options.user;\n\t\t\tthis.lazy = !!options.lazy;\n\t\t\tthis.sync = !!options.sync;\n\t\t} else {\n\t\t\tthis.deep = this.user = this.lazy = this.sync = false;\n\t\t}\n\t\tthis.cb = cb;\n\t\tthis.id = ++uid$2; // uid for batching\n\t\tthis.active = true;\n\t\tthis.dirty = this.lazy; // for lazy watchers\n\t\tthis.deps = [];\n\t\tthis.newDeps = [];\n\t\tthis.depIds = new _Set();\n\t\tthis.newDepIds = new _Set();\n\t\tthis.expression = expOrFn.toString();\n\t\t// parse expression for getter\n\t\tif (typeof expOrFn === 'function') {\n\t\t\tthis.getter = expOrFn;\n\t\t} else {\n\t\t\tthis.getter = parsePath(expOrFn);\n\t\t\tif (!this.getter) {\n\t\t\t\tthis.getter = function () {};\n\t\t\t\t\"development\" !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n\t\t\t}\n\t\t}\n\t\tthis.value = this.lazy ? undefined : this.get();\n\t};\n\n\t/**\n  * Evaluate the getter, and re-collect dependencies.\n  */\n\tWatcher.prototype.get = function get() {\n\t\tpushTarget(this);\n\t\tvar value;\n\t\tvar vm = this.vm;\n\t\tif (this.user) {\n\t\t\ttry {\n\t\t\t\tvalue = this.getter.call(vm, vm);\n\t\t\t} catch (e) {\n\t\t\t\thandleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = this.getter.call(vm, vm);\n\t\t}\n\t\t// \"touch\" every property so they are all tracked as\n\t\t// dependencies for deep watching\n\t\tif (this.deep) {\n\t\t\ttraverse(value);\n\t\t}\n\t\tpopTarget();\n\t\tthis.cleanupDeps();\n\t\treturn value;\n\t};\n\n\t/**\n  * Add a dependency to this directive.\n  */\n\tWatcher.prototype.addDep = function addDep(dep) {\n\t\tvar id = dep.id;\n\t\tif (!this.newDepIds.has(id)) {\n\t\t\tthis.newDepIds.add(id);\n\t\t\tthis.newDeps.push(dep);\n\t\t\tif (!this.depIds.has(id)) {\n\t\t\t\tdep.addSub(this);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Clean up for dependency collection.\n  */\n\tWatcher.prototype.cleanupDeps = function cleanupDeps() {\n\t\tvar this$1 = this;\n\n\t\tvar i = this.deps.length;\n\t\twhile (i--) {\n\t\t\tvar dep = this$1.deps[i];\n\t\t\tif (!this$1.newDepIds.has(dep.id)) {\n\t\t\t\tdep.removeSub(this$1);\n\t\t\t}\n\t\t}\n\t\tvar tmp = this.depIds;\n\t\tthis.depIds = this.newDepIds;\n\t\tthis.newDepIds = tmp;\n\t\tthis.newDepIds.clear();\n\t\ttmp = this.deps;\n\t\tthis.deps = this.newDeps;\n\t\tthis.newDeps = tmp;\n\t\tthis.newDeps.length = 0;\n\t};\n\n\t/**\n  * Subscriber interface.\n  * Will be called when a dependency changes.\n  */\n\tWatcher.prototype.update = function update() {\n\t\t/* istanbul ignore else */\n\t\tif (this.lazy) {\n\t\t\tthis.dirty = true;\n\t\t} else if (this.sync) {\n\t\t\tthis.run();\n\t\t} else {\n\t\t\tqueueWatcher(this);\n\t\t}\n\t};\n\n\t/**\n  * Scheduler job interface.\n  * Will be called by the scheduler.\n  */\n\tWatcher.prototype.run = function run() {\n\t\tif (this.active) {\n\t\t\tvar value = this.get();\n\t\t\tif (value !== this.value ||\n\t\t\t// Deep watchers and watchers on Object/Arrays should fire even\n\t\t\t// when the value is the same, because the value may\n\t\t\t// have mutated.\n\t\t\tisObject(value) || this.deep) {\n\t\t\t\t// set new value\n\t\t\t\tvar oldValue = this.value;\n\t\t\t\tthis.value = value;\n\t\t\t\tif (this.user) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.cb.call(this.vm, value, oldValue);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\thandleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.cb.call(this.vm, value, oldValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Evaluate the value of the watcher.\n  * This only gets called for lazy watchers.\n  */\n\tWatcher.prototype.evaluate = function evaluate() {\n\t\tthis.value = this.get();\n\t\tthis.dirty = false;\n\t};\n\n\t/**\n  * Depend on all deps collected by this watcher.\n  */\n\tWatcher.prototype.depend = function depend() {\n\t\tvar this$1 = this;\n\n\t\tvar i = this.deps.length;\n\t\twhile (i--) {\n\t\t\tthis$1.deps[i].depend();\n\t\t}\n\t};\n\n\t/**\n  * Remove self from all dependencies' subscriber list.\n  */\n\tWatcher.prototype.teardown = function teardown() {\n\t\tvar this$1 = this;\n\n\t\tif (this.active) {\n\t\t\t// remove self from vm's watcher list\n\t\t\t// this is a somewhat expensive operation so we skip it\n\t\t\t// if the vm is being destroyed.\n\t\t\tif (!this.vm._isBeingDestroyed) {\n\t\t\t\tremove(this.vm._watchers, this);\n\t\t\t}\n\t\t\tvar i = this.deps.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis$1.deps[i].removeSub(this$1);\n\t\t\t}\n\t\t\tthis.active = false;\n\t\t}\n\t};\n\n\t/**\n  * Recursively traverse an object to evoke all converted\n  * getters, so that every nested property inside the object\n  * is collected as a \"deep\" dependency.\n  */\n\tvar seenObjects = new _Set();\n\tfunction traverse(val) {\n\t\tseenObjects.clear();\n\t\t_traverse(val, seenObjects);\n\t}\n\n\tfunction _traverse(val, seen) {\n\t\tvar i, keys;\n\t\tvar isA = Array.isArray(val);\n\t\tif (!isA && !isObject(val) || !Object.isExtensible(val)) {\n\t\t\treturn;\n\t\t}\n\t\tif (val.__ob__) {\n\t\t\tvar depId = val.__ob__.dep.id;\n\t\t\tif (seen.has(depId)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tseen.add(depId);\n\t\t}\n\t\tif (isA) {\n\t\t\ti = val.length;\n\t\t\twhile (i--) {\n\t\t\t\t_traverse(val[i], seen);\n\t\t\t}\n\t\t} else {\n\t\t\tkeys = Object.keys(val);\n\t\t\ti = keys.length;\n\t\t\twhile (i--) {\n\t\t\t\t_traverse(val[keys[i]], seen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar sharedPropertyDefinition = {\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t\tget: noop,\n\t\tset: noop\n\t};\n\n\tfunction proxy(target, sourceKey, key) {\n\t\tsharedPropertyDefinition.get = function proxyGetter() {\n\t\t\treturn this[sourceKey][key];\n\t\t};\n\t\tsharedPropertyDefinition.set = function proxySetter(val) {\n\t\t\tthis[sourceKey][key] = val;\n\t\t};\n\t\tObject.defineProperty(target, key, sharedPropertyDefinition);\n\t}\n\n\tfunction initState(vm) {\n\t\tvm._watchers = [];\n\t\tvar opts = vm.$options;\n\t\tif (opts.props) {\n\t\t\tinitProps(vm, opts.props);\n\t\t}\n\t\tif (opts.methods) {\n\t\t\tinitMethods(vm, opts.methods);\n\t\t}\n\t\tif (opts.data) {\n\t\t\tinitData(vm);\n\t\t} else {\n\t\t\tobserve(vm._data = {}, true /* asRootData */);\n\t\t}\n\t\tif (opts.computed) {\n\t\t\tinitComputed(vm, opts.computed);\n\t\t}\n\t\tif (opts.watch) {\n\t\t\tinitWatch(vm, opts.watch);\n\t\t}\n\t}\n\n\tvar isReservedProp = {\n\t\tkey: 1,\n\t\tref: 1,\n\t\tslot: 1\n\t};\n\n\tfunction initProps(vm, propsOptions) {\n\t\tvar propsData = vm.$options.propsData || {};\n\t\tvar props = vm._props = {};\n\t\t// cache prop keys so that future props updates can iterate using Array\n\t\t// instead of dynamic object key enumeration.\n\t\tvar keys = vm.$options._propKeys = [];\n\t\tvar isRoot = !vm.$parent;\n\t\t// root instance props should be converted\n\t\tobserverState.shouldConvert = isRoot;\n\t\tvar loop = function loop(key) {\n\t\t\tkeys.push(key);\n\t\t\tvar value = validateProp(key, propsOptions, propsData, vm);\n\t\t\t/* istanbul ignore else */\n\t\t\t{\n\t\t\t\tif (isReservedProp[key] || config.isReservedAttr(key)) {\n\t\t\t\t\twarn(\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n\t\t\t\t}\n\t\t\t\tdefineReactive$$1(props, key, value, function () {\n\t\t\t\t\tif (vm.$parent && !observerState.isSettingProps) {\n\t\t\t\t\t\twarn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t// static props are already proxied on the component's prototype\n\t\t\t// during Vue.extend(). We only need to proxy props defined at\n\t\t\t// instantiation here.\n\t\t\tif (!(key in vm)) {\n\t\t\t\tproxy(vm, \"_props\", key);\n\t\t\t}\n\t\t};\n\n\t\tfor (var key in propsOptions) {\n\t\t\tloop(key);\n\t\t}observerState.shouldConvert = true;\n\t}\n\n\tfunction initData(vm) {\n\t\tvar data = vm.$options.data;\n\t\tdata = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\t\tif (!isPlainObject(data)) {\n\t\t\tdata = {};\n\t\t\t\"development\" !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n\t\t}\n\t\t// proxy data on instance\n\t\tvar keys = Object.keys(data);\n\t\tvar props = vm.$options.props;\n\t\tvar i = keys.length;\n\t\twhile (i--) {\n\t\t\tif (props && hasOwn(props, keys[i])) {\n\t\t\t\t\"development\" !== 'production' && warn(\"The data property \\\"\" + keys[i] + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n\t\t\t} else if (!isReserved(keys[i])) {\n\t\t\t\tproxy(vm, \"_data\", keys[i]);\n\t\t\t}\n\t\t}\n\t\t// observe data\n\t\tobserve(data, true /* asRootData */);\n\t}\n\n\tfunction getData(data, vm) {\n\t\ttry {\n\t\t\treturn data.call(vm);\n\t\t} catch (e) {\n\t\t\thandleError(e, vm, \"data()\");\n\t\t\treturn {};\n\t\t}\n\t}\n\n\tvar computedWatcherOptions = { lazy: true };\n\n\tfunction initComputed(vm, computed) {\n\t\tvar watchers = vm._computedWatchers = Object.create(null);\n\n\t\tfor (var key in computed) {\n\t\t\tvar userDef = computed[key];\n\t\t\tvar getter = typeof userDef === 'function' ? userDef : userDef.get;\n\t\t\t{\n\t\t\t\tif (getter === undefined) {\n\t\t\t\t\twarn(\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\", vm);\n\t\t\t\t\tgetter = noop;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// create internal watcher for the computed property.\n\t\t\twatchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n\t\t\t// component-defined computed properties are already defined on the\n\t\t\t// component prototype. We only need to define computed properties defined\n\t\t\t// at instantiation here.\n\t\t\tif (!(key in vm)) {\n\t\t\t\tdefineComputed(vm, key, userDef);\n\t\t\t} else {\n\t\t\t\tif (key in vm.$data) {\n\t\t\t\t\twarn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n\t\t\t\t} else if (vm.$options.props && key in vm.$options.props) {\n\t\t\t\t\twarn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction defineComputed(target, key, userDef) {\n\t\tif (typeof userDef === 'function') {\n\t\t\tsharedPropertyDefinition.get = createComputedGetter(key);\n\t\t\tsharedPropertyDefinition.set = noop;\n\t\t} else {\n\t\t\tsharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n\t\t\tsharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n\t\t}\n\t\tObject.defineProperty(target, key, sharedPropertyDefinition);\n\t}\n\n\tfunction createComputedGetter(key) {\n\t\treturn function computedGetter() {\n\t\t\tvar watcher = this._computedWatchers && this._computedWatchers[key];\n\t\t\tif (watcher) {\n\t\t\t\tif (watcher.dirty) {\n\t\t\t\t\twatcher.evaluate();\n\t\t\t\t}\n\t\t\t\tif (Dep.target) {\n\t\t\t\t\twatcher.depend();\n\t\t\t\t}\n\t\t\t\treturn watcher.value;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction initMethods(vm, methods) {\n\t\tvar props = vm.$options.props;\n\t\tfor (var key in methods) {\n\t\t\tvm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n\t\t\t{\n\t\t\t\tif (methods[key] == null) {\n\t\t\t\t\twarn(\"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n\t\t\t\t}\n\t\t\t\tif (props && hasOwn(props, key)) {\n\t\t\t\t\twarn(\"method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction initWatch(vm, watch) {\n\t\tfor (var key in watch) {\n\t\t\tvar handler = watch[key];\n\t\t\tif (Array.isArray(handler)) {\n\t\t\t\tfor (var i = 0; i < handler.length; i++) {\n\t\t\t\t\tcreateWatcher(vm, key, handler[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcreateWatcher(vm, key, handler);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction createWatcher(vm, key, handler) {\n\t\tvar options;\n\t\tif (isPlainObject(handler)) {\n\t\t\toptions = handler;\n\t\t\thandler = handler.handler;\n\t\t}\n\t\tif (typeof handler === 'string') {\n\t\t\thandler = vm[handler];\n\t\t}\n\t\tvm.$watch(key, handler, options);\n\t}\n\n\tfunction stateMixin(Vue) {\n\t\t// flow somehow has problems with directly declared definition object\n\t\t// when using Object.defineProperty, so we have to procedurally build up\n\t\t// the object here.\n\t\tvar dataDef = {};\n\t\tdataDef.get = function () {\n\t\t\treturn this._data;\n\t\t};\n\t\tvar propsDef = {};\n\t\tpropsDef.get = function () {\n\t\t\treturn this._props;\n\t\t};\n\t\t{\n\t\t\tdataDef.set = function (newData) {\n\t\t\t\twarn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n\t\t\t};\n\t\t\tpropsDef.set = function () {\n\t\t\t\twarn(\"$props is readonly.\", this);\n\t\t\t};\n\t\t}\n\t\tObject.defineProperty(Vue.prototype, '$data', dataDef);\n\t\tObject.defineProperty(Vue.prototype, '$props', propsDef);\n\n\t\tVue.prototype.$set = set;\n\t\tVue.prototype.$delete = del;\n\n\t\tVue.prototype.$watch = function (expOrFn, cb, options) {\n\t\t\tvar vm = this;\n\t\t\toptions = options || {};\n\t\t\toptions.user = true;\n\t\t\tvar watcher = new Watcher(vm, expOrFn, cb, options);\n\t\t\tif (options.immediate) {\n\t\t\t\tcb.call(vm, watcher.value);\n\t\t\t}\n\t\t\treturn function unwatchFn() {\n\t\t\t\twatcher.teardown();\n\t\t\t};\n\t\t};\n\t}\n\n\t/*  */\n\n\tfunction initProvide(vm) {\n\t\tvar provide = vm.$options.provide;\n\t\tif (provide) {\n\t\t\tvm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n\t\t}\n\t}\n\n\tfunction initInjections(vm) {\n\t\tvar result = resolveInject(vm.$options.inject, vm);\n\t\tif (result) {\n\t\t\tObject.keys(result).forEach(function (key) {\n\t\t\t\t/* istanbul ignore else */\n\t\t\t\t{\n\t\t\t\t\tdefineReactive$$1(vm, key, result[key], function () {\n\t\t\t\t\t\twarn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction resolveInject(inject, vm) {\n\t\tif (inject) {\n\t\t\t// inject is :any because flow is not smart enough to figure out cached\n\t\t\t// isArray here\n\t\t\tvar isArray = Array.isArray(inject);\n\t\t\tvar result = Object.create(null);\n\t\t\tvar keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tvar provideKey = isArray ? key : inject[key];\n\t\t\t\tvar source = vm;\n\t\t\t\twhile (source) {\n\t\t\t\t\tif (source._provided && provideKey in source._provided) {\n\t\t\t\t\t\tresult[key] = source._provided[provideKey];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsource = source.$parent;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction createFunctionalComponent(Ctor, propsData, data, context, children) {\n\t\tvar props = {};\n\t\tvar propOptions = Ctor.options.props;\n\t\tif (isDef(propOptions)) {\n\t\t\tfor (var key in propOptions) {\n\t\t\t\tprops[key] = validateProp(key, propOptions, propsData || {});\n\t\t\t}\n\t\t} else {\n\t\t\tif (isDef(data.attrs)) {\n\t\t\t\tmergeProps(props, data.attrs);\n\t\t\t}\n\t\t\tif (isDef(data.props)) {\n\t\t\t\tmergeProps(props, data.props);\n\t\t\t}\n\t\t}\n\t\t// ensure the createElement function in functional components\n\t\t// gets a unique context - this is necessary for correct named slot check\n\t\tvar _context = Object.create(context);\n\t\tvar h = function h(a, b, c, d) {\n\t\t\treturn createElement(_context, a, b, c, d, true);\n\t\t};\n\t\tvar vnode = Ctor.options.render.call(null, h, {\n\t\t\tdata: data,\n\t\t\tprops: props,\n\t\t\tchildren: children,\n\t\t\tparent: context,\n\t\t\tlisteners: data.on || {},\n\t\t\tinjections: resolveInject(Ctor.options.inject, context),\n\t\t\tslots: function slots() {\n\t\t\t\treturn resolveSlots(children, context);\n\t\t\t}\n\t\t});\n\t\tif (vnode instanceof VNode) {\n\t\t\tvnode.functionalContext = context;\n\t\t\tvnode.functionalOptions = Ctor.options;\n\t\t\tif (data.slot) {\n\t\t\t\t(vnode.data || (vnode.data = {})).slot = data.slot;\n\t\t\t}\n\t\t}\n\t\treturn vnode;\n\t}\n\n\tfunction mergeProps(to, from) {\n\t\tfor (var key in from) {\n\t\t\tto[camelize(key)] = from[key];\n\t\t}\n\t}\n\n\t/*  */\n\n\t// hooks to be invoked on component VNodes during patch\n\tvar componentVNodeHooks = {\n\t\tinit: function init(vnode, hydrating, parentElm, refElm) {\n\t\t\tif (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n\t\t\t\tvar child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n\t\t\t\tchild.$mount(hydrating ? vnode.elm : undefined, hydrating);\n\t\t\t} else if (vnode.data.keepAlive) {\n\t\t\t\t// kept-alive components, treat as a patch\n\t\t\t\tvar mountedNode = vnode; // work around flow\n\t\t\t\tcomponentVNodeHooks.prepatch(mountedNode, mountedNode);\n\t\t\t}\n\t\t},\n\n\t\tprepatch: function prepatch(oldVnode, vnode) {\n\t\t\tvar options = vnode.componentOptions;\n\t\t\tvar child = vnode.componentInstance = oldVnode.componentInstance;\n\t\t\tupdateChildComponent(child, options.propsData, // updated props\n\t\t\toptions.listeners, // updated listeners\n\t\t\tvnode, // new parent vnode\n\t\t\toptions.children // new children\n\t\t\t);\n\t\t},\n\n\t\tinsert: function insert(vnode) {\n\t\t\tvar context = vnode.context;\n\t\t\tvar componentInstance = vnode.componentInstance;\n\t\t\tif (!componentInstance._isMounted) {\n\t\t\t\tcomponentInstance._isMounted = true;\n\t\t\t\tcallHook(componentInstance, 'mounted');\n\t\t\t}\n\t\t\tif (vnode.data.keepAlive) {\n\t\t\t\tif (context._isMounted) {\n\t\t\t\t\t// vue-router#1212\n\t\t\t\t\t// During updates, a kept-alive component's child components may\n\t\t\t\t\t// change, so directly walking the tree here may call activated hooks\n\t\t\t\t\t// on incorrect children. Instead we push them into a queue which will\n\t\t\t\t\t// be processed after the whole patch process ended.\n\t\t\t\t\tqueueActivatedComponent(componentInstance);\n\t\t\t\t} else {\n\t\t\t\t\tactivateChildComponent(componentInstance, true /* direct */);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdestroy: function destroy(vnode) {\n\t\t\tvar componentInstance = vnode.componentInstance;\n\t\t\tif (!componentInstance._isDestroyed) {\n\t\t\t\tif (!vnode.data.keepAlive) {\n\t\t\t\t\tcomponentInstance.$destroy();\n\t\t\t\t} else {\n\t\t\t\t\tdeactivateChildComponent(componentInstance, true /* direct */);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar hooksToMerge = Object.keys(componentVNodeHooks);\n\n\tfunction createComponent(Ctor, data, context, children, tag) {\n\t\tif (isUndef(Ctor)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar baseCtor = context.$options._base;\n\n\t\t// plain options object: turn it into a constructor\n\t\tif (isObject(Ctor)) {\n\t\t\tCtor = baseCtor.extend(Ctor);\n\t\t}\n\n\t\t// if at this stage it's not a constructor or an async component factory,\n\t\t// reject.\n\t\tif (typeof Ctor !== 'function') {\n\t\t\t{\n\t\t\t\twarn(\"Invalid Component definition: \" + String(Ctor), context);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// async component\n\t\tif (isUndef(Ctor.cid)) {\n\t\t\tCtor = resolveAsyncComponent(Ctor, baseCtor, context);\n\t\t\tif (Ctor === undefined) {\n\t\t\t\t// return nothing if this is indeed an async component\n\t\t\t\t// wait for the callback to trigger parent update.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// resolve constructor options in case global mixins are applied after\n\t\t// component constructor creation\n\t\tresolveConstructorOptions(Ctor);\n\n\t\tdata = data || {};\n\n\t\t// transform component v-model data into props & events\n\t\tif (isDef(data.model)) {\n\t\t\ttransformModel(Ctor.options, data);\n\t\t}\n\n\t\t// extract props\n\t\tvar propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n\t\t// functional component\n\t\tif (isTrue(Ctor.options.functional)) {\n\t\t\treturn createFunctionalComponent(Ctor, propsData, data, context, children);\n\t\t}\n\n\t\t// extract listeners, since these needs to be treated as\n\t\t// child component listeners instead of DOM listeners\n\t\tvar listeners = data.on;\n\t\t// replace with listeners with .native modifier\n\t\tdata.on = data.nativeOn;\n\n\t\tif (isTrue(Ctor.options.abstract)) {\n\t\t\t// abstract components do not keep anything\n\t\t\t// other than props & listeners\n\t\t\tdata = {};\n\t\t}\n\n\t\t// merge component management hooks onto the placeholder node\n\t\tmergeHooks(data);\n\n\t\t// return a placeholder vnode\n\t\tvar name = Ctor.options.name || tag;\n\t\tvar vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });\n\t\treturn vnode;\n\t}\n\n\tfunction createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n\tparent, // activeInstance in lifecycle state\n\tparentElm, refElm) {\n\t\tvar vnodeComponentOptions = vnode.componentOptions;\n\t\tvar options = {\n\t\t\t_isComponent: true,\n\t\t\tparent: parent,\n\t\t\tpropsData: vnodeComponentOptions.propsData,\n\t\t\t_componentTag: vnodeComponentOptions.tag,\n\t\t\t_parentVnode: vnode,\n\t\t\t_parentListeners: vnodeComponentOptions.listeners,\n\t\t\t_renderChildren: vnodeComponentOptions.children,\n\t\t\t_parentElm: parentElm || null,\n\t\t\t_refElm: refElm || null\n\t\t};\n\t\t// check inline-template render functions\n\t\tvar inlineTemplate = vnode.data.inlineTemplate;\n\t\tif (isDef(inlineTemplate)) {\n\t\t\toptions.render = inlineTemplate.render;\n\t\t\toptions.staticRenderFns = inlineTemplate.staticRenderFns;\n\t\t}\n\t\treturn new vnodeComponentOptions.Ctor(options);\n\t}\n\n\tfunction mergeHooks(data) {\n\t\tif (!data.hook) {\n\t\t\tdata.hook = {};\n\t\t}\n\t\tfor (var i = 0; i < hooksToMerge.length; i++) {\n\t\t\tvar key = hooksToMerge[i];\n\t\t\tvar fromParent = data.hook[key];\n\t\t\tvar ours = componentVNodeHooks[key];\n\t\t\tdata.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n\t\t}\n\t}\n\n\tfunction mergeHook$1(one, two) {\n\t\treturn function (a, b, c, d) {\n\t\t\tone(a, b, c, d);\n\t\t\ttwo(a, b, c, d);\n\t\t};\n\t}\n\n\t// transform component v-model info (value and callback) into\n\t// prop and event handler respectively.\n\tfunction transformModel(options, data) {\n\t\tvar prop = options.model && options.model.prop || 'value';\n\t\tvar event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n\t\tvar on = data.on || (data.on = {});\n\t\tif (isDef(on[event])) {\n\t\t\ton[event] = [data.model.callback].concat(on[event]);\n\t\t} else {\n\t\t\ton[event] = data.model.callback;\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar SIMPLE_NORMALIZE = 1;\n\tvar ALWAYS_NORMALIZE = 2;\n\n\t// wrapper function for providing a more flexible interface\n\t// without getting yelled at by flow\n\tfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n\t\tif (Array.isArray(data) || isPrimitive(data)) {\n\t\t\tnormalizationType = children;\n\t\t\tchildren = data;\n\t\t\tdata = undefined;\n\t\t}\n\t\tif (isTrue(alwaysNormalize)) {\n\t\t\tnormalizationType = ALWAYS_NORMALIZE;\n\t\t}\n\t\treturn _createElement(context, tag, data, children, normalizationType);\n\t}\n\n\tfunction _createElement(context, tag, data, children, normalizationType) {\n\t\tif (isDef(data) && isDef(data.__ob__)) {\n\t\t\t\"development\" !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n\t\t\treturn createEmptyVNode();\n\t\t}\n\t\tif (!tag) {\n\t\t\t// in case of component :is set to falsy value\n\t\t\treturn createEmptyVNode();\n\t\t}\n\t\t// support single function children as default scoped slot\n\t\tif (Array.isArray(children) && typeof children[0] === 'function') {\n\t\t\tdata = data || {};\n\t\t\tdata.scopedSlots = { default: children[0] };\n\t\t\tchildren.length = 0;\n\t\t}\n\t\tif (normalizationType === ALWAYS_NORMALIZE) {\n\t\t\tchildren = normalizeChildren(children);\n\t\t} else if (normalizationType === SIMPLE_NORMALIZE) {\n\t\t\tchildren = simpleNormalizeChildren(children);\n\t\t}\n\t\tvar vnode, ns;\n\t\tif (typeof tag === 'string') {\n\t\t\tvar Ctor;\n\t\t\tns = config.getTagNamespace(tag);\n\t\t\tif (config.isReservedTag(tag)) {\n\t\t\t\t// platform built-in elements\n\t\t\t\tvnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n\t\t\t} else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n\t\t\t\t// component\n\t\t\t\tvnode = createComponent(Ctor, data, context, children, tag);\n\t\t\t} else {\n\t\t\t\t// unknown or unlisted namespaced elements\n\t\t\t\t// check at runtime because it may get assigned a namespace when its\n\t\t\t\t// parent normalizes children\n\t\t\t\tvnode = new VNode(tag, data, children, undefined, undefined, context);\n\t\t\t}\n\t\t} else {\n\t\t\t// direct component options / constructor\n\t\t\tvnode = createComponent(tag, data, context, children);\n\t\t}\n\t\tif (isDef(vnode)) {\n\t\t\tif (ns) {\n\t\t\t\tapplyNS(vnode, ns);\n\t\t\t}\n\t\t\treturn vnode;\n\t\t} else {\n\t\t\treturn createEmptyVNode();\n\t\t}\n\t}\n\n\tfunction applyNS(vnode, ns) {\n\t\tvnode.ns = ns;\n\t\tif (vnode.tag === 'foreignObject') {\n\t\t\t// use default namespace inside foreignObject\n\t\t\treturn;\n\t\t}\n\t\tif (isDef(vnode.children)) {\n\t\t\tfor (var i = 0, l = vnode.children.length; i < l; i++) {\n\t\t\t\tvar child = vnode.children[i];\n\t\t\t\tif (isDef(child.tag) && isUndef(child.ns)) {\n\t\t\t\t\tapplyNS(child, ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for rendering v-for lists.\n  */\n\tfunction renderList(val, render) {\n\t\tvar ret, i, l, keys, key;\n\t\tif (Array.isArray(val) || typeof val === 'string') {\n\t\t\tret = new Array(val.length);\n\t\t\tfor (i = 0, l = val.length; i < l; i++) {\n\t\t\t\tret[i] = render(val[i], i);\n\t\t\t}\n\t\t} else if (typeof val === 'number') {\n\t\t\tret = new Array(val);\n\t\t\tfor (i = 0; i < val; i++) {\n\t\t\t\tret[i] = render(i + 1, i);\n\t\t\t}\n\t\t} else if (isObject(val)) {\n\t\t\tkeys = Object.keys(val);\n\t\t\tret = new Array(keys.length);\n\t\t\tfor (i = 0, l = keys.length; i < l; i++) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tret[i] = render(val[key], key, i);\n\t\t\t}\n\t\t}\n\t\tif (isDef(ret)) {\n\t\t\tret._isVList = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for rendering <slot>\n  */\n\tfunction renderSlot(name, fallback, props, bindObject) {\n\t\tvar scopedSlotFn = this.$scopedSlots[name];\n\t\tif (scopedSlotFn) {\n\t\t\t// scoped slot\n\t\t\tprops = props || {};\n\t\t\tif (bindObject) {\n\t\t\t\textend(props, bindObject);\n\t\t\t}\n\t\t\treturn scopedSlotFn(props) || fallback;\n\t\t} else {\n\t\t\tvar slotNodes = this.$slots[name];\n\t\t\t// warn duplicate slot usage\n\t\t\tif (slotNodes && \"development\" !== 'production') {\n\t\t\t\tslotNodes._rendered && warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n\t\t\t\tslotNodes._rendered = true;\n\t\t\t}\n\t\t\treturn slotNodes || fallback;\n\t\t}\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for resolving filters\n  */\n\tfunction resolveFilter(id) {\n\t\treturn resolveAsset(this.$options, 'filters', id, true) || identity;\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for checking keyCodes from config.\n  */\n\tfunction checkKeyCodes(eventKeyCode, key, builtInAlias) {\n\t\tvar keyCodes = config.keyCodes[key] || builtInAlias;\n\t\tif (Array.isArray(keyCodes)) {\n\t\t\treturn keyCodes.indexOf(eventKeyCode) === -1;\n\t\t} else {\n\t\t\treturn keyCodes !== eventKeyCode;\n\t\t}\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n  */\n\tfunction bindObjectProps(data, tag, value, asProp) {\n\t\tif (value) {\n\t\t\tif (!isObject(value)) {\n\t\t\t\t\"development\" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n\t\t\t} else {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tvalue = toObject(value);\n\t\t\t\t}\n\t\t\t\tvar hash;\n\t\t\t\tfor (var key in value) {\n\t\t\t\t\tif (key === 'class' || key === 'style') {\n\t\t\t\t\t\thash = data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar type = data.attrs && data.attrs.type;\n\t\t\t\t\t\thash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n\t\t\t\t\t}\n\t\t\t\t\tif (!(key in hash)) {\n\t\t\t\t\t\thash[key] = value[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for rendering static trees.\n  */\n\tfunction renderStatic(index, isInFor) {\n\t\tvar tree = this._staticTrees[index];\n\t\t// if has already-rendered static tree and not inside v-for,\n\t\t// we can reuse the same tree by doing a shallow clone.\n\t\tif (tree && !isInFor) {\n\t\t\treturn Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);\n\t\t}\n\t\t// otherwise, render a fresh tree.\n\t\ttree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n\t\tmarkStatic(tree, \"__static__\" + index, false);\n\t\treturn tree;\n\t}\n\n\t/**\n  * Runtime helper for v-once.\n  * Effectively it means marking the node as static with a unique key.\n  */\n\tfunction markOnce(tree, index, key) {\n\t\tmarkStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n\t\treturn tree;\n\t}\n\n\tfunction markStatic(tree, key, isOnce) {\n\t\tif (Array.isArray(tree)) {\n\t\t\tfor (var i = 0; i < tree.length; i++) {\n\t\t\t\tif (tree[i] && typeof tree[i] !== 'string') {\n\t\t\t\t\tmarkStaticNode(tree[i], key + \"_\" + i, isOnce);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmarkStaticNode(tree, key, isOnce);\n\t\t}\n\t}\n\n\tfunction markStaticNode(node, key, isOnce) {\n\t\tnode.isStatic = true;\n\t\tnode.key = key;\n\t\tnode.isOnce = isOnce;\n\t}\n\n\t/*  */\n\n\tfunction initRender(vm) {\n\t\tvm._vnode = null; // the root of the child tree\n\t\tvm._staticTrees = null;\n\t\tvar parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n\t\tvar renderContext = parentVnode && parentVnode.context;\n\t\tvm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n\t\tvm.$scopedSlots = emptyObject;\n\t\t// bind the createElement fn to this instance\n\t\t// so that we get proper render context inside it.\n\t\t// args order: tag, data, children, normalizationType, alwaysNormalize\n\t\t// internal version is used by render functions compiled from templates\n\t\tvm._c = function (a, b, c, d) {\n\t\t\treturn createElement(vm, a, b, c, d, false);\n\t\t};\n\t\t// normalization is always applied for the public version, used in\n\t\t// user-written render functions.\n\t\tvm.$createElement = function (a, b, c, d) {\n\t\t\treturn createElement(vm, a, b, c, d, true);\n\t\t};\n\t}\n\n\tfunction renderMixin(Vue) {\n\t\tVue.prototype.$nextTick = function (fn) {\n\t\t\treturn nextTick(fn, this);\n\t\t};\n\n\t\tVue.prototype._render = function () {\n\t\t\tvar vm = this;\n\t\t\tvar ref = vm.$options;\n\t\t\tvar render = ref.render;\n\t\t\tvar staticRenderFns = ref.staticRenderFns;\n\t\t\tvar _parentVnode = ref._parentVnode;\n\n\t\t\tif (vm._isMounted) {\n\t\t\t\t// clone slot nodes on re-renders\n\t\t\t\tfor (var key in vm.$slots) {\n\t\t\t\t\tvm.$slots[key] = cloneVNodes(vm.$slots[key]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;\n\n\t\t\tif (staticRenderFns && !vm._staticTrees) {\n\t\t\t\tvm._staticTrees = [];\n\t\t\t}\n\t\t\t// set parent vnode. this allows render functions to have access\n\t\t\t// to the data on the placeholder node.\n\t\t\tvm.$vnode = _parentVnode;\n\t\t\t// render self\n\t\t\tvar vnode;\n\t\t\ttry {\n\t\t\t\tvnode = render.call(vm._renderProxy, vm.$createElement);\n\t\t\t} catch (e) {\n\t\t\t\thandleError(e, vm, \"render function\");\n\t\t\t\t// return error render result,\n\t\t\t\t// or previous vnode to prevent render error causing blank component\n\t\t\t\t/* istanbul ignore else */\n\t\t\t\t{\n\t\t\t\t\tvnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return empty vnode in case the render function errored out\n\t\t\tif (!(vnode instanceof VNode)) {\n\t\t\t\tif (\"development\" !== 'production' && Array.isArray(vnode)) {\n\t\t\t\t\twarn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n\t\t\t\t}\n\t\t\t\tvnode = createEmptyVNode();\n\t\t\t}\n\t\t\t// set parent\n\t\t\tvnode.parent = _parentVnode;\n\t\t\treturn vnode;\n\t\t};\n\n\t\t// internal render helpers.\n\t\t// these are exposed on the instance prototype to reduce generated render\n\t\t// code size.\n\t\tVue.prototype._o = markOnce;\n\t\tVue.prototype._n = toNumber;\n\t\tVue.prototype._s = toString;\n\t\tVue.prototype._l = renderList;\n\t\tVue.prototype._t = renderSlot;\n\t\tVue.prototype._q = looseEqual;\n\t\tVue.prototype._i = looseIndexOf;\n\t\tVue.prototype._m = renderStatic;\n\t\tVue.prototype._f = resolveFilter;\n\t\tVue.prototype._k = checkKeyCodes;\n\t\tVue.prototype._b = bindObjectProps;\n\t\tVue.prototype._v = createTextVNode;\n\t\tVue.prototype._e = createEmptyVNode;\n\t\tVue.prototype._u = resolveScopedSlots;\n\t}\n\n\t/*  */\n\n\tvar uid$1 = 0;\n\n\tfunction initMixin(Vue) {\n\t\tVue.prototype._init = function (options) {\n\t\t\tvar vm = this;\n\t\t\t// a uid\n\t\t\tvm._uid = uid$1++;\n\n\t\t\tvar startTag, endTag;\n\t\t\t/* istanbul ignore if */\n\t\t\tif (\"development\" !== 'production' && config.performance && mark) {\n\t\t\t\tstartTag = \"vue-perf-init:\" + vm._uid;\n\t\t\t\tendTag = \"vue-perf-end:\" + vm._uid;\n\t\t\t\tmark(startTag);\n\t\t\t}\n\n\t\t\t// a flag to avoid this being observed\n\t\t\tvm._isVue = true;\n\t\t\t// merge options\n\t\t\tif (options && options._isComponent) {\n\t\t\t\t// optimize internal component instantiation\n\t\t\t\t// since dynamic options merging is pretty slow, and none of the\n\t\t\t\t// internal component options needs special treatment.\n\t\t\t\tinitInternalComponent(vm, options);\n\t\t\t} else {\n\t\t\t\tvm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n\t\t\t}\n\t\t\t/* istanbul ignore else */\n\t\t\t{\n\t\t\t\tinitProxy(vm);\n\t\t\t}\n\t\t\t// expose real self\n\t\t\tvm._self = vm;\n\t\t\tinitLifecycle(vm);\n\t\t\tinitEvents(vm);\n\t\t\tinitRender(vm);\n\t\t\tcallHook(vm, 'beforeCreate');\n\t\t\tinitInjections(vm); // resolve injections before data/props\n\t\t\tinitState(vm);\n\t\t\tinitProvide(vm); // resolve provide after data/props\n\t\t\tcallHook(vm, 'created');\n\n\t\t\t/* istanbul ignore if */\n\t\t\tif (\"development\" !== 'production' && config.performance && mark) {\n\t\t\t\tvm._name = formatComponentName(vm, false);\n\t\t\t\tmark(endTag);\n\t\t\t\tmeasure(vm._name + \" init\", startTag, endTag);\n\t\t\t}\n\n\t\t\tif (vm.$options.el) {\n\t\t\t\tvm.$mount(vm.$options.el);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction initInternalComponent(vm, options) {\n\t\tvar opts = vm.$options = Object.create(vm.constructor.options);\n\t\t// doing this because it's faster than dynamic enumeration.\n\t\topts.parent = options.parent;\n\t\topts.propsData = options.propsData;\n\t\topts._parentVnode = options._parentVnode;\n\t\topts._parentListeners = options._parentListeners;\n\t\topts._renderChildren = options._renderChildren;\n\t\topts._componentTag = options._componentTag;\n\t\topts._parentElm = options._parentElm;\n\t\topts._refElm = options._refElm;\n\t\tif (options.render) {\n\t\t\topts.render = options.render;\n\t\t\topts.staticRenderFns = options.staticRenderFns;\n\t\t}\n\t}\n\n\tfunction resolveConstructorOptions(Ctor) {\n\t\tvar options = Ctor.options;\n\t\tif (Ctor.super) {\n\t\t\tvar superOptions = resolveConstructorOptions(Ctor.super);\n\t\t\tvar cachedSuperOptions = Ctor.superOptions;\n\t\t\tif (superOptions !== cachedSuperOptions) {\n\t\t\t\t// super option changed,\n\t\t\t\t// need to resolve new options.\n\t\t\t\tCtor.superOptions = superOptions;\n\t\t\t\t// check if there are any late-modified/attached options (#4976)\n\t\t\t\tvar modifiedOptions = resolveModifiedOptions(Ctor);\n\t\t\t\t// update base extend options\n\t\t\t\tif (modifiedOptions) {\n\t\t\t\t\textend(Ctor.extendOptions, modifiedOptions);\n\t\t\t\t}\n\t\t\t\toptions = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\t\t\t\tif (options.name) {\n\t\t\t\t\toptions.components[options.name] = Ctor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\tfunction resolveModifiedOptions(Ctor) {\n\t\tvar modified;\n\t\tvar latest = Ctor.options;\n\t\tvar extended = Ctor.extendOptions;\n\t\tvar sealed = Ctor.sealedOptions;\n\t\tfor (var key in latest) {\n\t\t\tif (latest[key] !== sealed[key]) {\n\t\t\t\tif (!modified) {\n\t\t\t\t\tmodified = {};\n\t\t\t\t}\n\t\t\t\tmodified[key] = dedupe(latest[key], extended[key], sealed[key]);\n\t\t\t}\n\t\t}\n\t\treturn modified;\n\t}\n\n\tfunction dedupe(latest, extended, sealed) {\n\t\t// compare latest and sealed to ensure lifecycle hooks won't be duplicated\n\t\t// between merges\n\t\tif (Array.isArray(latest)) {\n\t\t\tvar res = [];\n\t\t\tsealed = Array.isArray(sealed) ? sealed : [sealed];\n\t\t\textended = Array.isArray(extended) ? extended : [extended];\n\t\t\tfor (var i = 0; i < latest.length; i++) {\n\t\t\t\t// push original options and not sealed options to exclude duplicated options\n\t\t\t\tif (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n\t\t\t\t\tres.push(latest[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t} else {\n\t\t\treturn latest;\n\t\t}\n\t}\n\n\tfunction Vue$3(options) {\n\t\tif (\"development\" !== 'production' && !(this instanceof Vue$3)) {\n\t\t\twarn('Vue is a constructor and should be called with the `new` keyword');\n\t\t}\n\t\tthis._init(options);\n\t}\n\n\tinitMixin(Vue$3);\n\tstateMixin(Vue$3);\n\teventsMixin(Vue$3);\n\tlifecycleMixin(Vue$3);\n\trenderMixin(Vue$3);\n\n\t/*  */\n\n\tfunction initUse(Vue) {\n\t\tVue.use = function (plugin) {\n\t\t\t/* istanbul ignore if */\n\t\t\tif (plugin.installed) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t// additional parameters\n\t\t\tvar args = toArray(arguments, 1);\n\t\t\targs.unshift(this);\n\t\t\tif (typeof plugin.install === 'function') {\n\t\t\t\tplugin.install.apply(plugin, args);\n\t\t\t} else if (typeof plugin === 'function') {\n\t\t\t\tplugin.apply(null, args);\n\t\t\t}\n\t\t\tplugin.installed = true;\n\t\t\treturn this;\n\t\t};\n\t}\n\n\t/*  */\n\n\tfunction initMixin$1(Vue) {\n\t\tVue.mixin = function (mixin) {\n\t\t\tthis.options = mergeOptions(this.options, mixin);\n\t\t\treturn this;\n\t\t};\n\t}\n\n\t/*  */\n\n\tfunction initExtend(Vue) {\n\t\t/**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n\t\tVue.cid = 0;\n\t\tvar cid = 1;\n\n\t\t/**\n   * Class inheritance\n   */\n\t\tVue.extend = function (extendOptions) {\n\t\t\textendOptions = extendOptions || {};\n\t\t\tvar Super = this;\n\t\t\tvar SuperId = Super.cid;\n\t\t\tvar cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\t\t\tif (cachedCtors[SuperId]) {\n\t\t\t\treturn cachedCtors[SuperId];\n\t\t\t}\n\n\t\t\tvar name = extendOptions.name || Super.options.name;\n\t\t\t{\n\t\t\t\tif (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n\t\t\t\t\twarn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar Sub = function VueComponent(options) {\n\t\t\t\tthis._init(options);\n\t\t\t};\n\t\t\tSub.prototype = Object.create(Super.prototype);\n\t\t\tSub.prototype.constructor = Sub;\n\t\t\tSub.cid = cid++;\n\t\t\tSub.options = mergeOptions(Super.options, extendOptions);\n\t\t\tSub['super'] = Super;\n\n\t\t\t// For props and computed properties, we define the proxy getters on\n\t\t\t// the Vue instances at extension time, on the extended prototype. This\n\t\t\t// avoids Object.defineProperty calls for each instance created.\n\t\t\tif (Sub.options.props) {\n\t\t\t\tinitProps$1(Sub);\n\t\t\t}\n\t\t\tif (Sub.options.computed) {\n\t\t\t\tinitComputed$1(Sub);\n\t\t\t}\n\n\t\t\t// allow further extension/mixin/plugin usage\n\t\t\tSub.extend = Super.extend;\n\t\t\tSub.mixin = Super.mixin;\n\t\t\tSub.use = Super.use;\n\n\t\t\t// create asset registers, so extended classes\n\t\t\t// can have their private assets too.\n\t\t\tASSET_TYPES.forEach(function (type) {\n\t\t\t\tSub[type] = Super[type];\n\t\t\t});\n\t\t\t// enable recursive self-lookup\n\t\t\tif (name) {\n\t\t\t\tSub.options.components[name] = Sub;\n\t\t\t}\n\n\t\t\t// keep a reference to the super options at extension time.\n\t\t\t// later at instantiation we can check if Super's options have\n\t\t\t// been updated.\n\t\t\tSub.superOptions = Super.options;\n\t\t\tSub.extendOptions = extendOptions;\n\t\t\tSub.sealedOptions = extend({}, Sub.options);\n\n\t\t\t// cache constructor\n\t\t\tcachedCtors[SuperId] = Sub;\n\t\t\treturn Sub;\n\t\t};\n\t}\n\n\tfunction initProps$1(Comp) {\n\t\tvar props = Comp.options.props;\n\t\tfor (var key in props) {\n\t\t\tproxy(Comp.prototype, \"_props\", key);\n\t\t}\n\t}\n\n\tfunction initComputed$1(Comp) {\n\t\tvar computed = Comp.options.computed;\n\t\tfor (var key in computed) {\n\t\t\tdefineComputed(Comp.prototype, key, computed[key]);\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction initAssetRegisters(Vue) {\n\t\t/**\n   * Create asset registration methods.\n   */\n\t\tASSET_TYPES.forEach(function (type) {\n\t\t\tVue[type] = function (id, definition) {\n\t\t\t\tif (!definition) {\n\t\t\t\t\treturn this.options[type + 's'][id];\n\t\t\t\t} else {\n\t\t\t\t\t/* istanbul ignore if */\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type === 'component' && config.isReservedTag(id)) {\n\t\t\t\t\t\t\twarn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (type === 'component' && isPlainObject(definition)) {\n\t\t\t\t\t\tdefinition.name = definition.name || id;\n\t\t\t\t\t\tdefinition = this.options._base.extend(definition);\n\t\t\t\t\t}\n\t\t\t\t\tif (type === 'directive' && typeof definition === 'function') {\n\t\t\t\t\t\tdefinition = { bind: definition, update: definition };\n\t\t\t\t\t}\n\t\t\t\t\tthis.options[type + 's'][id] = definition;\n\t\t\t\t\treturn definition;\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t/*  */\n\n\tvar patternTypes = [String, RegExp];\n\n\tfunction getComponentName(opts) {\n\t\treturn opts && (opts.Ctor.options.name || opts.tag);\n\t}\n\n\tfunction matches(pattern, name) {\n\t\tif (typeof pattern === 'string') {\n\t\t\treturn pattern.split(',').indexOf(name) > -1;\n\t\t} else if (isRegExp(pattern)) {\n\t\t\treturn pattern.test(name);\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn false;\n\t}\n\n\tfunction pruneCache(cache, current, filter) {\n\t\tfor (var key in cache) {\n\t\t\tvar cachedNode = cache[key];\n\t\t\tif (cachedNode) {\n\t\t\t\tvar name = getComponentName(cachedNode.componentOptions);\n\t\t\t\tif (name && !filter(name)) {\n\t\t\t\t\tif (cachedNode !== current) {\n\t\t\t\t\t\tpruneCacheEntry(cachedNode);\n\t\t\t\t\t}\n\t\t\t\t\tcache[key] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction pruneCacheEntry(vnode) {\n\t\tif (vnode) {\n\t\t\tvnode.componentInstance.$destroy();\n\t\t}\n\t}\n\n\tvar KeepAlive = {\n\t\tname: 'keep-alive',\n\t\tabstract: true,\n\n\t\tprops: {\n\t\t\tinclude: patternTypes,\n\t\t\texclude: patternTypes\n\t\t},\n\n\t\tcreated: function created() {\n\t\t\tthis.cache = Object.create(null);\n\t\t},\n\n\t\tdestroyed: function destroyed() {\n\t\t\tvar this$1 = this;\n\n\t\t\tfor (var key in this$1.cache) {\n\t\t\t\tpruneCacheEntry(this$1.cache[key]);\n\t\t\t}\n\t\t},\n\n\t\twatch: {\n\t\t\tinclude: function include(val) {\n\t\t\t\tpruneCache(this.cache, this._vnode, function (name) {\n\t\t\t\t\treturn matches(val, name);\n\t\t\t\t});\n\t\t\t},\n\t\t\texclude: function exclude(val) {\n\t\t\t\tpruneCache(this.cache, this._vnode, function (name) {\n\t\t\t\t\treturn !matches(val, name);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\trender: function render() {\n\t\t\tvar vnode = getFirstComponentChild(this.$slots.default);\n\t\t\tvar componentOptions = vnode && vnode.componentOptions;\n\t\t\tif (componentOptions) {\n\t\t\t\t// check pattern\n\t\t\t\tvar name = getComponentName(componentOptions);\n\t\t\t\tif (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {\n\t\t\t\t\treturn vnode;\n\t\t\t\t}\n\t\t\t\tvar key = vnode.key == null\n\t\t\t\t// same constructor may get registered as different local components\n\t\t\t\t// so cid alone is not enough (#3269)\n\t\t\t\t? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\t\t\t\tif (this.cache[key]) {\n\t\t\t\t\tvnode.componentInstance = this.cache[key].componentInstance;\n\t\t\t\t} else {\n\t\t\t\t\tthis.cache[key] = vnode;\n\t\t\t\t}\n\t\t\t\tvnode.data.keepAlive = true;\n\t\t\t}\n\t\t\treturn vnode;\n\t\t}\n\t};\n\n\tvar builtInComponents = {\n\t\tKeepAlive: KeepAlive\n\t};\n\n\t/*  */\n\n\tfunction initGlobalAPI(Vue) {\n\t\t// config\n\t\tvar configDef = {};\n\t\tconfigDef.get = function () {\n\t\t\treturn config;\n\t\t};\n\t\t{\n\t\t\tconfigDef.set = function () {\n\t\t\t\twarn('Do not replace the Vue.config object, set individual fields instead.');\n\t\t\t};\n\t\t}\n\t\tObject.defineProperty(Vue, 'config', configDef);\n\n\t\t// exposed util methods.\n\t\t// NOTE: these are not considered part of the public API - avoid relying on\n\t\t// them unless you are aware of the risk.\n\t\tVue.util = {\n\t\t\twarn: warn,\n\t\t\textend: extend,\n\t\t\tmergeOptions: mergeOptions,\n\t\t\tdefineReactive: defineReactive$$1\n\t\t};\n\n\t\tVue.set = set;\n\t\tVue.delete = del;\n\t\tVue.nextTick = nextTick;\n\n\t\tVue.options = Object.create(null);\n\t\tASSET_TYPES.forEach(function (type) {\n\t\t\tVue.options[type + 's'] = Object.create(null);\n\t\t});\n\n\t\t// this is used to identify the \"base\" constructor to extend all plain-object\n\t\t// components with in Weex's multi-instance scenarios.\n\t\tVue.options._base = Vue;\n\n\t\textend(Vue.options.components, builtInComponents);\n\n\t\tinitUse(Vue);\n\t\tinitMixin$1(Vue);\n\t\tinitExtend(Vue);\n\t\tinitAssetRegisters(Vue);\n\t}\n\n\tinitGlobalAPI(Vue$3);\n\n\tObject.defineProperty(Vue$3.prototype, '$isServer', {\n\t\tget: isServerRendering\n\t});\n\n\tObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n\t\tget: function get() {\n\t\t\t/* istanbul ignore next */\n\t\t\treturn this.$vnode.ssrContext;\n\t\t}\n\t});\n\n\tVue$3.version = '2.3.4';\n\n\t/*  */\n\n\t// these are reserved for web because they are directly compiled away\n\t// during template compilation\n\tvar isReservedAttr = makeMap('style,class');\n\n\t// attributes that should be using props for binding\n\tvar acceptValue = makeMap('input,textarea,option,select');\n\tvar mustUseProp = function mustUseProp(tag, type, attr) {\n\t\treturn attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n\t};\n\n\tvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n\tvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\n\tvar isXlink = function isXlink(name) {\n\t\treturn name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n\t};\n\n\tvar getXlinkProp = function getXlinkProp(name) {\n\t\treturn isXlink(name) ? name.slice(6, name.length) : '';\n\t};\n\n\tvar isFalsyAttrValue = function isFalsyAttrValue(val) {\n\t\treturn val == null || val === false;\n\t};\n\n\t/*  */\n\n\tfunction genClassForVnode(vnode) {\n\t\tvar data = vnode.data;\n\t\tvar parentNode = vnode;\n\t\tvar childNode = vnode;\n\t\twhile (isDef(childNode.componentInstance)) {\n\t\t\tchildNode = childNode.componentInstance._vnode;\n\t\t\tif (childNode.data) {\n\t\t\t\tdata = mergeClassData(childNode.data, data);\n\t\t\t}\n\t\t}\n\t\twhile (isDef(parentNode = parentNode.parent)) {\n\t\t\tif (parentNode.data) {\n\t\t\t\tdata = mergeClassData(data, parentNode.data);\n\t\t\t}\n\t\t}\n\t\treturn genClassFromData(data);\n\t}\n\n\tfunction mergeClassData(child, parent) {\n\t\treturn {\n\t\t\tstaticClass: concat(child.staticClass, parent.staticClass),\n\t\t\tclass: isDef(child.class) ? [child.class, parent.class] : parent.class\n\t\t};\n\t}\n\n\tfunction genClassFromData(data) {\n\t\tvar dynamicClass = data.class;\n\t\tvar staticClass = data.staticClass;\n\t\tif (isDef(staticClass) || isDef(dynamicClass)) {\n\t\t\treturn concat(staticClass, stringifyClass(dynamicClass));\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn '';\n\t}\n\n\tfunction concat(a, b) {\n\t\treturn a ? b ? a + ' ' + b : a : b || '';\n\t}\n\n\tfunction stringifyClass(value) {\n\t\tif (isUndef(value)) {\n\t\t\treturn '';\n\t\t}\n\t\tif (typeof value === 'string') {\n\t\t\treturn value;\n\t\t}\n\t\tvar res = '';\n\t\tif (Array.isArray(value)) {\n\t\t\tvar stringified;\n\t\t\tfor (var i = 0, l = value.length; i < l; i++) {\n\t\t\t\tif (isDef(value[i])) {\n\t\t\t\t\tif (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n\t\t\t\t\t\tres += stringified + ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.slice(0, -1);\n\t\t}\n\t\tif (isObject(value)) {\n\t\t\tfor (var key in value) {\n\t\t\t\tif (value[key]) {\n\t\t\t\t\tres += key + ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.slice(0, -1);\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tvar namespaceMap = {\n\t\tsvg: 'http://www.w3.org/2000/svg',\n\t\tmath: 'http://www.w3.org/1998/Math/MathML'\n\t};\n\n\tvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');\n\n\t// this map is intentionally selective, only covering SVG elements that may\n\t// contain child elements.\n\tvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n\tvar isPreTag = function isPreTag(tag) {\n\t\treturn tag === 'pre';\n\t};\n\n\tvar isReservedTag = function isReservedTag(tag) {\n\t\treturn isHTMLTag(tag) || isSVG(tag);\n\t};\n\n\tfunction getTagNamespace(tag) {\n\t\tif (isSVG(tag)) {\n\t\t\treturn 'svg';\n\t\t}\n\t\t// basic support for MathML\n\t\t// note it doesn't support other MathML elements being component roots\n\t\tif (tag === 'math') {\n\t\t\treturn 'math';\n\t\t}\n\t}\n\n\tvar unknownElementCache = Object.create(null);\n\tfunction isUnknownElement(tag) {\n\t\t/* istanbul ignore if */\n\t\tif (!inBrowser) {\n\t\t\treturn true;\n\t\t}\n\t\tif (isReservedTag(tag)) {\n\t\t\treturn false;\n\t\t}\n\t\ttag = tag.toLowerCase();\n\t\t/* istanbul ignore if */\n\t\tif (unknownElementCache[tag] != null) {\n\t\t\treturn unknownElementCache[tag];\n\t\t}\n\t\tvar el = document.createElement(tag);\n\t\tif (tag.indexOf('-') > -1) {\n\t\t\t// http://stackoverflow.com/a/28210364/1070244\n\t\t\treturn unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n\t\t} else {\n\t\t\treturn unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n\t\t}\n\t}\n\n\t/*  */\n\n\t/**\n  * Query an element selector if it's not an element already.\n  */\n\tfunction query(el) {\n\t\tif (typeof el === 'string') {\n\t\t\tvar selected = document.querySelector(el);\n\t\t\tif (!selected) {\n\t\t\t\t\"development\" !== 'production' && warn('Cannot find element: ' + el);\n\t\t\t\treturn document.createElement('div');\n\t\t\t}\n\t\t\treturn selected;\n\t\t} else {\n\t\t\treturn el;\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction createElement$1(tagName, vnode) {\n\t\tvar elm = document.createElement(tagName);\n\t\tif (tagName !== 'select') {\n\t\t\treturn elm;\n\t\t}\n\t\t// false or null will remove the attribute but undefined will not\n\t\tif (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n\t\t\telm.setAttribute('multiple', 'multiple');\n\t\t}\n\t\treturn elm;\n\t}\n\n\tfunction createElementNS(namespace, tagName) {\n\t\treturn document.createElementNS(namespaceMap[namespace], tagName);\n\t}\n\n\tfunction createTextNode(text) {\n\t\treturn document.createTextNode(text);\n\t}\n\n\tfunction createComment(text) {\n\t\treturn document.createComment(text);\n\t}\n\n\tfunction insertBefore(parentNode, newNode, referenceNode) {\n\t\tparentNode.insertBefore(newNode, referenceNode);\n\t}\n\n\tfunction removeChild(node, child) {\n\t\tnode.removeChild(child);\n\t}\n\n\tfunction appendChild(node, child) {\n\t\tnode.appendChild(child);\n\t}\n\n\tfunction parentNode(node) {\n\t\treturn node.parentNode;\n\t}\n\n\tfunction nextSibling(node) {\n\t\treturn node.nextSibling;\n\t}\n\n\tfunction tagName(node) {\n\t\treturn node.tagName;\n\t}\n\n\tfunction setTextContent(node, text) {\n\t\tnode.textContent = text;\n\t}\n\n\tfunction setAttribute(node, key, val) {\n\t\tnode.setAttribute(key, val);\n\t}\n\n\tvar nodeOps = Object.freeze({\n\t\tcreateElement: createElement$1,\n\t\tcreateElementNS: createElementNS,\n\t\tcreateTextNode: createTextNode,\n\t\tcreateComment: createComment,\n\t\tinsertBefore: insertBefore,\n\t\tremoveChild: removeChild,\n\t\tappendChild: appendChild,\n\t\tparentNode: parentNode,\n\t\tnextSibling: nextSibling,\n\t\ttagName: tagName,\n\t\tsetTextContent: setTextContent,\n\t\tsetAttribute: setAttribute\n\t});\n\n\t/*  */\n\n\tvar ref = {\n\t\tcreate: function create(_, vnode) {\n\t\t\tregisterRef(vnode);\n\t\t},\n\t\tupdate: function update(oldVnode, vnode) {\n\t\t\tif (oldVnode.data.ref !== vnode.data.ref) {\n\t\t\t\tregisterRef(oldVnode, true);\n\t\t\t\tregisterRef(vnode);\n\t\t\t}\n\t\t},\n\t\tdestroy: function destroy(vnode) {\n\t\t\tregisterRef(vnode, true);\n\t\t}\n\t};\n\n\tfunction registerRef(vnode, isRemoval) {\n\t\tvar key = vnode.data.ref;\n\t\tif (!key) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar vm = vnode.context;\n\t\tvar ref = vnode.componentInstance || vnode.elm;\n\t\tvar refs = vm.$refs;\n\t\tif (isRemoval) {\n\t\t\tif (Array.isArray(refs[key])) {\n\t\t\t\tremove(refs[key], ref);\n\t\t\t} else if (refs[key] === ref) {\n\t\t\t\trefs[key] = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tif (vnode.data.refInFor) {\n\t\t\t\tif (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n\t\t\t\t\trefs[key].push(ref);\n\t\t\t\t} else {\n\t\t\t\t\trefs[key] = [ref];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trefs[key] = ref;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Virtual DOM patching algorithm based on Snabbdom by\n  * Simon Friis Vindum (@paldepind)\n  * Licensed under the MIT License\n  * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n  *\n  * modified by Evan You (@yyx990803)\n  *\n \t /*\n  * Not type-checking this because this file is perf-critical and the cost\n  * of making flow understand it is not worth it.\n  */\n\n\tvar emptyNode = new VNode('', {}, []);\n\n\tvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n\tfunction sameVnode(a, b) {\n\t\treturn a.key === b.key && a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b);\n\t}\n\n\t// Some browsers do not support dynamically changing type for <input>\n\t// so they need to be treated as different nodes\n\tfunction sameInputType(a, b) {\n\t\tif (a.tag !== 'input') {\n\t\t\treturn true;\n\t\t}\n\t\tvar i;\n\t\tvar typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n\t\tvar typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n\t\treturn typeA === typeB;\n\t}\n\n\tfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n\t\tvar i, key;\n\t\tvar map = {};\n\t\tfor (i = beginIdx; i <= endIdx; ++i) {\n\t\t\tkey = children[i].key;\n\t\t\tif (isDef(key)) {\n\t\t\t\tmap[key] = i;\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\tfunction createPatchFunction(backend) {\n\t\tvar i, j;\n\t\tvar cbs = {};\n\n\t\tvar modules = backend.modules;\n\t\tvar nodeOps = backend.nodeOps;\n\n\t\tfor (i = 0; i < hooks.length; ++i) {\n\t\t\tcbs[hooks[i]] = [];\n\t\t\tfor (j = 0; j < modules.length; ++j) {\n\t\t\t\tif (isDef(modules[j][hooks[i]])) {\n\t\t\t\t\tcbs[hooks[i]].push(modules[j][hooks[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction emptyNodeAt(elm) {\n\t\t\treturn new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n\t\t}\n\n\t\tfunction createRmCb(childElm, listeners) {\n\t\t\tfunction remove$$1() {\n\t\t\t\tif (--remove$$1.listeners === 0) {\n\t\t\t\t\tremoveNode(childElm);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove$$1.listeners = listeners;\n\t\t\treturn remove$$1;\n\t\t}\n\n\t\tfunction removeNode(el) {\n\t\t\tvar parent = nodeOps.parentNode(el);\n\t\t\t// element may have already been removed due to v-html / v-text\n\t\t\tif (isDef(parent)) {\n\t\t\t\tnodeOps.removeChild(parent, el);\n\t\t\t}\n\t\t}\n\n\t\tvar inPre = 0;\n\t\tfunction createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n\t\t\tvnode.isRootInsert = !nested; // for transition enter check\n\t\t\tif (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar data = vnode.data;\n\t\t\tvar children = vnode.children;\n\t\t\tvar tag = vnode.tag;\n\t\t\tif (isDef(tag)) {\n\t\t\t\t{\n\t\t\t\t\tif (data && data.pre) {\n\t\t\t\t\t\tinPre++;\n\t\t\t\t\t}\n\t\t\t\t\tif (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {\n\t\t\t\t\t\twarn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n\t\t\t\tsetScope(vnode);\n\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\t{\n\t\t\t\t\tcreateChildren(vnode, children, insertedVnodeQueue);\n\t\t\t\t\tif (isDef(data)) {\n\t\t\t\t\t\tinvokeCreateHooks(vnode, insertedVnodeQueue);\n\t\t\t\t\t}\n\t\t\t\t\tinsert(parentElm, vnode.elm, refElm);\n\t\t\t\t}\n\n\t\t\t\tif (\"development\" !== 'production' && data && data.pre) {\n\t\t\t\t\tinPre--;\n\t\t\t\t}\n\t\t\t} else if (isTrue(vnode.isComment)) {\n\t\t\t\tvnode.elm = nodeOps.createComment(vnode.text);\n\t\t\t\tinsert(parentElm, vnode.elm, refElm);\n\t\t\t} else {\n\t\t\t\tvnode.elm = nodeOps.createTextNode(vnode.text);\n\t\t\t\tinsert(parentElm, vnode.elm, refElm);\n\t\t\t}\n\t\t}\n\n\t\tfunction createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n\t\t\tvar i = vnode.data;\n\t\t\tif (isDef(i)) {\n\t\t\t\tvar isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\t\t\t\tif (isDef(i = i.hook) && isDef(i = i.init)) {\n\t\t\t\t\ti(vnode, false /* hydrating */, parentElm, refElm);\n\t\t\t\t}\n\t\t\t\t// after calling the init hook, if the vnode is a child component\n\t\t\t\t// it should've created a child instance and mounted it. the child\n\t\t\t\t// component also has set the placeholder vnode's elm.\n\t\t\t\t// in that case we can just return the element and be done.\n\t\t\t\tif (isDef(vnode.componentInstance)) {\n\t\t\t\t\tinitComponent(vnode, insertedVnodeQueue);\n\t\t\t\t\tif (isTrue(isReactivated)) {\n\t\t\t\t\t\treactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction initComponent(vnode, insertedVnodeQueue) {\n\t\t\tif (isDef(vnode.data.pendingInsert)) {\n\t\t\t\tinsertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n\t\t\t\tvnode.data.pendingInsert = null;\n\t\t\t}\n\t\t\tvnode.elm = vnode.componentInstance.$el;\n\t\t\tif (isPatchable(vnode)) {\n\t\t\t\tinvokeCreateHooks(vnode, insertedVnodeQueue);\n\t\t\t\tsetScope(vnode);\n\t\t\t} else {\n\t\t\t\t// empty component root.\n\t\t\t\t// skip all element-related modules except for ref (#3455)\n\t\t\t\tregisterRef(vnode);\n\t\t\t\t// make sure to invoke the insert hook\n\t\t\t\tinsertedVnodeQueue.push(vnode);\n\t\t\t}\n\t\t}\n\n\t\tfunction reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n\t\t\tvar i;\n\t\t\t// hack for #4339: a reactivated component with inner transition\n\t\t\t// does not trigger because the inner node's created hooks are not called\n\t\t\t// again. It's not ideal to involve module-specific logic in here but\n\t\t\t// there doesn't seem to be a better way to do it.\n\t\t\tvar innerNode = vnode;\n\t\t\twhile (innerNode.componentInstance) {\n\t\t\t\tinnerNode = innerNode.componentInstance._vnode;\n\t\t\t\tif (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n\t\t\t\t\tfor (i = 0; i < cbs.activate.length; ++i) {\n\t\t\t\t\t\tcbs.activate[i](emptyNode, innerNode);\n\t\t\t\t\t}\n\t\t\t\t\tinsertedVnodeQueue.push(innerNode);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// unlike a newly created component,\n\t\t\t// a reactivated keep-alive component doesn't insert itself\n\t\t\tinsert(parentElm, vnode.elm, refElm);\n\t\t}\n\n\t\tfunction insert(parent, elm, ref) {\n\t\t\tif (isDef(parent)) {\n\t\t\t\tif (isDef(ref)) {\n\t\t\t\t\tif (ref.parentNode === parent) {\n\t\t\t\t\t\tnodeOps.insertBefore(parent, elm, ref);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnodeOps.appendChild(parent, elm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction createChildren(vnode, children, insertedVnodeQueue) {\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; ++i) {\n\t\t\t\t\tcreateElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n\t\t\t\t}\n\t\t\t} else if (isPrimitive(vnode.text)) {\n\t\t\t\tnodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n\t\t\t}\n\t\t}\n\n\t\tfunction isPatchable(vnode) {\n\t\t\twhile (vnode.componentInstance) {\n\t\t\t\tvnode = vnode.componentInstance._vnode;\n\t\t\t}\n\t\t\treturn isDef(vnode.tag);\n\t\t}\n\n\t\tfunction invokeCreateHooks(vnode, insertedVnodeQueue) {\n\t\t\tfor (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n\t\t\t\tcbs.create[i$1](emptyNode, vnode);\n\t\t\t}\n\t\t\ti = vnode.data.hook; // Reuse variable\n\t\t\tif (isDef(i)) {\n\t\t\t\tif (isDef(i.create)) {\n\t\t\t\t\ti.create(emptyNode, vnode);\n\t\t\t\t}\n\t\t\t\tif (isDef(i.insert)) {\n\t\t\t\t\tinsertedVnodeQueue.push(vnode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// set scope id attribute for scoped CSS.\n\t\t// this is implemented as a special case to avoid the overhead\n\t\t// of going through the normal attribute patching process.\n\t\tfunction setScope(vnode) {\n\t\t\tvar i;\n\t\t\tvar ancestor = vnode;\n\t\t\twhile (ancestor) {\n\t\t\t\tif (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n\t\t\t\t\tnodeOps.setAttribute(vnode.elm, i, '');\n\t\t\t\t}\n\t\t\t\tancestor = ancestor.parent;\n\t\t\t}\n\t\t\t// for slot content they should also get the scopeId from the host instance.\n\t\t\tif (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {\n\t\t\t\tnodeOps.setAttribute(vnode.elm, i, '');\n\t\t\t}\n\t\t}\n\n\t\tfunction addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n\t\t\tfor (; startIdx <= endIdx; ++startIdx) {\n\t\t\t\tcreateElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n\t\t\t}\n\t\t}\n\n\t\tfunction invokeDestroyHook(vnode) {\n\t\t\tvar i, j;\n\t\t\tvar data = vnode.data;\n\t\t\tif (isDef(data)) {\n\t\t\t\tif (isDef(i = data.hook) && isDef(i = i.destroy)) {\n\t\t\t\t\ti(vnode);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < cbs.destroy.length; ++i) {\n\t\t\t\t\tcbs.destroy[i](vnode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDef(i = vnode.children)) {\n\t\t\t\tfor (j = 0; j < vnode.children.length; ++j) {\n\t\t\t\t\tinvokeDestroyHook(vnode.children[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n\t\t\tfor (; startIdx <= endIdx; ++startIdx) {\n\t\t\t\tvar ch = vnodes[startIdx];\n\t\t\t\tif (isDef(ch)) {\n\t\t\t\t\tif (isDef(ch.tag)) {\n\t\t\t\t\t\tremoveAndInvokeRemoveHook(ch);\n\t\t\t\t\t\tinvokeDestroyHook(ch);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Text node\n\t\t\t\t\t\tremoveNode(ch.elm);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction removeAndInvokeRemoveHook(vnode, rm) {\n\t\t\tif (isDef(rm) || isDef(vnode.data)) {\n\t\t\t\tvar i;\n\t\t\t\tvar listeners = cbs.remove.length + 1;\n\t\t\t\tif (isDef(rm)) {\n\t\t\t\t\t// we have a recursively passed down rm callback\n\t\t\t\t\t// increase the listeners count\n\t\t\t\t\trm.listeners += listeners;\n\t\t\t\t} else {\n\t\t\t\t\t// directly removing\n\t\t\t\t\trm = createRmCb(vnode.elm, listeners);\n\t\t\t\t}\n\t\t\t\t// recursively invoke hooks on child component root node\n\t\t\t\tif (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n\t\t\t\t\tremoveAndInvokeRemoveHook(i, rm);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < cbs.remove.length; ++i) {\n\t\t\t\t\tcbs.remove[i](vnode, rm);\n\t\t\t\t}\n\t\t\t\tif (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n\t\t\t\t\ti(vnode, rm);\n\t\t\t\t} else {\n\t\t\t\t\trm();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tremoveNode(vnode.elm);\n\t\t\t}\n\t\t}\n\n\t\tfunction updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n\t\t\tvar oldStartIdx = 0;\n\t\t\tvar newStartIdx = 0;\n\t\t\tvar oldEndIdx = oldCh.length - 1;\n\t\t\tvar oldStartVnode = oldCh[0];\n\t\t\tvar oldEndVnode = oldCh[oldEndIdx];\n\t\t\tvar newEndIdx = newCh.length - 1;\n\t\t\tvar newStartVnode = newCh[0];\n\t\t\tvar newEndVnode = newCh[newEndIdx];\n\t\t\tvar oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n\t\t\t// removeOnly is a special flag used only by <transition-group>\n\t\t\t// to ensure removed elements stay in correct relative positions\n\t\t\t// during leaving transitions\n\t\t\tvar canMove = !removeOnly;\n\n\t\t\twhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n\t\t\t\tif (isUndef(oldStartVnode)) {\n\t\t\t\t\toldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n\t\t\t\t} else if (isUndef(oldEndVnode)) {\n\t\t\t\t\toldEndVnode = oldCh[--oldEndIdx];\n\t\t\t\t} else if (sameVnode(oldStartVnode, newStartVnode)) {\n\t\t\t\t\tpatchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n\t\t\t\t\toldStartVnode = oldCh[++oldStartIdx];\n\t\t\t\t\tnewStartVnode = newCh[++newStartIdx];\n\t\t\t\t} else if (sameVnode(oldEndVnode, newEndVnode)) {\n\t\t\t\t\tpatchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n\t\t\t\t\toldEndVnode = oldCh[--oldEndIdx];\n\t\t\t\t\tnewEndVnode = newCh[--newEndIdx];\n\t\t\t\t} else if (sameVnode(oldStartVnode, newEndVnode)) {\n\t\t\t\t\t// Vnode moved right\n\t\t\t\t\tpatchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n\t\t\t\t\tcanMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n\t\t\t\t\toldStartVnode = oldCh[++oldStartIdx];\n\t\t\t\t\tnewEndVnode = newCh[--newEndIdx];\n\t\t\t\t} else if (sameVnode(oldEndVnode, newStartVnode)) {\n\t\t\t\t\t// Vnode moved left\n\t\t\t\t\tpatchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n\t\t\t\t\tcanMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n\t\t\t\t\toldEndVnode = oldCh[--oldEndIdx];\n\t\t\t\t\tnewStartVnode = newCh[++newStartIdx];\n\t\t\t\t} else {\n\t\t\t\t\tif (isUndef(oldKeyToIdx)) {\n\t\t\t\t\t\toldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n\t\t\t\t\t}\n\t\t\t\t\tidxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n\t\t\t\t\tif (isUndef(idxInOld)) {\n\t\t\t\t\t\t// New element\n\t\t\t\t\t\tcreateElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t\t\t\t\t\tnewStartVnode = newCh[++newStartIdx];\n\t\t\t\t\t} else {\n\t\t\t\t\t\telmToMove = oldCh[idxInOld];\n\t\t\t\t\t\t/* istanbul ignore if */\n\t\t\t\t\t\tif (\"development\" !== 'production' && !elmToMove) {\n\t\t\t\t\t\t\twarn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sameVnode(elmToMove, newStartVnode)) {\n\t\t\t\t\t\t\tpatchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n\t\t\t\t\t\t\toldCh[idxInOld] = undefined;\n\t\t\t\t\t\t\tcanMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n\t\t\t\t\t\t\tnewStartVnode = newCh[++newStartIdx];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// same key but different element. treat as new element\n\t\t\t\t\t\t\tcreateElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t\t\t\t\t\t\tnewStartVnode = newCh[++newStartIdx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (oldStartIdx > oldEndIdx) {\n\t\t\t\trefElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n\t\t\t\taddVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n\t\t\t} else if (newStartIdx > newEndIdx) {\n\t\t\t\tremoveVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n\t\t\t}\n\t\t}\n\n\t\tfunction patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n\t\t\tif (oldVnode === vnode) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// reuse element for static trees.\n\t\t\t// note we only do this if the vnode is cloned -\n\t\t\t// if the new node is not cloned it means the render functions have been\n\t\t\t// reset by the hot-reload-api and we need to do a proper re-render.\n\t\t\tif (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n\t\t\t\tvnode.elm = oldVnode.elm;\n\t\t\t\tvnode.componentInstance = oldVnode.componentInstance;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar i;\n\t\t\tvar data = vnode.data;\n\t\t\tif (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n\t\t\t\ti(oldVnode, vnode);\n\t\t\t}\n\t\t\tvar elm = vnode.elm = oldVnode.elm;\n\t\t\tvar oldCh = oldVnode.children;\n\t\t\tvar ch = vnode.children;\n\t\t\tif (isDef(data) && isPatchable(vnode)) {\n\t\t\t\tfor (i = 0; i < cbs.update.length; ++i) {\n\t\t\t\t\tcbs.update[i](oldVnode, vnode);\n\t\t\t\t}\n\t\t\t\tif (isDef(i = data.hook) && isDef(i = i.update)) {\n\t\t\t\t\ti(oldVnode, vnode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isUndef(vnode.text)) {\n\t\t\t\tif (isDef(oldCh) && isDef(ch)) {\n\t\t\t\t\tif (oldCh !== ch) {\n\t\t\t\t\t\tupdateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n\t\t\t\t\t}\n\t\t\t\t} else if (isDef(ch)) {\n\t\t\t\t\tif (isDef(oldVnode.text)) {\n\t\t\t\t\t\tnodeOps.setTextContent(elm, '');\n\t\t\t\t\t}\n\t\t\t\t\taddVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n\t\t\t\t} else if (isDef(oldCh)) {\n\t\t\t\t\tremoveVnodes(elm, oldCh, 0, oldCh.length - 1);\n\t\t\t\t} else if (isDef(oldVnode.text)) {\n\t\t\t\t\tnodeOps.setTextContent(elm, '');\n\t\t\t\t}\n\t\t\t} else if (oldVnode.text !== vnode.text) {\n\t\t\t\tnodeOps.setTextContent(elm, vnode.text);\n\t\t\t}\n\t\t\tif (isDef(data)) {\n\t\t\t\tif (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n\t\t\t\t\ti(oldVnode, vnode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction invokeInsertHook(vnode, queue, initial) {\n\t\t\t// delay insert hooks for component root nodes, invoke them after the\n\t\t\t// element is really inserted\n\t\t\tif (isTrue(initial) && isDef(vnode.parent)) {\n\t\t\t\tvnode.parent.data.pendingInsert = queue;\n\t\t\t} else {\n\t\t\t\tfor (var i = 0; i < queue.length; ++i) {\n\t\t\t\t\tqueue[i].data.hook.insert(queue[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar bailed = false;\n\t\t// list of modules that can skip create hook during hydration because they\n\t\t// are already rendered on the client or has no need for initialization\n\t\tvar isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n\t\t// Note: this is a browser-only function so we can assume elms are DOM nodes.\n\t\tfunction hydrate(elm, vnode, insertedVnodeQueue) {\n\t\t\t{\n\t\t\t\tif (!assertNodeMatch(elm, vnode)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvnode.elm = elm;\n\t\t\tvar tag = vnode.tag;\n\t\t\tvar data = vnode.data;\n\t\t\tvar children = vnode.children;\n\t\t\tif (isDef(data)) {\n\t\t\t\tif (isDef(i = data.hook) && isDef(i = i.init)) {\n\t\t\t\t\ti(vnode, true /* hydrating */);\n\t\t\t\t}\n\t\t\t\tif (isDef(i = vnode.componentInstance)) {\n\t\t\t\t\t// child component. it should have hydrated its own tree.\n\t\t\t\t\tinitComponent(vnode, insertedVnodeQueue);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDef(tag)) {\n\t\t\t\tif (isDef(children)) {\n\t\t\t\t\t// empty element, allow client to pick up and populate children\n\t\t\t\t\tif (!elm.hasChildNodes()) {\n\t\t\t\t\t\tcreateChildren(vnode, children, insertedVnodeQueue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar childrenMatch = true;\n\t\t\t\t\t\tvar childNode = elm.firstChild;\n\t\t\t\t\t\tfor (var i$1 = 0; i$1 < children.length; i$1++) {\n\t\t\t\t\t\t\tif (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n\t\t\t\t\t\t\t\tchildrenMatch = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchildNode = childNode.nextSibling;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if childNode is not null, it means the actual childNodes list is\n\t\t\t\t\t\t// longer than the virtual children list.\n\t\t\t\t\t\tif (!childrenMatch || childNode) {\n\t\t\t\t\t\t\tif (\"development\" !== 'production' && typeof console !== 'undefined' && !bailed) {\n\t\t\t\t\t\t\t\tbailed = true;\n\t\t\t\t\t\t\t\tconsole.warn('Parent: ', elm);\n\t\t\t\t\t\t\t\tconsole.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isDef(data)) {\n\t\t\t\t\tfor (var key in data) {\n\t\t\t\t\t\tif (!isRenderedModule(key)) {\n\t\t\t\t\t\t\tinvokeCreateHooks(vnode, insertedVnodeQueue);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (elm.data !== vnode.text) {\n\t\t\t\telm.data = vnode.text;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction assertNodeMatch(node, vnode) {\n\t\t\tif (isDef(vnode.tag)) {\n\t\t\t\treturn vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n\t\t\t} else {\n\t\t\t\treturn node.nodeType === (vnode.isComment ? 8 : 3);\n\t\t\t}\n\t\t}\n\n\t\treturn function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n\t\t\tif (isUndef(vnode)) {\n\t\t\t\tif (isDef(oldVnode)) {\n\t\t\t\t\tinvokeDestroyHook(oldVnode);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar isInitialPatch = false;\n\t\t\tvar insertedVnodeQueue = [];\n\n\t\t\tif (isUndef(oldVnode)) {\n\t\t\t\t// empty mount (likely as component), create new root element\n\t\t\t\tisInitialPatch = true;\n\t\t\t\tcreateElm(vnode, insertedVnodeQueue, parentElm, refElm);\n\t\t\t} else {\n\t\t\t\tvar isRealElement = isDef(oldVnode.nodeType);\n\t\t\t\tif (!isRealElement && sameVnode(oldVnode, vnode)) {\n\t\t\t\t\t// patch existing root node\n\t\t\t\t\tpatchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n\t\t\t\t} else {\n\t\t\t\t\tif (isRealElement) {\n\t\t\t\t\t\t// mounting to a real element\n\t\t\t\t\t\t// check if this is server-rendered content and if we can perform\n\t\t\t\t\t\t// a successful hydration.\n\t\t\t\t\t\tif (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n\t\t\t\t\t\t\toldVnode.removeAttribute(SSR_ATTR);\n\t\t\t\t\t\t\thydrating = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isTrue(hydrating)) {\n\t\t\t\t\t\t\tif (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n\t\t\t\t\t\t\t\tinvokeInsertHook(vnode, insertedVnodeQueue, true);\n\t\t\t\t\t\t\t\treturn oldVnode;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twarn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// either not server-rendered, or hydration failed.\n\t\t\t\t\t\t// create an empty node and replace it\n\t\t\t\t\t\toldVnode = emptyNodeAt(oldVnode);\n\t\t\t\t\t}\n\t\t\t\t\t// replacing existing element\n\t\t\t\t\tvar oldElm = oldVnode.elm;\n\t\t\t\t\tvar parentElm$1 = nodeOps.parentNode(oldElm);\n\t\t\t\t\tcreateElm(vnode, insertedVnodeQueue,\n\t\t\t\t\t// extremely rare edge case: do not insert if old element is in a\n\t\t\t\t\t// leaving transition. Only happens when combining transition +\n\t\t\t\t\t// keep-alive + HOCs. (#4590)\n\t\t\t\t\toldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));\n\n\t\t\t\t\tif (isDef(vnode.parent)) {\n\t\t\t\t\t\t// component root element replaced.\n\t\t\t\t\t\t// update parent placeholder node element, recursively\n\t\t\t\t\t\tvar ancestor = vnode.parent;\n\t\t\t\t\t\twhile (ancestor) {\n\t\t\t\t\t\t\tancestor.elm = vnode.elm;\n\t\t\t\t\t\t\tancestor = ancestor.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isPatchable(vnode)) {\n\t\t\t\t\t\t\tfor (var i = 0; i < cbs.create.length; ++i) {\n\t\t\t\t\t\t\t\tcbs.create[i](emptyNode, vnode.parent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isDef(parentElm$1)) {\n\t\t\t\t\t\tremoveVnodes(parentElm$1, [oldVnode], 0, 0);\n\t\t\t\t\t} else if (isDef(oldVnode.tag)) {\n\t\t\t\t\t\tinvokeDestroyHook(oldVnode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinvokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n\t\t\treturn vnode.elm;\n\t\t};\n\t}\n\n\t/*  */\n\n\tvar directives = {\n\t\tcreate: updateDirectives,\n\t\tupdate: updateDirectives,\n\t\tdestroy: function unbindDirectives(vnode) {\n\t\t\tupdateDirectives(vnode, emptyNode);\n\t\t}\n\t};\n\n\tfunction updateDirectives(oldVnode, vnode) {\n\t\tif (oldVnode.data.directives || vnode.data.directives) {\n\t\t\t_update(oldVnode, vnode);\n\t\t}\n\t}\n\n\tfunction _update(oldVnode, vnode) {\n\t\tvar isCreate = oldVnode === emptyNode;\n\t\tvar isDestroy = vnode === emptyNode;\n\t\tvar oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n\t\tvar newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n\t\tvar dirsWithInsert = [];\n\t\tvar dirsWithPostpatch = [];\n\n\t\tvar key, oldDir, dir;\n\t\tfor (key in newDirs) {\n\t\t\toldDir = oldDirs[key];\n\t\t\tdir = newDirs[key];\n\t\t\tif (!oldDir) {\n\t\t\t\t// new directive, bind\n\t\t\t\tcallHook$1(dir, 'bind', vnode, oldVnode);\n\t\t\t\tif (dir.def && dir.def.inserted) {\n\t\t\t\t\tdirsWithInsert.push(dir);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// existing directive, update\n\t\t\t\tdir.oldValue = oldDir.value;\n\t\t\t\tcallHook$1(dir, 'update', vnode, oldVnode);\n\t\t\t\tif (dir.def && dir.def.componentUpdated) {\n\t\t\t\t\tdirsWithPostpatch.push(dir);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dirsWithInsert.length) {\n\t\t\tvar callInsert = function callInsert() {\n\t\t\t\tfor (var i = 0; i < dirsWithInsert.length; i++) {\n\t\t\t\t\tcallHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (isCreate) {\n\t\t\t\tmergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n\t\t\t} else {\n\t\t\t\tcallInsert();\n\t\t\t}\n\t\t}\n\n\t\tif (dirsWithPostpatch.length) {\n\t\t\tmergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n\t\t\t\tfor (var i = 0; i < dirsWithPostpatch.length; i++) {\n\t\t\t\t\tcallHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (!isCreate) {\n\t\t\tfor (key in oldDirs) {\n\t\t\t\tif (!newDirs[key]) {\n\t\t\t\t\t// no longer present, unbind\n\t\t\t\t\tcallHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar emptyModifiers = Object.create(null);\n\n\tfunction normalizeDirectives$1(dirs, vm) {\n\t\tvar res = Object.create(null);\n\t\tif (!dirs) {\n\t\t\treturn res;\n\t\t}\n\t\tvar i, dir;\n\t\tfor (i = 0; i < dirs.length; i++) {\n\t\t\tdir = dirs[i];\n\t\t\tif (!dir.modifiers) {\n\t\t\t\tdir.modifiers = emptyModifiers;\n\t\t\t}\n\t\t\tres[getRawDirName(dir)] = dir;\n\t\t\tdir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction getRawDirName(dir) {\n\t\treturn dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n\t}\n\n\tfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n\t\tvar fn = dir.def && dir.def[hook];\n\t\tif (fn) {\n\t\t\ttry {\n\t\t\t\tfn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n\t\t\t} catch (e) {\n\t\t\t\thandleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n\t\t\t}\n\t\t}\n\t}\n\n\tvar baseModules = [ref, directives];\n\n\t/*  */\n\n\tfunction updateAttrs(oldVnode, vnode) {\n\t\tif (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n\t\t\treturn;\n\t\t}\n\t\tvar key, cur, old;\n\t\tvar elm = vnode.elm;\n\t\tvar oldAttrs = oldVnode.data.attrs || {};\n\t\tvar attrs = vnode.data.attrs || {};\n\t\t// clone observed objects, as the user probably wants to mutate it\n\t\tif (isDef(attrs.__ob__)) {\n\t\t\tattrs = vnode.data.attrs = extend({}, attrs);\n\t\t}\n\n\t\tfor (key in attrs) {\n\t\t\tcur = attrs[key];\n\t\t\told = oldAttrs[key];\n\t\t\tif (old !== cur) {\n\t\t\t\tsetAttr(elm, key, cur);\n\t\t\t}\n\t\t}\n\t\t// #4391: in IE9, setting type can reset value for input[type=radio]\n\t\t/* istanbul ignore if */\n\t\tif (isIE9 && attrs.value !== oldAttrs.value) {\n\t\t\tsetAttr(elm, 'value', attrs.value);\n\t\t}\n\t\tfor (key in oldAttrs) {\n\t\t\tif (isUndef(attrs[key])) {\n\t\t\t\tif (isXlink(key)) {\n\t\t\t\t\telm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t\t\t\t} else if (!isEnumeratedAttr(key)) {\n\t\t\t\t\telm.removeAttribute(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setAttr(el, key, value) {\n\t\tif (isBooleanAttr(key)) {\n\t\t\t// set attribute for blank value\n\t\t\t// e.g. <option disabled>Select one</option>\n\t\t\tif (isFalsyAttrValue(value)) {\n\t\t\t\tel.removeAttribute(key);\n\t\t\t} else {\n\t\t\t\tel.setAttribute(key, key);\n\t\t\t}\n\t\t} else if (isEnumeratedAttr(key)) {\n\t\t\tel.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n\t\t} else if (isXlink(key)) {\n\t\t\tif (isFalsyAttrValue(value)) {\n\t\t\t\tel.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t\t\t} else {\n\t\t\t\tel.setAttributeNS(xlinkNS, key, value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (isFalsyAttrValue(value)) {\n\t\t\t\tel.removeAttribute(key);\n\t\t\t} else {\n\t\t\t\tel.setAttribute(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar attrs = {\n\t\tcreate: updateAttrs,\n\t\tupdate: updateAttrs\n\t};\n\n\t/*  */\n\n\tfunction updateClass(oldVnode, vnode) {\n\t\tvar el = vnode.elm;\n\t\tvar data = vnode.data;\n\t\tvar oldData = oldVnode.data;\n\t\tif (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar cls = genClassForVnode(vnode);\n\n\t\t// handle transition classes\n\t\tvar transitionClass = el._transitionClasses;\n\t\tif (isDef(transitionClass)) {\n\t\t\tcls = concat(cls, stringifyClass(transitionClass));\n\t\t}\n\n\t\t// set the class\n\t\tif (cls !== el._prevClass) {\n\t\t\tel.setAttribute('class', cls);\n\t\t\tel._prevClass = cls;\n\t\t}\n\t}\n\n\tvar klass = {\n\t\tcreate: updateClass,\n\t\tupdate: updateClass\n\t};\n\n\t/*  */\n\n\tvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n\tfunction parseFilters(exp) {\n\t\tvar inSingle = false;\n\t\tvar inDouble = false;\n\t\tvar inTemplateString = false;\n\t\tvar inRegex = false;\n\t\tvar curly = 0;\n\t\tvar square = 0;\n\t\tvar paren = 0;\n\t\tvar lastFilterIndex = 0;\n\t\tvar c, prev, i, expression, filters;\n\n\t\tfor (i = 0; i < exp.length; i++) {\n\t\t\tprev = c;\n\t\t\tc = exp.charCodeAt(i);\n\t\t\tif (inSingle) {\n\t\t\t\tif (c === 0x27 && prev !== 0x5C) {\n\t\t\t\t\tinSingle = false;\n\t\t\t\t}\n\t\t\t} else if (inDouble) {\n\t\t\t\tif (c === 0x22 && prev !== 0x5C) {\n\t\t\t\t\tinDouble = false;\n\t\t\t\t}\n\t\t\t} else if (inTemplateString) {\n\t\t\t\tif (c === 0x60 && prev !== 0x5C) {\n\t\t\t\t\tinTemplateString = false;\n\t\t\t\t}\n\t\t\t} else if (inRegex) {\n\t\t\t\tif (c === 0x2f && prev !== 0x5C) {\n\t\t\t\t\tinRegex = false;\n\t\t\t\t}\n\t\t\t} else if (c === 0x7C && // pipe\n\t\t\texp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n\t\t\t\tif (expression === undefined) {\n\t\t\t\t\t// first filter, end of expression\n\t\t\t\t\tlastFilterIndex = i + 1;\n\t\t\t\t\texpression = exp.slice(0, i).trim();\n\t\t\t\t} else {\n\t\t\t\t\tpushFilter();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase 0x22:\n\t\t\t\t\t\tinDouble = true;break; // \"\n\t\t\t\t\tcase 0x27:\n\t\t\t\t\t\tinSingle = true;break; // '\n\t\t\t\t\tcase 0x60:\n\t\t\t\t\t\tinTemplateString = true;break; // `\n\t\t\t\t\tcase 0x28:\n\t\t\t\t\t\tparen++;break; // (\n\t\t\t\t\tcase 0x29:\n\t\t\t\t\t\tparen--;break; // )\n\t\t\t\t\tcase 0x5B:\n\t\t\t\t\t\tsquare++;break; // [\n\t\t\t\t\tcase 0x5D:\n\t\t\t\t\t\tsquare--;break; // ]\n\t\t\t\t\tcase 0x7B:\n\t\t\t\t\t\tcurly++;break; // {\n\t\t\t\t\tcase 0x7D:\n\t\t\t\t\t\tcurly--;break; // }\n\t\t\t\t}\n\t\t\t\tif (c === 0x2f) {\n\t\t\t\t\t// /\n\t\t\t\t\tvar j = i - 1;\n\t\t\t\t\tvar p = void 0;\n\t\t\t\t\t// find first non-whitespace prev char\n\t\t\t\t\tfor (; j >= 0; j--) {\n\t\t\t\t\t\tp = exp.charAt(j);\n\t\t\t\t\t\tif (p !== ' ') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!p || !validDivisionCharRE.test(p)) {\n\t\t\t\t\t\tinRegex = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (expression === undefined) {\n\t\t\texpression = exp.slice(0, i).trim();\n\t\t} else if (lastFilterIndex !== 0) {\n\t\t\tpushFilter();\n\t\t}\n\n\t\tfunction pushFilter() {\n\t\t\t(filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n\t\t\tlastFilterIndex = i + 1;\n\t\t}\n\n\t\tif (filters) {\n\t\t\tfor (i = 0; i < filters.length; i++) {\n\t\t\t\texpression = wrapFilter(expression, filters[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn expression;\n\t}\n\n\tfunction wrapFilter(exp, filter) {\n\t\tvar i = filter.indexOf('(');\n\t\tif (i < 0) {\n\t\t\t// _f: resolveFilter\n\t\t\treturn \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n\t\t} else {\n\t\t\tvar name = filter.slice(0, i);\n\t\t\tvar args = filter.slice(i + 1);\n\t\t\treturn \"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args;\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction baseWarn(msg) {\n\t\tconsole.error(\"[Vue compiler]: \" + msg);\n\t}\n\n\tfunction pluckModuleFunction(modules, key) {\n\t\treturn modules ? modules.map(function (m) {\n\t\t\treturn m[key];\n\t\t}).filter(function (_) {\n\t\t\treturn _;\n\t\t}) : [];\n\t}\n\n\tfunction addProp(el, name, value) {\n\t\t(el.props || (el.props = [])).push({ name: name, value: value });\n\t}\n\n\tfunction addAttr(el, name, value) {\n\t\t(el.attrs || (el.attrs = [])).push({ name: name, value: value });\n\t}\n\n\tfunction addDirective(el, name, rawName, value, arg, modifiers) {\n\t\t(el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n\t}\n\n\tfunction addHandler(el, name, value, modifiers, important, warn) {\n\t\t// warn prevent and passive modifier\n\t\t/* istanbul ignore if */\n\t\tif (\"development\" !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {\n\t\t\twarn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.');\n\t\t}\n\t\t// check capture modifier\n\t\tif (modifiers && modifiers.capture) {\n\t\t\tdelete modifiers.capture;\n\t\t\tname = '!' + name; // mark the event as captured\n\t\t}\n\t\tif (modifiers && modifiers.once) {\n\t\t\tdelete modifiers.once;\n\t\t\tname = '~' + name; // mark the event as once\n\t\t}\n\t\t/* istanbul ignore if */\n\t\tif (modifiers && modifiers.passive) {\n\t\t\tdelete modifiers.passive;\n\t\t\tname = '&' + name; // mark the event as passive\n\t\t}\n\t\tvar events;\n\t\tif (modifiers && modifiers.native) {\n\t\t\tdelete modifiers.native;\n\t\t\tevents = el.nativeEvents || (el.nativeEvents = {});\n\t\t} else {\n\t\t\tevents = el.events || (el.events = {});\n\t\t}\n\t\tvar newHandler = { value: value, modifiers: modifiers };\n\t\tvar handlers = events[name];\n\t\t/* istanbul ignore if */\n\t\tif (Array.isArray(handlers)) {\n\t\t\timportant ? handlers.unshift(newHandler) : handlers.push(newHandler);\n\t\t} else if (handlers) {\n\t\t\tevents[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n\t\t} else {\n\t\t\tevents[name] = newHandler;\n\t\t}\n\t}\n\n\tfunction getBindingAttr(el, name, getStatic) {\n\t\tvar dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\t\tif (dynamicValue != null) {\n\t\t\treturn parseFilters(dynamicValue);\n\t\t} else if (getStatic !== false) {\n\t\t\tvar staticValue = getAndRemoveAttr(el, name);\n\t\t\tif (staticValue != null) {\n\t\t\t\treturn JSON.stringify(staticValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction getAndRemoveAttr(el, name) {\n\t\tvar val;\n\t\tif ((val = el.attrsMap[name]) != null) {\n\t\t\tvar list = el.attrsList;\n\t\t\tfor (var i = 0, l = list.length; i < l; i++) {\n\t\t\t\tif (list[i].name === name) {\n\t\t\t\t\tlist.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn val;\n\t}\n\n\t/*  */\n\n\t/**\n  * Cross-platform code generation for component v-model\n  */\n\tfunction genComponentModel(el, value, modifiers) {\n\t\tvar ref = modifiers || {};\n\t\tvar number = ref.number;\n\t\tvar trim = ref.trim;\n\n\t\tvar baseValueExpression = '$$v';\n\t\tvar valueExpression = baseValueExpression;\n\t\tif (trim) {\n\t\t\tvalueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n\t\t}\n\t\tif (number) {\n\t\t\tvalueExpression = \"_n(\" + valueExpression + \")\";\n\t\t}\n\t\tvar assignment = genAssignmentCode(value, valueExpression);\n\n\t\tel.model = {\n\t\t\tvalue: \"(\" + value + \")\",\n\t\t\texpression: \"\\\"\" + value + \"\\\"\",\n\t\t\tcallback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n\t\t};\n\t}\n\n\t/**\n  * Cross-platform codegen helper for generating v-model value assignment code.\n  */\n\tfunction genAssignmentCode(value, assignment) {\n\t\tvar modelRs = parseModel(value);\n\t\tif (modelRs.idx === null) {\n\t\t\treturn value + \"=\" + assignment;\n\t\t} else {\n\t\t\treturn \"var $$exp = \" + modelRs.exp + \", $$idx = \" + modelRs.idx + \";\" + \"if (!Array.isArray($$exp)){\" + value + \"=\" + assignment + \"}\" + \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\";\n\t\t}\n\t}\n\n\t/**\n  * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n  *\n  * for loop possible cases:\n  *\n  * - test\n  * - test[idx]\n  * - test[test1[idx]]\n  * - test[\"a\"][idx]\n  * - xxx.test[a[a].test1[idx]]\n  * - test.xxx.a[\"asa\"][test1[idx]]\n  *\n  */\n\n\tvar len;\n\tvar str;\n\tvar chr;\n\tvar index$1;\n\tvar expressionPos;\n\tvar expressionEndPos;\n\n\tfunction parseModel(val) {\n\t\tstr = val;\n\t\tlen = str.length;\n\t\tindex$1 = expressionPos = expressionEndPos = 0;\n\n\t\tif (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n\t\t\treturn {\n\t\t\t\texp: val,\n\t\t\t\tidx: null\n\t\t\t};\n\t\t}\n\n\t\twhile (!eof()) {\n\t\t\tchr = next();\n\t\t\t/* istanbul ignore if */\n\t\t\tif (isStringStart(chr)) {\n\t\t\t\tparseString(chr);\n\t\t\t} else if (chr === 0x5B) {\n\t\t\t\tparseBracket(chr);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\texp: val.substring(0, expressionPos),\n\t\t\tidx: val.substring(expressionPos + 1, expressionEndPos)\n\t\t};\n\t}\n\n\tfunction next() {\n\t\treturn str.charCodeAt(++index$1);\n\t}\n\n\tfunction eof() {\n\t\treturn index$1 >= len;\n\t}\n\n\tfunction isStringStart(chr) {\n\t\treturn chr === 0x22 || chr === 0x27;\n\t}\n\n\tfunction parseBracket(chr) {\n\t\tvar inBracket = 1;\n\t\texpressionPos = index$1;\n\t\twhile (!eof()) {\n\t\t\tchr = next();\n\t\t\tif (isStringStart(chr)) {\n\t\t\t\tparseString(chr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (chr === 0x5B) {\n\t\t\t\tinBracket++;\n\t\t\t}\n\t\t\tif (chr === 0x5D) {\n\t\t\t\tinBracket--;\n\t\t\t}\n\t\t\tif (inBracket === 0) {\n\t\t\t\texpressionEndPos = index$1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseString(chr) {\n\t\tvar stringQuote = chr;\n\t\twhile (!eof()) {\n\t\t\tchr = next();\n\t\t\tif (chr === stringQuote) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar warn$1;\n\n\t// in some cases, the event used has to be determined at runtime\n\t// so we used some reserved tokens during compile.\n\tvar RANGE_TOKEN = '__r';\n\tvar CHECKBOX_RADIO_TOKEN = '__c';\n\n\tfunction model(el, dir, _warn) {\n\t\twarn$1 = _warn;\n\t\tvar value = dir.value;\n\t\tvar modifiers = dir.modifiers;\n\t\tvar tag = el.tag;\n\t\tvar type = el.attrsMap.type;\n\n\t\t{\n\t\t\tvar dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\t\t\tif (tag === 'input' && dynamicType) {\n\t\t\t\twarn$1(\"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" + \"v-model does not support dynamic input types. Use v-if branches instead.\");\n\t\t\t}\n\t\t\t// inputs with type=\"file\" are read only and setting the input's\n\t\t\t// value will throw an error.\n\t\t\tif (tag === 'input' && type === 'file') {\n\t\t\t\twarn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\");\n\t\t\t}\n\t\t}\n\n\t\tif (tag === 'select') {\n\t\t\tgenSelect(el, value, modifiers);\n\t\t} else if (tag === 'input' && type === 'checkbox') {\n\t\t\tgenCheckboxModel(el, value, modifiers);\n\t\t} else if (tag === 'input' && type === 'radio') {\n\t\t\tgenRadioModel(el, value, modifiers);\n\t\t} else if (tag === 'input' || tag === 'textarea') {\n\t\t\tgenDefaultModel(el, value, modifiers);\n\t\t} else if (!config.isReservedTag(tag)) {\n\t\t\tgenComponentModel(el, value, modifiers);\n\t\t\t// component v-model doesn't need extra runtime\n\t\t\treturn false;\n\t\t} else {\n\t\t\twarn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');\n\t\t}\n\n\t\t// ensure runtime directive metadata\n\t\treturn true;\n\t}\n\n\tfunction genCheckboxModel(el, value, modifiers) {\n\t\tvar number = modifiers && modifiers.number;\n\t\tvar valueBinding = getBindingAttr(el, 'value') || 'null';\n\t\tvar trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n\t\tvar falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n\t\taddProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n\t\taddHandler(el, CHECKBOX_RADIO_TOKEN, \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" + \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n\t}\n\n\tfunction genRadioModel(el, value, modifiers) {\n\t\tvar number = modifiers && modifiers.number;\n\t\tvar valueBinding = getBindingAttr(el, 'value') || 'null';\n\t\tvalueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n\t\taddProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n\t\taddHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n\t}\n\n\tfunction genSelect(el, value, modifiers) {\n\t\tvar number = modifiers && modifiers.number;\n\t\tvar selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n\t\tvar assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n\t\tvar code = \"var $$selectedVal = \" + selectedVal + \";\";\n\t\tcode = code + \" \" + genAssignmentCode(value, assignment);\n\t\taddHandler(el, 'change', code, null, true);\n\t}\n\n\tfunction genDefaultModel(el, value, modifiers) {\n\t\tvar type = el.attrsMap.type;\n\t\tvar ref = modifiers || {};\n\t\tvar lazy = ref.lazy;\n\t\tvar number = ref.number;\n\t\tvar trim = ref.trim;\n\t\tvar needCompositionGuard = !lazy && type !== 'range';\n\t\tvar event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n\n\t\tvar valueExpression = '$event.target.value';\n\t\tif (trim) {\n\t\t\tvalueExpression = \"$event.target.value.trim()\";\n\t\t}\n\t\tif (number) {\n\t\t\tvalueExpression = \"_n(\" + valueExpression + \")\";\n\t\t}\n\n\t\tvar code = genAssignmentCode(value, valueExpression);\n\t\tif (needCompositionGuard) {\n\t\t\tcode = \"if($event.target.composing)return;\" + code;\n\t\t}\n\n\t\taddProp(el, 'value', \"(\" + value + \")\");\n\t\taddHandler(el, event, code, null, true);\n\t\tif (trim || number || type === 'number') {\n\t\t\taddHandler(el, 'blur', '$forceUpdate()');\n\t\t}\n\t}\n\n\t/*  */\n\n\t// normalize v-model event tokens that can only be determined at runtime.\n\t// it's important to place the event as the first in the array because\n\t// the whole point is ensuring the v-model callback gets called before\n\t// user-attached handlers.\n\tfunction normalizeEvents(on) {\n\t\tvar event;\n\t\t/* istanbul ignore if */\n\t\tif (isDef(on[RANGE_TOKEN])) {\n\t\t\t// IE input[type=range] only supports `change` event\n\t\t\tevent = isIE ? 'change' : 'input';\n\t\t\ton[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n\t\t\tdelete on[RANGE_TOKEN];\n\t\t}\n\t\tif (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n\t\t\t// Chrome fires microtasks in between click/change, leads to #4521\n\t\t\tevent = isChrome ? 'click' : 'change';\n\t\t\ton[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n\t\t\tdelete on[CHECKBOX_RADIO_TOKEN];\n\t\t}\n\t}\n\n\tvar target$1;\n\n\tfunction add$1(event, _handler, once$$1, capture, passive) {\n\t\tif (once$$1) {\n\t\t\tvar oldHandler = _handler;\n\t\t\tvar _target = target$1; // save current target element in closure\n\t\t\t_handler = function handler(ev) {\n\t\t\t\tvar res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);\n\t\t\t\tif (res !== null) {\n\t\t\t\t\tremove$2(event, _handler, capture, _target);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\ttarget$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n\t}\n\n\tfunction remove$2(event, handler, capture, _target) {\n\t\t(_target || target$1).removeEventListener(event, handler, capture);\n\t}\n\n\tfunction updateDOMListeners(oldVnode, vnode) {\n\t\tif (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n\t\t\treturn;\n\t\t}\n\t\tvar on = vnode.data.on || {};\n\t\tvar oldOn = oldVnode.data.on || {};\n\t\ttarget$1 = vnode.elm;\n\t\tnormalizeEvents(on);\n\t\tupdateListeners(on, oldOn, add$1, remove$2, vnode.context);\n\t}\n\n\tvar events = {\n\t\tcreate: updateDOMListeners,\n\t\tupdate: updateDOMListeners\n\t};\n\n\t/*  */\n\n\tfunction updateDOMProps(oldVnode, vnode) {\n\t\tif (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n\t\t\treturn;\n\t\t}\n\t\tvar key, cur;\n\t\tvar elm = vnode.elm;\n\t\tvar oldProps = oldVnode.data.domProps || {};\n\t\tvar props = vnode.data.domProps || {};\n\t\t// clone observed objects, as the user probably wants to mutate it\n\t\tif (isDef(props.__ob__)) {\n\t\t\tprops = vnode.data.domProps = extend({}, props);\n\t\t}\n\n\t\tfor (key in oldProps) {\n\t\t\tif (isUndef(props[key])) {\n\t\t\t\telm[key] = '';\n\t\t\t}\n\t\t}\n\t\tfor (key in props) {\n\t\t\tcur = props[key];\n\t\t\t// ignore children if the node has textContent or innerHTML,\n\t\t\t// as these will throw away existing DOM nodes and cause removal errors\n\t\t\t// on subsequent patches (#3360)\n\t\t\tif (key === 'textContent' || key === 'innerHTML') {\n\t\t\t\tif (vnode.children) {\n\t\t\t\t\tvnode.children.length = 0;\n\t\t\t\t}\n\t\t\t\tif (cur === oldProps[key]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (key === 'value') {\n\t\t\t\t// store value as _value as well since\n\t\t\t\t// non-string values will be stringified\n\t\t\t\telm._value = cur;\n\t\t\t\t// avoid resetting cursor position when value is the same\n\t\t\t\tvar strCur = isUndef(cur) ? '' : String(cur);\n\t\t\t\tif (shouldUpdateValue(elm, vnode, strCur)) {\n\t\t\t\t\telm.value = strCur;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telm[key] = cur;\n\t\t\t}\n\t\t}\n\t}\n\n\t// check platforms/web/util/attrs.js acceptValue\n\n\n\tfunction shouldUpdateValue(elm, vnode, checkVal) {\n\t\treturn !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));\n\t}\n\n\tfunction isDirty(elm, checkVal) {\n\t\t// return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n\t\treturn document.activeElement !== elm && elm.value !== checkVal;\n\t}\n\n\tfunction isInputChanged(elm, newVal) {\n\t\tvar value = elm.value;\n\t\tvar modifiers = elm._vModifiers; // injected by v-model runtime\n\t\tif (isDef(modifiers) && modifiers.number || elm.type === 'number') {\n\t\t\treturn toNumber(value) !== toNumber(newVal);\n\t\t}\n\t\tif (isDef(modifiers) && modifiers.trim) {\n\t\t\treturn value.trim() !== newVal.trim();\n\t\t}\n\t\treturn value !== newVal;\n\t}\n\n\tvar domProps = {\n\t\tcreate: updateDOMProps,\n\t\tupdate: updateDOMProps\n\t};\n\n\t/*  */\n\n\tvar parseStyleText = cached(function (cssText) {\n\t\tvar res = {};\n\t\tvar listDelimiter = /;(?![^(]*\\))/g;\n\t\tvar propertyDelimiter = /:(.+)/;\n\t\tcssText.split(listDelimiter).forEach(function (item) {\n\t\t\tif (item) {\n\t\t\t\tvar tmp = item.split(propertyDelimiter);\n\t\t\t\ttmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n\t\t\t}\n\t\t});\n\t\treturn res;\n\t});\n\n\t// merge static and dynamic style data on the same vnode\n\tfunction normalizeStyleData(data) {\n\t\tvar style = normalizeStyleBinding(data.style);\n\t\t// static style is pre-processed into an object during compilation\n\t\t// and is always a fresh object, so it's safe to merge into it\n\t\treturn data.staticStyle ? extend(data.staticStyle, style) : style;\n\t}\n\n\t// normalize possible array / string values into Object\n\tfunction normalizeStyleBinding(bindingStyle) {\n\t\tif (Array.isArray(bindingStyle)) {\n\t\t\treturn toObject(bindingStyle);\n\t\t}\n\t\tif (typeof bindingStyle === 'string') {\n\t\t\treturn parseStyleText(bindingStyle);\n\t\t}\n\t\treturn bindingStyle;\n\t}\n\n\t/**\n  * parent component style should be after child's\n  * so that parent component's style could override it\n  */\n\tfunction getStyle(vnode, checkChild) {\n\t\tvar res = {};\n\t\tvar styleData;\n\n\t\tif (checkChild) {\n\t\t\tvar childNode = vnode;\n\t\t\twhile (childNode.componentInstance) {\n\t\t\t\tchildNode = childNode.componentInstance._vnode;\n\t\t\t\tif (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n\t\t\t\t\textend(res, styleData);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (styleData = normalizeStyleData(vnode.data)) {\n\t\t\textend(res, styleData);\n\t\t}\n\n\t\tvar parentNode = vnode;\n\t\twhile (parentNode = parentNode.parent) {\n\t\t\tif (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n\t\t\t\textend(res, styleData);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tvar cssVarRE = /^--/;\n\tvar importantRE = /\\s*!important$/;\n\tvar setProp = function setProp(el, name, val) {\n\t\t/* istanbul ignore if */\n\t\tif (cssVarRE.test(name)) {\n\t\t\tel.style.setProperty(name, val);\n\t\t} else if (importantRE.test(val)) {\n\t\t\tel.style.setProperty(name, val.replace(importantRE, ''), 'important');\n\t\t} else {\n\t\t\tvar normalizedName = normalize(name);\n\t\t\tif (Array.isArray(val)) {\n\t\t\t\t// Support values array created by autoprefixer, e.g.\n\t\t\t\t// {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n\t\t\t\t// Set them one by one, and the browser will only set those it can recognize\n\t\t\t\tfor (var i = 0, len = val.length; i < len; i++) {\n\t\t\t\t\tel.style[normalizedName] = val[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tel.style[normalizedName] = val;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar prefixes = ['Webkit', 'Moz', 'ms'];\n\n\tvar testEl;\n\tvar normalize = cached(function (prop) {\n\t\ttestEl = testEl || document.createElement('div');\n\t\tprop = camelize(prop);\n\t\tif (prop !== 'filter' && prop in testEl.style) {\n\t\t\treturn prop;\n\t\t}\n\t\tvar upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n\t\tfor (var i = 0; i < prefixes.length; i++) {\n\t\t\tvar prefixed = prefixes[i] + upper;\n\t\t\tif (prefixed in testEl.style) {\n\t\t\t\treturn prefixed;\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction updateStyle(oldVnode, vnode) {\n\t\tvar data = vnode.data;\n\t\tvar oldData = oldVnode.data;\n\n\t\tif (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar cur, name;\n\t\tvar el = vnode.elm;\n\t\tvar oldStaticStyle = oldData.staticStyle;\n\t\tvar oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n\t\t// if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\t\tvar oldStyle = oldStaticStyle || oldStyleBinding;\n\n\t\tvar style = normalizeStyleBinding(vnode.data.style) || {};\n\n\t\t// store normalized style under a different key for next diff\n\t\t// make sure to clone it if it's reactive, since the user likley wants\n\t\t// to mutate it.\n\t\tvnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n\n\t\tvar newStyle = getStyle(vnode, true);\n\n\t\tfor (name in oldStyle) {\n\t\t\tif (isUndef(newStyle[name])) {\n\t\t\t\tsetProp(el, name, '');\n\t\t\t}\n\t\t}\n\t\tfor (name in newStyle) {\n\t\t\tcur = newStyle[name];\n\t\t\tif (cur !== oldStyle[name]) {\n\t\t\t\t// ie9 setting to null has no effect, must use empty string\n\t\t\t\tsetProp(el, name, cur == null ? '' : cur);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar style = {\n\t\tcreate: updateStyle,\n\t\tupdate: updateStyle\n\t};\n\n\t/*  */\n\n\t/**\n  * Add class with compatibility for SVG since classList is not supported on\n  * SVG elements in IE\n  */\n\tfunction addClass(el, cls) {\n\t\t/* istanbul ignore if */\n\t\tif (!cls || !(cls = cls.trim())) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* istanbul ignore else */\n\t\tif (el.classList) {\n\t\t\tif (cls.indexOf(' ') > -1) {\n\t\t\t\tcls.split(/\\s+/).forEach(function (c) {\n\t\t\t\t\treturn el.classList.add(c);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tel.classList.add(cls);\n\t\t\t}\n\t\t} else {\n\t\t\tvar cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\t\t\tif (cur.indexOf(' ' + cls + ' ') < 0) {\n\t\t\t\tel.setAttribute('class', (cur + cls).trim());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Remove class with compatibility for SVG since classList is not supported on\n  * SVG elements in IE\n  */\n\tfunction removeClass(el, cls) {\n\t\t/* istanbul ignore if */\n\t\tif (!cls || !(cls = cls.trim())) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* istanbul ignore else */\n\t\tif (el.classList) {\n\t\t\tif (cls.indexOf(' ') > -1) {\n\t\t\t\tcls.split(/\\s+/).forEach(function (c) {\n\t\t\t\t\treturn el.classList.remove(c);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tel.classList.remove(cls);\n\t\t\t}\n\t\t} else {\n\t\t\tvar cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\t\t\tvar tar = ' ' + cls + ' ';\n\t\t\twhile (cur.indexOf(tar) >= 0) {\n\t\t\t\tcur = cur.replace(tar, ' ');\n\t\t\t}\n\t\t\tel.setAttribute('class', cur.trim());\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction resolveTransition(def$$1) {\n\t\tif (!def$$1) {\n\t\t\treturn;\n\t\t}\n\t\t/* istanbul ignore else */\n\t\tif ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {\n\t\t\tvar res = {};\n\t\t\tif (def$$1.css !== false) {\n\t\t\t\textend(res, autoCssTransition(def$$1.name || 'v'));\n\t\t\t}\n\t\t\textend(res, def$$1);\n\t\t\treturn res;\n\t\t} else if (typeof def$$1 === 'string') {\n\t\t\treturn autoCssTransition(def$$1);\n\t\t}\n\t}\n\n\tvar autoCssTransition = cached(function (name) {\n\t\treturn {\n\t\t\tenterClass: name + \"-enter\",\n\t\t\tenterToClass: name + \"-enter-to\",\n\t\t\tenterActiveClass: name + \"-enter-active\",\n\t\t\tleaveClass: name + \"-leave\",\n\t\t\tleaveToClass: name + \"-leave-to\",\n\t\t\tleaveActiveClass: name + \"-leave-active\"\n\t\t};\n\t});\n\n\tvar hasTransition = inBrowser && !isIE9;\n\tvar TRANSITION = 'transition';\n\tvar ANIMATION = 'animation';\n\n\t// Transition property/event sniffing\n\tvar transitionProp = 'transition';\n\tvar transitionEndEvent = 'transitionend';\n\tvar animationProp = 'animation';\n\tvar animationEndEvent = 'animationend';\n\tif (hasTransition) {\n\t\t/* istanbul ignore if */\n\t\tif (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n\t\t\ttransitionProp = 'WebkitTransition';\n\t\t\ttransitionEndEvent = 'webkitTransitionEnd';\n\t\t}\n\t\tif (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n\t\t\tanimationProp = 'WebkitAnimation';\n\t\t\tanimationEndEvent = 'webkitAnimationEnd';\n\t\t}\n\t}\n\n\t// binding to window is necessary to make hot reload work in IE in strict mode\n\tvar raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;\n\n\tfunction nextFrame(fn) {\n\t\traf(function () {\n\t\t\traf(fn);\n\t\t});\n\t}\n\n\tfunction addTransitionClass(el, cls) {\n\t\t(el._transitionClasses || (el._transitionClasses = [])).push(cls);\n\t\taddClass(el, cls);\n\t}\n\n\tfunction removeTransitionClass(el, cls) {\n\t\tif (el._transitionClasses) {\n\t\t\tremove(el._transitionClasses, cls);\n\t\t}\n\t\tremoveClass(el, cls);\n\t}\n\n\tfunction whenTransitionEnds(el, expectedType, cb) {\n\t\tvar ref = getTransitionInfo(el, expectedType);\n\t\tvar type = ref.type;\n\t\tvar timeout = ref.timeout;\n\t\tvar propCount = ref.propCount;\n\t\tif (!type) {\n\t\t\treturn cb();\n\t\t}\n\t\tvar event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n\t\tvar ended = 0;\n\t\tvar end = function end() {\n\t\t\tel.removeEventListener(event, onEnd);\n\t\t\tcb();\n\t\t};\n\t\tvar onEnd = function onEnd(e) {\n\t\t\tif (e.target === el) {\n\t\t\t\tif (++ended >= propCount) {\n\t\t\t\t\tend();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tsetTimeout(function () {\n\t\t\tif (ended < propCount) {\n\t\t\t\tend();\n\t\t\t}\n\t\t}, timeout + 1);\n\t\tel.addEventListener(event, onEnd);\n\t}\n\n\tvar transformRE = /\\b(transform|all)(,|$)/;\n\n\tfunction getTransitionInfo(el, expectedType) {\n\t\tvar styles = window.getComputedStyle(el);\n\t\tvar transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n\t\tvar transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n\t\tvar transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n\t\tvar animationDelays = styles[animationProp + 'Delay'].split(', ');\n\t\tvar animationDurations = styles[animationProp + 'Duration'].split(', ');\n\t\tvar animationTimeout = getTimeout(animationDelays, animationDurations);\n\n\t\tvar type;\n\t\tvar timeout = 0;\n\t\tvar propCount = 0;\n\t\t/* istanbul ignore if */\n\t\tif (expectedType === TRANSITION) {\n\t\t\tif (transitionTimeout > 0) {\n\t\t\t\ttype = TRANSITION;\n\t\t\t\ttimeout = transitionTimeout;\n\t\t\t\tpropCount = transitionDurations.length;\n\t\t\t}\n\t\t} else if (expectedType === ANIMATION) {\n\t\t\tif (animationTimeout > 0) {\n\t\t\t\ttype = ANIMATION;\n\t\t\t\ttimeout = animationTimeout;\n\t\t\t\tpropCount = animationDurations.length;\n\t\t\t}\n\t\t} else {\n\t\t\ttimeout = Math.max(transitionTimeout, animationTimeout);\n\t\t\ttype = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n\t\t\tpropCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n\t\t}\n\t\tvar hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n\t\treturn {\n\t\t\ttype: type,\n\t\t\ttimeout: timeout,\n\t\t\tpropCount: propCount,\n\t\t\thasTransform: hasTransform\n\t\t};\n\t}\n\n\tfunction getTimeout(delays, durations) {\n\t\t/* istanbul ignore next */\n\t\twhile (delays.length < durations.length) {\n\t\t\tdelays = delays.concat(delays);\n\t\t}\n\n\t\treturn Math.max.apply(null, durations.map(function (d, i) {\n\t\t\treturn toMs(d) + toMs(delays[i]);\n\t\t}));\n\t}\n\n\tfunction toMs(s) {\n\t\treturn Number(s.slice(0, -1)) * 1000;\n\t}\n\n\t/*  */\n\n\tfunction enter(vnode, toggleDisplay) {\n\t\tvar el = vnode.elm;\n\n\t\t// call leave callback now\n\t\tif (isDef(el._leaveCb)) {\n\t\t\tel._leaveCb.cancelled = true;\n\t\t\tel._leaveCb();\n\t\t}\n\n\t\tvar data = resolveTransition(vnode.data.transition);\n\t\tif (isUndef(data)) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* istanbul ignore if */\n\t\tif (isDef(el._enterCb) || el.nodeType !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar css = data.css;\n\t\tvar type = data.type;\n\t\tvar enterClass = data.enterClass;\n\t\tvar enterToClass = data.enterToClass;\n\t\tvar enterActiveClass = data.enterActiveClass;\n\t\tvar appearClass = data.appearClass;\n\t\tvar appearToClass = data.appearToClass;\n\t\tvar appearActiveClass = data.appearActiveClass;\n\t\tvar beforeEnter = data.beforeEnter;\n\t\tvar enter = data.enter;\n\t\tvar afterEnter = data.afterEnter;\n\t\tvar enterCancelled = data.enterCancelled;\n\t\tvar beforeAppear = data.beforeAppear;\n\t\tvar appear = data.appear;\n\t\tvar afterAppear = data.afterAppear;\n\t\tvar appearCancelled = data.appearCancelled;\n\t\tvar duration = data.duration;\n\n\t\t// activeInstance will always be the <transition> component managing this\n\t\t// transition. One edge case to check is when the <transition> is placed\n\t\t// as the root node of a child component. In that case we need to check\n\t\t// <transition>'s parent for appear check.\n\t\tvar context = activeInstance;\n\t\tvar transitionNode = activeInstance.$vnode;\n\t\twhile (transitionNode && transitionNode.parent) {\n\t\t\ttransitionNode = transitionNode.parent;\n\t\t\tcontext = transitionNode.context;\n\t\t}\n\n\t\tvar isAppear = !context._isMounted || !vnode.isRootInsert;\n\n\t\tif (isAppear && !appear && appear !== '') {\n\t\t\treturn;\n\t\t}\n\n\t\tvar startClass = isAppear && appearClass ? appearClass : enterClass;\n\t\tvar activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n\t\tvar toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n\t\tvar beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n\t\tvar enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n\t\tvar afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n\t\tvar enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n\t\tvar explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n\t\tif (\"development\" !== 'production' && explicitEnterDuration != null) {\n\t\t\tcheckDuration(explicitEnterDuration, 'enter', vnode);\n\t\t}\n\n\t\tvar expectsCSS = css !== false && !isIE9;\n\t\tvar userWantsControl = getHookArgumentsLength(enterHook);\n\n\t\tvar cb = el._enterCb = once(function () {\n\t\t\tif (expectsCSS) {\n\t\t\t\tremoveTransitionClass(el, toClass);\n\t\t\t\tremoveTransitionClass(el, activeClass);\n\t\t\t}\n\t\t\tif (cb.cancelled) {\n\t\t\t\tif (expectsCSS) {\n\t\t\t\t\tremoveTransitionClass(el, startClass);\n\t\t\t\t}\n\t\t\t\tenterCancelledHook && enterCancelledHook(el);\n\t\t\t} else {\n\t\t\t\tafterEnterHook && afterEnterHook(el);\n\t\t\t}\n\t\t\tel._enterCb = null;\n\t\t});\n\n\t\tif (!vnode.data.show) {\n\t\t\t// remove pending leave element on enter by injecting an insert hook\n\t\t\tmergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n\t\t\t\tvar parent = el.parentNode;\n\t\t\t\tvar pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\t\t\t\tif (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n\t\t\t\t\tpendingNode.elm._leaveCb();\n\t\t\t\t}\n\t\t\t\tenterHook && enterHook(el, cb);\n\t\t\t});\n\t\t}\n\n\t\t// start enter transition\n\t\tbeforeEnterHook && beforeEnterHook(el);\n\t\tif (expectsCSS) {\n\t\t\taddTransitionClass(el, startClass);\n\t\t\taddTransitionClass(el, activeClass);\n\t\t\tnextFrame(function () {\n\t\t\t\taddTransitionClass(el, toClass);\n\t\t\t\tremoveTransitionClass(el, startClass);\n\t\t\t\tif (!cb.cancelled && !userWantsControl) {\n\t\t\t\t\tif (isValidDuration(explicitEnterDuration)) {\n\t\t\t\t\t\tsetTimeout(cb, explicitEnterDuration);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhenTransitionEnds(el, type, cb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (vnode.data.show) {\n\t\t\ttoggleDisplay && toggleDisplay();\n\t\t\tenterHook && enterHook(el, cb);\n\t\t}\n\n\t\tif (!expectsCSS && !userWantsControl) {\n\t\t\tcb();\n\t\t}\n\t}\n\n\tfunction leave(vnode, rm) {\n\t\tvar el = vnode.elm;\n\n\t\t// call enter callback now\n\t\tif (isDef(el._enterCb)) {\n\t\t\tel._enterCb.cancelled = true;\n\t\t\tel._enterCb();\n\t\t}\n\n\t\tvar data = resolveTransition(vnode.data.transition);\n\t\tif (isUndef(data)) {\n\t\t\treturn rm();\n\t\t}\n\n\t\t/* istanbul ignore if */\n\t\tif (isDef(el._leaveCb) || el.nodeType !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar css = data.css;\n\t\tvar type = data.type;\n\t\tvar leaveClass = data.leaveClass;\n\t\tvar leaveToClass = data.leaveToClass;\n\t\tvar leaveActiveClass = data.leaveActiveClass;\n\t\tvar beforeLeave = data.beforeLeave;\n\t\tvar leave = data.leave;\n\t\tvar afterLeave = data.afterLeave;\n\t\tvar leaveCancelled = data.leaveCancelled;\n\t\tvar delayLeave = data.delayLeave;\n\t\tvar duration = data.duration;\n\n\t\tvar expectsCSS = css !== false && !isIE9;\n\t\tvar userWantsControl = getHookArgumentsLength(leave);\n\n\t\tvar explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n\t\tif (\"development\" !== 'production' && isDef(explicitLeaveDuration)) {\n\t\t\tcheckDuration(explicitLeaveDuration, 'leave', vnode);\n\t\t}\n\n\t\tvar cb = el._leaveCb = once(function () {\n\t\t\tif (el.parentNode && el.parentNode._pending) {\n\t\t\t\tel.parentNode._pending[vnode.key] = null;\n\t\t\t}\n\t\t\tif (expectsCSS) {\n\t\t\t\tremoveTransitionClass(el, leaveToClass);\n\t\t\t\tremoveTransitionClass(el, leaveActiveClass);\n\t\t\t}\n\t\t\tif (cb.cancelled) {\n\t\t\t\tif (expectsCSS) {\n\t\t\t\t\tremoveTransitionClass(el, leaveClass);\n\t\t\t\t}\n\t\t\t\tleaveCancelled && leaveCancelled(el);\n\t\t\t} else {\n\t\t\t\trm();\n\t\t\t\tafterLeave && afterLeave(el);\n\t\t\t}\n\t\t\tel._leaveCb = null;\n\t\t});\n\n\t\tif (delayLeave) {\n\t\t\tdelayLeave(performLeave);\n\t\t} else {\n\t\t\tperformLeave();\n\t\t}\n\n\t\tfunction performLeave() {\n\t\t\t// the delayed leave may have already been cancelled\n\t\t\tif (cb.cancelled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// record leaving element\n\t\t\tif (!vnode.data.show) {\n\t\t\t\t(el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n\t\t\t}\n\t\t\tbeforeLeave && beforeLeave(el);\n\t\t\tif (expectsCSS) {\n\t\t\t\taddTransitionClass(el, leaveClass);\n\t\t\t\taddTransitionClass(el, leaveActiveClass);\n\t\t\t\tnextFrame(function () {\n\t\t\t\t\taddTransitionClass(el, leaveToClass);\n\t\t\t\t\tremoveTransitionClass(el, leaveClass);\n\t\t\t\t\tif (!cb.cancelled && !userWantsControl) {\n\t\t\t\t\t\tif (isValidDuration(explicitLeaveDuration)) {\n\t\t\t\t\t\t\tsetTimeout(cb, explicitLeaveDuration);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhenTransitionEnds(el, type, cb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tleave && leave(el, cb);\n\t\t\tif (!expectsCSS && !userWantsControl) {\n\t\t\t\tcb();\n\t\t\t}\n\t\t}\n\t}\n\n\t// only used in dev mode\n\tfunction checkDuration(val, name, vnode) {\n\t\tif (typeof val !== 'number') {\n\t\t\twarn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n\t\t} else if (isNaN(val)) {\n\t\t\twarn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n\t\t}\n\t}\n\n\tfunction isValidDuration(val) {\n\t\treturn typeof val === 'number' && !isNaN(val);\n\t}\n\n\t/**\n  * Normalize a transition hook's argument length. The hook may be:\n  * - a merged hook (invoker) with the original in .fns\n  * - a wrapped component method (check ._length)\n  * - a plain function (.length)\n  */\n\tfunction getHookArgumentsLength(fn) {\n\t\tif (isUndef(fn)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar invokerFns = fn.fns;\n\t\tif (isDef(invokerFns)) {\n\t\t\t// invoker\n\t\t\treturn getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n\t\t} else {\n\t\t\treturn (fn._length || fn.length) > 1;\n\t\t}\n\t}\n\n\tfunction _enter(_, vnode) {\n\t\tif (vnode.data.show !== true) {\n\t\t\tenter(vnode);\n\t\t}\n\t}\n\n\tvar transition = inBrowser ? {\n\t\tcreate: _enter,\n\t\tactivate: _enter,\n\t\tremove: function remove$$1(vnode, rm) {\n\t\t\t/* istanbul ignore else */\n\t\t\tif (vnode.data.show !== true) {\n\t\t\t\tleave(vnode, rm);\n\t\t\t} else {\n\t\t\t\trm();\n\t\t\t}\n\t\t}\n\t} : {};\n\n\tvar platformModules = [attrs, klass, events, domProps, style, transition];\n\n\t/*  */\n\n\t// the directive module should be applied last, after all\n\t// built-in modules have been applied.\n\tvar modules = platformModules.concat(baseModules);\n\n\tvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n\t/**\n  * Not type checking this file because flow doesn't like attaching\n  * properties to Elements.\n  */\n\n\t/* istanbul ignore if */\n\tif (isIE9) {\n\t\t// http://www.matts411.com/post/internet-explorer-9-oninput/\n\t\tdocument.addEventListener('selectionchange', function () {\n\t\t\tvar el = document.activeElement;\n\t\t\tif (el && el.vmodel) {\n\t\t\t\ttrigger(el, 'input');\n\t\t\t}\n\t\t});\n\t}\n\n\tvar model$1 = {\n\t\tinserted: function inserted(el, binding, vnode) {\n\t\t\tif (vnode.tag === 'select') {\n\t\t\t\tvar cb = function cb() {\n\t\t\t\t\tsetSelected(el, binding, vnode.context);\n\t\t\t\t};\n\t\t\t\tcb();\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (isIE || isEdge) {\n\t\t\t\t\tsetTimeout(cb, 0);\n\t\t\t\t}\n\t\t\t} else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n\t\t\t\tel._vModifiers = binding.modifiers;\n\t\t\t\tif (!binding.modifiers.lazy) {\n\t\t\t\t\t// Safari < 10.2 & UIWebView doesn't fire compositionend when\n\t\t\t\t\t// switching focus before confirming composition choice\n\t\t\t\t\t// this also fixes the issue where some browsers e.g. iOS Chrome\n\t\t\t\t\t// fires \"change\" instead of \"input\" on autocomplete.\n\t\t\t\t\tel.addEventListener('change', onCompositionEnd);\n\t\t\t\t\tif (!isAndroid) {\n\t\t\t\t\t\tel.addEventListener('compositionstart', onCompositionStart);\n\t\t\t\t\t\tel.addEventListener('compositionend', onCompositionEnd);\n\t\t\t\t\t}\n\t\t\t\t\t/* istanbul ignore if */\n\t\t\t\t\tif (isIE9) {\n\t\t\t\t\t\tel.vmodel = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcomponentUpdated: function componentUpdated(el, binding, vnode) {\n\t\t\tif (vnode.tag === 'select') {\n\t\t\t\tsetSelected(el, binding, vnode.context);\n\t\t\t\t// in case the options rendered by v-for have changed,\n\t\t\t\t// it's possible that the value is out-of-sync with the rendered options.\n\t\t\t\t// detect such cases and filter out values that no longer has a matching\n\t\t\t\t// option in the DOM.\n\t\t\t\tvar needReset = el.multiple ? binding.value.some(function (v) {\n\t\t\t\t\treturn hasNoMatchingOption(v, el.options);\n\t\t\t\t}) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n\t\t\t\tif (needReset) {\n\t\t\t\t\ttrigger(el, 'change');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction setSelected(el, binding, vm) {\n\t\tvar value = binding.value;\n\t\tvar isMultiple = el.multiple;\n\t\tif (isMultiple && !Array.isArray(value)) {\n\t\t\t\"development\" !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n\t\t\treturn;\n\t\t}\n\t\tvar selected, option;\n\t\tfor (var i = 0, l = el.options.length; i < l; i++) {\n\t\t\toption = el.options[i];\n\t\t\tif (isMultiple) {\n\t\t\t\tselected = looseIndexOf(value, getValue(option)) > -1;\n\t\t\t\tif (option.selected !== selected) {\n\t\t\t\t\toption.selected = selected;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (looseEqual(getValue(option), value)) {\n\t\t\t\t\tif (el.selectedIndex !== i) {\n\t\t\t\t\t\tel.selectedIndex = i;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!isMultiple) {\n\t\t\tel.selectedIndex = -1;\n\t\t}\n\t}\n\n\tfunction hasNoMatchingOption(value, options) {\n\t\tfor (var i = 0, l = options.length; i < l; i++) {\n\t\t\tif (looseEqual(getValue(options[i]), value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction getValue(option) {\n\t\treturn '_value' in option ? option._value : option.value;\n\t}\n\n\tfunction onCompositionStart(e) {\n\t\te.target.composing = true;\n\t}\n\n\tfunction onCompositionEnd(e) {\n\t\t// prevent triggering an input event for no reason\n\t\tif (!e.target.composing) {\n\t\t\treturn;\n\t\t}\n\t\te.target.composing = false;\n\t\ttrigger(e.target, 'input');\n\t}\n\n\tfunction trigger(el, type) {\n\t\tvar e = document.createEvent('HTMLEvents');\n\t\te.initEvent(type, true, true);\n\t\tel.dispatchEvent(e);\n\t}\n\n\t/*  */\n\n\t// recursively search for possible transition defined inside the component root\n\tfunction locateNode(vnode) {\n\t\treturn vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n\t}\n\n\tvar show = {\n\t\tbind: function bind(el, ref, vnode) {\n\t\t\tvar value = ref.value;\n\n\t\t\tvnode = locateNode(vnode);\n\t\t\tvar transition = vnode.data && vnode.data.transition;\n\t\t\tvar originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\t\t\tif (value && transition && !isIE9) {\n\t\t\t\tvnode.data.show = true;\n\t\t\t\tenter(vnode, function () {\n\t\t\t\t\tel.style.display = originalDisplay;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tel.style.display = value ? originalDisplay : 'none';\n\t\t\t}\n\t\t},\n\n\t\tupdate: function update(el, ref, vnode) {\n\t\t\tvar value = ref.value;\n\t\t\tvar oldValue = ref.oldValue;\n\n\t\t\t/* istanbul ignore if */\n\t\t\tif (value === oldValue) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvnode = locateNode(vnode);\n\t\t\tvar transition = vnode.data && vnode.data.transition;\n\t\t\tif (transition && !isIE9) {\n\t\t\t\tvnode.data.show = true;\n\t\t\t\tif (value) {\n\t\t\t\t\tenter(vnode, function () {\n\t\t\t\t\t\tel.style.display = el.__vOriginalDisplay;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tleave(vnode, function () {\n\t\t\t\t\t\tel.style.display = 'none';\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tel.style.display = value ? el.__vOriginalDisplay : 'none';\n\t\t\t}\n\t\t},\n\n\t\tunbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n\t\t\tif (!isDestroy) {\n\t\t\t\tel.style.display = el.__vOriginalDisplay;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar platformDirectives = {\n\t\tmodel: model$1,\n\t\tshow: show\n\t};\n\n\t/*  */\n\n\t// Provides transition support for a single element/component.\n\t// supports transition mode (out-in / in-out)\n\n\tvar transitionProps = {\n\t\tname: String,\n\t\tappear: Boolean,\n\t\tcss: Boolean,\n\t\tmode: String,\n\t\ttype: String,\n\t\tenterClass: String,\n\t\tleaveClass: String,\n\t\tenterToClass: String,\n\t\tleaveToClass: String,\n\t\tenterActiveClass: String,\n\t\tleaveActiveClass: String,\n\t\tappearClass: String,\n\t\tappearActiveClass: String,\n\t\tappearToClass: String,\n\t\tduration: [Number, String, Object]\n\t};\n\n\t// in case the child is also an abstract component, e.g. <keep-alive>\n\t// we want to recursively retrieve the real component to be rendered\n\tfunction getRealChild(vnode) {\n\t\tvar compOptions = vnode && vnode.componentOptions;\n\t\tif (compOptions && compOptions.Ctor.options.abstract) {\n\t\t\treturn getRealChild(getFirstComponentChild(compOptions.children));\n\t\t} else {\n\t\t\treturn vnode;\n\t\t}\n\t}\n\n\tfunction extractTransitionData(comp) {\n\t\tvar data = {};\n\t\tvar options = comp.$options;\n\t\t// props\n\t\tfor (var key in options.propsData) {\n\t\t\tdata[key] = comp[key];\n\t\t}\n\t\t// events.\n\t\t// extract listeners and pass them directly to the transition methods\n\t\tvar listeners = options._parentListeners;\n\t\tfor (var key$1 in listeners) {\n\t\t\tdata[camelize(key$1)] = listeners[key$1];\n\t\t}\n\t\treturn data;\n\t}\n\n\tfunction placeholder(h, rawChild) {\n\t\tif (/\\d-keep-alive$/.test(rawChild.tag)) {\n\t\t\treturn h('keep-alive', {\n\t\t\t\tprops: rawChild.componentOptions.propsData\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction hasParentTransition(vnode) {\n\t\twhile (vnode = vnode.parent) {\n\t\t\tif (vnode.data.transition) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isSameChild(child, oldChild) {\n\t\treturn oldChild.key === child.key && oldChild.tag === child.tag;\n\t}\n\n\tvar Transition = {\n\t\tname: 'transition',\n\t\tprops: transitionProps,\n\t\tabstract: true,\n\n\t\trender: function render(h) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar children = this.$slots.default;\n\t\t\tif (!children) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// filter out text nodes (possible whitespaces)\n\t\t\tchildren = children.filter(function (c) {\n\t\t\t\treturn c.tag;\n\t\t\t});\n\t\t\t/* istanbul ignore if */\n\t\t\tif (!children.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// warn multiple elements\n\t\t\tif (\"development\" !== 'production' && children.length > 1) {\n\t\t\t\twarn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n\t\t\t}\n\n\t\t\tvar mode = this.mode;\n\n\t\t\t// warn invalid mode\n\t\t\tif (\"development\" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n\t\t\t\twarn('invalid <transition> mode: ' + mode, this.$parent);\n\t\t\t}\n\n\t\t\tvar rawChild = children[0];\n\n\t\t\t// if this is a component root node and the component's\n\t\t\t// parent container node also has transition, skip.\n\t\t\tif (hasParentTransition(this.$vnode)) {\n\t\t\t\treturn rawChild;\n\t\t\t}\n\n\t\t\t// apply transition data to child\n\t\t\t// use getRealChild() to ignore abstract components e.g. keep-alive\n\t\t\tvar child = getRealChild(rawChild);\n\t\t\t/* istanbul ignore if */\n\t\t\tif (!child) {\n\t\t\t\treturn rawChild;\n\t\t\t}\n\n\t\t\tif (this._leaving) {\n\t\t\t\treturn placeholder(h, rawChild);\n\t\t\t}\n\n\t\t\t// ensure a key that is unique to the vnode type and to this transition\n\t\t\t// component instance. This key will be used to remove pending leaving nodes\n\t\t\t// during entering.\n\t\t\tvar id = \"__transition-\" + this._uid + \"-\";\n\t\t\tchild.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n\t\t\tvar data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n\t\t\tvar oldRawChild = this._vnode;\n\t\t\tvar oldChild = getRealChild(oldRawChild);\n\n\t\t\t// mark v-show\n\t\t\t// so that the transition module can hand over the control to the directive\n\t\t\tif (child.data.directives && child.data.directives.some(function (d) {\n\t\t\t\treturn d.name === 'show';\n\t\t\t})) {\n\t\t\t\tchild.data.show = true;\n\t\t\t}\n\n\t\t\tif (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n\t\t\t\t// replace old child transition data with fresh one\n\t\t\t\t// important for dynamic transitions!\n\t\t\t\tvar oldData = oldChild && (oldChild.data.transition = extend({}, data));\n\t\t\t\t// handle transition mode\n\t\t\t\tif (mode === 'out-in') {\n\t\t\t\t\t// return placeholder node and queue update when leave finishes\n\t\t\t\t\tthis._leaving = true;\n\t\t\t\t\tmergeVNodeHook(oldData, 'afterLeave', function () {\n\t\t\t\t\t\tthis$1._leaving = false;\n\t\t\t\t\t\tthis$1.$forceUpdate();\n\t\t\t\t\t});\n\t\t\t\t\treturn placeholder(h, rawChild);\n\t\t\t\t} else if (mode === 'in-out') {\n\t\t\t\t\tvar delayedLeave;\n\t\t\t\t\tvar performLeave = function performLeave() {\n\t\t\t\t\t\tdelayedLeave();\n\t\t\t\t\t};\n\t\t\t\t\tmergeVNodeHook(data, 'afterEnter', performLeave);\n\t\t\t\t\tmergeVNodeHook(data, 'enterCancelled', performLeave);\n\t\t\t\t\tmergeVNodeHook(oldData, 'delayLeave', function (leave) {\n\t\t\t\t\t\tdelayedLeave = leave;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn rawChild;\n\t\t}\n\t};\n\n\t/*  */\n\n\t// Provides transition support for list items.\n\t// supports move transitions using the FLIP technique.\n\n\t// Because the vdom's children update algorithm is \"unstable\" - i.e.\n\t// it doesn't guarantee the relative positioning of removed elements,\n\t// we force transition-group to update its children into two passes:\n\t// in the first pass, we remove all nodes that need to be removed,\n\t// triggering their leaving transition; in the second pass, we insert/move\n\t// into the final desired state. This way in the second pass removed\n\t// nodes will remain where they should be.\n\n\tvar props = extend({\n\t\ttag: String,\n\t\tmoveClass: String\n\t}, transitionProps);\n\n\tdelete props.mode;\n\n\tvar TransitionGroup = {\n\t\tprops: props,\n\n\t\trender: function render(h) {\n\t\t\tvar tag = this.tag || this.$vnode.data.tag || 'span';\n\t\t\tvar map = Object.create(null);\n\t\t\tvar prevChildren = this.prevChildren = this.children;\n\t\t\tvar rawChildren = this.$slots.default || [];\n\t\t\tvar children = this.children = [];\n\t\t\tvar transitionData = extractTransitionData(this);\n\n\t\t\tfor (var i = 0; i < rawChildren.length; i++) {\n\t\t\t\tvar c = rawChildren[i];\n\t\t\t\tif (c.tag) {\n\t\t\t\t\tif (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n\t\t\t\t\t\tchildren.push(c);\n\t\t\t\t\t\tmap[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar opts = c.componentOptions;\n\t\t\t\t\t\tvar name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n\t\t\t\t\t\twarn(\"<transition-group> children must be keyed: <\" + name + \">\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (prevChildren) {\n\t\t\t\tvar kept = [];\n\t\t\t\tvar removed = [];\n\t\t\t\tfor (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n\t\t\t\t\tvar c$1 = prevChildren[i$1];\n\t\t\t\t\tc$1.data.transition = transitionData;\n\t\t\t\t\tc$1.data.pos = c$1.elm.getBoundingClientRect();\n\t\t\t\t\tif (map[c$1.key]) {\n\t\t\t\t\t\tkept.push(c$1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremoved.push(c$1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.kept = h(tag, null, kept);\n\t\t\t\tthis.removed = removed;\n\t\t\t}\n\n\t\t\treturn h(tag, null, children);\n\t\t},\n\n\t\tbeforeUpdate: function beforeUpdate() {\n\t\t\t// force removing pass\n\t\t\tthis.__patch__(this._vnode, this.kept, false, // hydrating\n\t\t\ttrue // removeOnly (!important, avoids unnecessary moves)\n\t\t\t);\n\t\t\tthis._vnode = this.kept;\n\t\t},\n\n\t\tupdated: function updated() {\n\t\t\tvar children = this.prevChildren;\n\t\t\tvar moveClass = this.moveClass || (this.name || 'v') + '-move';\n\t\t\tif (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// we divide the work into three loops to avoid mixing DOM reads and writes\n\t\t\t// in each iteration - which helps prevent layout thrashing.\n\t\t\tchildren.forEach(callPendingCbs);\n\t\t\tchildren.forEach(recordPosition);\n\t\t\tchildren.forEach(applyTranslation);\n\n\t\t\t// force reflow to put everything in position\n\t\t\tvar body = document.body;\n\t\t\tvar f = body.offsetHeight; // eslint-disable-line\n\n\t\t\tchildren.forEach(function (c) {\n\t\t\t\tif (c.data.moved) {\n\t\t\t\t\tvar el = c.elm;\n\t\t\t\t\tvar s = el.style;\n\t\t\t\t\taddTransitionClass(el, moveClass);\n\t\t\t\t\ts.transform = s.WebkitTransform = s.transitionDuration = '';\n\t\t\t\t\tel.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n\t\t\t\t\t\tif (!e || /transform$/.test(e.propertyName)) {\n\t\t\t\t\t\t\tel.removeEventListener(transitionEndEvent, cb);\n\t\t\t\t\t\t\tel._moveCb = null;\n\t\t\t\t\t\t\tremoveTransitionClass(el, moveClass);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tmethods: {\n\t\t\thasMove: function hasMove(el, moveClass) {\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (!hasTransition) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (this._hasMove != null) {\n\t\t\t\t\treturn this._hasMove;\n\t\t\t\t}\n\t\t\t\t// Detect whether an element with the move class applied has\n\t\t\t\t// CSS transitions. Since the element may be inside an entering\n\t\t\t\t// transition at this very moment, we make a clone of it and remove\n\t\t\t\t// all other transition classes applied to ensure only the move class\n\t\t\t\t// is applied.\n\t\t\t\tvar clone = el.cloneNode();\n\t\t\t\tif (el._transitionClasses) {\n\t\t\t\t\tel._transitionClasses.forEach(function (cls) {\n\t\t\t\t\t\tremoveClass(clone, cls);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\taddClass(clone, moveClass);\n\t\t\t\tclone.style.display = 'none';\n\t\t\t\tthis.$el.appendChild(clone);\n\t\t\t\tvar info = getTransitionInfo(clone);\n\t\t\t\tthis.$el.removeChild(clone);\n\t\t\t\treturn this._hasMove = info.hasTransform;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction callPendingCbs(c) {\n\t\t/* istanbul ignore if */\n\t\tif (c.elm._moveCb) {\n\t\t\tc.elm._moveCb();\n\t\t}\n\t\t/* istanbul ignore if */\n\t\tif (c.elm._enterCb) {\n\t\t\tc.elm._enterCb();\n\t\t}\n\t}\n\n\tfunction recordPosition(c) {\n\t\tc.data.newPos = c.elm.getBoundingClientRect();\n\t}\n\n\tfunction applyTranslation(c) {\n\t\tvar oldPos = c.data.pos;\n\t\tvar newPos = c.data.newPos;\n\t\tvar dx = oldPos.left - newPos.left;\n\t\tvar dy = oldPos.top - newPos.top;\n\t\tif (dx || dy) {\n\t\t\tc.data.moved = true;\n\t\t\tvar s = c.elm.style;\n\t\t\ts.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n\t\t\ts.transitionDuration = '0s';\n\t\t}\n\t}\n\n\tvar platformComponents = {\n\t\tTransition: Transition,\n\t\tTransitionGroup: TransitionGroup\n\t};\n\n\t/*  */\n\n\t// install platform specific utils\n\tVue$3.config.mustUseProp = mustUseProp;\n\tVue$3.config.isReservedTag = isReservedTag;\n\tVue$3.config.isReservedAttr = isReservedAttr;\n\tVue$3.config.getTagNamespace = getTagNamespace;\n\tVue$3.config.isUnknownElement = isUnknownElement;\n\n\t// install platform runtime directives & components\n\textend(Vue$3.options.directives, platformDirectives);\n\textend(Vue$3.options.components, platformComponents);\n\n\t// install platform patch function\n\tVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n\t// public mount method\n\tVue$3.prototype.$mount = function (el, hydrating) {\n\t\tel = el && inBrowser ? query(el) : undefined;\n\t\treturn mountComponent(this, el, hydrating);\n\t};\n\n\t// devtools global hook\n\t/* istanbul ignore next */\n\tsetTimeout(function () {\n\t\tif (config.devtools) {\n\t\t\tif (devtools) {\n\t\t\t\tdevtools.emit('init', Vue$3);\n\t\t\t} else if (\"development\" !== 'production' && isChrome) {\n\t\t\t\tconsole[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n\t\t\t}\n\t\t}\n\t\tif (\"development\" !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {\n\t\t\tconsole[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n\t\t}\n\t}, 0);\n\n\t/*  */\n\n\t// check whether current browser encodes a char inside attribute values\n\tfunction shouldDecode(content, encoded) {\n\t\tvar div = document.createElement('div');\n\t\tdiv.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n\t\treturn div.innerHTML.indexOf(encoded) > 0;\n\t}\n\n\t// #3663\n\t// IE encodes newlines inside attribute values while other browsers don't\n\tvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n\t/*  */\n\n\tvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');\n\n\t// Elements that you can, intentionally, leave open\n\t// (and which close themselves)\n\tvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n\n\t// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n\t// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\tvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n\n\t/*  */\n\n\tvar decoder;\n\n\tfunction decode(html) {\n\t\tdecoder = decoder || document.createElement('div');\n\t\tdecoder.innerHTML = html;\n\t\treturn decoder.textContent;\n\t}\n\n\t/**\n  * Not type-checking this file because it's mostly vendor code.\n  */\n\n\t/*!\n  * HTML Parser By John Resig (ejohn.org)\n  * Modified by Juriy \"kangax\" Zaytsev\n  * Original code by Erik Arvidsson, Mozilla Public License\n  * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n  */\n\n\t// Regular Expressions for parsing tags and attributes\n\tvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\n\tvar singleAttrAssign = /(?:=)/;\n\tvar singleAttrValues = [\n\t// attr value double quotes\n\t/\"([^\"]*)\"+/.source,\n\t// attr value, single quotes\n\t/'([^']*)'+/.source,\n\t// attr value, no quotes\n\t/([^\\s\"'=<>`]+)/.source];\n\tvar attribute = new RegExp('^\\\\s*' + singleAttrIdentifier.source + '(?:\\\\s*(' + singleAttrAssign.source + ')' + '\\\\s*(?:' + singleAttrValues.join('|') + '))?');\n\n\t// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n\t// but for Vue templates we can enforce a simple charset\n\tvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\n\tvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\n\tvar startTagOpen = new RegExp('^<' + qnameCapture);\n\tvar startTagClose = /^\\s*(\\/?)>/;\n\tvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\n\tvar doctype = /^<!DOCTYPE [^>]+>/i;\n\tvar comment = /^<!--/;\n\tvar conditionalComment = /^<!\\[/;\n\n\tvar IS_REGEX_CAPTURING_BROKEN = false;\n\t'x'.replace(/x(.)?/g, function (m, g) {\n\t\tIS_REGEX_CAPTURING_BROKEN = g === '';\n\t});\n\n\t// Special Elements (can contain anything)\n\tvar isPlainTextElement = makeMap('script,style,textarea', true);\n\tvar reCache = {};\n\n\tvar decodingMap = {\n\t\t'&lt;': '<',\n\t\t'&gt;': '>',\n\t\t'&quot;': '\"',\n\t\t'&amp;': '&',\n\t\t'&#10;': '\\n'\n\t};\n\tvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\n\tvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\n\tfunction decodeAttr(value, shouldDecodeNewlines) {\n\t\tvar re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n\t\treturn value.replace(re, function (match) {\n\t\t\treturn decodingMap[match];\n\t\t});\n\t}\n\n\tfunction parseHTML(html, options) {\n\t\tvar stack = [];\n\t\tvar expectHTML = options.expectHTML;\n\t\tvar isUnaryTag$$1 = options.isUnaryTag || no;\n\t\tvar canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n\t\tvar index = 0;\n\t\tvar last, lastTag;\n\t\twhile (html) {\n\t\t\tlast = html;\n\t\t\t// Make sure we're not in a plaintext content element like script/style\n\t\t\tif (!lastTag || !isPlainTextElement(lastTag)) {\n\t\t\t\tvar textEnd = html.indexOf('<');\n\t\t\t\tif (textEnd === 0) {\n\t\t\t\t\t// Comment:\n\t\t\t\t\tif (comment.test(html)) {\n\t\t\t\t\t\tvar commentEnd = html.indexOf('-->');\n\n\t\t\t\t\t\tif (commentEnd >= 0) {\n\t\t\t\t\t\t\tadvance(commentEnd + 3);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\t\t\t\t\tif (conditionalComment.test(html)) {\n\t\t\t\t\t\tvar conditionalEnd = html.indexOf(']>');\n\n\t\t\t\t\t\tif (conditionalEnd >= 0) {\n\t\t\t\t\t\t\tadvance(conditionalEnd + 2);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Doctype:\n\t\t\t\t\tvar doctypeMatch = html.match(doctype);\n\t\t\t\t\tif (doctypeMatch) {\n\t\t\t\t\t\tadvance(doctypeMatch[0].length);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// End tag:\n\t\t\t\t\tvar endTagMatch = html.match(endTag);\n\t\t\t\t\tif (endTagMatch) {\n\t\t\t\t\t\tvar curIndex = index;\n\t\t\t\t\t\tadvance(endTagMatch[0].length);\n\t\t\t\t\t\tparseEndTag(endTagMatch[1], curIndex, index);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Start tag:\n\t\t\t\t\tvar startTagMatch = parseStartTag();\n\t\t\t\t\tif (startTagMatch) {\n\t\t\t\t\t\thandleStartTag(startTagMatch);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar text = void 0,\n\t\t\t\t    rest$1 = void 0,\n\t\t\t\t    next = void 0;\n\t\t\t\tif (textEnd >= 0) {\n\t\t\t\t\trest$1 = html.slice(textEnd);\n\t\t\t\t\twhile (!endTag.test(rest$1) && !startTagOpen.test(rest$1) && !comment.test(rest$1) && !conditionalComment.test(rest$1)) {\n\t\t\t\t\t\t// < in plain text, be forgiving and treat it as text\n\t\t\t\t\t\tnext = rest$1.indexOf('<', 1);\n\t\t\t\t\t\tif (next < 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttextEnd += next;\n\t\t\t\t\t\trest$1 = html.slice(textEnd);\n\t\t\t\t\t}\n\t\t\t\t\ttext = html.substring(0, textEnd);\n\t\t\t\t\tadvance(textEnd);\n\t\t\t\t}\n\n\t\t\t\tif (textEnd < 0) {\n\t\t\t\t\ttext = html;\n\t\t\t\t\thtml = '';\n\t\t\t\t}\n\n\t\t\t\tif (options.chars && text) {\n\t\t\t\t\toptions.chars(text);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar stackedTag = lastTag.toLowerCase();\n\t\t\t\tvar reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n\t\t\t\tvar endTagLength = 0;\n\t\t\t\tvar rest = html.replace(reStackedTag, function (all, text, endTag) {\n\t\t\t\t\tendTagLength = endTag.length;\n\t\t\t\t\tif (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n\t\t\t\t\t\ttext = text.replace(/<!--([\\s\\S]*?)-->/g, '$1').replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n\t\t\t\t\t}\n\t\t\t\t\tif (options.chars) {\n\t\t\t\t\t\toptions.chars(text);\n\t\t\t\t\t}\n\t\t\t\t\treturn '';\n\t\t\t\t});\n\t\t\t\tindex += html.length - rest.length;\n\t\t\t\thtml = rest;\n\t\t\t\tparseEndTag(stackedTag, index - endTagLength, index);\n\t\t\t}\n\n\t\t\tif (html === last) {\n\t\t\t\toptions.chars && options.chars(html);\n\t\t\t\tif (\"development\" !== 'production' && !stack.length && options.warn) {\n\t\t\t\t\toptions.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Clean up any remaining tags\n\t\tparseEndTag();\n\n\t\tfunction advance(n) {\n\t\t\tindex += n;\n\t\t\thtml = html.substring(n);\n\t\t}\n\n\t\tfunction parseStartTag() {\n\t\t\tvar start = html.match(startTagOpen);\n\t\t\tif (start) {\n\t\t\t\tvar match = {\n\t\t\t\t\ttagName: start[1],\n\t\t\t\t\tattrs: [],\n\t\t\t\t\tstart: index\n\t\t\t\t};\n\t\t\t\tadvance(start[0].length);\n\t\t\t\tvar end, attr;\n\t\t\t\twhile (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n\t\t\t\t\tadvance(attr[0].length);\n\t\t\t\t\tmatch.attrs.push(attr);\n\t\t\t\t}\n\t\t\t\tif (end) {\n\t\t\t\t\tmatch.unarySlash = end[1];\n\t\t\t\t\tadvance(end[0].length);\n\t\t\t\t\tmatch.end = index;\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction handleStartTag(match) {\n\t\t\tvar tagName = match.tagName;\n\t\t\tvar unarySlash = match.unarySlash;\n\n\t\t\tif (expectHTML) {\n\t\t\t\tif (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n\t\t\t\t\tparseEndTag(lastTag);\n\t\t\t\t}\n\t\t\t\tif (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n\t\t\t\t\tparseEndTag(tagName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n\t\t\tvar l = match.attrs.length;\n\t\t\tvar attrs = new Array(l);\n\t\t\tfor (var i = 0; i < l; i++) {\n\t\t\t\tvar args = match.attrs[i];\n\t\t\t\t// hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n\t\t\t\tif (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n\t\t\t\t\tif (args[3] === '') {\n\t\t\t\t\t\tdelete args[3];\n\t\t\t\t\t}\n\t\t\t\t\tif (args[4] === '') {\n\t\t\t\t\t\tdelete args[4];\n\t\t\t\t\t}\n\t\t\t\t\tif (args[5] === '') {\n\t\t\t\t\t\tdelete args[5];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar value = args[3] || args[4] || args[5] || '';\n\t\t\t\tattrs[i] = {\n\t\t\t\t\tname: args[1],\n\t\t\t\t\tvalue: decodeAttr(value, options.shouldDecodeNewlines)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (!unary) {\n\t\t\t\tstack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n\t\t\t\tlastTag = tagName;\n\t\t\t}\n\n\t\t\tif (options.start) {\n\t\t\t\toptions.start(tagName, attrs, unary, match.start, match.end);\n\t\t\t}\n\t\t}\n\n\t\tfunction parseEndTag(tagName, start, end) {\n\t\t\tvar pos, lowerCasedTagName;\n\t\t\tif (start == null) {\n\t\t\t\tstart = index;\n\t\t\t}\n\t\t\tif (end == null) {\n\t\t\t\tend = index;\n\t\t\t}\n\n\t\t\tif (tagName) {\n\t\t\t\tlowerCasedTagName = tagName.toLowerCase();\n\t\t\t}\n\n\t\t\t// Find the closest opened tag of the same type\n\t\t\tif (tagName) {\n\t\t\t\tfor (pos = stack.length - 1; pos >= 0; pos--) {\n\t\t\t\t\tif (stack[pos].lowerCasedTag === lowerCasedTagName) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If no tag name is provided, clean shop\n\t\t\t\tpos = 0;\n\t\t\t}\n\n\t\t\tif (pos >= 0) {\n\t\t\t\t// Close all the open elements, up the stack\n\t\t\t\tfor (var i = stack.length - 1; i >= pos; i--) {\n\t\t\t\t\tif (\"development\" !== 'production' && (i > pos || !tagName) && options.warn) {\n\t\t\t\t\t\toptions.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (options.end) {\n\t\t\t\t\t\toptions.end(stack[i].tag, start, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove the open elements from the stack\n\t\t\t\tstack.length = pos;\n\t\t\t\tlastTag = pos && stack[pos - 1].tag;\n\t\t\t} else if (lowerCasedTagName === 'br') {\n\t\t\t\tif (options.start) {\n\t\t\t\t\toptions.start(tagName, [], true, start, end);\n\t\t\t\t}\n\t\t\t} else if (lowerCasedTagName === 'p') {\n\t\t\t\tif (options.start) {\n\t\t\t\t\toptions.start(tagName, [], false, start, end);\n\t\t\t\t}\n\t\t\t\tif (options.end) {\n\t\t\t\t\toptions.end(tagName, start, end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\n\tvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n\tvar buildRegex = cached(function (delimiters) {\n\t\tvar open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n\t\tvar close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n\t\treturn new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n\t});\n\n\tfunction parseText(text, delimiters) {\n\t\tvar tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\t\tif (!tagRE.test(text)) {\n\t\t\treturn;\n\t\t}\n\t\tvar tokens = [];\n\t\tvar lastIndex = tagRE.lastIndex = 0;\n\t\tvar match, index;\n\t\twhile (match = tagRE.exec(text)) {\n\t\t\tindex = match.index;\n\t\t\t// push text token\n\t\t\tif (index > lastIndex) {\n\t\t\t\ttokens.push(JSON.stringify(text.slice(lastIndex, index)));\n\t\t\t}\n\t\t\t// tag token\n\t\t\tvar exp = parseFilters(match[1].trim());\n\t\t\ttokens.push(\"_s(\" + exp + \")\");\n\t\t\tlastIndex = index + match[0].length;\n\t\t}\n\t\tif (lastIndex < text.length) {\n\t\t\ttokens.push(JSON.stringify(text.slice(lastIndex)));\n\t\t}\n\t\treturn tokens.join('+');\n\t}\n\n\t/*  */\n\n\tvar onRE = /^@|^v-on:/;\n\tvar dirRE = /^v-|^@|^:/;\n\tvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\n\tvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\n\tvar argRE = /:(.*)$/;\n\tvar bindRE = /^:|^v-bind:/;\n\tvar modifierRE = /\\.[^.]+/g;\n\n\tvar decodeHTMLCached = cached(decode);\n\n\t// configurable state\n\tvar warn$2;\n\tvar delimiters;\n\tvar transforms;\n\tvar preTransforms;\n\tvar postTransforms;\n\tvar platformIsPreTag;\n\tvar platformMustUseProp;\n\tvar platformGetTagNamespace;\n\n\t/**\n  * Convert HTML string to AST.\n  */\n\tfunction parse(template, options) {\n\t\twarn$2 = options.warn || baseWarn;\n\t\tplatformGetTagNamespace = options.getTagNamespace || no;\n\t\tplatformMustUseProp = options.mustUseProp || no;\n\t\tplatformIsPreTag = options.isPreTag || no;\n\t\tpreTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n\t\ttransforms = pluckModuleFunction(options.modules, 'transformNode');\n\t\tpostTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\t\tdelimiters = options.delimiters;\n\n\t\tvar stack = [];\n\t\tvar preserveWhitespace = options.preserveWhitespace !== false;\n\t\tvar root;\n\t\tvar currentParent;\n\t\tvar inVPre = false;\n\t\tvar inPre = false;\n\t\tvar warned = false;\n\n\t\tfunction warnOnce(msg) {\n\t\t\tif (!warned) {\n\t\t\t\twarned = true;\n\t\t\t\twarn$2(msg);\n\t\t\t}\n\t\t}\n\n\t\tfunction endPre(element) {\n\t\t\t// check pre state\n\t\t\tif (element.pre) {\n\t\t\t\tinVPre = false;\n\t\t\t}\n\t\t\tif (platformIsPreTag(element.tag)) {\n\t\t\t\tinPre = false;\n\t\t\t}\n\t\t}\n\n\t\tparseHTML(template, {\n\t\t\twarn: warn$2,\n\t\t\texpectHTML: options.expectHTML,\n\t\t\tisUnaryTag: options.isUnaryTag,\n\t\t\tcanBeLeftOpenTag: options.canBeLeftOpenTag,\n\t\t\tshouldDecodeNewlines: options.shouldDecodeNewlines,\n\t\t\tstart: function start(tag, attrs, unary) {\n\t\t\t\t// check namespace.\n\t\t\t\t// inherit parent ns if there is one\n\t\t\t\tvar ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n\t\t\t\t// handle IE svg bug\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (isIE && ns === 'svg') {\n\t\t\t\t\tattrs = guardIESVGBug(attrs);\n\t\t\t\t}\n\n\t\t\t\tvar element = {\n\t\t\t\t\ttype: 1,\n\t\t\t\t\ttag: tag,\n\t\t\t\t\tattrsList: attrs,\n\t\t\t\t\tattrsMap: makeAttrsMap(attrs),\n\t\t\t\t\tparent: currentParent,\n\t\t\t\t\tchildren: []\n\t\t\t\t};\n\t\t\t\tif (ns) {\n\t\t\t\t\telement.ns = ns;\n\t\t\t\t}\n\n\t\t\t\tif (isForbiddenTag(element) && !isServerRendering()) {\n\t\t\t\t\telement.forbidden = true;\n\t\t\t\t\t\"development\" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.');\n\t\t\t\t}\n\n\t\t\t\t// apply pre-transforms\n\t\t\t\tfor (var i = 0; i < preTransforms.length; i++) {\n\t\t\t\t\tpreTransforms[i](element, options);\n\t\t\t\t}\n\n\t\t\t\tif (!inVPre) {\n\t\t\t\t\tprocessPre(element);\n\t\t\t\t\tif (element.pre) {\n\t\t\t\t\t\tinVPre = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (platformIsPreTag(element.tag)) {\n\t\t\t\t\tinPre = true;\n\t\t\t\t}\n\t\t\t\tif (inVPre) {\n\t\t\t\t\tprocessRawAttrs(element);\n\t\t\t\t} else {\n\t\t\t\t\tprocessFor(element);\n\t\t\t\t\tprocessIf(element);\n\t\t\t\t\tprocessOnce(element);\n\t\t\t\t\tprocessKey(element);\n\n\t\t\t\t\t// determine whether this is a plain element after\n\t\t\t\t\t// removing structural attributes\n\t\t\t\t\telement.plain = !element.key && !attrs.length;\n\n\t\t\t\t\tprocessRef(element);\n\t\t\t\t\tprocessSlot(element);\n\t\t\t\t\tprocessComponent(element);\n\t\t\t\t\tfor (var i$1 = 0; i$1 < transforms.length; i$1++) {\n\t\t\t\t\t\ttransforms[i$1](element, options);\n\t\t\t\t\t}\n\t\t\t\t\tprocessAttrs(element);\n\t\t\t\t}\n\n\t\t\t\tfunction checkRootConstraints(el) {\n\t\t\t\t\t{\n\t\t\t\t\t\tif (el.tag === 'slot' || el.tag === 'template') {\n\t\t\t\t\t\t\twarnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (el.attrsMap.hasOwnProperty('v-for')) {\n\t\t\t\t\t\t\twarnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// tree management\n\t\t\t\tif (!root) {\n\t\t\t\t\troot = element;\n\t\t\t\t\tcheckRootConstraints(root);\n\t\t\t\t} else if (!stack.length) {\n\t\t\t\t\t// allow root elements with v-if, v-else-if and v-else\n\t\t\t\t\tif (root.if && (element.elseif || element.else)) {\n\t\t\t\t\t\tcheckRootConstraints(element);\n\t\t\t\t\t\taddIfCondition(root, {\n\t\t\t\t\t\t\texp: element.elseif,\n\t\t\t\t\t\t\tblock: element\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentParent && !element.forbidden) {\n\t\t\t\t\tif (element.elseif || element.else) {\n\t\t\t\t\t\tprocessIfConditions(element, currentParent);\n\t\t\t\t\t} else if (element.slotScope) {\n\t\t\t\t\t\t// scoped slot\n\t\t\t\t\t\tcurrentParent.plain = false;\n\t\t\t\t\t\tvar name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentParent.children.push(element);\n\t\t\t\t\t\telement.parent = currentParent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!unary) {\n\t\t\t\t\tcurrentParent = element;\n\t\t\t\t\tstack.push(element);\n\t\t\t\t} else {\n\t\t\t\t\tendPre(element);\n\t\t\t\t}\n\t\t\t\t// apply post-transforms\n\t\t\t\tfor (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n\t\t\t\t\tpostTransforms[i$2](element, options);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tend: function end() {\n\t\t\t\t// remove trailing whitespace\n\t\t\t\tvar element = stack[stack.length - 1];\n\t\t\t\tvar lastNode = element.children[element.children.length - 1];\n\t\t\t\tif (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n\t\t\t\t\telement.children.pop();\n\t\t\t\t}\n\t\t\t\t// pop stack\n\t\t\t\tstack.length -= 1;\n\t\t\t\tcurrentParent = stack[stack.length - 1];\n\t\t\t\tendPre(element);\n\t\t\t},\n\n\t\t\tchars: function chars(text) {\n\t\t\t\tif (!currentParent) {\n\t\t\t\t\t{\n\t\t\t\t\t\tif (text === template) {\n\t\t\t\t\t\t\twarnOnce('Component template requires a root element, rather than just text.');\n\t\t\t\t\t\t} else if (text = text.trim()) {\n\t\t\t\t\t\t\twarnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// IE textarea placeholder bug\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar children = currentParent.children;\n\t\t\t\ttext = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n\t\t\t\t// only preserve whitespace if its not right after a starting tag\n\t\t\t\t: preserveWhitespace && children.length ? ' ' : '';\n\t\t\t\tif (text) {\n\t\t\t\t\tvar expression;\n\t\t\t\t\tif (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n\t\t\t\t\t\tchildren.push({\n\t\t\t\t\t\t\ttype: 2,\n\t\t\t\t\t\t\texpression: expression,\n\t\t\t\t\t\t\ttext: text\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n\t\t\t\t\t\tchildren.push({\n\t\t\t\t\t\t\ttype: 3,\n\t\t\t\t\t\t\ttext: text\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn root;\n\t}\n\n\tfunction processPre(el) {\n\t\tif (getAndRemoveAttr(el, 'v-pre') != null) {\n\t\t\tel.pre = true;\n\t\t}\n\t}\n\n\tfunction processRawAttrs(el) {\n\t\tvar l = el.attrsList.length;\n\t\tif (l) {\n\t\t\tvar attrs = el.attrs = new Array(l);\n\t\t\tfor (var i = 0; i < l; i++) {\n\t\t\t\tattrs[i] = {\n\t\t\t\t\tname: el.attrsList[i].name,\n\t\t\t\t\tvalue: JSON.stringify(el.attrsList[i].value)\n\t\t\t\t};\n\t\t\t}\n\t\t} else if (!el.pre) {\n\t\t\t// non root node in pre blocks with no attributes\n\t\t\tel.plain = true;\n\t\t}\n\t}\n\n\tfunction processKey(el) {\n\t\tvar exp = getBindingAttr(el, 'key');\n\t\tif (exp) {\n\t\t\tif (\"development\" !== 'production' && el.tag === 'template') {\n\t\t\t\twarn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n\t\t\t}\n\t\t\tel.key = exp;\n\t\t}\n\t}\n\n\tfunction processRef(el) {\n\t\tvar ref = getBindingAttr(el, 'ref');\n\t\tif (ref) {\n\t\t\tel.ref = ref;\n\t\t\tel.refInFor = checkInFor(el);\n\t\t}\n\t}\n\n\tfunction processFor(el) {\n\t\tvar exp;\n\t\tif (exp = getAndRemoveAttr(el, 'v-for')) {\n\t\t\tvar inMatch = exp.match(forAliasRE);\n\t\t\tif (!inMatch) {\n\t\t\t\t\"development\" !== 'production' && warn$2(\"Invalid v-for expression: \" + exp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tel.for = inMatch[2].trim();\n\t\t\tvar alias = inMatch[1].trim();\n\t\t\tvar iteratorMatch = alias.match(forIteratorRE);\n\t\t\tif (iteratorMatch) {\n\t\t\t\tel.alias = iteratorMatch[1].trim();\n\t\t\t\tel.iterator1 = iteratorMatch[2].trim();\n\t\t\t\tif (iteratorMatch[3]) {\n\t\t\t\t\tel.iterator2 = iteratorMatch[3].trim();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tel.alias = alias;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction processIf(el) {\n\t\tvar exp = getAndRemoveAttr(el, 'v-if');\n\t\tif (exp) {\n\t\t\tel.if = exp;\n\t\t\taddIfCondition(el, {\n\t\t\t\texp: exp,\n\t\t\t\tblock: el\n\t\t\t});\n\t\t} else {\n\t\t\tif (getAndRemoveAttr(el, 'v-else') != null) {\n\t\t\t\tel.else = true;\n\t\t\t}\n\t\t\tvar elseif = getAndRemoveAttr(el, 'v-else-if');\n\t\t\tif (elseif) {\n\t\t\t\tel.elseif = elseif;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction processIfConditions(el, parent) {\n\t\tvar prev = findPrevElement(parent.children);\n\t\tif (prev && prev.if) {\n\t\t\taddIfCondition(prev, {\n\t\t\t\texp: el.elseif,\n\t\t\t\tblock: el\n\t\t\t});\n\t\t} else {\n\t\t\twarn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\");\n\t\t}\n\t}\n\n\tfunction findPrevElement(children) {\n\t\tvar i = children.length;\n\t\twhile (i--) {\n\t\t\tif (children[i].type === 1) {\n\t\t\t\treturn children[i];\n\t\t\t} else {\n\t\t\t\tif (\"development\" !== 'production' && children[i].text !== ' ') {\n\t\t\t\t\twarn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\");\n\t\t\t\t}\n\t\t\t\tchildren.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addIfCondition(el, condition) {\n\t\tif (!el.ifConditions) {\n\t\t\tel.ifConditions = [];\n\t\t}\n\t\tel.ifConditions.push(condition);\n\t}\n\n\tfunction processOnce(el) {\n\t\tvar once$$1 = getAndRemoveAttr(el, 'v-once');\n\t\tif (once$$1 != null) {\n\t\t\tel.once = true;\n\t\t}\n\t}\n\n\tfunction processSlot(el) {\n\t\tif (el.tag === 'slot') {\n\t\t\tel.slotName = getBindingAttr(el, 'name');\n\t\t\tif (\"development\" !== 'production' && el.key) {\n\t\t\t\twarn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\");\n\t\t\t}\n\t\t} else {\n\t\t\tvar slotTarget = getBindingAttr(el, 'slot');\n\t\t\tif (slotTarget) {\n\t\t\t\tel.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n\t\t\t}\n\t\t\tif (el.tag === 'template') {\n\t\t\t\tel.slotScope = getAndRemoveAttr(el, 'scope');\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction processComponent(el) {\n\t\tvar binding;\n\t\tif (binding = getBindingAttr(el, 'is')) {\n\t\t\tel.component = binding;\n\t\t}\n\t\tif (getAndRemoveAttr(el, 'inline-template') != null) {\n\t\t\tel.inlineTemplate = true;\n\t\t}\n\t}\n\n\tfunction processAttrs(el) {\n\t\tvar list = el.attrsList;\n\t\tvar i, l, name, rawName, value, modifiers, isProp;\n\t\tfor (i = 0, l = list.length; i < l; i++) {\n\t\t\tname = rawName = list[i].name;\n\t\t\tvalue = list[i].value;\n\t\t\tif (dirRE.test(name)) {\n\t\t\t\t// mark element as dynamic\n\t\t\t\tel.hasBindings = true;\n\t\t\t\t// modifiers\n\t\t\t\tmodifiers = parseModifiers(name);\n\t\t\t\tif (modifiers) {\n\t\t\t\t\tname = name.replace(modifierRE, '');\n\t\t\t\t}\n\t\t\t\tif (bindRE.test(name)) {\n\t\t\t\t\t// v-bind\n\t\t\t\t\tname = name.replace(bindRE, '');\n\t\t\t\t\tvalue = parseFilters(value);\n\t\t\t\t\tisProp = false;\n\t\t\t\t\tif (modifiers) {\n\t\t\t\t\t\tif (modifiers.prop) {\n\t\t\t\t\t\t\tisProp = true;\n\t\t\t\t\t\t\tname = camelize(name);\n\t\t\t\t\t\t\tif (name === 'innerHtml') {\n\t\t\t\t\t\t\t\tname = 'innerHTML';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (modifiers.camel) {\n\t\t\t\t\t\t\tname = camelize(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (modifiers.sync) {\n\t\t\t\t\t\t\taddHandler(el, \"update:\" + camelize(name), genAssignmentCode(value, \"$event\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n\t\t\t\t\t\taddProp(el, name, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddAttr(el, name, value);\n\t\t\t\t\t}\n\t\t\t\t} else if (onRE.test(name)) {\n\t\t\t\t\t// v-on\n\t\t\t\t\tname = name.replace(onRE, '');\n\t\t\t\t\taddHandler(el, name, value, modifiers, false, warn$2);\n\t\t\t\t} else {\n\t\t\t\t\t// normal directives\n\t\t\t\t\tname = name.replace(dirRE, '');\n\t\t\t\t\t// parse arg\n\t\t\t\t\tvar argMatch = name.match(argRE);\n\t\t\t\t\tvar arg = argMatch && argMatch[1];\n\t\t\t\t\tif (arg) {\n\t\t\t\t\t\tname = name.slice(0, -(arg.length + 1));\n\t\t\t\t\t}\n\t\t\t\t\taddDirective(el, name, rawName, value, arg, modifiers);\n\t\t\t\t\tif (\"development\" !== 'production' && name === 'model') {\n\t\t\t\t\t\tcheckForAliasModel(el, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// literal attribute\n\t\t\t\t{\n\t\t\t\t\tvar expression = parseText(value, delimiters);\n\t\t\t\t\tif (expression) {\n\t\t\t\t\t\twarn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddAttr(el, name, JSON.stringify(value));\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction checkInFor(el) {\n\t\tvar parent = el;\n\t\twhile (parent) {\n\t\t\tif (parent.for !== undefined) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tparent = parent.parent;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction parseModifiers(name) {\n\t\tvar match = name.match(modifierRE);\n\t\tif (match) {\n\t\t\tvar ret = {};\n\t\t\tmatch.forEach(function (m) {\n\t\t\t\tret[m.slice(1)] = true;\n\t\t\t});\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfunction makeAttrsMap(attrs) {\n\t\tvar map = {};\n\t\tfor (var i = 0, l = attrs.length; i < l; i++) {\n\t\t\tif (\"development\" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n\t\t\t\twarn$2('duplicate attribute: ' + attrs[i].name);\n\t\t\t}\n\t\t\tmap[attrs[i].name] = attrs[i].value;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// for script (e.g. type=\"x/template\") or style, do not decode content\n\tfunction isTextTag(el) {\n\t\treturn el.tag === 'script' || el.tag === 'style';\n\t}\n\n\tfunction isForbiddenTag(el) {\n\t\treturn el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n\t}\n\n\tvar ieNSBug = /^xmlns:NS\\d+/;\n\tvar ieNSPrefix = /^NS\\d+:/;\n\n\t/* istanbul ignore next */\n\tfunction guardIESVGBug(attrs) {\n\t\tvar res = [];\n\t\tfor (var i = 0; i < attrs.length; i++) {\n\t\t\tvar attr = attrs[i];\n\t\t\tif (!ieNSBug.test(attr.name)) {\n\t\t\t\tattr.name = attr.name.replace(ieNSPrefix, '');\n\t\t\t\tres.push(attr);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction checkForAliasModel(el, value) {\n\t\tvar _el = el;\n\t\twhile (_el) {\n\t\t\tif (_el.for && _el.alias === value) {\n\t\t\t\twarn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\");\n\t\t\t}\n\t\t\t_el = _el.parent;\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar isStaticKey;\n\tvar isPlatformReservedTag;\n\n\tvar genStaticKeysCached = cached(genStaticKeys$1);\n\n\t/**\n  * Goal of the optimizer: walk the generated template AST tree\n  * and detect sub-trees that are purely static, i.e. parts of\n  * the DOM that never needs to change.\n  *\n  * Once we detect these sub-trees, we can:\n  *\n  * 1. Hoist them into constants, so that we no longer need to\n  *    create fresh nodes for them on each re-render;\n  * 2. Completely skip them in the patching process.\n  */\n\tfunction optimize(root, options) {\n\t\tif (!root) {\n\t\t\treturn;\n\t\t}\n\t\tisStaticKey = genStaticKeysCached(options.staticKeys || '');\n\t\tisPlatformReservedTag = options.isReservedTag || no;\n\t\t// first pass: mark all non-static nodes.\n\t\tmarkStatic$1(root);\n\t\t// second pass: mark static roots.\n\t\tmarkStaticRoots(root, false);\n\t}\n\n\tfunction genStaticKeys$1(keys) {\n\t\treturn makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n\t}\n\n\tfunction markStatic$1(node) {\n\t\tnode.static = isStatic(node);\n\t\tif (node.type === 1) {\n\t\t\t// do not make component slot content static. this avoids\n\t\t\t// 1. components not able to mutate slot nodes\n\t\t\t// 2. static slot content fails for hot-reloading\n\t\t\tif (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (var i = 0, l = node.children.length; i < l; i++) {\n\t\t\t\tvar child = node.children[i];\n\t\t\t\tmarkStatic$1(child);\n\t\t\t\tif (!child.static) {\n\t\t\t\t\tnode.static = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markStaticRoots(node, isInFor) {\n\t\tif (node.type === 1) {\n\t\t\tif (node.static || node.once) {\n\t\t\t\tnode.staticInFor = isInFor;\n\t\t\t}\n\t\t\t// For a node to qualify as a static root, it should have children that\n\t\t\t// are not just static text. Otherwise the cost of hoisting out will\n\t\t\t// outweigh the benefits and it's better off to just always render it fresh.\n\t\t\tif (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n\t\t\t\tnode.staticRoot = true;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tnode.staticRoot = false;\n\t\t\t}\n\t\t\tif (node.children) {\n\t\t\t\tfor (var i = 0, l = node.children.length; i < l; i++) {\n\t\t\t\t\tmarkStaticRoots(node.children[i], isInFor || !!node.for);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.ifConditions) {\n\t\t\t\twalkThroughConditionsBlocks(node.ifConditions, isInFor);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction walkThroughConditionsBlocks(conditionBlocks, isInFor) {\n\t\tfor (var i = 1, len = conditionBlocks.length; i < len; i++) {\n\t\t\tmarkStaticRoots(conditionBlocks[i].block, isInFor);\n\t\t}\n\t}\n\n\tfunction isStatic(node) {\n\t\tif (node.type === 2) {\n\t\t\t// expression\n\t\t\treturn false;\n\t\t}\n\t\tif (node.type === 3) {\n\t\t\t// text\n\t\t\treturn true;\n\t\t}\n\t\treturn !!(node.pre || !node.hasBindings && // no dynamic bindings\n\t\t!node.if && !node.for && // not v-if or v-for or v-else\n\t\t!isBuiltInTag(node.tag) && // not a built-in\n\t\tisPlatformReservedTag(node.tag) && // not a component\n\t\t!isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n\t}\n\n\tfunction isDirectChildOfTemplateFor(node) {\n\t\twhile (node.parent) {\n\t\t\tnode = node.parent;\n\t\t\tif (node.tag !== 'template') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (node.for) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*  */\n\n\tvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\n\tvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n\t// keyCode aliases\n\tvar keyCodes = {\n\t\tesc: 27,\n\t\ttab: 9,\n\t\tenter: 13,\n\t\tspace: 32,\n\t\tup: 38,\n\t\tleft: 37,\n\t\tright: 39,\n\t\tdown: 40,\n\t\t'delete': [8, 46]\n\t};\n\n\t// #4868: modifiers that prevent the execution of the listener\n\t// need to explicitly return null so that we can determine whether to remove\n\t// the listener for .once\n\tvar genGuard = function genGuard(condition) {\n\t\treturn \"if(\" + condition + \")return null;\";\n\t};\n\n\tvar modifierCode = {\n\t\tstop: '$event.stopPropagation();',\n\t\tprevent: '$event.preventDefault();',\n\t\tself: genGuard(\"$event.target !== $event.currentTarget\"),\n\t\tctrl: genGuard(\"!$event.ctrlKey\"),\n\t\tshift: genGuard(\"!$event.shiftKey\"),\n\t\talt: genGuard(\"!$event.altKey\"),\n\t\tmeta: genGuard(\"!$event.metaKey\"),\n\t\tleft: genGuard(\"'button' in $event && $event.button !== 0\"),\n\t\tmiddle: genGuard(\"'button' in $event && $event.button !== 1\"),\n\t\tright: genGuard(\"'button' in $event && $event.button !== 2\")\n\t};\n\n\tfunction genHandlers(events, isNative, warn) {\n\t\tvar res = isNative ? 'nativeOn:{' : 'on:{';\n\t\tfor (var name in events) {\n\t\t\tvar handler = events[name];\n\t\t\t// #5330: warn click.right, since right clicks do not actually fire click events.\n\t\t\tif (\"development\" !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {\n\t\t\t\twarn(\"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" + \"do not actually fire \\\"click\\\" events.\");\n\t\t\t}\n\t\t\tres += \"\\\"\" + name + \"\\\":\" + genHandler(name, handler) + \",\";\n\t\t}\n\t\treturn res.slice(0, -1) + '}';\n\t}\n\n\tfunction genHandler(name, handler) {\n\t\tif (!handler) {\n\t\t\treturn 'function(){}';\n\t\t}\n\n\t\tif (Array.isArray(handler)) {\n\t\t\treturn \"[\" + handler.map(function (handler) {\n\t\t\t\treturn genHandler(name, handler);\n\t\t\t}).join(',') + \"]\";\n\t\t}\n\n\t\tvar isMethodPath = simplePathRE.test(handler.value);\n\t\tvar isFunctionExpression = fnExpRE.test(handler.value);\n\n\t\tif (!handler.modifiers) {\n\t\t\treturn isMethodPath || isFunctionExpression ? handler.value : \"function($event){\" + handler.value + \"}\"; // inline statement\n\t\t} else {\n\t\t\tvar code = '';\n\t\t\tvar genModifierCode = '';\n\t\t\tvar keys = [];\n\t\t\tfor (var key in handler.modifiers) {\n\t\t\t\tif (modifierCode[key]) {\n\t\t\t\t\tgenModifierCode += modifierCode[key];\n\t\t\t\t\t// left/right\n\t\t\t\t\tif (keyCodes[key]) {\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (keys.length) {\n\t\t\t\tcode += genKeyFilter(keys);\n\t\t\t}\n\t\t\t// Make sure modifiers like prevent and stop get executed after key filtering\n\t\t\tif (genModifierCode) {\n\t\t\t\tcode += genModifierCode;\n\t\t\t}\n\t\t\tvar handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? \"(\" + handler.value + \")($event)\" : handler.value;\n\t\t\treturn \"function($event){\" + code + handlerCode + \"}\";\n\t\t}\n\t}\n\n\tfunction genKeyFilter(keys) {\n\t\treturn \"if(!('button' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n\t}\n\n\tfunction genFilterCode(key) {\n\t\tvar keyVal = parseInt(key, 10);\n\t\tif (keyVal) {\n\t\t\treturn \"$event.keyCode!==\" + keyVal;\n\t\t}\n\t\tvar alias = keyCodes[key];\n\t\treturn \"_k($event.keyCode,\" + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + \")\";\n\t}\n\n\t/*  */\n\n\tfunction bind$1(el, dir) {\n\t\tel.wrapData = function (code) {\n\t\t\treturn \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\";\n\t\t};\n\t}\n\n\t/*  */\n\n\tvar baseDirectives = {\n\t\tbind: bind$1,\n\t\tcloak: noop\n\t};\n\n\t/*  */\n\n\t// configurable state\n\tvar warn$3;\n\tvar transforms$1;\n\tvar dataGenFns;\n\tvar platformDirectives$1;\n\tvar isPlatformReservedTag$1;\n\tvar staticRenderFns;\n\tvar onceCount;\n\tvar currentOptions;\n\n\tfunction generate(ast, options) {\n\t\t// save previous staticRenderFns so generate calls can be nested\n\t\tvar prevStaticRenderFns = staticRenderFns;\n\t\tvar currentStaticRenderFns = staticRenderFns = [];\n\t\tvar prevOnceCount = onceCount;\n\t\tonceCount = 0;\n\t\tcurrentOptions = options;\n\t\twarn$3 = options.warn || baseWarn;\n\t\ttransforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n\t\tdataGenFns = pluckModuleFunction(options.modules, 'genData');\n\t\tplatformDirectives$1 = options.directives || {};\n\t\tisPlatformReservedTag$1 = options.isReservedTag || no;\n\t\tvar code = ast ? genElement(ast) : '_c(\"div\")';\n\t\tstaticRenderFns = prevStaticRenderFns;\n\t\tonceCount = prevOnceCount;\n\t\treturn {\n\t\t\trender: \"with(this){return \" + code + \"}\",\n\t\t\tstaticRenderFns: currentStaticRenderFns\n\t\t};\n\t}\n\n\tfunction genElement(el) {\n\t\tif (el.staticRoot && !el.staticProcessed) {\n\t\t\treturn genStatic(el);\n\t\t} else if (el.once && !el.onceProcessed) {\n\t\t\treturn genOnce(el);\n\t\t} else if (el.for && !el.forProcessed) {\n\t\t\treturn genFor(el);\n\t\t} else if (el.if && !el.ifProcessed) {\n\t\t\treturn genIf(el);\n\t\t} else if (el.tag === 'template' && !el.slotTarget) {\n\t\t\treturn genChildren(el) || 'void 0';\n\t\t} else if (el.tag === 'slot') {\n\t\t\treturn genSlot(el);\n\t\t} else {\n\t\t\t// component or element\n\t\t\tvar code;\n\t\t\tif (el.component) {\n\t\t\t\tcode = genComponent(el.component, el);\n\t\t\t} else {\n\t\t\t\tvar data = el.plain ? undefined : genData(el);\n\n\t\t\t\tvar children = el.inlineTemplate ? null : genChildren(el, true);\n\t\t\t\tcode = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n\t\t\t}\n\t\t\t// module transforms\n\t\t\tfor (var i = 0; i < transforms$1.length; i++) {\n\t\t\t\tcode = transforms$1[i](el, code);\n\t\t\t}\n\t\t\treturn code;\n\t\t}\n\t}\n\n\t// hoist static sub-trees out\n\tfunction genStatic(el) {\n\t\tel.staticProcessed = true;\n\t\tstaticRenderFns.push(\"with(this){return \" + genElement(el) + \"}\");\n\t\treturn \"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n\t}\n\n\t// v-once\n\tfunction genOnce(el) {\n\t\tel.onceProcessed = true;\n\t\tif (el.if && !el.ifProcessed) {\n\t\t\treturn genIf(el);\n\t\t} else if (el.staticInFor) {\n\t\t\tvar key = '';\n\t\t\tvar parent = el.parent;\n\t\t\twhile (parent) {\n\t\t\t\tif (parent.for) {\n\t\t\t\t\tkey = parent.key;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t\tif (!key) {\n\t\t\t\t\"development\" !== 'production' && warn$3(\"v-once can only be used inside v-for that is keyed. \");\n\t\t\t\treturn genElement(el);\n\t\t\t}\n\t\t\treturn \"_o(\" + genElement(el) + \",\" + onceCount++ + (key ? \",\" + key : \"\") + \")\";\n\t\t} else {\n\t\t\treturn genStatic(el);\n\t\t}\n\t}\n\n\tfunction genIf(el) {\n\t\tel.ifProcessed = true; // avoid recursion\n\t\treturn genIfConditions(el.ifConditions.slice());\n\t}\n\n\tfunction genIfConditions(conditions) {\n\t\tif (!conditions.length) {\n\t\t\treturn '_e()';\n\t\t}\n\n\t\tvar condition = conditions.shift();\n\t\tif (condition.exp) {\n\t\t\treturn \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions);\n\t\t} else {\n\t\t\treturn \"\" + genTernaryExp(condition.block);\n\t\t}\n\n\t\t// v-if with v-once should generate code like (a)?_m(0):_m(1)\n\t\tfunction genTernaryExp(el) {\n\t\t\treturn el.once ? genOnce(el) : genElement(el);\n\t\t}\n\t}\n\n\tfunction genFor(el) {\n\t\tvar exp = el.for;\n\t\tvar alias = el.alias;\n\t\tvar iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n\t\tvar iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n\t\tif (\"development\" !== 'production' && maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n\t\t\twarn$3(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", true /* tip */\n\t\t\t);\n\t\t}\n\n\t\tel.forProcessed = true; // avoid recursion\n\t\treturn \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genElement(el) + '})';\n\t}\n\n\tfunction genData(el) {\n\t\tvar data = '{';\n\n\t\t// directives first.\n\t\t// directives may mutate the el's other properties before they are generated.\n\t\tvar dirs = genDirectives(el);\n\t\tif (dirs) {\n\t\t\tdata += dirs + ',';\n\t\t}\n\n\t\t// key\n\t\tif (el.key) {\n\t\t\tdata += \"key:\" + el.key + \",\";\n\t\t}\n\t\t// ref\n\t\tif (el.ref) {\n\t\t\tdata += \"ref:\" + el.ref + \",\";\n\t\t}\n\t\tif (el.refInFor) {\n\t\t\tdata += \"refInFor:true,\";\n\t\t}\n\t\t// pre\n\t\tif (el.pre) {\n\t\t\tdata += \"pre:true,\";\n\t\t}\n\t\t// record original tag name for components using \"is\" attribute\n\t\tif (el.component) {\n\t\t\tdata += \"tag:\\\"\" + el.tag + \"\\\",\";\n\t\t}\n\t\t// module data generation functions\n\t\tfor (var i = 0; i < dataGenFns.length; i++) {\n\t\t\tdata += dataGenFns[i](el);\n\t\t}\n\t\t// attributes\n\t\tif (el.attrs) {\n\t\t\tdata += \"attrs:{\" + genProps(el.attrs) + \"},\";\n\t\t}\n\t\t// DOM props\n\t\tif (el.props) {\n\t\t\tdata += \"domProps:{\" + genProps(el.props) + \"},\";\n\t\t}\n\t\t// event handlers\n\t\tif (el.events) {\n\t\t\tdata += genHandlers(el.events, false, warn$3) + \",\";\n\t\t}\n\t\tif (el.nativeEvents) {\n\t\t\tdata += genHandlers(el.nativeEvents, true, warn$3) + \",\";\n\t\t}\n\t\t// slot target\n\t\tif (el.slotTarget) {\n\t\t\tdata += \"slot:\" + el.slotTarget + \",\";\n\t\t}\n\t\t// scoped slots\n\t\tif (el.scopedSlots) {\n\t\t\tdata += genScopedSlots(el.scopedSlots) + \",\";\n\t\t}\n\t\t// component v-model\n\t\tif (el.model) {\n\t\t\tdata += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n\t\t}\n\t\t// inline-template\n\t\tif (el.inlineTemplate) {\n\t\t\tvar inlineTemplate = genInlineTemplate(el);\n\t\t\tif (inlineTemplate) {\n\t\t\t\tdata += inlineTemplate + \",\";\n\t\t\t}\n\t\t}\n\t\tdata = data.replace(/,$/, '') + '}';\n\t\t// v-bind data wrap\n\t\tif (el.wrapData) {\n\t\t\tdata = el.wrapData(data);\n\t\t}\n\t\treturn data;\n\t}\n\n\tfunction genDirectives(el) {\n\t\tvar dirs = el.directives;\n\t\tif (!dirs) {\n\t\t\treturn;\n\t\t}\n\t\tvar res = 'directives:[';\n\t\tvar hasRuntime = false;\n\t\tvar i, l, dir, needRuntime;\n\t\tfor (i = 0, l = dirs.length; i < l; i++) {\n\t\t\tdir = dirs[i];\n\t\t\tneedRuntime = true;\n\t\t\tvar gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n\t\t\tif (gen) {\n\t\t\t\t// compile-time directive that manipulates AST.\n\t\t\t\t// returns true if it also needs a runtime counterpart.\n\t\t\t\tneedRuntime = !!gen(el, dir, warn$3);\n\t\t\t}\n\t\t\tif (needRuntime) {\n\t\t\t\thasRuntime = true;\n\t\t\t\tres += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\\\"\" + dir.arg + \"\\\"\" : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n\t\t\t}\n\t\t}\n\t\tif (hasRuntime) {\n\t\t\treturn res.slice(0, -1) + ']';\n\t\t}\n\t}\n\n\tfunction genInlineTemplate(el) {\n\t\tvar ast = el.children[0];\n\t\tif (\"development\" !== 'production' && (el.children.length > 1 || ast.type !== 1)) {\n\t\t\twarn$3('Inline-template components must have exactly one child element.');\n\t\t}\n\t\tif (ast.type === 1) {\n\t\t\tvar inlineRenderFns = generate(ast, currentOptions);\n\t\t\treturn \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n\t\t\t\treturn \"function(){\" + code + \"}\";\n\t\t\t}).join(',') + \"]}\";\n\t\t}\n\t}\n\n\tfunction genScopedSlots(slots) {\n\t\treturn \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n\t\t\treturn genScopedSlot(key, slots[key]);\n\t\t}).join(',') + \"])\";\n\t}\n\n\tfunction genScopedSlot(key, el) {\n\t\tif (el.for && !el.forProcessed) {\n\t\t\treturn genForScopedSlot(key, el);\n\t\t}\n\t\treturn \"{key:\" + key + \",fn:function(\" + String(el.attrsMap.scope) + \"){\" + \"return \" + (el.tag === 'template' ? genChildren(el) || 'void 0' : genElement(el)) + \"}}\";\n\t}\n\n\tfunction genForScopedSlot(key, el) {\n\t\tvar exp = el.for;\n\t\tvar alias = el.alias;\n\t\tvar iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n\t\tvar iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\t\tel.forProcessed = true; // avoid recursion\n\t\treturn \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genScopedSlot(key, el) + '})';\n\t}\n\n\tfunction genChildren(el, checkSkip) {\n\t\tvar children = el.children;\n\t\tif (children.length) {\n\t\t\tvar el$1 = children[0];\n\t\t\t// optimize single v-for\n\t\t\tif (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n\t\t\t\treturn genElement(el$1);\n\t\t\t}\n\t\t\tvar normalizationType = checkSkip ? getNormalizationType(children) : 0;\n\t\t\treturn \"[\" + children.map(genNode).join(',') + \"]\" + (normalizationType ? \",\" + normalizationType : '');\n\t\t}\n\t}\n\n\t// determine the normalization needed for the children array.\n\t// 0: no normalization needed\n\t// 1: simple normalization needed (possible 1-level deep nested array)\n\t// 2: full normalization needed\n\tfunction getNormalizationType(children) {\n\t\tvar res = 0;\n\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\tvar el = children[i];\n\t\t\tif (el.type !== 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n\t\t\t\treturn needsNormalization(c.block);\n\t\t\t})) {\n\t\t\t\tres = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n\t\t\t\treturn maybeComponent(c.block);\n\t\t\t})) {\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction needsNormalization(el) {\n\t\treturn el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n\t}\n\n\tfunction maybeComponent(el) {\n\t\treturn !isPlatformReservedTag$1(el.tag);\n\t}\n\n\tfunction genNode(node) {\n\t\tif (node.type === 1) {\n\t\t\treturn genElement(node);\n\t\t} else {\n\t\t\treturn genText(node);\n\t\t}\n\t}\n\n\tfunction genText(text) {\n\t\treturn \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n\t\t: transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n\t}\n\n\tfunction genSlot(el) {\n\t\tvar slotName = el.slotName || '\"default\"';\n\t\tvar children = genChildren(el);\n\t\tvar res = \"_t(\" + slotName + (children ? \",\" + children : '');\n\t\tvar attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n\t\t\treturn camelize(a.name) + \":\" + a.value;\n\t\t}).join(',') + \"}\";\n\t\tvar bind$$1 = el.attrsMap['v-bind'];\n\t\tif ((attrs || bind$$1) && !children) {\n\t\t\tres += \",null\";\n\t\t}\n\t\tif (attrs) {\n\t\t\tres += \",\" + attrs;\n\t\t}\n\t\tif (bind$$1) {\n\t\t\tres += (attrs ? '' : ',null') + \",\" + bind$$1;\n\t\t}\n\t\treturn res + ')';\n\t}\n\n\t// componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\tfunction genComponent(componentName, el) {\n\t\tvar children = el.inlineTemplate ? null : genChildren(el, true);\n\t\treturn \"_c(\" + componentName + \",\" + genData(el) + (children ? \",\" + children : '') + \")\";\n\t}\n\n\tfunction genProps(props) {\n\t\tvar res = '';\n\t\tfor (var i = 0; i < props.length; i++) {\n\t\t\tvar prop = props[i];\n\t\t\tres += \"\\\"\" + prop.name + \"\\\":\" + transformSpecialNewlines(prop.value) + \",\";\n\t\t}\n\t\treturn res.slice(0, -1);\n\t}\n\n\t// #3895, #4268\n\tfunction transformSpecialNewlines(text) {\n\t\treturn text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n\t}\n\n\t/*  */\n\n\t// these keywords should not appear inside expressions, but operators like\n\t// typeof, instanceof and in are allowed\n\tvar prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n\t// these unary operators should not be used as property/method names\n\tvar unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n\t// check valid identifier for v-for\n\tvar identRE = /[A-Za-z_$][\\w$]*/;\n\n\t// strip strings in expressions\n\tvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n\t// detect problematic expressions in a template\n\tfunction detectErrors(ast) {\n\t\tvar errors = [];\n\t\tif (ast) {\n\t\t\tcheckNode(ast, errors);\n\t\t}\n\t\treturn errors;\n\t}\n\n\tfunction checkNode(node, errors) {\n\t\tif (node.type === 1) {\n\t\t\tfor (var name in node.attrsMap) {\n\t\t\t\tif (dirRE.test(name)) {\n\t\t\t\t\tvar value = node.attrsMap[name];\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (name === 'v-for') {\n\t\t\t\t\t\t\tcheckFor(node, \"v-for=\\\"\" + value + \"\\\"\", errors);\n\t\t\t\t\t\t} else if (onRE.test(name)) {\n\t\t\t\t\t\t\tcheckEvent(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcheckExpression(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.children) {\n\t\t\t\tfor (var i = 0; i < node.children.length; i++) {\n\t\t\t\t\tcheckNode(node.children[i], errors);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node.type === 2) {\n\t\t\tcheckExpression(node.expression, node.text, errors);\n\t\t}\n\t}\n\n\tfunction checkEvent(exp, text, errors) {\n\t\tvar stipped = exp.replace(stripStringRE, '');\n\t\tvar keywordMatch = stipped.match(unaryOperatorsRE);\n\t\tif (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n\t\t\terrors.push(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n\t\t}\n\t\tcheckExpression(exp, text, errors);\n\t}\n\n\tfunction checkFor(node, text, errors) {\n\t\tcheckExpression(node.for || '', text, errors);\n\t\tcheckIdentifier(node.alias, 'v-for alias', text, errors);\n\t\tcheckIdentifier(node.iterator1, 'v-for iterator', text, errors);\n\t\tcheckIdentifier(node.iterator2, 'v-for iterator', text, errors);\n\t}\n\n\tfunction checkIdentifier(ident, type, text, errors) {\n\t\tif (typeof ident === 'string' && !identRE.test(ident)) {\n\t\t\terrors.push(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim());\n\t\t}\n\t}\n\n\tfunction checkExpression(exp, text, errors) {\n\t\ttry {\n\t\t\tnew Function(\"return \" + exp);\n\t\t} catch (e) {\n\t\t\tvar keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\t\t\tif (keywordMatch) {\n\t\t\t\terrors.push(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n\t\t\t} else {\n\t\t\t\terrors.push(\"invalid expression: \" + text.trim());\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction baseCompile(template, options) {\n\t\tvar ast = parse(template.trim(), options);\n\t\toptimize(ast, options);\n\t\tvar code = generate(ast, options);\n\t\treturn {\n\t\t\tast: ast,\n\t\t\trender: code.render,\n\t\t\tstaticRenderFns: code.staticRenderFns\n\t\t};\n\t}\n\n\tfunction makeFunction(code, errors) {\n\t\ttry {\n\t\t\treturn new Function(code);\n\t\t} catch (err) {\n\t\t\terrors.push({ err: err, code: code });\n\t\t\treturn noop;\n\t\t}\n\t}\n\n\tfunction createCompiler(baseOptions) {\n\t\tvar functionCompileCache = Object.create(null);\n\n\t\tfunction compile(template, options) {\n\t\t\tvar finalOptions = Object.create(baseOptions);\n\t\t\tvar errors = [];\n\t\t\tvar tips = [];\n\t\t\tfinalOptions.warn = function (msg, tip$$1) {\n\t\t\t\t(tip$$1 ? tips : errors).push(msg);\n\t\t\t};\n\n\t\t\tif (options) {\n\t\t\t\t// merge custom modules\n\t\t\t\tif (options.modules) {\n\t\t\t\t\tfinalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n\t\t\t\t}\n\t\t\t\t// merge custom directives\n\t\t\t\tif (options.directives) {\n\t\t\t\t\tfinalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);\n\t\t\t\t}\n\t\t\t\t// copy other options\n\t\t\t\tfor (var key in options) {\n\t\t\t\t\tif (key !== 'modules' && key !== 'directives') {\n\t\t\t\t\t\tfinalOptions[key] = options[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar compiled = baseCompile(template, finalOptions);\n\t\t\t{\n\t\t\t\terrors.push.apply(errors, detectErrors(compiled.ast));\n\t\t\t}\n\t\t\tcompiled.errors = errors;\n\t\t\tcompiled.tips = tips;\n\t\t\treturn compiled;\n\t\t}\n\n\t\tfunction compileToFunctions(template, options, vm) {\n\t\t\toptions = options || {};\n\n\t\t\t/* istanbul ignore if */\n\t\t\t{\n\t\t\t\t// detect possible CSP restriction\n\t\t\t\ttry {\n\t\t\t\t\tnew Function('return 1');\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e.toString().match(/unsafe-eval|CSP/)) {\n\t\t\t\t\t\twarn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check cache\n\t\t\tvar key = options.delimiters ? String(options.delimiters) + template : template;\n\t\t\tif (functionCompileCache[key]) {\n\t\t\t\treturn functionCompileCache[key];\n\t\t\t}\n\n\t\t\t// compile\n\t\t\tvar compiled = compile(template, options);\n\n\t\t\t// check compilation errors/tips\n\t\t\t{\n\t\t\t\tif (compiled.errors && compiled.errors.length) {\n\t\t\t\t\twarn(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n\t\t\t\t\t\treturn \"- \" + e;\n\t\t\t\t\t}).join('\\n') + '\\n', vm);\n\t\t\t\t}\n\t\t\t\tif (compiled.tips && compiled.tips.length) {\n\t\t\t\t\tcompiled.tips.forEach(function (msg) {\n\t\t\t\t\t\treturn tip(msg, vm);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn code into functions\n\t\t\tvar res = {};\n\t\t\tvar fnGenErrors = [];\n\t\t\tres.render = makeFunction(compiled.render, fnGenErrors);\n\t\t\tvar l = compiled.staticRenderFns.length;\n\t\t\tres.staticRenderFns = new Array(l);\n\t\t\tfor (var i = 0; i < l; i++) {\n\t\t\t\tres.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n\t\t\t}\n\n\t\t\t// check function generation errors.\n\t\t\t// this should only happen if there is a bug in the compiler itself.\n\t\t\t// mostly for codegen development use\n\t\t\t/* istanbul ignore if */\n\t\t\t{\n\t\t\t\tif ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n\t\t\t\t\twarn(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n\t\t\t\t\t\tvar err = ref.err;\n\t\t\t\t\t\tvar code = ref.code;\n\n\t\t\t\t\t\treturn err.toString() + \" in\\n\\n\" + code + \"\\n\";\n\t\t\t\t\t}).join('\\n'), vm);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn functionCompileCache[key] = res;\n\t\t}\n\n\t\treturn {\n\t\t\tcompile: compile,\n\t\t\tcompileToFunctions: compileToFunctions\n\t\t};\n\t}\n\n\t/*  */\n\n\tfunction transformNode(el, options) {\n\t\tvar warn = options.warn || baseWarn;\n\t\tvar staticClass = getAndRemoveAttr(el, 'class');\n\t\tif (\"development\" !== 'production' && staticClass) {\n\t\t\tvar expression = parseText(staticClass, options.delimiters);\n\t\t\tif (expression) {\n\t\t\t\twarn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.');\n\t\t\t}\n\t\t}\n\t\tif (staticClass) {\n\t\t\tel.staticClass = JSON.stringify(staticClass);\n\t\t}\n\t\tvar classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n\t\tif (classBinding) {\n\t\t\tel.classBinding = classBinding;\n\t\t}\n\t}\n\n\tfunction genData$1(el) {\n\t\tvar data = '';\n\t\tif (el.staticClass) {\n\t\t\tdata += \"staticClass:\" + el.staticClass + \",\";\n\t\t}\n\t\tif (el.classBinding) {\n\t\t\tdata += \"class:\" + el.classBinding + \",\";\n\t\t}\n\t\treturn data;\n\t}\n\n\tvar klass$1 = {\n\t\tstaticKeys: ['staticClass'],\n\t\ttransformNode: transformNode,\n\t\tgenData: genData$1\n\t};\n\n\t/*  */\n\n\tfunction transformNode$1(el, options) {\n\t\tvar warn = options.warn || baseWarn;\n\t\tvar staticStyle = getAndRemoveAttr(el, 'style');\n\t\tif (staticStyle) {\n\t\t\t/* istanbul ignore if */\n\t\t\t{\n\t\t\t\tvar expression = parseText(staticStyle, options.delimiters);\n\t\t\t\tif (expression) {\n\t\t\t\t\twarn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tel.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n\t\t}\n\n\t\tvar styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n\t\tif (styleBinding) {\n\t\t\tel.styleBinding = styleBinding;\n\t\t}\n\t}\n\n\tfunction genData$2(el) {\n\t\tvar data = '';\n\t\tif (el.staticStyle) {\n\t\t\tdata += \"staticStyle:\" + el.staticStyle + \",\";\n\t\t}\n\t\tif (el.styleBinding) {\n\t\t\tdata += \"style:(\" + el.styleBinding + \"),\";\n\t\t}\n\t\treturn data;\n\t}\n\n\tvar style$1 = {\n\t\tstaticKeys: ['staticStyle'],\n\t\ttransformNode: transformNode$1,\n\t\tgenData: genData$2\n\t};\n\n\tvar modules$1 = [klass$1, style$1];\n\n\t/*  */\n\n\tfunction text(el, dir) {\n\t\tif (dir.value) {\n\t\t\taddProp(el, 'textContent', \"_s(\" + dir.value + \")\");\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction html(el, dir) {\n\t\tif (dir.value) {\n\t\t\taddProp(el, 'innerHTML', \"_s(\" + dir.value + \")\");\n\t\t}\n\t}\n\n\tvar directives$1 = {\n\t\tmodel: model,\n\t\ttext: text,\n\t\thtml: html\n\t};\n\n\t/*  */\n\n\tvar baseOptions = {\n\t\texpectHTML: true,\n\t\tmodules: modules$1,\n\t\tdirectives: directives$1,\n\t\tisPreTag: isPreTag,\n\t\tisUnaryTag: isUnaryTag,\n\t\tmustUseProp: mustUseProp,\n\t\tcanBeLeftOpenTag: canBeLeftOpenTag,\n\t\tisReservedTag: isReservedTag,\n\t\tgetTagNamespace: getTagNamespace,\n\t\tstaticKeys: genStaticKeys(modules$1)\n\t};\n\n\tvar ref$1 = createCompiler(baseOptions);\n\tvar compileToFunctions = ref$1.compileToFunctions;\n\n\t/*  */\n\n\tvar idToTemplate = cached(function (id) {\n\t\tvar el = query(id);\n\t\treturn el && el.innerHTML;\n\t});\n\n\tvar mount = Vue$3.prototype.$mount;\n\tVue$3.prototype.$mount = function (el, hydrating) {\n\t\tel = el && query(el);\n\n\t\t/* istanbul ignore if */\n\t\tif (el === document.body || el === document.documentElement) {\n\t\t\t\"development\" !== 'production' && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n\t\t\treturn this;\n\t\t}\n\n\t\tvar options = this.$options;\n\t\t// resolve template/el and convert to render function\n\t\tif (!options.render) {\n\t\t\tvar template = options.template;\n\t\t\tif (template) {\n\t\t\t\tif (typeof template === 'string') {\n\t\t\t\t\tif (template.charAt(0) === '#') {\n\t\t\t\t\t\ttemplate = idToTemplate(template);\n\t\t\t\t\t\t/* istanbul ignore if */\n\t\t\t\t\t\tif (\"development\" !== 'production' && !template) {\n\t\t\t\t\t\t\twarn(\"Template element not found or is empty: \" + options.template, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (template.nodeType) {\n\t\t\t\t\ttemplate = template.innerHTML;\n\t\t\t\t} else {\n\t\t\t\t\t{\n\t\t\t\t\t\twarn('invalid template option:' + template, this);\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} else if (el) {\n\t\t\t\ttemplate = getOuterHTML(el);\n\t\t\t}\n\t\t\tif (template) {\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (\"development\" !== 'production' && config.performance && mark) {\n\t\t\t\t\tmark('compile');\n\t\t\t\t}\n\n\t\t\t\tvar ref = compileToFunctions(template, {\n\t\t\t\t\tshouldDecodeNewlines: shouldDecodeNewlines,\n\t\t\t\t\tdelimiters: options.delimiters\n\t\t\t\t}, this);\n\t\t\t\tvar render = ref.render;\n\t\t\t\tvar staticRenderFns = ref.staticRenderFns;\n\t\t\t\toptions.render = render;\n\t\t\t\toptions.staticRenderFns = staticRenderFns;\n\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (\"development\" !== 'production' && config.performance && mark) {\n\t\t\t\t\tmark('compile end');\n\t\t\t\t\tmeasure(this._name + \" compile\", 'compile', 'compile end');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mount.call(this, el, hydrating);\n\t};\n\n\t/**\n  * Get outerHTML of elements, taking care\n  * of SVG elements in IE as well.\n  */\n\tfunction getOuterHTML(el) {\n\t\tif (el.outerHTML) {\n\t\t\treturn el.outerHTML;\n\t\t} else {\n\t\t\tvar container = document.createElement('div');\n\t\t\tcontainer.appendChild(el.cloneNode(true));\n\t\t\treturn container.innerHTML;\n\t\t}\n\t}\n\n\tVue$3.compile = compileToFunctions;\n\n\treturn Vue$3;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ 9)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9wdWJsaWMvc2NyaXB0cy9saWIvdnVlLmpzPzMzNTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBWdWUuanMgdjIuMy40XG4gKiAoYykgMjAxNC0yMDE3IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0XHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHRcdFx0KGdsb2JhbC5WdWUgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cblx0LyogICovXG5cbi8vIHRoZXNlIGhlbHBlcnMgcHJvZHVjZXMgYmV0dGVyIHZtIGNvZGUgaW4gSlMgZW5naW5lcyBkdWUgdG8gdGhlaXJcbi8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmdcblx0ZnVuY3Rpb24gaXNVbmRlZiAodikge1xuXHRcdHJldHVybiB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbFxuXHR9XG5cblx0ZnVuY3Rpb24gaXNEZWYgKHYpIHtcblx0XHRyZXR1cm4gdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGxcblx0fVxuXG5cdGZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuXHRcdHJldHVybiB2ID09PSB0cnVlXG5cdH1cblxuXHRmdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG5cdFx0cmV0dXJuIHYgPT09IGZhbHNlXG5cdH1cblx0LyoqXG5cdCAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuXHQgKi9cblx0ZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJ1xuXHR9XG5cblx0LyoqXG5cdCAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuXHQgKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG5cdCAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cblx0ICovXG5cdGZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcblx0XHRyZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG5cdH1cblxuXHR2YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuXHQvKipcblx0ICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuXHQgKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuXHQgKi9cblx0ZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG5cdFx0cmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG5cdH1cblxuXHRmdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuXHRcdHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBzdHJpbmcgdGhhdCBpcyBhY3R1YWxseSByZW5kZXJlZC5cblx0ICovXG5cdGZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcblx0XHRyZXR1cm4gdmFsID09IG51bGxcblx0XHRcdD8gJydcblx0XHRcdDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcblx0XHRcdD8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuXHRcdFx0OiBTdHJpbmcodmFsKVxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG5cdCAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuXHRcdHZhciBuID0gcGFyc2VGbG9hdCh2YWwpO1xuXHRcdHJldHVybiBpc05hTihuKSA/IHZhbCA6IG5cblx0fVxuXG5cdC8qKlxuXHQgKiBNYWtlIGEgbWFwIGFuZCByZXR1cm4gYSBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYSBrZXlcblx0ICogaXMgaW4gdGhhdCBtYXAuXG5cdCAqL1xuXHRmdW5jdGlvbiBtYWtlTWFwIChcblx0XHRzdHIsXG5cdFx0ZXhwZWN0c0xvd2VyQ2FzZVxuXHQpIHtcblx0XHR2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR2YXIgbGlzdCA9IHN0ci5zcGxpdCgnLCcpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0bWFwW2xpc3RbaV1dID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGV4cGVjdHNMb3dlckNhc2Vcblx0XHRcdD8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuXHRcdFx0OiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBtYXBbdmFsXTsgfVxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuXHQgKi9cblx0dmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXlcblx0ICovXG5cdGZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG5cdFx0aWYgKGFyci5sZW5ndGgpIHtcblx0XHRcdHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuXHRcdFx0aWYgKGluZGV4ID4gLTEpIHtcblx0XHRcdFx0cmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuXHQgKi9cblx0dmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0ZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuXHRcdHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcblx0XHR2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuXHRcdFx0dmFyIGhpdCA9IGNhY2hlW3N0cl07XG5cdFx0XHRyZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcblx0XHR9KVxuXHR9XG5cblx0LyoqXG5cdCAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG5cdCAqL1xuXHR2YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcblx0dmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcblx0fSk7XG5cblx0LyoqXG5cdCAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG5cdCAqL1xuXHR2YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxuXHR9KTtcblxuXHQvKipcblx0ICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cblx0ICovXG5cdHZhciBoeXBoZW5hdGVSRSA9IC8oW14tXSkoW0EtWl0pL2c7XG5cdHZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuXHRcdHJldHVybiBzdHJcblx0XHRcdC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuXHRcdFx0LnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG5cdFx0XHQudG9Mb3dlckNhc2UoKVxuXHR9KTtcblxuXHQvKipcblx0ICogU2ltcGxlIGJpbmQsIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYmluZCAoZm4sIGN0eCkge1xuXHRcdGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcblx0XHRcdHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRcdHJldHVybiBsXG5cdFx0XHRcdD8gbCA+IDFcblx0XHRcdFx0PyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcblx0XHRcdFx0OiBmbi5jYWxsKGN0eCwgYSlcblx0XHRcdFx0OiBmbi5jYWxsKGN0eClcblx0XHR9XG5cdFx0Ly8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuXHRcdGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcblx0XHRyZXR1cm4gYm91bmRGblxuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcblx0XHRzdGFydCA9IHN0YXJ0IHx8IDA7XG5cdFx0dmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuXHRcdHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0cmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0XG5cdH1cblxuXHQvKipcblx0ICogTWl4IHByb3BlcnRpZXMgaW50byB0YXJnZXQgb2JqZWN0LlxuXHQgKi9cblx0ZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gX2Zyb20pIHtcblx0XHRcdHRvW2tleV0gPSBfZnJvbVtrZXldO1xuXHRcdH1cblx0XHRyZXR1cm4gdG9cblx0fVxuXG5cdC8qKlxuXHQgKiBNZXJnZSBhbiBBcnJheSBvZiBPYmplY3RzIGludG8gYSBzaW5nbGUgT2JqZWN0LlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuXHRcdHZhciByZXMgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycltpXSkge1xuXHRcdFx0XHRleHRlbmQocmVzLCBhcnJbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzXG5cdH1cblxuXHQvKipcblx0ICogUGVyZm9ybSBubyBvcGVyYXRpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBub29wICgpIHt9XG5cblx0LyoqXG5cdCAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG5cdCAqL1xuXHR2YXIgbm8gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuXHQvKipcblx0ICogUmV0dXJuIHNhbWUgdmFsdWVcblx0ICovXG5cdHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhIHN0YXRpYyBrZXlzIHN0cmluZyBmcm9tIGNvbXBpbGVyIG1vZHVsZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG5cdFx0cmV0dXJuIG1vZHVsZXMucmVkdWNlKGZ1bmN0aW9uIChrZXlzLCBtKSB7XG5cdFx0XHRyZXR1cm4ga2V5cy5jb25jYXQobS5zdGF0aWNLZXlzIHx8IFtdKVxuXHRcdH0sIFtdKS5qb2luKCcsJylcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcblx0ICogaWYgdGhleSBhcmUgcGxhaW4gb2JqZWN0cywgZG8gdGhleSBoYXZlIHRoZSBzYW1lIHNoYXBlP1xuXHQgKi9cblx0ZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuXHRcdHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcblx0XHR2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG5cdFx0aWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYilcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0Ly8gcG9zc2libGUgY2lyY3VsYXIgcmVmZXJlbmNlXG5cdFx0XHRcdHJldHVybiBhID09PSBiXG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghaXNPYmplY3RBICYmICFpc09iamVjdEIpIHtcblx0XHRcdHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBsb29zZUluZGV4T2YgKGFyciwgdmFsKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG5cdFx0fVxuXHRcdHJldHVybiAtMVxuXHR9XG5cblx0LyoqXG5cdCAqIEVuc3VyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IG9uY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBvbmNlIChmbikge1xuXHRcdHZhciBjYWxsZWQgPSBmYWxzZTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCFjYWxsZWQpIHtcblx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgU1NSX0FUVFIgPSAnZGF0YS1zZXJ2ZXItcmVuZGVyZWQnO1xuXG5cdHZhciBBU1NFVF9UWVBFUyA9IFtcblx0XHQnY29tcG9uZW50Jyxcblx0XHQnZGlyZWN0aXZlJyxcblx0XHQnZmlsdGVyJ1xuXHRdO1xuXG5cdHZhciBMSUZFQ1lDTEVfSE9PS1MgPSBbXG5cdFx0J2JlZm9yZUNyZWF0ZScsXG5cdFx0J2NyZWF0ZWQnLFxuXHRcdCdiZWZvcmVNb3VudCcsXG5cdFx0J21vdW50ZWQnLFxuXHRcdCdiZWZvcmVVcGRhdGUnLFxuXHRcdCd1cGRhdGVkJyxcblx0XHQnYmVmb3JlRGVzdHJveScsXG5cdFx0J2Rlc3Ryb3llZCcsXG5cdFx0J2FjdGl2YXRlZCcsXG5cdFx0J2RlYWN0aXZhdGVkJ1xuXHRdO1xuXG5cdC8qICAqL1xuXG5cdHZhciBjb25maWcgPSAoe1xuXHRcdC8qKlxuXHRcdCAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuXHRcdCAqL1xuXHRcdG9wdGlvbk1lcmdlU3RyYXRlZ2llczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG5cdFx0ICovXG5cdFx0c2lsZW50OiBmYWxzZSxcblxuXHRcdC8qKlxuXHRcdCAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG5cdFx0ICovXG5cdFx0cHJvZHVjdGlvblRpcDogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuXHRcdCAqL1xuXHRcdGRldnRvb2xzOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuXHRcdC8qKlxuXHRcdCAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcblx0XHQgKi9cblx0XHRwZXJmb3JtYW5jZTogZmFsc2UsXG5cblx0XHQvKipcblx0XHQgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuXHRcdCAqL1xuXHRcdGVycm9ySGFuZGxlcjogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuXHRcdCAqL1xuXHRcdGlnbm9yZWRFbGVtZW50czogW10sXG5cblx0XHQvKipcblx0XHQgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuXHRcdCAqL1xuXHRcdGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG5cdFx0ICogY29tcG9uZW50LiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuXHRcdCAqL1xuXHRcdGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHVzZWQgYXMgYSBjb21wb25lbnRcblx0XHQgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuXHRcdCAqL1xuXHRcdGlzUmVzZXJ2ZWRBdHRyOiBubyxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cblx0XHQgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG5cdFx0ICovXG5cdFx0aXNVbmtub3duRWxlbWVudDogbm8sXG5cblx0XHQvKipcblx0XHQgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG5cdFx0ICovXG5cdFx0Z2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG5cdFx0LyoqXG5cdFx0ICogUGFyc2UgdGhlIHJlYWwgdGFnIG5hbWUgZm9yIHRoZSBzcGVjaWZpYyBwbGF0Zm9ybS5cblx0XHQgKi9cblx0XHRwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuXHRcdCAqIFBsYXRmb3JtLWRlcGVuZGVudC5cblx0XHQgKi9cblx0XHRtdXN0VXNlUHJvcDogbm8sXG5cblx0XHQvKipcblx0XHQgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuXHRcdCAqL1xuXHRcdF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG5cdH0pO1xuXG5cdC8qICAqL1xuXG5cdHZhciBlbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cblx0ICovXG5cdGZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuXHRcdHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuXHRcdHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWZpbmUgYSBwcm9wZXJ0eS5cblx0ICovXG5cdGZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuXHRcdFx0dmFsdWU6IHZhbCxcblx0XHRcdGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcblx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2Ugc2ltcGxlIHBhdGguXG5cdCAqL1xuXHR2YXIgYmFpbFJFID0gL1teXFx3LiRdLztcblx0ZnVuY3Rpb24gcGFyc2VQYXRoIChwYXRoKSB7XG5cdFx0aWYgKGJhaWxSRS50ZXN0KHBhdGgpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuXHRcdHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmICghb2JqKSB7IHJldHVybiB9XG5cdFx0XHRcdG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqXG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0dmFyIHdhcm4gPSBub29wO1xuXHR2YXIgdGlwID0gbm9vcDtcblx0dmFyIGZvcm1hdENvbXBvbmVudE5hbWUgPSAobnVsbCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcblxuXHR7XG5cdFx0dmFyIGhhc0NvbnNvbGUgPSB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCc7XG5cdFx0dmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG5cdFx0dmFyIGNsYXNzaWZ5ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyXG5cdFx0XHQucmVwbGFjZShjbGFzc2lmeVJFLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KVxuXHRcdFx0LnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG5cdFx0d2FybiA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG5cdFx0XHRpZiAoaGFzQ29uc29sZSAmJiAoIWNvbmZpZy5zaWxlbnQpKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIChcblx0XHRcdFx0XHRcdHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuXHRcdFx0XHRcdCkpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR0aXAgPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuXHRcdFx0aWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oXCJbVnVlIHRpcF06IFwiICsgbXNnICsgKFxuXHRcdFx0XHRcdFx0dm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG5cdFx0XHRcdFx0KSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG5cdFx0XHRpZiAodm0uJHJvb3QgPT09IHZtKSB7XG5cdFx0XHRcdHJldHVybiAnPFJvb3Q+J1xuXHRcdFx0fVxuXHRcdFx0dmFyIG5hbWUgPSB0eXBlb2Ygdm0gPT09ICdzdHJpbmcnXG5cdFx0XHRcdD8gdm1cblx0XHRcdFx0OiB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0ub3B0aW9uc1xuXHRcdFx0XHQ/IHZtLm9wdGlvbnMubmFtZVxuXHRcdFx0XHQ6IHZtLl9pc1Z1ZVxuXHRcdFx0XHQ/IHZtLiRvcHRpb25zLm5hbWUgfHwgdm0uJG9wdGlvbnMuX2NvbXBvbmVudFRhZ1xuXHRcdFx0XHQ6IHZtLm5hbWU7XG5cblx0XHRcdHZhciBmaWxlID0gdm0uX2lzVnVlICYmIHZtLiRvcHRpb25zLl9fZmlsZTtcblx0XHRcdGlmICghbmFtZSAmJiBmaWxlKSB7XG5cdFx0XHRcdHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuXHRcdFx0XHRuYW1lID0gbWF0Y2ggJiYgbWF0Y2hbMV07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdChuYW1lID8gKFwiPFwiICsgKGNsYXNzaWZ5KG5hbWUpKSArIFwiPlwiKSA6IFwiPEFub255bW91cz5cIikgK1xuXHRcdFx0XHQoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyAoXCIgYXQgXCIgKyBmaWxlKSA6ICcnKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0XHR2YXIgcmVwZWF0ID0gZnVuY3Rpb24gKHN0ciwgbikge1xuXHRcdFx0dmFyIHJlcyA9ICcnO1xuXHRcdFx0d2hpbGUgKG4pIHtcblx0XHRcdFx0aWYgKG4gJSAyID09PSAxKSB7IHJlcyArPSBzdHI7IH1cblx0XHRcdFx0aWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cblx0XHRcdFx0biA+Pj0gMTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNcblx0XHR9O1xuXG5cdFx0dmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcblx0XHRcdGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuXHRcdFx0XHR2YXIgdHJlZSA9IFtdO1xuXHRcdFx0XHR2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcblx0XHRcdFx0d2hpbGUgKHZtKSB7XG5cdFx0XHRcdFx0aWYgKHRyZWUubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdFx0dmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0XHRpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG5cdFx0XHRcdFx0XHRcdHZtID0gdm0uJHBhcmVudDtcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuXHRcdFx0XHRcdFx0XHR0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dHJlZS5wdXNoKHZtKTtcblx0XHRcdFx0XHR2bSA9IHZtLiRwYXJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG5cdFx0XHRcdFx0XHQubWFwKGZ1bmN0aW9uICh2bSwgaSkgeyByZXR1cm4gKFwiXCIgKyAoaSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpKSArIChBcnJheS5pc0FycmF5KHZtKVxuXHRcdFx0XHRcdFx0XHQ/ICgoZm9ybWF0Q29tcG9uZW50TmFtZSh2bVswXSkpICsgXCIuLi4gKFwiICsgKHZtWzFdKSArIFwiIHJlY3Vyc2l2ZSBjYWxscylcIilcblx0XHRcdFx0XHRcdFx0OiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuXHRcdFx0XHRcdFx0LmpvaW4oJ1xcbicpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gKFwiXFxuXFxuKGZvdW5kIGluIFwiICsgKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiKVwiKVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuXHRcdGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG5cdFx0XHRjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHtcblx0XHRcdFx0d2FybigoXCJFcnJvciBpbiBcIiArIGluZm8gKyBcIjogXFxcIlwiICsgKGVyci50b1N0cmluZygpKSArIFwiXFxcIlwiKSwgdm0pO1xuXHRcdFx0fVxuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRcdGlmIChpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IGVyclxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXHQvKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG5cdHZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG5cdHZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblx0dmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5cdHZhciBpc0lFID0gVUEgJiYgL21zaWV8dHJpZGVudC8udGVzdChVQSk7XG5cdHZhciBpc0lFOSA9IFVBICYmIFVBLmluZGV4T2YoJ21zaWUgOS4wJykgPiAwO1xuXHR2YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG5cdHZhciBpc0FuZHJvaWQgPSBVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwO1xuXHR2YXIgaXNJT1MgPSBVQSAmJiAvaXBob25lfGlwYWR8aXBvZHxpb3MvLnRlc3QoVUEpO1xuXHR2YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcblxuXHR2YXIgc3VwcG9ydHNQYXNzaXZlID0gZmFsc2U7XG5cdGlmIChpbkJyb3dzZXIpIHtcblx0XHR0cnkge1xuXHRcdFx0dmFyIG9wdHMgPSB7fTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcblx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0XHRcdHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gKSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcblx0XHR9IGNhdGNoIChlKSB7fVxuXHR9XG5cbi8vIHRoaXMgbmVlZHMgdG8gYmUgbGF6eS1ldmFsZWQgYmVjYXVzZSB2dWUgbWF5IGJlIHJlcXVpcmVkIGJlZm9yZVxuLy8gdnVlLXNlcnZlci1yZW5kZXJlciBjYW4gc2V0IFZVRV9FTlZcblx0dmFyIF9pc1NlcnZlcjtcblx0dmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuXHRcdGlmIChfaXNTZXJ2ZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHQvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcblx0XHRcdFx0Ly8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuXHRcdFx0XHRfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfaXNTZXJ2ZXIgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIF9pc1NlcnZlclxuXHR9O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcblx0dmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG5cdH1cblxuXHR2YXIgaGFzU3ltYm9sID1cblx0XHR0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTeW1ib2wpICYmXG5cdFx0dHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFJlZmxlY3Qub3duS2V5cyk7XG5cblx0LyoqXG5cdCAqIERlZmVyIGEgdGFzayB0byBleGVjdXRlIGl0IGFzeW5jaHJvbm91c2x5LlxuXHQgKi9cblx0dmFyIG5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2FsbGJhY2tzID0gW107XG5cdFx0dmFyIHBlbmRpbmcgPSBmYWxzZTtcblx0XHR2YXIgdGltZXJGdW5jO1xuXG5cdFx0ZnVuY3Rpb24gbmV4dFRpY2tIYW5kbGVyICgpIHtcblx0XHRcdHBlbmRpbmcgPSBmYWxzZTtcblx0XHRcdHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG5cdFx0XHRjYWxsYmFja3MubGVuZ3RoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvcGllc1tpXSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG5cdFx0Ly8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG5cdFx0Ly8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG5cdFx0Ly8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcblx0XHQvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG5cdFx0Ly8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcblx0XHRcdHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHR2YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfTtcblx0XHRcdHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cC50aGVuKG5leHRUaWNrSGFuZGxlcikuY2F0Y2gobG9nRXJyb3IpO1xuXHRcdFx0XHQvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcblx0XHRcdFx0Ly8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG5cdFx0XHRcdC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG5cdFx0XHRcdC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuXHRcdFx0XHQvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cblx0XHRcdFx0aWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cblx0XHRcdH07XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuXHRcdFx0XHRpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuXHRcdFx0XHRcdC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuXHRcdFx0XHRNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG5cdFx0XHQpKSB7XG5cdFx0XHQvLyB1c2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuXHRcdFx0Ly8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcblx0XHRcdHZhciBjb3VudGVyID0gMTtcblx0XHRcdHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG5leHRUaWNrSGFuZGxlcik7XG5cdFx0XHR2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuXHRcdFx0b2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuXHRcdFx0XHRjaGFyYWN0ZXJEYXRhOiB0cnVlXG5cdFx0XHR9KTtcblx0XHRcdHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Y291bnRlciA9IChjb3VudGVyICsgMSkgJSAyO1xuXHRcdFx0XHR0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuXHRcdFx0dmFyIF9yZXNvbHZlO1xuXHRcdFx0Y2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoY2IpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Y2IuY2FsbChjdHgpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKF9yZXNvbHZlKSB7XG5cdFx0XHRcdFx0X3Jlc29sdmUoY3R4KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoIXBlbmRpbmcpIHtcblx0XHRcdFx0cGVuZGluZyA9IHRydWU7XG5cdFx0XHRcdHRpbWVyRnVuYygpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRcdFx0XHRfcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fVxuXHR9KSgpO1xuXG5cdHZhciBfU2V0O1xuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0aWYgKHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFNldCkpIHtcblx0XHQvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cblx0XHRfU2V0ID0gU2V0O1xuXHR9IGVsc2Uge1xuXHRcdC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cblx0XHRfU2V0ID0gKGZ1bmN0aW9uICgpIHtcblx0XHRcdGZ1bmN0aW9uIFNldCAoKSB7XG5cdFx0XHRcdHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdH1cblx0XHRcdFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcblx0XHRcdH07XG5cdFx0XHRTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG5cdFx0XHRcdHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuXHRcdFx0fTtcblx0XHRcdFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG5cdFx0XHRcdHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdH07XG5cblx0XHRcdHJldHVybiBTZXQ7XG5cdFx0fSgpKTtcblx0fVxuXG5cdC8qICAqL1xuXG5cblx0dmFyIHVpZCA9IDA7XG5cblx0LyoqXG5cdCAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuXHQgKiBkaXJlY3RpdmVzIHN1YnNjcmliaW5nIHRvIGl0LlxuXHQgKi9cblx0dmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG5cdFx0dGhpcy5pZCA9IHVpZCsrO1xuXHRcdHRoaXMuc3VicyA9IFtdO1xuXHR9O1xuXG5cdERlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcblx0XHR0aGlzLnN1YnMucHVzaChzdWIpO1xuXHR9O1xuXG5cdERlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcblx0XHRyZW1vdmUodGhpcy5zdWJzLCBzdWIpO1xuXHR9O1xuXG5cdERlcC5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcblx0XHRpZiAoRGVwLnRhcmdldCkge1xuXHRcdFx0RGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG5cdFx0fVxuXHR9O1xuXG5cdERlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcblx0XHQvLyBzdGFiaWxpemUgdGhlIHN1YnNjcmliZXIgbGlzdCBmaXJzdFxuXHRcdHZhciBzdWJzID0gdGhpcy5zdWJzLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c3Vic1tpXS51cGRhdGUoKTtcblx0XHR9XG5cdH07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuXHREZXAudGFyZ2V0ID0gbnVsbDtcblx0dmFyIHRhcmdldFN0YWNrID0gW107XG5cblx0ZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuXHRcdGlmIChEZXAudGFyZ2V0KSB7IHRhcmdldFN0YWNrLnB1c2goRGVwLnRhcmdldCk7IH1cblx0XHREZXAudGFyZ2V0ID0gX3RhcmdldDtcblx0fVxuXG5cdGZ1bmN0aW9uIHBvcFRhcmdldCAoKSB7XG5cdFx0RGVwLnRhcmdldCA9IHRhcmdldFN0YWNrLnBvcCgpO1xuXHR9XG5cblx0Lypcblx0ICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG5cdCAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuXHQgKi9cblxuXHR2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblx0dmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuXHRcdCdwdXNoJyxcblx0XHQncG9wJyxcblx0XHQnc2hpZnQnLFxuXHRcdCd1bnNoaWZ0Jyxcblx0XHQnc3BsaWNlJyxcblx0XHQnc29ydCcsXG5cdFx0J3JldmVyc2UnXG5cdF1cblx0XHQuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG5cdFx0XHQvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2Rcblx0XHRcdHZhciBvcmlnaW5hbCA9IGFycmF5UHJvdG9bbWV0aG9kXTtcblx0XHRcdGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG5cdFx0XHRcdHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuXHRcdFx0XHQvLyBhdm9pZCBsZWFraW5nIGFyZ3VtZW50czpcblx0XHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuXHRcdFx0XHR2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRcdHZhciBhcmdzID0gbmV3IEFycmF5KGkpO1xuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0YXJnc1tpXSA9IGFyZ3VtZW50cyQxW2ldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdFx0dmFyIG9iID0gdGhpcy5fX29iX187XG5cdFx0XHRcdHZhciBpbnNlcnRlZDtcblx0XHRcdFx0c3dpdGNoIChtZXRob2QpIHtcblx0XHRcdFx0XHRjYXNlICdwdXNoJzpcblx0XHRcdFx0XHRcdGluc2VydGVkID0gYXJncztcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0Y2FzZSAndW5zaGlmdCc6XG5cdFx0XHRcdFx0XHRpbnNlcnRlZCA9IGFyZ3M7XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdGNhc2UgJ3NwbGljZSc6XG5cdFx0XHRcdFx0XHRpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpbnNlcnRlZCkgeyBvYi5vYnNlcnZlQXJyYXkoaW5zZXJ0ZWQpOyB9XG5cdFx0XHRcdC8vIG5vdGlmeSBjaGFuZ2Vcblx0XHRcdFx0b2IuZGVwLm5vdGlmeSgpO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHQvKiAgKi9cblxuXHR2YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuXHQvKipcblx0ICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuXHQgKiBhbHNvIGNvbnZlcnRlZCB0byBiZWNvbWUgcmVhY3RpdmUuIEhvd2V2ZXIgd2hlbiBwYXNzaW5nIGRvd24gcHJvcHMsXG5cdCAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcblx0ICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG5cdCAqL1xuXHR2YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcblx0XHRzaG91bGRDb252ZXJ0OiB0cnVlLFxuXHRcdGlzU2V0dGluZ1Byb3BzOiBmYWxzZVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG5cdCAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRhcmdldFxuXHQgKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuXHQgKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuXHQgKi9cblx0dmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG5cdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdHRoaXMuZGVwID0gbmV3IERlcCgpO1xuXHRcdHRoaXMudm1Db3VudCA9IDA7XG5cdFx0ZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHR2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG5cdFx0XHRcdD8gcHJvdG9BdWdtZW50XG5cdFx0XHRcdDogY29weUF1Z21lbnQ7XG5cdFx0XHRhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG5cdFx0XHR0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMud2Fsayh2YWx1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cblx0ICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG5cdCAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuXHQgKi9cblx0T2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cblx0ICovXG5cdE9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlQXJyYXkgPSBmdW5jdGlvbiBvYnNlcnZlQXJyYXkgKGl0ZW1zKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdG9ic2VydmUoaXRlbXNbaV0pO1xuXHRcdH1cblx0fTtcblxuLy8gaGVscGVyc1xuXG5cdC8qKlxuXHQgKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgaW50ZXJjZXB0aW5nXG5cdCAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG5cdCAqL1xuXHRmdW5jdGlvbiBwcm90b0F1Z21lbnQgKHRhcmdldCwgc3JjKSB7XG5cdFx0LyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblx0XHR0YXJnZXQuX19wcm90b19fID0gc3JjO1xuXHRcdC8qIGVzbGludC1lbmFibGUgbm8tcHJvdG8gKi9cblx0fVxuXG5cdC8qKlxuXHQgKiBBdWdtZW50IGFuIHRhcmdldCBPYmplY3Qgb3IgQXJyYXkgYnkgZGVmaW5pbmdcblx0ICogaGlkZGVuIHByb3BlcnRpZXMuXG5cdCAqL1xuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRmdW5jdGlvbiBjb3B5QXVnbWVudCAodGFyZ2V0LCBzcmMsIGtleXMpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdGRlZih0YXJnZXQsIGtleSwgc3JjW2tleV0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcblx0ICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcblx0ICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG5cdCAqL1xuXHRmdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSwgYXNSb290RGF0YSkge1xuXHRcdGlmICghaXNPYmplY3QodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dmFyIG9iO1xuXHRcdGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuXHRcdFx0b2IgPSB2YWx1ZS5fX29iX187XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCAmJlxuXHRcdFx0IWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcblx0XHRcdChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkgJiZcblx0XHRcdE9iamVjdC5pc0V4dGVuc2libGUodmFsdWUpICYmXG5cdFx0XHQhdmFsdWUuX2lzVnVlXG5cdFx0KSB7XG5cdFx0XHRvYiA9IG5ldyBPYnNlcnZlcih2YWx1ZSk7XG5cdFx0fVxuXHRcdGlmIChhc1Jvb3REYXRhICYmIG9iKSB7XG5cdFx0XHRvYi52bUNvdW50Kys7XG5cdFx0fVxuXHRcdHJldHVybiBvYlxuXHR9XG5cblx0LyoqXG5cdCAqIERlZmluZSBhIHJlYWN0aXZlIHByb3BlcnR5IG9uIGFuIE9iamVjdC5cblx0ICovXG5cdGZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcblx0XHRvYmosXG5cdFx0a2V5LFxuXHRcdHZhbCxcblx0XHRjdXN0b21TZXR0ZXJcblx0KSB7XG5cdFx0dmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuXHRcdHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuXHRcdGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcblx0XHR2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuXHRcdHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG5cblx0XHR2YXIgY2hpbGRPYiA9IG9ic2VydmUodmFsKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcblx0XHRcdFx0aWYgKERlcC50YXJnZXQpIHtcblx0XHRcdFx0XHRkZXAuZGVwZW5kKCk7XG5cdFx0XHRcdFx0aWYgKGNoaWxkT2IpIHtcblx0XHRcdFx0XHRcdGNoaWxkT2IuZGVwLmRlcGVuZCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdGRlcGVuZEFycmF5KHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlciAobmV3VmFsKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXHRcdFx0XHRpZiAobmV3VmFsID09PSB2YWx1ZSB8fCAobmV3VmFsICE9PSBuZXdWYWwgJiYgdmFsdWUgIT09IHZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlICovXG5cdFx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjdXN0b21TZXR0ZXIpIHtcblx0XHRcdFx0XHRjdXN0b21TZXR0ZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoc2V0dGVyKSB7XG5cdFx0XHRcdFx0c2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbCA9IG5ld1ZhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuXHRcdFx0XHRkZXAubm90aWZ5KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG5cdCAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3Rcblx0ICogYWxyZWFkeSBleGlzdC5cblx0ICovXG5cdGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgdHlwZW9mIGtleSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHRhcmdldC5sZW5ndGggPSBNYXRoLm1heCh0YXJnZXQubGVuZ3RoLCBrZXkpO1xuXHRcdFx0dGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG5cdFx0XHRyZXR1cm4gdmFsXG5cdFx0fVxuXHRcdGlmIChoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IHZhbDtcblx0XHRcdHJldHVybiB2YWxcblx0XHR9XG5cdFx0dmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcblx0XHRpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcblx0XHRcdFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG5cdFx0XHRcdCdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcblx0XHRcdFx0J2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdmFsXG5cdFx0fVxuXHRcdGlmICghb2IpIHtcblx0XHRcdHRhcmdldFtrZXldID0gdmFsO1xuXHRcdFx0cmV0dXJuIHZhbFxuXHRcdH1cblx0XHRkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuXHRcdG9iLmRlcC5ub3RpZnkoKTtcblx0XHRyZXR1cm4gdmFsXG5cdH1cblxuXHQvKipcblx0ICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cblx0ICovXG5cdGZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG5cdFx0XHR0YXJnZXQuc3BsaWNlKGtleSwgMSk7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dmFyIG9iID0gKHRhcmdldCApLl9fb2JfXztcblx0XHRpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcblx0XHRcdFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG5cdFx0XHRcdCdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuXHRcdFx0XHQnLSBqdXN0IHNldCBpdCB0byBudWxsLidcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0aWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0ZGVsZXRlIHRhcmdldFtrZXldO1xuXHRcdGlmICghb2IpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRvYi5kZXAubm90aWZ5KCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2Vcblx0ICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcblx0XHRmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRlID0gdmFsdWVbaV07XG5cdFx0XHRlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG5cdFx0XHRcdGRlcGVuZEFycmF5KGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdC8qKlxuXHQgKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG5cdCAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG5cdCAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuXHQgKi9cblx0dmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cblx0LyoqXG5cdCAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcblx0ICovXG5cdHtcblx0XHRzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcblx0XHRcdGlmICghdm0pIHtcblx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuXHRcdFx0XHRcdCdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuXHRcdGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuXHRcdHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0dG9WYWwgPSB0b1trZXldO1xuXHRcdFx0ZnJvbVZhbCA9IGZyb21ba2V5XTtcblx0XHRcdGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG5cdFx0XHRcdHNldCh0bywga2V5LCBmcm9tVmFsKTtcblx0XHRcdH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiYgaXNQbGFpbk9iamVjdChmcm9tVmFsKSkge1xuXHRcdFx0XHRtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdG9cblx0fVxuXG5cdC8qKlxuXHQgKiBEYXRhXG5cdCAqL1xuXHRzdHJhdHMuZGF0YSA9IGZ1bmN0aW9uIChcblx0XHRwYXJlbnRWYWwsXG5cdFx0Y2hpbGRWYWwsXG5cdFx0dm1cblx0KSB7XG5cdFx0aWYgKCF2bSkge1xuXHRcdFx0Ly8gaW4gYSBWdWUuZXh0ZW5kIG1lcmdlLCBib3RoIHNob3VsZCBiZSBmdW5jdGlvbnNcblx0XHRcdGlmICghY2hpbGRWYWwpIHtcblx0XHRcdFx0cmV0dXJuIHBhcmVudFZhbFxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHRcdCdUaGUgXCJkYXRhXCIgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uICcgK1xuXHRcdFx0XHRcdCd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuXHRcdFx0XHRcdCdkZWZpbml0aW9ucy4nLFxuXHRcdFx0XHRcdHZtXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJldHVybiBwYXJlbnRWYWxcblx0XHRcdH1cblx0XHRcdGlmICghcGFyZW50VmFsKSB7XG5cdFx0XHRcdHJldHVybiBjaGlsZFZhbFxuXHRcdFx0fVxuXHRcdFx0Ly8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuXHRcdFx0Ly8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG5cdFx0XHQvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cblx0XHRcdC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuXHRcdFx0Ly8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcblx0XHRcdFx0cmV0dXJuIG1lcmdlRGF0YShcblx0XHRcdFx0XHRjaGlsZFZhbC5jYWxsKHRoaXMpLFxuXHRcdFx0XHRcdHBhcmVudFZhbC5jYWxsKHRoaXMpXG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHBhcmVudFZhbCB8fCBjaGlsZFZhbCkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcblx0XHRcdFx0Ly8gaW5zdGFuY2UgbWVyZ2Vcblx0XHRcdFx0dmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdD8gY2hpbGRWYWwuY2FsbCh2bSlcblx0XHRcdFx0XHQ6IGNoaWxkVmFsO1xuXHRcdFx0XHR2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0PyBwYXJlbnRWYWwuY2FsbCh2bSlcblx0XHRcdFx0XHQ6IHVuZGVmaW5lZDtcblx0XHRcdFx0aWYgKGluc3RhbmNlRGF0YSkge1xuXHRcdFx0XHRcdHJldHVybiBtZXJnZURhdGEoaW5zdGFuY2VEYXRhLCBkZWZhdWx0RGF0YSlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZGVmYXVsdERhdGFcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWVyZ2VIb29rIChcblx0XHRwYXJlbnRWYWwsXG5cdFx0Y2hpbGRWYWxcblx0KSB7XG5cdFx0cmV0dXJuIGNoaWxkVmFsXG5cdFx0XHQ/IHBhcmVudFZhbFxuXHRcdFx0PyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuXHRcdFx0OiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuXHRcdFx0PyBjaGlsZFZhbFxuXHRcdFx0OiBbY2hpbGRWYWxdXG5cdFx0XHQ6IHBhcmVudFZhbFxuXHR9XG5cblx0TElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcblx0XHRzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBBc3NldHNcblx0ICpcblx0ICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuXHQgKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG5cdCAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWVyZ2VBc3NldHMgKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcblx0XHR2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG5cdFx0cmV0dXJuIGNoaWxkVmFsXG5cdFx0XHQ/IGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuXHRcdFx0OiByZXNcblx0fVxuXG5cdEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcblx0fSk7XG5cblx0LyoqXG5cdCAqIFdhdGNoZXJzLlxuXHQgKlxuXHQgKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG5cdCAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuXHQgKi9cblx0c3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG5cdFx0aWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cblx0XHR2YXIgcmV0ID0ge307XG5cdFx0ZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcblx0XHRmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcblx0XHRcdHZhciBwYXJlbnQgPSByZXRba2V5XTtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleV07XG5cdFx0XHRpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcblx0XHRcdFx0cGFyZW50ID0gW3BhcmVudF07XG5cdFx0XHR9XG5cdFx0XHRyZXRba2V5XSA9IHBhcmVudFxuXHRcdFx0XHQ/IHBhcmVudC5jb25jYXQoY2hpbGQpXG5cdFx0XHRcdDogW2NoaWxkXTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuXHQgKi9cblx0c3RyYXRzLnByb3BzID1cblx0XHRzdHJhdHMubWV0aG9kcyA9XG5cdFx0XHRzdHJhdHMuY29tcHV0ZWQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuXHRcdFx0XHRpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG5cdFx0XHRcdGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG5cdFx0XHRcdHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0XHRleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuXHRcdFx0XHRleHRlbmQocmV0LCBjaGlsZFZhbCk7XG5cdFx0XHRcdHJldHVybiByZXRcblx0XHRcdH07XG5cblx0LyoqXG5cdCAqIERlZmF1bHQgc3RyYXRlZ3kuXG5cdCAqL1xuXHR2YXIgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcblx0XHRyZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuXHRcdFx0PyBwYXJlbnRWYWxcblx0XHRcdDogY2hpbGRWYWxcblx0fTtcblxuXHQvKipcblx0ICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG5cdCAqL1xuXHRmdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG5cdFx0XHR2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuXHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuXHRcdFx0XHRcdCdpZDogJyArIGtleVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcblx0ICogT2JqZWN0LWJhc2VkIGZvcm1hdC5cblx0ICovXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG5cdFx0dmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcblx0XHRpZiAoIXByb3BzKSB7IHJldHVybiB9XG5cdFx0dmFyIHJlcyA9IHt9O1xuXHRcdHZhciBpLCB2YWwsIG5hbWU7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG5cdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHR2YWwgPSBwcm9wc1tpXTtcblx0XHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0bmFtZSA9IGNhbWVsaXplKHZhbCk7XG5cdFx0XHRcdFx0cmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0d2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHByb3BzKSB7XG5cdFx0XHRcdHZhbCA9IHByb3BzW2tleV07XG5cdFx0XHRcdG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuXHRcdFx0XHRyZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcblx0XHRcdFx0XHQ/IHZhbFxuXHRcdFx0XHRcdDogeyB0eXBlOiB2YWwgfTtcblx0XHRcdH1cblx0XHR9XG5cdFx0b3B0aW9ucy5wcm9wcyA9IHJlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuXHQgKi9cblx0ZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyAob3B0aW9ucykge1xuXHRcdHZhciBkaXJzID0gb3B0aW9ucy5kaXJlY3RpdmVzO1xuXHRcdGlmIChkaXJzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZGlycykge1xuXHRcdFx0XHR2YXIgZGVmID0gZGlyc1trZXldO1xuXHRcdFx0XHRpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cblx0ICogQ29yZSB1dGlsaXR5IHVzZWQgaW4gYm90aCBpbnN0YW50aWF0aW9uIGFuZCBpbmhlcml0YW5jZS5cblx0ICovXG5cdGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG5cdFx0cGFyZW50LFxuXHRcdGNoaWxkLFxuXHRcdHZtXG5cdCkge1xuXHRcdHtcblx0XHRcdGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y2hpbGQgPSBjaGlsZC5vcHRpb25zO1xuXHRcdH1cblxuXHRcdG5vcm1hbGl6ZVByb3BzKGNoaWxkKTtcblx0XHRub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcblx0XHR2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuXHRcdGlmIChleHRlbmRzRnJvbSkge1xuXHRcdFx0cGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcblx0XHR9XG5cdFx0aWYgKGNoaWxkLm1peGlucykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLm1peGluc1tpXSwgdm0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgb3B0aW9ucyA9IHt9O1xuXHRcdHZhciBrZXk7XG5cdFx0Zm9yIChrZXkgaW4gcGFyZW50KSB7XG5cdFx0XHRtZXJnZUZpZWxkKGtleSk7XG5cdFx0fVxuXHRcdGZvciAoa2V5IGluIGNoaWxkKSB7XG5cdFx0XHRpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcblx0XHRcdFx0bWVyZ2VGaWVsZChrZXkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcblx0XHRcdHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcblx0XHRcdG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcblx0XHR9XG5cdFx0cmV0dXJuIG9wdGlvbnNcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNvbHZlIGFuIGFzc2V0LlxuXHQgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3Ncblx0ICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuXHQgKi9cblx0ZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcblx0XHRvcHRpb25zLFxuXHRcdHR5cGUsXG5cdFx0aWQsXG5cdFx0d2Fybk1pc3Npbmdcblx0KSB7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHR2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcblx0XHQvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuXHRcdGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuXHRcdHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcblx0XHRpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cblx0XHR2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG5cdFx0aWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cblx0XHQvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cblx0XHR2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuXHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG5cdFx0XHR3YXJuKFxuXHRcdFx0XHQnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuXHRcdFx0XHRvcHRpb25zXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzXG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiB2YWxpZGF0ZVByb3AgKFxuXHRcdGtleSxcblx0XHRwcm9wT3B0aW9ucyxcblx0XHRwcm9wc0RhdGEsXG5cdFx0dm1cblx0KSB7XG5cdFx0dmFyIHByb3AgPSBwcm9wT3B0aW9uc1trZXldO1xuXHRcdHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcblx0XHR2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcblx0XHQvLyBoYW5kbGUgYm9vbGVhbiBwcm9wc1xuXHRcdGlmIChpc1R5cGUoQm9vbGVhbiwgcHJvcC50eXBlKSkge1xuXHRcdFx0aWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcblx0XHRcdFx0dmFsdWUgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIWlzVHlwZShTdHJpbmcsIHByb3AudHlwZSkgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpKSB7XG5cdFx0XHRcdHZhbHVlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG5cdFx0XHQvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG5cdFx0XHQvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cblx0XHRcdHZhciBwcmV2U2hvdWxkQ29udmVydCA9IG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydDtcblx0XHRcdG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG5cdFx0XHRvYnNlcnZlKHZhbHVlKTtcblx0XHRcdG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHByZXZTaG91bGRDb252ZXJ0O1xuXHRcdH1cblx0XHR7XG5cdFx0XHRhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwcm9wLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSAodm0sIHByb3AsIGtleSkge1xuXHRcdC8vIG5vIGRlZmF1bHQsIHJldHVybiB1bmRlZmluZWRcblx0XHRpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkXG5cdFx0fVxuXHRcdHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG5cdFx0Ly8gd2FybiBhZ2FpbnN0IG5vbi1mYWN0b3J5IGRlZmF1bHRzIGZvciBPYmplY3QgJiBBcnJheVxuXHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpc09iamVjdChkZWYpKSB7XG5cdFx0XHR3YXJuKFxuXHRcdFx0XHQnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG5cdFx0XHRcdCdQcm9wcyB3aXRoIHR5cGUgT2JqZWN0L0FycmF5IG11c3QgdXNlIGEgZmFjdG9yeSBmdW5jdGlvbiAnICtcblx0XHRcdFx0J3RvIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZS4nLFxuXHRcdFx0XHR2bVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Ly8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcblx0XHQvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcblx0XHRpZiAodm0gJiYgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG5cdFx0XHR2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHR2bS5fcHJvcHNba2V5XSAhPT0gdW5kZWZpbmVkXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gdm0uX3Byb3BzW2tleV1cblx0XHR9XG5cdFx0Ly8gY2FsbCBmYWN0b3J5IGZ1bmN0aW9uIGZvciBub24tRnVuY3Rpb24gdHlwZXNcblx0XHQvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG5cdFx0cmV0dXJuIHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG5cdFx0XHQ/IGRlZi5jYWxsKHZtKVxuXHRcdFx0OiBkZWZcblx0fVxuXG5cdC8qKlxuXHQgKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG5cdCAqL1xuXHRmdW5jdGlvbiBhc3NlcnRQcm9wIChcblx0XHRwcm9wLFxuXHRcdG5hbWUsXG5cdFx0dmFsdWUsXG5cdFx0dm0sXG5cdFx0YWJzZW50XG5cdCkge1xuXHRcdGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuXHRcdFx0d2Fybihcblx0XHRcdFx0J01pc3NpbmcgcmVxdWlyZWQgcHJvcDogXCInICsgbmFtZSArICdcIicsXG5cdFx0XHRcdHZtXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dmFyIHR5cGUgPSBwcm9wLnR5cGU7XG5cdFx0dmFyIHZhbGlkID0gIXR5cGUgfHwgdHlwZSA9PT0gdHJ1ZTtcblx0XHR2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuXHRcdGlmICh0eXBlKSB7XG5cdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkodHlwZSkpIHtcblx0XHRcdFx0dHlwZSA9IFt0eXBlXTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGggJiYgIXZhbGlkOyBpKyspIHtcblx0XHRcdFx0dmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuXHRcdFx0XHRleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSB8fCAnJyk7XG5cdFx0XHRcdHZhbGlkID0gYXNzZXJ0ZWRUeXBlLnZhbGlkO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXZhbGlkKSB7XG5cdFx0XHR3YXJuKFxuXHRcdFx0XHQnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuXHRcdFx0XHQnIEV4cGVjdGVkICcgKyBleHBlY3RlZFR5cGVzLm1hcChjYXBpdGFsaXplKS5qb2luKCcsICcpICtcblx0XHRcdFx0JywgZ290ICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSArICcuJyxcblx0XHRcdFx0dm1cblx0XHRcdCk7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuXHRcdGlmICh2YWxpZGF0b3IpIHtcblx0XHRcdGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuXHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdCdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcblx0XHRcdFx0XHR2bVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuXHRmdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuXHRcdHZhciB2YWxpZDtcblx0XHR2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcblx0XHRpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcblx0XHRcdHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcblx0XHR9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcblx0XHRcdHZhbGlkID0gaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG5cdFx0fSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdBcnJheScpIHtcblx0XHRcdHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0dmFsaWQ6IHZhbGlkLFxuXHRcdFx0ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuXHQgKiBiZWNhdXNlIGEgc2ltcGxlIGVxdWFsaXR5IGNoZWNrIHdpbGwgZmFpbCB3aGVuIHJ1bm5pbmdcblx0ICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0VHlwZSAoZm4pIHtcblx0XHR2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuXHRcdHJldHVybiBtYXRjaCA/IG1hdGNoWzFdIDogJydcblx0fVxuXG5cdGZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcblx0XHRpZiAoIUFycmF5LmlzQXJyYXkoZm4pKSB7XG5cdFx0XHRyZXR1cm4gZ2V0VHlwZShmbikgPT09IGdldFR5cGUodHlwZSlcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoZ2V0VHlwZShmbltpXSkgPT09IGdldFR5cGUodHlwZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHR9XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBtYXJrO1xuXHR2YXIgbWVhc3VyZTtcblxuXHR7XG5cdFx0dmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmIChcblx0XHRcdHBlcmYgJiZcblx0XHRcdHBlcmYubWFyayAmJlxuXHRcdFx0cGVyZi5tZWFzdXJlICYmXG5cdFx0XHRwZXJmLmNsZWFyTWFya3MgJiZcblx0XHRcdHBlcmYuY2xlYXJNZWFzdXJlc1xuXHRcdCkge1xuXHRcdFx0bWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuXHRcdFx0bWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG5cdFx0XHRcdHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcblx0XHRcdFx0cGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcblx0XHRcdFx0cGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG5cdFx0XHRcdHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0Lyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cblx0dmFyIGluaXRQcm94eTtcblxuXHR7XG5cdFx0dmFyIGFsbG93ZWRHbG9iYWxzID0gbWFrZU1hcChcblx0XHRcdCdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuXHRcdFx0J3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuXHRcdFx0J01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCwnICtcblx0XHRcdCdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG5cdFx0KTtcblxuXHRcdHZhciB3YXJuTm9uUHJlc2VudCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuXHRcdFx0d2Fybihcblx0XHRcdFx0XCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuXHRcdFx0XHRcInJlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRvIGRlY2xhcmUgcmVhY3RpdmUgZGF0YSBcIiArXG5cdFx0XHRcdFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG5cdFx0XHRcdHRhcmdldFxuXHRcdFx0KTtcblx0XHR9O1xuXG5cdFx0dmFyIGhhc1Byb3h5ID1cblx0XHRcdHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0XHRcdFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cblx0XHRpZiAoaGFzUHJveHkpIHtcblx0XHRcdHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEnKTtcblx0XHRcdGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcblx0XHRcdFx0c2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG5cdFx0XHRcdFx0XHR3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgaGFzSGFuZGxlciA9IHtcblx0XHRcdGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuXHRcdFx0XHR2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcblx0XHRcdFx0dmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuXHRcdFx0XHRpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG5cdFx0XHRcdFx0d2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBoYXMgfHwgIWlzQWxsb3dlZFxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgZ2V0SGFuZGxlciA9IHtcblx0XHRcdGdldDogZnVuY3Rpb24gZ2V0ICh0YXJnZXQsIGtleSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuXHRcdFx0XHRcdHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0W2tleV1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0aW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuXHRcdFx0aWYgKGhhc1Byb3h5KSB7XG5cdFx0XHRcdC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXHRcdFx0XHR2YXIgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkXG5cdFx0XHRcdFx0PyBnZXRIYW5kbGVyXG5cdFx0XHRcdFx0OiBoYXNIYW5kbGVyO1xuXHRcdFx0XHR2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG5cdFx0dGFnLFxuXHRcdGRhdGEsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0dGV4dCxcblx0XHRlbG0sXG5cdFx0Y29udGV4dCxcblx0XHRjb21wb25lbnRPcHRpb25zXG5cdCkge1xuXHRcdHRoaXMudGFnID0gdGFnO1xuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0dGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuXHRcdHRoaXMudGV4dCA9IHRleHQ7XG5cdFx0dGhpcy5lbG0gPSBlbG07XG5cdFx0dGhpcy5ucyA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXHRcdHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuXHRcdHRoaXMuY29tcG9uZW50T3B0aW9ucyA9IGNvbXBvbmVudE9wdGlvbnM7XG5cdFx0dGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnJhdyA9IGZhbHNlO1xuXHRcdHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcblx0XHR0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG5cdFx0dGhpcy5pc0NvbW1lbnQgPSBmYWxzZTtcblx0XHR0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG5cdFx0dGhpcy5pc09uY2UgPSBmYWxzZTtcblx0fTtcblxuXHR2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDoge30gfTtcblxuLy8gREVQUkVDQVRFRDogYWxpYXMgZm9yIGNvbXBvbmVudEluc3RhbmNlIGZvciBiYWNrd2FyZHMgY29tcGF0LlxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRwcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlXG5cdH07XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cblx0dmFyIGNyZWF0ZUVtcHR5Vk5vZGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcblx0XHRub2RlLnRleHQgPSAnJztcblx0XHRub2RlLmlzQ29tbWVudCA9IHRydWU7XG5cdFx0cmV0dXJuIG5vZGVcblx0fTtcblxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuXHRcdHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG5cdH1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cblx0ZnVuY3Rpb24gY2xvbmVWTm9kZSAodm5vZGUpIHtcblx0XHR2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuXHRcdFx0dm5vZGUudGFnLFxuXHRcdFx0dm5vZGUuZGF0YSxcblx0XHRcdHZub2RlLmNoaWxkcmVuLFxuXHRcdFx0dm5vZGUudGV4dCxcblx0XHRcdHZub2RlLmVsbSxcblx0XHRcdHZub2RlLmNvbnRleHQsXG5cdFx0XHR2bm9kZS5jb21wb25lbnRPcHRpb25zXG5cdFx0KTtcblx0XHRjbG9uZWQubnMgPSB2bm9kZS5ucztcblx0XHRjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcblx0XHRjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuXHRcdGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG5cdFx0Y2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2xvbmVkXG5cdH1cblxuXHRmdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG5cdFx0dmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG5cdFx0dmFyIHJlcyA9IG5ldyBBcnJheShsZW4pO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cblx0LyogICovXG5cblx0dmFyIG5vcm1hbGl6ZUV2ZW50ID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0dmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuXHRcdG5hbWUgPSBwYXNzaXZlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG5cdFx0dmFyIG9uY2UkJDEgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG5cdFx0bmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcblx0XHR2YXIgY2FwdHVyZSA9IG5hbWUuY2hhckF0KDApID09PSAnISc7XG5cdFx0bmFtZSA9IGNhcHR1cmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdG9uY2U6IG9uY2UkJDEsXG5cdFx0XHRjYXB0dXJlOiBjYXB0dXJlLFxuXHRcdFx0cGFzc2l2ZTogcGFzc2l2ZVxuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gY3JlYXRlRm5JbnZva2VyIChmbnMpIHtcblx0XHRmdW5jdGlvbiBpbnZva2VyICgpIHtcblx0XHRcdHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuXHRcdFx0dmFyIGZucyA9IGludm9rZXIuZm5zO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGZuc1tpXS5hcHBseShudWxsLCBhcmd1bWVudHMkMSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJldHVybiBoYW5kbGVyIHJldHVybiB2YWx1ZSBmb3Igc2luZ2xlIGhhbmRsZXJzXG5cdFx0XHRcdHJldHVybiBmbnMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpbnZva2VyLmZucyA9IGZucztcblx0XHRyZXR1cm4gaW52b2tlclxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcblx0XHRvbixcblx0XHRvbGRPbixcblx0XHRhZGQsXG5cdFx0cmVtb3ZlJCQxLFxuXHRcdHZtXG5cdCkge1xuXHRcdHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG5cdFx0Zm9yIChuYW1lIGluIG9uKSB7XG5cdFx0XHRjdXIgPSBvbltuYW1lXTtcblx0XHRcdG9sZCA9IG9sZE9uW25hbWVdO1xuXHRcdFx0ZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcblx0XHRcdGlmIChpc1VuZGVmKGN1cikpIHtcblx0XHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybihcblx0XHRcdFx0XHRcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcblx0XHRcdFx0XHR2bVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcblx0XHRcdFx0aWYgKGlzVW5kZWYoY3VyLmZucykpIHtcblx0XHRcdFx0XHRjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZUZuSW52b2tlcihjdXIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50Lm9uY2UsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUpO1xuXHRcdFx0fSBlbHNlIGlmIChjdXIgIT09IG9sZCkge1xuXHRcdFx0XHRvbGQuZm5zID0gY3VyO1xuXHRcdFx0XHRvbltuYW1lXSA9IG9sZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yIChuYW1lIGluIG9sZE9uKSB7XG5cdFx0XHRpZiAoaXNVbmRlZihvbltuYW1lXSkpIHtcblx0XHRcdFx0ZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcblx0XHRcdFx0cmVtb3ZlJCQxKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG5cdFx0dmFyIGludm9rZXI7XG5cdFx0dmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cblx0XHRmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG5cdFx0XHRob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHQvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG5cdFx0XHQvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuXHRcdFx0cmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzVW5kZWYob2xkSG9vaykpIHtcblx0XHRcdC8vIG5vIGV4aXN0aW5nIGhvb2tcblx0XHRcdGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0aWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG5cdFx0XHRcdC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuXHRcdFx0XHRpbnZva2VyID0gb2xkSG9vaztcblx0XHRcdFx0aW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBleGlzdGluZyBwbGFpbiBob29rXG5cdFx0XHRcdGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aW52b2tlci5tZXJnZWQgPSB0cnVlO1xuXHRcdGRlZltob29rS2V5XSA9IGludm9rZXI7XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcblx0XHRkYXRhLFxuXHRcdEN0b3IsXG5cdFx0dGFnXG5cdCkge1xuXHRcdC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuXHRcdC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuXHRcdC8vIGNvbXBvbmVudCBpdHNlbGYuXG5cdFx0dmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuXHRcdGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHZhciByZXMgPSB7fTtcblx0XHR2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuXHRcdHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG5cdFx0aWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuXHRcdFx0XHR2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG5cdFx0XHRcdFx0XHRhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0dGlwKFxuXHRcdFx0XHRcdFx0XHRcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG5cdFx0XHRcdFx0XHRcdChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG5cdFx0XHRcdFx0XHRcdFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuXHRcdFx0XHRcdFx0XHRcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuXHRcdFx0XHRcdFx0XHRcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuXHRcdFx0XHRcdFx0XHRcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG5cdFx0XHRcdGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzXG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja1Byb3AgKFxuXHRcdHJlcyxcblx0XHRoYXNoLFxuXHRcdGtleSxcblx0XHRhbHRLZXksXG5cdFx0cHJlc2VydmVcblx0KSB7XG5cdFx0aWYgKGlzRGVmKGhhc2gpKSB7XG5cdFx0XHRpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcblx0XHRcdFx0cmVzW2tleV0gPSBoYXNoW2tleV07XG5cdFx0XHRcdGlmICghcHJlc2VydmUpIHtcblx0XHRcdFx0XHRkZWxldGUgaGFzaFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG5cdFx0XHRcdHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuXHRcdFx0XHRpZiAoIXByZXNlcnZlKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGhhc2hbYWx0S2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdC8qICAqL1xuXG4vLyBUaGUgdGVtcGxhdGUgY29tcGlsZXIgYXR0ZW1wdHMgdG8gbWluaW1pemUgdGhlIG5lZWQgZm9yIG5vcm1hbGl6YXRpb24gYnlcbi8vIHN0YXRpY2FsbHkgYW5hbHl6aW5nIHRoZSB0ZW1wbGF0ZSBhdCBjb21waWxlIHRpbWUuXG4vL1xuLy8gRm9yIHBsYWluIEhUTUwgbWFya3VwLCBub3JtYWxpemF0aW9uIGNhbiBiZSBjb21wbGV0ZWx5IHNraXBwZWQgYmVjYXVzZSB0aGVcbi8vIGdlbmVyYXRlZCByZW5kZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZXR1cm4gQXJyYXk8Vk5vZGU+LiBUaGVyZSBhcmVcbi8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cblx0ZnVuY3Rpb24gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4gKGNoaWxkcmVuKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW5baV0pKSB7XG5cdFx0XHRcdHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbilcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNoaWxkcmVuXG5cdH1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuXHRcdHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcblx0XHRcdD8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG5cdFx0XHQ6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG5cdFx0XHQ/IG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4pXG5cdFx0XHQ6IHVuZGVmaW5lZFxuXHR9XG5cblx0ZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuXHRcdHJldHVybiBpc0RlZihub2RlKSAmJiBpc0RlZihub2RlLnRleHQpICYmIGlzRmFsc2Uobm9kZS5pc0NvbW1lbnQpXG5cdH1cblxuXHRmdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcblx0XHR2YXIgcmVzID0gW107XG5cdFx0dmFyIGksIGMsIGxhc3Q7XG5cdFx0Zm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cblx0XHRcdGxhc3QgPSByZXNbcmVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0Ly8gIG5lc3RlZFxuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYykpIHtcblx0XHRcdFx0cmVzLnB1c2guYXBwbHkocmVzLCBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuXHRcdFx0fSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuXHRcdFx0XHRpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuXHRcdFx0XHRcdC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcblx0XHRcdFx0XHQvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG5cdFx0XHRcdFx0Ly8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG5cdFx0XHRcdFx0KGxhc3QpLnRleHQgKz0gU3RyaW5nKGMpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG5cdFx0XHRcdFx0Ly8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcblx0XHRcdFx0XHRyZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG5cdFx0XHRcdFx0Ly8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuXHRcdFx0XHRcdHJlc1tyZXMubGVuZ3RoIC0gMV0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuXHRcdFx0XHRcdGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG5cdFx0XHRcdFx0XHRpc0RlZihjLnRhZykgJiZcblx0XHRcdFx0XHRcdGlzVW5kZWYoYy5rZXkpICYmXG5cdFx0XHRcdFx0XHRpc0RlZihuZXN0ZWRJbmRleCkpIHtcblx0XHRcdFx0XHRcdGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzLnB1c2goYyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuXHRcdHJldHVybiBpc09iamVjdChjb21wKVxuXHRcdFx0PyBiYXNlLmV4dGVuZChjb21wKVxuXHRcdFx0OiBjb21wXG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlQXN5bmNDb21wb25lbnQgKFxuXHRcdGZhY3RvcnksXG5cdFx0YmFzZUN0b3IsXG5cdFx0Y29udGV4dFxuXHQpIHtcblx0XHRpZiAoaXNUcnVlKGZhY3RvcnkuZXJyb3IpICYmIGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wXG5cdFx0fVxuXG5cdFx0aWYgKGlzRGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuXHRcdH1cblxuXHRcdGlmIChpc1RydWUoZmFjdG9yeS5sb2FkaW5nKSAmJiBpc0RlZihmYWN0b3J5LmxvYWRpbmdDb21wKSkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkubG9hZGluZ0NvbXBcblx0XHR9XG5cblx0XHRpZiAoaXNEZWYoZmFjdG9yeS5jb250ZXh0cykpIHtcblx0XHRcdC8vIGFscmVhZHkgcGVuZGluZ1xuXHRcdFx0ZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY29udGV4dHMgPSBmYWN0b3J5LmNvbnRleHRzID0gW2NvbnRleHRdO1xuXHRcdFx0dmFyIHN5bmMgPSB0cnVlO1xuXG5cdFx0XHR2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29udGV4dHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG5cdFx0XHRcdC8vIGNhY2hlIHJlc29sdmVkXG5cdFx0XHRcdGZhY3RvcnkucmVzb2x2ZWQgPSBlbnN1cmVDdG9yKHJlcywgYmFzZUN0b3IpO1xuXHRcdFx0XHQvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG5cdFx0XHRcdC8vIChhc3luYyByZXNvbHZlcyBhcmUgc2hpbW1lZCBhcyBzeW5jaHJvbm91cyBkdXJpbmcgU1NSKVxuXHRcdFx0XHRpZiAoIXN5bmMpIHtcblx0XHRcdFx0XHRmb3JjZVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuXHRcdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHRcdFwiRmFpbGVkIHRvIHJlc29sdmUgYXN5bmMgY29tcG9uZW50OiBcIiArIChTdHJpbmcoZmFjdG9yeSkpICtcblx0XHRcdFx0XHQocmVhc29uID8gKFwiXFxuUmVhc29uOiBcIiArIHJlYXNvbikgOiAnJylcblx0XHRcdFx0KTtcblx0XHRcdFx0aWYgKGlzRGVmKGZhY3RvcnkuZXJyb3JDb21wKSkge1xuXHRcdFx0XHRcdGZhY3RvcnkuZXJyb3IgPSB0cnVlO1xuXHRcdFx0XHRcdGZvcmNlUmVuZGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG5cdFx0XHRpZiAoaXNPYmplY3QocmVzKSkge1xuXHRcdFx0XHRpZiAodHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Ly8gKCkgPT4gUHJvbWlzZVxuXHRcdFx0XHRcdGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG5cdFx0XHRcdFx0XHRyZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChpc0RlZihyZXMuY29tcG9uZW50KSAmJiB0eXBlb2YgcmVzLmNvbXBvbmVudC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0cmVzLmNvbXBvbmVudC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cblx0XHRcdFx0XHRpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuXHRcdFx0XHRcdFx0ZmFjdG9yeS5lcnJvckNvbXAgPSBlbnN1cmVDdG9yKHJlcy5lcnJvciwgYmFzZUN0b3IpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcblx0XHRcdFx0XHRcdGZhY3RvcnkubG9hZGluZ0NvbXAgPSBlbnN1cmVDdG9yKHJlcy5sb2FkaW5nLCBiYXNlQ3Rvcik7XG5cdFx0XHRcdFx0XHRpZiAocmVzLmRlbGF5ID09PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yY2VSZW5kZXIoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sIHJlcy5kZWxheSB8fCAyMDApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJlamVjdChcblx0XHRcdFx0XHRcdFx0XHRcdFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIlxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIHJlcy50aW1lb3V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0c3luYyA9IGZhbHNlO1xuXHRcdFx0Ly8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuXHRcdFx0cmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuXHRcdFx0XHQ/IGZhY3RvcnkubG9hZGluZ0NvbXBcblx0XHRcdFx0OiBmYWN0b3J5LnJlc29sdmVkXG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCAoY2hpbGRyZW4pIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGMgPSBjaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKGlzRGVmKGMpICYmIGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykpIHtcblx0XHRcdFx0XHRyZXR1cm4gY1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcblx0XHR2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR2bS5faGFzSG9va0V2ZW50ID0gZmFsc2U7XG5cdFx0Ly8gaW5pdCBwYXJlbnQgYXR0YWNoZWQgZXZlbnRzXG5cdFx0dmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG5cdFx0aWYgKGxpc3RlbmVycykge1xuXHRcdFx0dXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMpO1xuXHRcdH1cblx0fVxuXG5cdHZhciB0YXJnZXQ7XG5cblx0ZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UkJDEpIHtcblx0XHRpZiAob25jZSQkMSkge1xuXHRcdFx0dGFyZ2V0LiRvbmNlKGV2ZW50LCBmbik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC4kb24oZXZlbnQsIGZuKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmUkMSAoZXZlbnQsIGZuKSB7XG5cdFx0dGFyZ2V0LiRvZmYoZXZlbnQsIGZuKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyAoXG5cdFx0dm0sXG5cdFx0bGlzdGVuZXJzLFxuXHRcdG9sZExpc3RlbmVyc1xuXHQpIHtcblx0XHR0YXJnZXQgPSB2bTtcblx0XHR1cGRhdGVMaXN0ZW5lcnMobGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMgfHwge30sIGFkZCwgcmVtb3ZlJDEsIHZtKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcblx0XHR2YXIgaG9va1JFID0gL15ob29rOi87XG5cdFx0VnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG5cdFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdFx0dmFyIHZtID0gdGhpcztcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0KHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG5cdFx0XHRcdC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG5cdFx0XHRcdC8vIGluc3RlYWQgb2YgYSBoYXNoIGxvb2t1cFxuXHRcdFx0XHRpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG5cdFx0XHRcdFx0dm0uX2hhc0hvb2tFdmVudCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB2bVxuXHRcdH07XG5cblx0XHRWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuXHRcdFx0dmFyIHZtID0gdGhpcztcblx0XHRcdGZ1bmN0aW9uIG9uICgpIHtcblx0XHRcdFx0dm0uJG9mZihldmVudCwgb24pO1xuXHRcdFx0XHRmbi5hcHBseSh2bSwgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdG9uLmZuID0gZm47XG5cdFx0XHR2bS4kb24oZXZlbnQsIG9uKTtcblx0XHRcdHJldHVybiB2bVxuXHRcdH07XG5cblx0XHRWdWUucHJvdG90eXBlLiRvZmYgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG5cdFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdFx0dmFyIHZtID0gdGhpcztcblx0XHRcdC8vIGFsbFxuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRcdHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0XHRyZXR1cm4gdm1cblx0XHRcdH1cblx0XHRcdC8vIGFycmF5IG9mIGV2ZW50c1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkkMSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkkMSA8IGw7IGkkMSsrKSB7XG5cdFx0XHRcdFx0dGhpcyQxLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2bVxuXHRcdFx0fVxuXHRcdFx0Ly8gc3BlY2lmaWMgZXZlbnRcblx0XHRcdHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcblx0XHRcdGlmICghY2JzKSB7XG5cdFx0XHRcdHJldHVybiB2bVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0dm0uX2V2ZW50c1tldmVudF0gPSBudWxsO1xuXHRcdFx0XHRyZXR1cm4gdm1cblx0XHRcdH1cblx0XHRcdC8vIHNwZWNpZmljIGhhbmRsZXJcblx0XHRcdHZhciBjYjtcblx0XHRcdHZhciBpID0gY2JzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0Y2IgPSBjYnNbaV07XG5cdFx0XHRcdGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG5cdFx0XHRcdFx0Y2JzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdm1cblx0XHR9O1xuXG5cdFx0VnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdFx0dmFyIHZtID0gdGhpcztcblx0XHRcdHtcblx0XHRcdFx0dmFyIGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0aWYgKGxvd2VyQ2FzZUV2ZW50ICE9PSBldmVudCAmJiB2bS5fZXZlbnRzW2xvd2VyQ2FzZUV2ZW50XSkge1xuXHRcdFx0XHRcdHRpcChcblx0XHRcdFx0XHRcdFwiRXZlbnQgXFxcIlwiICsgbG93ZXJDYXNlRXZlbnQgKyBcIlxcXCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgXCIgK1xuXHRcdFx0XHRcdFx0KGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSArIFwiIGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcXFwiXCIgKyBldmVudCArIFwiXFxcIi4gXCIgK1xuXHRcdFx0XHRcdFx0XCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG5cdFx0XHRcdFx0XHRcInYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBcIiArXG5cdFx0XHRcdFx0XHRcIllvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIChoeXBoZW5hdGUoZXZlbnQpKSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuXHRcdFx0aWYgKGNicykge1xuXHRcdFx0XHRjYnMgPSBjYnMubGVuZ3RoID4gMSA/IHRvQXJyYXkoY2JzKSA6IGNicztcblx0XHRcdFx0dmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNic1tpXS5hcHBseSh2bSwgYXJncyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB2bVxuXHRcdH07XG5cdH1cblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cblx0ICovXG5cdGZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG5cdFx0Y2hpbGRyZW4sXG5cdFx0Y29udGV4dFxuXHQpIHtcblx0XHR2YXIgc2xvdHMgPSB7fTtcblx0XHRpZiAoIWNoaWxkcmVuKSB7XG5cdFx0XHRyZXR1cm4gc2xvdHNcblx0XHR9XG5cdFx0dmFyIGRlZmF1bHRTbG90ID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0Ly8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG5cdFx0XHQvLyBzYW1lIGNvbnRleHQuXG5cdFx0XHRpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZnVuY3Rpb25hbENvbnRleHQgPT09IGNvbnRleHQpICYmXG5cdFx0XHRcdGNoaWxkLmRhdGEgJiYgY2hpbGQuZGF0YS5zbG90ICE9IG51bGxcblx0XHRcdCkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGNoaWxkLmRhdGEuc2xvdDtcblx0XHRcdFx0dmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcblx0XHRcdFx0aWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuXHRcdFx0XHRcdHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2xvdC5wdXNoKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmYXVsdFNsb3QucHVzaChjaGlsZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGlnbm9yZSB3aGl0ZXNwYWNlXG5cdFx0aWYgKCFkZWZhdWx0U2xvdC5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG5cdFx0XHRzbG90cy5kZWZhdWx0ID0gZGVmYXVsdFNsb3Q7XG5cdFx0fVxuXHRcdHJldHVybiBzbG90c1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG5cdFx0cmV0dXJuIG5vZGUuaXNDb21tZW50IHx8IG5vZGUudGV4dCA9PT0gJyAnXG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMgKFxuXHRcdGZucywgLy8gc2VlIGZsb3cvdm5vZGVcblx0XHRyZXNcblx0KSB7XG5cdFx0cmVzID0gcmVzIHx8IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShmbnNbaV0pKSB7XG5cdFx0XHRcdHJlc29sdmVTY29wZWRTbG90cyhmbnNbaV0sIHJlcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXNbZm5zW2ldLmtleV0gPSBmbnNbaV0uZm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXNcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cblx0ZnVuY3Rpb24gaW5pdExpZmVjeWNsZSAodm0pIHtcblx0XHR2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG5cdFx0Ly8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcblx0XHR2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuXHRcdFx0d2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcblx0XHRcdH1cblx0XHRcdHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG5cdFx0fVxuXG5cdFx0dm0uJHBhcmVudCA9IHBhcmVudDtcblx0XHR2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG5cdFx0dm0uJGNoaWxkcmVuID0gW107XG5cdFx0dm0uJHJlZnMgPSB7fTtcblxuXHRcdHZtLl93YXRjaGVyID0gbnVsbDtcblx0XHR2bS5faW5hY3RpdmUgPSBudWxsO1xuXHRcdHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuXHRcdHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcblx0XHR2bS5faXNEZXN0cm95ZWQgPSBmYWxzZTtcblx0XHR2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gbGlmZWN5Y2xlTWl4aW4gKFZ1ZSkge1xuXHRcdFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG5cdFx0XHR2YXIgdm0gPSB0aGlzO1xuXHRcdFx0aWYgKHZtLl9pc01vdW50ZWQpIHtcblx0XHRcdFx0Y2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcblx0XHRcdH1cblx0XHRcdHZhciBwcmV2RWwgPSB2bS4kZWw7XG5cdFx0XHR2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuXHRcdFx0dmFyIHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuXHRcdFx0YWN0aXZlSW5zdGFuY2UgPSB2bTtcblx0XHRcdHZtLl92bm9kZSA9IHZub2RlO1xuXHRcdFx0Ly8gVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gaXMgaW5qZWN0ZWQgaW4gZW50cnkgcG9pbnRzXG5cdFx0XHQvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cblx0XHRcdGlmICghcHJldlZub2RlKSB7XG5cdFx0XHRcdC8vIGluaXRpYWwgcmVuZGVyXG5cdFx0XHRcdHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhcblx0XHRcdFx0XHR2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG5cdFx0XHRcdFx0dm0uJG9wdGlvbnMuX3BhcmVudEVsbSxcblx0XHRcdFx0XHR2bS4kb3B0aW9ucy5fcmVmRWxtXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB1cGRhdGVzXG5cdFx0XHRcdHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcblx0XHRcdH1cblx0XHRcdGFjdGl2ZUluc3RhbmNlID0gcHJldkFjdGl2ZUluc3RhbmNlO1xuXHRcdFx0Ly8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG5cdFx0XHRpZiAocHJldkVsKSB7XG5cdFx0XHRcdHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICh2bS4kZWwpIHtcblx0XHRcdFx0dm0uJGVsLl9fdnVlX18gPSB2bTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcblx0XHRcdGlmICh2bS4kdm5vZGUgJiYgdm0uJHBhcmVudCAmJiB2bS4kdm5vZGUgPT09IHZtLiRwYXJlbnQuX3Zub2RlKSB7XG5cdFx0XHRcdHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlZCBob29rIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHRvIGVuc3VyZSB0aGF0IGNoaWxkcmVuIGFyZVxuXHRcdFx0Ly8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cblx0XHR9O1xuXG5cdFx0VnVlLnByb3RvdHlwZS4kZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdm0gPSB0aGlzO1xuXHRcdFx0aWYgKHZtLl93YXRjaGVyKSB7XG5cdFx0XHRcdHZtLl93YXRjaGVyLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRWdWUucHJvdG90eXBlLiRkZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHZtID0gdGhpcztcblx0XHRcdGlmICh2bS5faXNCZWluZ0Rlc3Ryb3llZCkge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGNhbGxIb29rKHZtLCAnYmVmb3JlRGVzdHJveScpO1xuXHRcdFx0dm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuXHRcdFx0Ly8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcblx0XHRcdHZhciBwYXJlbnQgPSB2bS4kcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc0JlaW5nRGVzdHJveWVkICYmICF2bS4kb3B0aW9ucy5hYnN0cmFjdCkge1xuXHRcdFx0XHRyZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdGVhcmRvd24gd2F0Y2hlcnNcblx0XHRcdGlmICh2bS5fd2F0Y2hlcikge1xuXHRcdFx0XHR2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHR2bS5fd2F0Y2hlcnNbaV0udGVhcmRvd24oKTtcblx0XHRcdH1cblx0XHRcdC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG5cdFx0XHQvLyBmcm96ZW4gb2JqZWN0IG1heSBub3QgaGF2ZSBvYnNlcnZlci5cblx0XHRcdGlmICh2bS5fZGF0YS5fX29iX18pIHtcblx0XHRcdFx0dm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcblx0XHRcdH1cblx0XHRcdC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuXHRcdFx0dm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcblx0XHRcdC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuXHRcdFx0dm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG5cdFx0XHQvLyBmaXJlIGRlc3Ryb3llZCBob29rXG5cdFx0XHRjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuXHRcdFx0Ly8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cblx0XHRcdHZtLiRvZmYoKTtcblx0XHRcdC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuXHRcdFx0aWYgKHZtLiRlbCkge1xuXHRcdFx0XHR2bS4kZWwuX192dWVfXyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyByZW1vdmUgcmVmZXJlbmNlIHRvIERPTSBub2RlcyAocHJldmVudHMgbGVhaylcblx0XHRcdHZtLiRvcHRpb25zLl9wYXJlbnRFbG0gPSB2bS4kb3B0aW9ucy5fcmVmRWxtID0gbnVsbDtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gbW91bnRDb21wb25lbnQgKFxuXHRcdHZtLFxuXHRcdGVsLFxuXHRcdGh5ZHJhdGluZ1xuXHQpIHtcblx0XHR2bS4kZWwgPSBlbDtcblx0XHRpZiAoIXZtLiRvcHRpb25zLnJlbmRlcikge1xuXHRcdFx0dm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcblx0XHRcdHtcblx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRcdGlmICgodm0uJG9wdGlvbnMudGVtcGxhdGUgJiYgdm0uJG9wdGlvbnMudGVtcGxhdGUuY2hhckF0KDApICE9PSAnIycpIHx8XG5cdFx0XHRcdFx0dm0uJG9wdGlvbnMuZWwgfHwgZWwpIHtcblx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0J1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuXHRcdFx0XHRcdFx0J2NvbXBpbGVyIGlzIG5vdCBhdmFpbGFibGUuIEVpdGhlciBwcmUtY29tcGlsZSB0aGUgdGVtcGxhdGVzIGludG8gJyArXG5cdFx0XHRcdFx0XHQncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuXHRcdFx0XHRcdFx0dm1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHQnRmFpbGVkIHRvIG1vdW50IGNvbXBvbmVudDogdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uIG5vdCBkZWZpbmVkLicsXG5cdFx0XHRcdFx0XHR2bVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0Y2FsbEhvb2sodm0sICdiZWZvcmVNb3VudCcpO1xuXG5cdFx0dmFyIHVwZGF0ZUNvbXBvbmVudDtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcblx0XHRcdHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIG5hbWUgPSB2bS5fbmFtZTtcblx0XHRcdFx0dmFyIGlkID0gdm0uX3VpZDtcblx0XHRcdFx0dmFyIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArIGlkO1xuXHRcdFx0XHR2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuXHRcdFx0XHRtYXJrKHN0YXJ0VGFnKTtcblx0XHRcdFx0dmFyIHZub2RlID0gdm0uX3JlbmRlcigpO1xuXHRcdFx0XHRtYXJrKGVuZFRhZyk7XG5cdFx0XHRcdG1lYXN1cmUoKG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG5cdFx0XHRcdG1hcmsoc3RhcnRUYWcpO1xuXHRcdFx0XHR2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuXHRcdFx0XHRtYXJrKGVuZFRhZyk7XG5cdFx0XHRcdG1lYXN1cmUoKG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR2bS5fd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCB1cGRhdGVDb21wb25lbnQsIG5vb3ApO1xuXHRcdGh5ZHJhdGluZyA9IGZhbHNlO1xuXG5cdFx0Ly8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcblx0XHQvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuXHRcdGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuXHRcdFx0dm0uX2lzTW91bnRlZCA9IHRydWU7XG5cdFx0XHRjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZtXG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG5cdFx0dm0sXG5cdFx0cHJvcHNEYXRhLFxuXHRcdGxpc3RlbmVycyxcblx0XHRwYXJlbnRWbm9kZSxcblx0XHRyZW5kZXJDaGlsZHJlblxuXHQpIHtcblx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cblx0XHQvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlblxuXHRcdHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuXHRcdFx0cmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuXHRcdFx0dm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuXHRcdFx0cGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuXHRcdFx0dm0uJHNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAvLyBoYXMgb2xkIHNjb3BlZCBzbG90c1xuXHRcdCk7XG5cblx0XHR2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblx0XHR2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuXHRcdGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcblx0XHRcdHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcblx0XHR9XG5cdFx0dm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cblx0XHQvLyB1cGRhdGUgcHJvcHNcblx0XHRpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG5cdFx0XHRvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcblx0XHRcdHtcblx0XHRcdFx0b2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG5cdFx0XHR2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcblx0XHRcdFx0cHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHZtLiRvcHRpb25zLnByb3BzLCBwcm9wc0RhdGEsIHZtKTtcblx0XHRcdH1cblx0XHRcdG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG5cdFx0XHR7XG5cdFx0XHRcdG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcblx0XHRcdHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcblx0XHR9XG5cdFx0Ly8gdXBkYXRlIGxpc3RlbmVyc1xuXHRcdGlmIChsaXN0ZW5lcnMpIHtcblx0XHRcdHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuXHRcdFx0dm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcblx0XHRcdHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpO1xuXHRcdH1cblx0XHQvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuXHRcdGlmIChoYXNDaGlsZHJlbikge1xuXHRcdFx0dm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcblx0XHRcdHZtLiRmb3JjZVVwZGF0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUgKHZtKSB7XG5cdFx0d2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG5cdFx0XHRpZiAodm0uX2luYWN0aXZlKSB7IHJldHVybiB0cnVlIH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblxuXHRmdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50ICh2bSwgZGlyZWN0KSB7XG5cdFx0aWYgKGRpcmVjdCkge1xuXHRcdFx0dm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuXHRcdFx0dm0uX2luYWN0aXZlID0gZmFsc2U7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHZtLiRjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsSG9vayh2bSwgJ2FjdGl2YXRlZCcpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuXHRcdGlmIChkaXJlY3QpIHtcblx0XHRcdHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG5cdFx0XHRpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghdm0uX2luYWN0aXZlKSB7XG5cdFx0XHR2bS5faW5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLiRjaGlsZHJlbltpXSk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsSG9vayh2bSwgJ2RlYWN0aXZhdGVkJyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2FsbEhvb2sgKHZtLCBob29rKSB7XG5cdFx0dmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG5cdFx0aWYgKGhhbmRsZXJzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0aGFuZGxlRXJyb3IoZSwgdm0sIChob29rICsgXCIgaG9va1wiKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcblx0XHRcdHZtLiRlbWl0KCdob29rOicgKyBob29rKTtcblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXG5cdHZhciBNQVhfVVBEQVRFX0NPVU5UID0gMTAwO1xuXG5cdHZhciBxdWV1ZSA9IFtdO1xuXHR2YXIgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcblx0dmFyIGhhcyA9IHt9O1xuXHR2YXIgY2lyY3VsYXIgPSB7fTtcblx0dmFyIHdhaXRpbmcgPSBmYWxzZTtcblx0dmFyIGZsdXNoaW5nID0gZmFsc2U7XG5cdHZhciBpbmRleCA9IDA7XG5cblx0LyoqXG5cdCAqIFJlc2V0IHRoZSBzY2hlZHVsZXIncyBzdGF0ZS5cblx0ICovXG5cdGZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUgKCkge1xuXHRcdGluZGV4ID0gcXVldWUubGVuZ3RoID0gYWN0aXZhdGVkQ2hpbGRyZW4ubGVuZ3RoID0gMDtcblx0XHRoYXMgPSB7fTtcblx0XHR7XG5cdFx0XHRjaXJjdWxhciA9IHt9O1xuXHRcdH1cblx0XHR3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cblx0ICovXG5cdGZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuXHRcdGZsdXNoaW5nID0gdHJ1ZTtcblx0XHR2YXIgd2F0Y2hlciwgaWQ7XG5cblx0XHQvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cblx0XHQvLyBUaGlzIGVuc3VyZXMgdGhhdDpcblx0XHQvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG5cdFx0Ly8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuXHRcdC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2Vcblx0XHQvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG5cdFx0Ly8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcblx0XHQvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG5cdFx0Ly8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG5cdFx0Ly8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG5cdFx0Zm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0XHR3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuXHRcdFx0aWQgPSB3YXRjaGVyLmlkO1xuXHRcdFx0aGFzW2lkXSA9IG51bGw7XG5cdFx0XHR3YXRjaGVyLnJ1bigpO1xuXHRcdFx0Ly8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuXHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGhhc1tpZF0gIT0gbnVsbCkge1xuXHRcdFx0XHRjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcblx0XHRcdFx0aWYgKGNpcmN1bGFyW2lkXSA+IE1BWF9VUERBVEVfQ09VTlQpIHtcblx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0J1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuXHRcdFx0XHRcdFx0XHR3YXRjaGVyLnVzZXJcblx0XHRcdFx0XHRcdFx0XHQ/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG5cdFx0XHRcdFx0XHRcdFx0OiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuXHRcdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRcdHdhdGNoZXIudm1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBrZWVwIGNvcGllcyBvZiBwb3N0IHF1ZXVlcyBiZWZvcmUgcmVzZXR0aW5nIHN0YXRlXG5cdFx0dmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcblx0XHR2YXIgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcblxuXHRcdHJlc2V0U2NoZWR1bGVyU3RhdGUoKTtcblxuXHRcdC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuXHRcdGNhbGxBY3RpdmF0ZWRIb29rcyhhY3RpdmF0ZWRRdWV1ZSk7XG5cdFx0Y2FsbFVwZGF0ZUhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cblx0XHQvLyBkZXZ0b29sIGhvb2tcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG5cdFx0XHRkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNhbGxVcGRhdGVIb29rcyAocXVldWUpIHtcblx0XHR2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHR2YXIgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuXHRcdFx0dmFyIHZtID0gd2F0Y2hlci52bTtcblx0XHRcdGlmICh2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkKSB7XG5cdFx0XHRcdGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG5cdCAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cblx0ICovXG5cdGZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuXHRcdC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cblx0XHQvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuXHRcdHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuXHRcdGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG5cdFx0XHRhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuXHQgKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3Ncblx0ICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcblx0XHR2YXIgaWQgPSB3YXRjaGVyLmlkO1xuXHRcdGlmIChoYXNbaWRdID09IG51bGwpIHtcblx0XHRcdGhhc1tpZF0gPSB0cnVlO1xuXHRcdFx0aWYgKCFmbHVzaGluZykge1xuXHRcdFx0XHRxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuXHRcdFx0XHQvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuXHRcdFx0XHR2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG5cdFx0XHRcdHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG5cdFx0XHRcdFx0aS0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG5cdFx0XHR9XG5cdFx0XHQvLyBxdWV1ZSB0aGUgZmx1c2hcblx0XHRcdGlmICghd2FpdGluZykge1xuXHRcdFx0XHR3YWl0aW5nID0gdHJ1ZTtcblx0XHRcdFx0bmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0dmFyIHVpZCQyID0gMDtcblxuXHQvKipcblx0ICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG5cdCAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG5cdCAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuXHQgKi9cblx0dmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcblx0XHR2bSxcblx0XHRleHBPckZuLFxuXHRcdGNiLFxuXHRcdG9wdGlvbnNcblx0KSB7XG5cdFx0dGhpcy52bSA9IHZtO1xuXHRcdHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuXHRcdC8vIG9wdGlvbnNcblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0dGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG5cdFx0XHR0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcblx0XHRcdHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuXHRcdFx0dGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLmNiID0gY2I7XG5cdFx0dGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdFx0dGhpcy5kaXJ0eSA9IHRoaXMubGF6eTsgLy8gZm9yIGxhenkgd2F0Y2hlcnNcblx0XHR0aGlzLmRlcHMgPSBbXTtcblx0XHR0aGlzLm5ld0RlcHMgPSBbXTtcblx0XHR0aGlzLmRlcElkcyA9IG5ldyBfU2V0KCk7XG5cdFx0dGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuXHRcdHRoaXMuZXhwcmVzc2lvbiA9IGV4cE9yRm4udG9TdHJpbmcoKTtcblx0XHQvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcblx0XHRpZiAodHlwZW9mIGV4cE9yRm4gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMuZ2V0dGVyID0gZXhwT3JGbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG5cdFx0XHRpZiAoIXRoaXMuZ2V0dGVyKSB7XG5cdFx0XHRcdHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG5cdFx0XHRcdFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG5cdFx0XHRcdFx0XCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG5cdFx0XHRcdFx0J1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcblx0XHRcdFx0XHQnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuXHRcdFx0XHRcdHZtXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMudmFsdWUgPSB0aGlzLmxhenlcblx0XHRcdD8gdW5kZWZpbmVkXG5cdFx0XHQ6IHRoaXMuZ2V0KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cblx0ICovXG5cdFdhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG5cdFx0cHVzaFRhcmdldCh0aGlzKTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIHZtID0gdGhpcy52bTtcblx0XHRpZiAodGhpcy51c2VyKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aGFuZGxlRXJyb3IoZSwgdm0sIChcImdldHRlciBmb3Igd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCh2bSwgdm0pO1xuXHRcdH1cblx0XHQvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcblx0XHQvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcblx0XHRpZiAodGhpcy5kZWVwKSB7XG5cdFx0XHR0cmF2ZXJzZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHBvcFRhcmdldCgpO1xuXHRcdHRoaXMuY2xlYW51cERlcHMoKTtcblx0XHRyZXR1cm4gdmFsdWVcblx0fTtcblxuXHQvKipcblx0ICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cblx0ICovXG5cdFdhdGNoZXIucHJvdG90eXBlLmFkZERlcCA9IGZ1bmN0aW9uIGFkZERlcCAoZGVwKSB7XG5cdFx0dmFyIGlkID0gZGVwLmlkO1xuXHRcdGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuXHRcdFx0dGhpcy5uZXdEZXBJZHMuYWRkKGlkKTtcblx0XHRcdHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG5cdFx0XHRpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcblx0XHRcdFx0ZGVwLmFkZFN1Yih0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG5cdCAqL1xuXHRXYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcblx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHR2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG5cdFx0XHRpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcblx0XHRcdFx0ZGVwLnJlbW92ZVN1Yih0aGlzJDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG5cdFx0dGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcblx0XHR0aGlzLm5ld0RlcElkcyA9IHRtcDtcblx0XHR0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuXHRcdHRtcCA9IHRoaXMuZGVwcztcblx0XHR0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG5cdFx0dGhpcy5uZXdEZXBzID0gdG1wO1xuXHRcdHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cblx0ICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cblx0ICovXG5cdFdhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRpZiAodGhpcy5sYXp5KSB7XG5cdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuXHRcdFx0dGhpcy5ydW4oKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cXVldWVXYXRjaGVyKHRoaXMpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG5cdCAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG5cdCAqL1xuXHRXYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuXHRcdGlmICh0aGlzLmFjdGl2ZSkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcblx0XHRcdGlmIChcblx0XHRcdFx0dmFsdWUgIT09IHRoaXMudmFsdWUgfHxcblx0XHRcdFx0XHQvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cblx0XHRcdFx0XHQvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG5cdFx0XHRcdFx0Ly8gaGF2ZSBtdXRhdGVkLlxuXHRcdFx0XHRpc09iamVjdCh2YWx1ZSkgfHxcblx0XHRcdFx0dGhpcy5kZWVwXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gc2V0IG5ldyB2YWx1ZVxuXHRcdFx0XHR2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdGlmICh0aGlzLnVzZXIpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdFx0aGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuXHQgKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG5cdCAqL1xuXHRXYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcblx0XHR0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcblx0XHR0aGlzLmRpcnR5ID0gZmFsc2U7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuXHQgKi9cblx0V2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcblx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHR0aGlzJDEuZGVwc1tpXS5kZXBlbmQoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuXHQgKi9cblx0V2F0Y2hlci5wcm90b3R5cGUudGVhcmRvd24gPSBmdW5jdGlvbiB0ZWFyZG93biAoKSB7XG5cdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHRpZiAodGhpcy5hY3RpdmUpIHtcblx0XHRcdC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3Rcblx0XHRcdC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcblx0XHRcdC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG5cdFx0XHRpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcblx0XHRcdFx0cmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcblx0XHRcdH1cblx0XHRcdHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0dGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcblx0ICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3Rcblx0ICogaXMgY29sbGVjdGVkIGFzIGEgXCJkZWVwXCIgZGVwZW5kZW5jeS5cblx0ICovXG5cdHZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cdGZ1bmN0aW9uIHRyYXZlcnNlICh2YWwpIHtcblx0XHRzZWVuT2JqZWN0cy5jbGVhcigpO1xuXHRcdF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIF90cmF2ZXJzZSAodmFsLCBzZWVuKSB7XG5cdFx0dmFyIGksIGtleXM7XG5cdFx0dmFyIGlzQSA9IEFycmF5LmlzQXJyYXkodmFsKTtcblx0XHRpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8ICFPYmplY3QuaXNFeHRlbnNpYmxlKHZhbCkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRpZiAodmFsLl9fb2JfXykge1xuXHRcdFx0dmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG5cdFx0XHRpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0c2Vlbi5hZGQoZGVwSWQpO1xuXHRcdH1cblx0XHRpZiAoaXNBKSB7XG5cdFx0XHRpID0gdmFsLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG5cdFx0XHRpID0ga2V5cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0dmFyIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbiA9IHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQ6IG5vb3AsXG5cdFx0c2V0OiBub29wXG5cdH07XG5cblx0ZnVuY3Rpb24gcHJveHkgKHRhcmdldCwgc291cmNlS2V5LCBrZXkpIHtcblx0XHRzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbc291cmNlS2V5XVtrZXldXG5cdFx0fTtcblx0XHRzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuXHRcdFx0dGhpc1tzb3VyY2VLZXldW2tleV0gPSB2YWw7XG5cdFx0fTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0U3RhdGUgKHZtKSB7XG5cdFx0dm0uX3dhdGNoZXJzID0gW107XG5cdFx0dmFyIG9wdHMgPSB2bS4kb3B0aW9ucztcblx0XHRpZiAob3B0cy5wcm9wcykgeyBpbml0UHJvcHModm0sIG9wdHMucHJvcHMpOyB9XG5cdFx0aWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuXHRcdGlmIChvcHRzLmRhdGEpIHtcblx0XHRcdGluaXREYXRhKHZtKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2JzZXJ2ZSh2bS5fZGF0YSA9IHt9LCB0cnVlIC8qIGFzUm9vdERhdGEgKi8pO1xuXHRcdH1cblx0XHRpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG5cdFx0aWYgKG9wdHMud2F0Y2gpIHsgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTsgfVxuXHR9XG5cblx0dmFyIGlzUmVzZXJ2ZWRQcm9wID0ge1xuXHRcdGtleTogMSxcblx0XHRyZWY6IDEsXG5cdFx0c2xvdDogMVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuXHRcdHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG5cdFx0dmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG5cdFx0Ly8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcblx0XHQvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cblx0XHR2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuXHRcdHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcblx0XHQvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcblx0XHRvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG5cdFx0dmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcblx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0dmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChpc1Jlc2VydmVkUHJvcFtrZXldIHx8IGNvbmZpZy5pc1Jlc2VydmVkQXR0cihrZXkpKSB7XG5cdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdChcIlxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuXHRcdFx0XHRcdFx0dm1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0aWYgKHZtLiRwYXJlbnQgJiYgIW9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMpIHtcblx0XHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHRcdFwiQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIFwiICtcblx0XHRcdFx0XHRcdFx0XCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG5cdFx0XHRcdFx0XHRcdFwiSW5zdGVhZCwgdXNlIGEgZGF0YSBvciBjb21wdXRlZCBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcHJvcCdzIFwiICtcblx0XHRcdFx0XHRcdFx0XCJ2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcblx0XHRcdFx0XHRcdFx0dm1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIHN0YXRpYyBwcm9wcyBhcmUgYWxyZWFkeSBwcm94aWVkIG9uIHRoZSBjb21wb25lbnQncyBwcm90b3R5cGVcblx0XHRcdC8vIGR1cmluZyBWdWUuZXh0ZW5kKCkuIFdlIG9ubHkgbmVlZCB0byBwcm94eSBwcm9wcyBkZWZpbmVkIGF0XG5cdFx0XHQvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG5cdFx0XHRpZiAoIShrZXkgaW4gdm0pKSB7XG5cdFx0XHRcdHByb3h5KHZtLCBcIl9wcm9wc1wiLCBrZXkpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gcHJvcHNPcHRpb25zKSBsb29wKCBrZXkgKTtcblx0XHRvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdERhdGEgKHZtKSB7XG5cdFx0dmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuXHRcdGRhdGEgPSB2bS5fZGF0YSA9IHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nXG5cdFx0XHQ/IGdldERhdGEoZGF0YSwgdm0pXG5cdFx0XHQ6IGRhdGEgfHwge307XG5cdFx0aWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG5cdFx0XHRkYXRhID0ge307XG5cdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHQnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG5cdFx0XHRcdCdodHRwczovL3Z1ZWpzLm9yZy92Mi9ndWlkZS9jb21wb25lbnRzLmh0bWwjZGF0YS1NdXN0LUJlLWEtRnVuY3Rpb24nLFxuXHRcdFx0XHR2bVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Ly8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuXHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG5cdFx0dmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG5cdFx0dmFyIGkgPSBrZXlzLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXlzW2ldKSkge1xuXHRcdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHRcdFwiVGhlIGRhdGEgcHJvcGVydHkgXFxcIlwiICsgKGtleXNbaV0pICsgXCJcXFwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBcIiArXG5cdFx0XHRcdFx0XCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG5cdFx0XHRcdFx0dm1cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5c1tpXSkpIHtcblx0XHRcdFx0cHJveHkodm0sIFwiX2RhdGFcIiwga2V5c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIG9ic2VydmUgZGF0YVxuXHRcdG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBkYXRhLmNhbGwodm0pXG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0aGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuXHRcdFx0cmV0dXJuIHt9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnMgPSB7IGxhenk6IHRydWUgfTtcblxuXHRmdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuXHRcdHZhciB3YXRjaGVycyA9IHZtLl9jb21wdXRlZFdhdGNoZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuXHRcdFx0dmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuXHRcdFx0dmFyIGdldHRlciA9IHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nID8gdXNlckRlZiA6IHVzZXJEZWYuZ2V0O1xuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0KFwiTm8gZ2V0dGVyIGZ1bmN0aW9uIGhhcyBiZWVuIGRlZmluZWQgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG5cdFx0XHRcdFx0XHR2bVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0Z2V0dGVyID0gbm9vcDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIGludGVybmFsIHdhdGNoZXIgZm9yIHRoZSBjb21wdXRlZCBwcm9wZXJ0eS5cblx0XHRcdHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcih2bSwgZ2V0dGVyLCBub29wLCBjb21wdXRlZFdhdGNoZXJPcHRpb25zKTtcblxuXHRcdFx0Ly8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuXHRcdFx0Ly8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcblx0XHRcdC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cblx0XHRcdGlmICghKGtleSBpbiB2bSkpIHtcblx0XHRcdFx0ZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG5cdFx0XHRcdFx0d2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuXHRcdFx0XHRcdHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKHRhcmdldCwga2V5LCB1c2VyRGVmKSB7XG5cdFx0aWYgKHR5cGVvZiB1c2VyRGVmID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KTtcblx0XHRcdHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBub29wO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcblx0XHRcdFx0PyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuXHRcdFx0XHQ/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcblx0XHRcdFx0OiB1c2VyRGVmLmdldFxuXHRcdFx0XHQ6IG5vb3A7XG5cdFx0XHRzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXRcblx0XHRcdFx0PyB1c2VyRGVmLnNldFxuXHRcdFx0XHQ6IG5vb3A7XG5cdFx0fVxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gY29tcHV0ZWRHZXR0ZXIgKCkge1xuXHRcdFx0dmFyIHdhdGNoZXIgPSB0aGlzLl9jb21wdXRlZFdhdGNoZXJzICYmIHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnNba2V5XTtcblx0XHRcdGlmICh3YXRjaGVyKSB7XG5cdFx0XHRcdGlmICh3YXRjaGVyLmRpcnR5KSB7XG5cdFx0XHRcdFx0d2F0Y2hlci5ldmFsdWF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChEZXAudGFyZ2V0KSB7XG5cdFx0XHRcdFx0d2F0Y2hlci5kZXBlbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gd2F0Y2hlci52YWx1ZVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuXHRcdHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuXHRcdGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG5cdFx0XHR2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZChtZXRob2RzW2tleV0sIHZtKTtcblx0XHRcdHtcblx0XHRcdFx0aWYgKG1ldGhvZHNba2V5XSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYW4gdW5kZWZpbmVkIHZhbHVlIGluIHRoZSBjb21wb25lbnQgZGVmaW5pdGlvbi4gXCIgK1xuXHRcdFx0XHRcdFx0XCJEaWQgeW91IHJlZmVyZW5jZSB0aGUgZnVuY3Rpb24gY29ycmVjdGx5P1wiLFxuXHRcdFx0XHRcdFx0dm1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcblx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0KFwibWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLlwiKSxcblx0XHRcdFx0XHRcdHZtXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRXYXRjaCAodm0sIHdhdGNoKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG5cdFx0XHR2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVdhdGNoZXIgKHZtLCBrZXksIGhhbmRsZXIpIHtcblx0XHR2YXIgb3B0aW9ucztcblx0XHRpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuXHRcdFx0b3B0aW9ucyA9IGhhbmRsZXI7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRoYW5kbGVyID0gdm1baGFuZGxlcl07XG5cdFx0fVxuXHRcdHZtLiR3YXRjaChrZXksIGhhbmRsZXIsIG9wdGlvbnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG5cdFx0Ly8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG5cdFx0Ly8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG5cdFx0Ly8gdGhlIG9iamVjdCBoZXJlLlxuXHRcdHZhciBkYXRhRGVmID0ge307XG5cdFx0ZGF0YURlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhIH07XG5cdFx0dmFyIHByb3BzRGVmID0ge307XG5cdFx0cHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcblx0XHR7XG5cdFx0XHRkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG5cdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0J0F2b2lkIHJlcGxhY2luZyBpbnN0YW5jZSByb290ICRkYXRhLiAnICtcblx0XHRcdFx0XHQnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuXHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0KTtcblx0XHRcdH07XG5cdFx0XHRwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHdhcm4oXCIkcHJvcHMgaXMgcmVhZG9ubHkuXCIsIHRoaXMpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG5cdFx0VnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuXHRcdFZ1ZS5wcm90b3R5cGUuJGRlbGV0ZSA9IGRlbDtcblxuXHRcdFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuXHRcdFx0ZXhwT3JGbixcblx0XHRcdGNiLFxuXHRcdFx0b3B0aW9uc1xuXHRcdCkge1xuXHRcdFx0dmFyIHZtID0gdGhpcztcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0b3B0aW9ucy51c2VyID0gdHJ1ZTtcblx0XHRcdHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcblx0XHRcdGlmIChvcHRpb25zLmltbWVkaWF0ZSkge1xuXHRcdFx0XHRjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4gKCkge1xuXHRcdFx0XHR3YXRjaGVyLnRlYXJkb3duKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGluaXRQcm92aWRlICh2bSkge1xuXHRcdHZhciBwcm92aWRlID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcblx0XHRpZiAocHJvdmlkZSkge1xuXHRcdFx0dm0uX3Byb3ZpZGVkID0gdHlwZW9mIHByb3ZpZGUgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0PyBwcm92aWRlLmNhbGwodm0pXG5cdFx0XHRcdDogcHJvdmlkZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcblx0XHR2YXIgcmVzdWx0ID0gcmVzb2x2ZUluamVjdCh2bS4kb3B0aW9ucy5pbmplY3QsIHZtKTtcblx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHRcdFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG5cdFx0XHRcdFx0XHRcdFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG5cdFx0XHRcdFx0XHRcdFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuXHRcdFx0XHRcdFx0XHR2bVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuXHRcdGlmIChpbmplY3QpIHtcblx0XHRcdC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG5cdFx0XHQvLyBpc0FycmF5IGhlcmVcblx0XHRcdHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShpbmplY3QpO1xuXHRcdFx0dmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHR2YXIga2V5cyA9IGlzQXJyYXlcblx0XHRcdFx0PyBpbmplY3Rcblx0XHRcdFx0OiBoYXNTeW1ib2xcblx0XHRcdFx0PyBSZWZsZWN0Lm93bktleXMoaW5qZWN0KVxuXHRcdFx0XHQ6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0dmFyIHByb3ZpZGVLZXkgPSBpc0FycmF5ID8ga2V5IDogaW5qZWN0W2tleV07XG5cdFx0XHRcdHZhciBzb3VyY2UgPSB2bTtcblx0XHRcdFx0d2hpbGUgKHNvdXJjZSkge1xuXHRcdFx0XHRcdGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIHByb3ZpZGVLZXkgaW4gc291cmNlLl9wcm92aWRlZCkge1xuXHRcdFx0XHRcdFx0cmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c291cmNlID0gc291cmNlLiRwYXJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRcblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcblx0XHRDdG9yLFxuXHRcdHByb3BzRGF0YSxcblx0XHRkYXRhLFxuXHRcdGNvbnRleHQsXG5cdFx0Y2hpbGRyZW5cblx0KSB7XG5cdFx0dmFyIHByb3BzID0ge307XG5cdFx0dmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuXHRcdGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuXHRcdFx0XHRwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCB7fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuXHRcdFx0aWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG5cdFx0fVxuXHRcdC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcblx0XHQvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG5cdFx0dmFyIF9jb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShjb250ZXh0KTtcblx0XHR2YXIgaCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KF9jb250ZXh0LCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblx0XHR2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgaCwge1xuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHByb3BzOiBwcm9wcyxcblx0XHRcdGNoaWxkcmVuOiBjaGlsZHJlbixcblx0XHRcdHBhcmVudDogY29udGV4dCxcblx0XHRcdGxpc3RlbmVyczogZGF0YS5vbiB8fCB7fSxcblx0XHRcdGluamVjdGlvbnM6IHJlc29sdmVJbmplY3QoQ3Rvci5vcHRpb25zLmluamVjdCwgY29udGV4dCksXG5cdFx0XHRzbG90czogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KTsgfVxuXHRcdH0pO1xuXHRcdGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG5cdFx0XHR2bm9kZS5mdW5jdGlvbmFsQ29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHR2bm9kZS5mdW5jdGlvbmFsT3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcblx0XHRcdGlmIChkYXRhLnNsb3QpIHtcblx0XHRcdFx0KHZub2RlLmRhdGEgfHwgKHZub2RlLmRhdGEgPSB7fSkpLnNsb3QgPSBkYXRhLnNsb3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2bm9kZVxuXHR9XG5cblx0ZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0dG9bY2FtZWxpemUoa2V5KV0gPSBmcm9tW2tleV07XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cbi8vIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcblx0dmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG5cdFx0aW5pdDogZnVuY3Rpb24gaW5pdCAoXG5cdFx0XHR2bm9kZSxcblx0XHRcdGh5ZHJhdGluZyxcblx0XHRcdHBhcmVudEVsbSxcblx0XHRcdHJlZkVsbVxuXHRcdCkge1xuXHRcdFx0aWYgKCF2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuXHRcdFx0XHRcdHZub2RlLFxuXHRcdFx0XHRcdGFjdGl2ZUluc3RhbmNlLFxuXHRcdFx0XHRcdHBhcmVudEVsbSxcblx0XHRcdFx0XHRyZWZFbG1cblx0XHRcdFx0KTtcblx0XHRcdFx0Y2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcblx0XHRcdH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcblx0XHRcdFx0Ly8ga2VwdC1hbGl2ZSBjb21wb25lbnRzLCB0cmVhdCBhcyBhIHBhdGNoXG5cdFx0XHRcdHZhciBtb3VudGVkTm9kZSA9IHZub2RlOyAvLyB3b3JrIGFyb3VuZCBmbG93XG5cdFx0XHRcdGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcblx0XHRcdHZhciBvcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcblx0XHRcdHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG5cdFx0XHR1cGRhdGVDaGlsZENvbXBvbmVudChcblx0XHRcdFx0Y2hpbGQsXG5cdFx0XHRcdG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG5cdFx0XHRcdG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuXHRcdFx0XHR2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuXHRcdFx0XHRvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0aW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG5cdFx0XHR2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG5cdFx0XHR2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcblx0XHRcdGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCkge1xuXHRcdFx0XHRjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcblx0XHRcdFx0Y2FsbEhvb2soY29tcG9uZW50SW5zdGFuY2UsICdtb3VudGVkJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcblx0XHRcdFx0aWYgKGNvbnRleHQuX2lzTW91bnRlZCkge1xuXHRcdFx0XHRcdC8vIHZ1ZS1yb3V0ZXIjMTIxMlxuXHRcdFx0XHRcdC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcblx0XHRcdFx0XHQvLyBjaGFuZ2UsIHNvIGRpcmVjdGx5IHdhbGtpbmcgdGhlIHRyZWUgaGVyZSBtYXkgY2FsbCBhY3RpdmF0ZWQgaG9va3Ncblx0XHRcdFx0XHQvLyBvbiBpbmNvcnJlY3QgY2hpbGRyZW4uIEluc3RlYWQgd2UgcHVzaCB0aGVtIGludG8gYSBxdWV1ZSB3aGljaCB3aWxsXG5cdFx0XHRcdFx0Ly8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuXHRcdFx0XHRcdHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcblx0XHRcdHZhciBjb21wb25lbnRJbnN0YW5jZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuXHRcdFx0aWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcblx0XHRcdFx0aWYgKCF2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuXHRcdFx0XHRcdGNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0dmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAoXG5cdFx0Q3Rvcixcblx0XHRkYXRhLFxuXHRcdGNvbnRleHQsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0dGFnXG5cdCkge1xuXHRcdGlmIChpc1VuZGVmKEN0b3IpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHR2YXIgYmFzZUN0b3IgPSBjb250ZXh0LiRvcHRpb25zLl9iYXNlO1xuXG5cdFx0Ly8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG5cdFx0aWYgKGlzT2JqZWN0KEN0b3IpKSB7XG5cdFx0XHRDdG9yID0gYmFzZUN0b3IuZXh0ZW5kKEN0b3IpO1xuXHRcdH1cblxuXHRcdC8vIGlmIGF0IHRoaXMgc3RhZ2UgaXQncyBub3QgYSBjb25zdHJ1Y3RvciBvciBhbiBhc3luYyBjb21wb25lbnQgZmFjdG9yeSxcblx0XHQvLyByZWplY3QuXG5cdFx0aWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR7XG5cdFx0XHRcdHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Ly8gYXN5bmMgY29tcG9uZW50XG5cdFx0aWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG5cdFx0XHRDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KEN0b3IsIGJhc2VDdG9yLCBjb250ZXh0KTtcblx0XHRcdGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0Ly8gcmV0dXJuIG5vdGhpbmcgaWYgdGhpcyBpcyBpbmRlZWQgYW4gYXN5bmMgY29tcG9uZW50XG5cdFx0XHRcdC8vIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byB0cmlnZ2VyIHBhcmVudCB1cGRhdGUuXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHJlc29sdmUgY29uc3RydWN0b3Igb3B0aW9ucyBpbiBjYXNlIGdsb2JhbCBtaXhpbnMgYXJlIGFwcGxpZWQgYWZ0ZXJcblx0XHQvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cblx0XHRyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3IpO1xuXG5cdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cblx0XHQvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG5cdFx0aWYgKGlzRGVmKGRhdGEubW9kZWwpKSB7XG5cdFx0XHR0cmFuc2Zvcm1Nb2RlbChDdG9yLm9wdGlvbnMsIGRhdGEpO1xuXHRcdH1cblxuXHRcdC8vIGV4dHJhY3QgcHJvcHNcblx0XHR2YXIgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuXG5cdFx0Ly8gZnVuY3Rpb25hbCBjb21wb25lbnRcblx0XHRpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSkge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcblx0XHR9XG5cblx0XHQvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuXHRcdC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG5cdFx0dmFyIGxpc3RlbmVycyA9IGRhdGEub247XG5cdFx0Ly8gcmVwbGFjZSB3aXRoIGxpc3RlbmVycyB3aXRoIC5uYXRpdmUgbW9kaWZpZXJcblx0XHRkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuXHRcdGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSkge1xuXHRcdFx0Ly8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuXHRcdFx0Ly8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVyc1xuXHRcdFx0ZGF0YSA9IHt9O1xuXHRcdH1cblxuXHRcdC8vIG1lcmdlIGNvbXBvbmVudCBtYW5hZ2VtZW50IGhvb2tzIG9udG8gdGhlIHBsYWNlaG9sZGVyIG5vZGVcblx0XHRtZXJnZUhvb2tzKGRhdGEpO1xuXG5cdFx0Ly8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcblx0XHR2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcblx0XHR2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG5cdFx0XHQoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuXHRcdFx0ZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcblx0XHRcdHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH1cblx0XHQpO1xuXHRcdHJldHVybiB2bm9kZVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG5cdFx0dm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuXHRcdHBhcmVudCwgLy8gYWN0aXZlSW5zdGFuY2UgaW4gbGlmZWN5Y2xlIHN0YXRlXG5cdFx0cGFyZW50RWxtLFxuXHRcdHJlZkVsbVxuXHQpIHtcblx0XHR2YXIgdm5vZGVDb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcblx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdF9pc0NvbXBvbmVudDogdHJ1ZSxcblx0XHRcdHBhcmVudDogcGFyZW50LFxuXHRcdFx0cHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuXHRcdFx0X2NvbXBvbmVudFRhZzogdm5vZGVDb21wb25lbnRPcHRpb25zLnRhZyxcblx0XHRcdF9wYXJlbnRWbm9kZTogdm5vZGUsXG5cdFx0XHRfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuXHRcdFx0X3JlbmRlckNoaWxkcmVuOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sXG5cdFx0XHRfcGFyZW50RWxtOiBwYXJlbnRFbG0gfHwgbnVsbCxcblx0XHRcdF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG5cdFx0fTtcblx0XHQvLyBjaGVjayBpbmxpbmUtdGVtcGxhdGUgcmVuZGVyIGZ1bmN0aW9uc1xuXHRcdHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG5cdFx0aWYgKGlzRGVmKGlubGluZVRlbXBsYXRlKSkge1xuXHRcdFx0b3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG5cdFx0XHRvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcblx0XHR9XG5cdFx0cmV0dXJuIG5ldyB2bm9kZUNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKVxuXHR9XG5cblx0ZnVuY3Rpb24gbWVyZ2VIb29rcyAoZGF0YSkge1xuXHRcdGlmICghZGF0YS5ob29rKSB7XG5cdFx0XHRkYXRhLmhvb2sgPSB7fTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG5cdFx0XHR2YXIgZnJvbVBhcmVudCA9IGRhdGEuaG9va1trZXldO1xuXHRcdFx0dmFyIG91cnMgPSBjb21wb25lbnRWTm9kZUhvb2tzW2tleV07XG5cdFx0XHRkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG5cdFx0XHRvbmUoYSwgYiwgYywgZCk7XG5cdFx0XHR0d28oYSwgYiwgYywgZCk7XG5cdFx0fVxuXHR9XG5cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuXHRcdHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuXHRcdHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCc7KGRhdGEucHJvcHMgfHwgKGRhdGEucHJvcHMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcblx0XHR2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuXHRcdGlmIChpc0RlZihvbltldmVudF0pKSB7XG5cdFx0XHRvbltldmVudF0gPSBbZGF0YS5tb2RlbC5jYWxsYmFja10uY29uY2F0KG9uW2V2ZW50XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9uW2V2ZW50XSA9IGRhdGEubW9kZWwuY2FsbGJhY2s7XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0dmFyIFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xuXHR2YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG5cdFx0Y29udGV4dCxcblx0XHR0YWcsXG5cdFx0ZGF0YSxcblx0XHRjaGlsZHJlbixcblx0XHRub3JtYWxpemF0aW9uVHlwZSxcblx0XHRhbHdheXNOb3JtYWxpemVcblx0KSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcblx0XHRcdG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG5cdFx0XHRjaGlsZHJlbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcblx0XHRcdG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcblx0XHR9XG5cdFx0cmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxuXHR9XG5cblx0ZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuXHRcdGNvbnRleHQsXG5cdFx0dGFnLFxuXHRcdGRhdGEsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0bm9ybWFsaXphdGlvblR5cGVcblx0KSB7XG5cdFx0aWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG5cdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHRcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuXHRcdFx0XHQnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcblx0XHRcdFx0Y29udGV4dFxuXHRcdFx0KTtcblx0XHRcdHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcblx0XHR9XG5cdFx0aWYgKCF0YWcpIHtcblx0XHRcdC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcblx0XHRcdHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcblx0XHR9XG5cdFx0Ly8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuXHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSAmJlxuXHRcdFx0dHlwZW9mIGNoaWxkcmVuWzBdID09PSAnZnVuY3Rpb24nXG5cdFx0KSB7XG5cdFx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRcdGRhdGEuc2NvcGVkU2xvdHMgPSB7IGRlZmF1bHQ6IGNoaWxkcmVuWzBdIH07XG5cdFx0XHRjaGlsZHJlbi5sZW5ndGggPSAwO1xuXHRcdH1cblx0XHRpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IEFMV0FZU19OT1JNQUxJWkUpIHtcblx0XHRcdGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXHRcdH0gZWxzZSBpZiAobm9ybWFsaXphdGlvblR5cGUgPT09IFNJTVBMRV9OT1JNQUxJWkUpIHtcblx0XHRcdGNoaWxkcmVuID0gc2ltcGxlTm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXHRcdH1cblx0XHR2YXIgdm5vZGUsIG5zO1xuXHRcdGlmICh0eXBlb2YgdGFnID09PSAnc3RyaW5nJykge1xuXHRcdFx0dmFyIEN0b3I7XG5cdFx0XHRucyA9IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcblx0XHRcdGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG5cdFx0XHRcdC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG5cdFx0XHRcdHZub2RlID0gbmV3IFZOb2RlKFxuXHRcdFx0XHRcdGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcblx0XHRcdFx0XHR1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIGlmIChpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcblx0XHRcdFx0Ly8gY29tcG9uZW50XG5cdFx0XHRcdHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG5cdFx0XHRcdC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG5cdFx0XHRcdC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG5cdFx0XHRcdHZub2RlID0gbmV3IFZOb2RlKFxuXHRcdFx0XHRcdHRhZywgZGF0YSwgY2hpbGRyZW4sXG5cdFx0XHRcdFx0dW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3Jcblx0XHRcdHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuXHRcdH1cblx0XHRpZiAoaXNEZWYodm5vZGUpKSB7XG5cdFx0XHRpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG5cdFx0XHRyZXR1cm4gdm5vZGVcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuXHRcdHZub2RlLm5zID0gbnM7XG5cdFx0aWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG5cdFx0XHQvLyB1c2UgZGVmYXVsdCBuYW1lc3BhY2UgaW5zaWRlIGZvcmVpZ25PYmplY3Rcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSB2bm9kZS5jaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKGlzRGVmKGNoaWxkLnRhZykgJiYgaXNVbmRlZihjaGlsZC5ucykpIHtcblx0XHRcdFx0XHRhcHBseU5TKGNoaWxkLCBucyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyB2LWZvciBsaXN0cy5cblx0ICovXG5cdGZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuXHRcdHZhbCxcblx0XHRyZW5kZXJcblx0KSB7XG5cdFx0dmFyIHJldCwgaSwgbCwga2V5cywga2V5O1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcblx0XHRcdGZvciAoaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHJldFtpXSA9IHJlbmRlcih2YWxbaV0sIGkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcblx0XHRcdHJldCA9IG5ldyBBcnJheSh2YWwpO1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG5cdFx0XHRcdHJldFtpXSA9IHJlbmRlcihpICsgMSwgaSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG5cdFx0XHRrZXlzID0gT2JqZWN0LmtleXModmFsKTtcblx0XHRcdHJldCA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCk7XG5cdFx0XHRmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0cmV0W2ldID0gcmVuZGVyKHZhbFtrZXldLCBrZXksIGkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaXNEZWYocmV0KSkge1xuXHRcdFx0KHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0XG5cdH1cblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cblx0ICovXG5cdGZ1bmN0aW9uIHJlbmRlclNsb3QgKFxuXHRcdG5hbWUsXG5cdFx0ZmFsbGJhY2ssXG5cdFx0cHJvcHMsXG5cdFx0YmluZE9iamVjdFxuXHQpIHtcblx0XHR2YXIgc2NvcGVkU2xvdEZuID0gdGhpcy4kc2NvcGVkU2xvdHNbbmFtZV07XG5cdFx0aWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuXHRcdFx0cHJvcHMgPSBwcm9wcyB8fCB7fTtcblx0XHRcdGlmIChiaW5kT2JqZWN0KSB7XG5cdFx0XHRcdGV4dGVuZChwcm9wcywgYmluZE9iamVjdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2NvcGVkU2xvdEZuKHByb3BzKSB8fCBmYWxsYmFja1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG5cdFx0XHQvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG5cdFx0XHRpZiAoc2xvdE5vZGVzICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG5cdFx0XHRcdHNsb3ROb2Rlcy5fcmVuZGVyZWQgJiYgd2Fybihcblx0XHRcdFx0XHRcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuXHRcdFx0XHRcdFwiLSB0aGlzIHdpbGwgbGlrZWx5IGNhdXNlIHJlbmRlciBlcnJvcnMuXCIsXG5cdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG5cdCAqL1xuXHRmdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuXHRcdHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcblx0fVxuXG5cdC8qICAqL1xuXG5cdC8qKlxuXHQgKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG5cdCAqL1xuXHRmdW5jdGlvbiBjaGVja0tleUNvZGVzIChcblx0XHRldmVudEtleUNvZGUsXG5cdFx0a2V5LFxuXHRcdGJ1aWx0SW5BbGlhc1xuXHQpIHtcblx0XHR2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoa2V5Q29kZXMpKSB7XG5cdFx0XHRyZXR1cm4ga2V5Q29kZXMuaW5kZXhPZihldmVudEtleUNvZGUpID09PSAtMVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4ga2V5Q29kZXMgIT09IGV2ZW50S2V5Q29kZVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdC8qKlxuXHQgKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmluZE9iamVjdFByb3BzIChcblx0XHRkYXRhLFxuXHRcdHRhZyxcblx0XHR2YWx1ZSxcblx0XHRhc1Byb3Bcblx0KSB7XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHRcdCd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG5cdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGhhc2g7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7XG5cdFx0XHRcdFx0XHRoYXNoID0gZGF0YTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHR5cGUgPSBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMudHlwZTtcblx0XHRcdFx0XHRcdGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuXHRcdFx0XHRcdFx0XHQ/IGRhdGEuZG9tUHJvcHMgfHwgKGRhdGEuZG9tUHJvcHMgPSB7fSlcblx0XHRcdFx0XHRcdFx0OiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIShrZXkgaW4gaGFzaCkpIHtcblx0XHRcdFx0XHRcdGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG5cdCAqL1xuXHRmdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuXHRcdGluZGV4LFxuXHRcdGlzSW5Gb3Jcblx0KSB7XG5cdFx0dmFyIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF07XG5cdFx0Ly8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG5cdFx0Ly8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuXHRcdGlmICh0cmVlICYmICFpc0luRm9yKSB7XG5cdFx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuXHRcdFx0XHQ/IGNsb25lVk5vZGVzKHRyZWUpXG5cdFx0XHRcdDogY2xvbmVWTm9kZSh0cmVlKVxuXHRcdH1cblx0XHQvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG5cdFx0dHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XSA9XG5cdFx0XHR0aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1tpbmRleF0uY2FsbCh0aGlzLl9yZW5kZXJQcm94eSk7XG5cdFx0bWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcblx0XHRyZXR1cm4gdHJlZVxuXHR9XG5cblx0LyoqXG5cdCAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG5cdCAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFya09uY2UgKFxuXHRcdHRyZWUsXG5cdFx0aW5kZXgsXG5cdFx0a2V5XG5cdCkge1xuXHRcdG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuXHRcdHJldHVybiB0cmVlXG5cdH1cblxuXHRmdW5jdGlvbiBtYXJrU3RhdGljIChcblx0XHR0cmVlLFxuXHRcdGtleSxcblx0XHRpc09uY2Vcblx0KSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG5cdFx0bm9kZS5pc1N0YXRpYyA9IHRydWU7XG5cdFx0bm9kZS5rZXkgPSBrZXk7XG5cdFx0bm9kZS5pc09uY2UgPSBpc09uY2U7XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuXHRcdHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG5cdFx0dm0uX3N0YXRpY1RyZWVzID0gbnVsbDtcblx0XHR2YXIgcGFyZW50Vm5vZGUgPSB2bS4kdm5vZGUgPSB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG5cdFx0dmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuXHRcdHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyh2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuXHRcdHZtLiRzY29wZWRTbG90cyA9IGVtcHR5T2JqZWN0O1xuXHRcdC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuXHRcdC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG5cdFx0Ly8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuXHRcdC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG5cdFx0dm0uX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgZmFsc2UpOyB9O1xuXHRcdC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuXHRcdC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuXHRcdHZtLiRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIHRydWUpOyB9O1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuXHRcdFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG5cdFx0XHRyZXR1cm4gbmV4dFRpY2soZm4sIHRoaXMpXG5cdFx0fTtcblxuXHRcdFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB2bSA9IHRoaXM7XG5cdFx0XHR2YXIgcmVmID0gdm0uJG9wdGlvbnM7XG5cdFx0XHR2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcblx0XHRcdHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuXHRcdFx0dmFyIF9wYXJlbnRWbm9kZSA9IHJlZi5fcGFyZW50Vm5vZGU7XG5cblx0XHRcdGlmICh2bS5faXNNb3VudGVkKSB7XG5cdFx0XHRcdC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gdm0uJHNsb3RzKSB7XG5cdFx0XHRcdFx0dm0uJHNsb3RzW2tleV0gPSBjbG9uZVZOb2Rlcyh2bS4kc2xvdHNba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dm0uJHNjb3BlZFNsb3RzID0gKF9wYXJlbnRWbm9kZSAmJiBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cykgfHwgZW1wdHlPYmplY3Q7XG5cblx0XHRcdGlmIChzdGF0aWNSZW5kZXJGbnMgJiYgIXZtLl9zdGF0aWNUcmVlcykge1xuXHRcdFx0XHR2bS5fc3RhdGljVHJlZXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3Ncblx0XHRcdC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuXHRcdFx0dm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuXHRcdFx0Ly8gcmVuZGVyIHNlbGZcblx0XHRcdHZhciB2bm9kZTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlciBmdW5jdGlvblwiKTtcblx0XHRcdFx0Ly8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG5cdFx0XHRcdC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG5cdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yXG5cdFx0XHRcdFx0XHQ/IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSlcblx0XHRcdFx0XHRcdDogdm0uX3Zub2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG5cdFx0XHRpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuXHRcdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcblx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0J011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcblx0XHRcdFx0XHRcdCdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLFxuXHRcdFx0XHRcdFx0dm1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc2V0IHBhcmVudFxuXHRcdFx0dm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuXHRcdFx0cmV0dXJuIHZub2RlXG5cdFx0fTtcblxuXHRcdC8vIGludGVybmFsIHJlbmRlciBoZWxwZXJzLlxuXHRcdC8vIHRoZXNlIGFyZSBleHBvc2VkIG9uIHRoZSBpbnN0YW5jZSBwcm90b3R5cGUgdG8gcmVkdWNlIGdlbmVyYXRlZCByZW5kZXJcblx0XHQvLyBjb2RlIHNpemUuXG5cdFx0VnVlLnByb3RvdHlwZS5fbyA9IG1hcmtPbmNlO1xuXHRcdFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcblx0XHRWdWUucHJvdG90eXBlLl9zID0gdG9TdHJpbmc7XG5cdFx0VnVlLnByb3RvdHlwZS5fbCA9IHJlbmRlckxpc3Q7XG5cdFx0VnVlLnByb3RvdHlwZS5fdCA9IHJlbmRlclNsb3Q7XG5cdFx0VnVlLnByb3RvdHlwZS5fcSA9IGxvb3NlRXF1YWw7XG5cdFx0VnVlLnByb3RvdHlwZS5faSA9IGxvb3NlSW5kZXhPZjtcblx0XHRWdWUucHJvdG90eXBlLl9tID0gcmVuZGVyU3RhdGljO1xuXHRcdFZ1ZS5wcm90b3R5cGUuX2YgPSByZXNvbHZlRmlsdGVyO1xuXHRcdFZ1ZS5wcm90b3R5cGUuX2sgPSBjaGVja0tleUNvZGVzO1xuXHRcdFZ1ZS5wcm90b3R5cGUuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG5cdFx0VnVlLnByb3RvdHlwZS5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcblx0XHRWdWUucHJvdG90eXBlLl9lID0gY3JlYXRlRW1wdHlWTm9kZTtcblx0XHRWdWUucHJvdG90eXBlLl91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuXHR9XG5cblx0LyogICovXG5cblx0dmFyIHVpZCQxID0gMDtcblxuXHRmdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuXHRcdFZ1ZS5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdFx0dmFyIHZtID0gdGhpcztcblx0XHRcdC8vIGEgdWlkXG5cdFx0XHR2bS5fdWlkID0gdWlkJDErKztcblxuXHRcdFx0dmFyIHN0YXJ0VGFnLCBlbmRUYWc7XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuXHRcdFx0XHRzdGFydFRhZyA9IFwidnVlLXBlcmYtaW5pdDpcIiArICh2bS5fdWlkKTtcblx0XHRcdFx0ZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG5cdFx0XHRcdG1hcmsoc3RhcnRUYWcpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuXHRcdFx0dm0uX2lzVnVlID0gdHJ1ZTtcblx0XHRcdC8vIG1lcmdlIG9wdGlvbnNcblx0XHRcdGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG5cdFx0XHRcdC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG5cdFx0XHRcdC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcblx0XHRcdFx0Ly8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG5cdFx0XHRcdGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcblx0XHRcdFx0XHRyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcblx0XHRcdFx0XHRvcHRpb25zIHx8IHt9LFxuXHRcdFx0XHRcdHZtXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRcdFx0e1xuXHRcdFx0XHRpbml0UHJveHkodm0pO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZXhwb3NlIHJlYWwgc2VsZlxuXHRcdFx0dm0uX3NlbGYgPSB2bTtcblx0XHRcdGluaXRMaWZlY3ljbGUodm0pO1xuXHRcdFx0aW5pdEV2ZW50cyh2bSk7XG5cdFx0XHRpbml0UmVuZGVyKHZtKTtcblx0XHRcdGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG5cdFx0XHRpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuXHRcdFx0aW5pdFN0YXRlKHZtKTtcblx0XHRcdGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcblx0XHRcdGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuXHRcdFx0XHR2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcblx0XHRcdFx0bWFyayhlbmRUYWcpO1xuXHRcdFx0XHRtZWFzdXJlKCgodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2bS4kb3B0aW9ucy5lbCkge1xuXHRcdFx0XHR2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQgKHZtLCBvcHRpb25zKSB7XG5cdFx0dmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG5cdFx0Ly8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cblx0XHRvcHRzLnBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuXHRcdG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG5cdFx0b3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcblx0XHRvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG5cdFx0b3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcblx0XHRvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG5cdFx0b3B0cy5fcGFyZW50RWxtID0gb3B0aW9ucy5fcGFyZW50RWxtO1xuXHRcdG9wdHMuX3JlZkVsbSA9IG9wdGlvbnMuX3JlZkVsbTtcblx0XHRpZiAob3B0aW9ucy5yZW5kZXIpIHtcblx0XHRcdG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG5cdFx0XHRvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcblx0XHR2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcblx0XHRpZiAoQ3Rvci5zdXBlcikge1xuXHRcdFx0dmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG5cdFx0XHR2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG5cdFx0XHRpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcblx0XHRcdFx0Ly8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG5cdFx0XHRcdC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cblx0XHRcdFx0Q3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG5cdFx0XHRcdC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3Nilcblx0XHRcdFx0dmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG5cdFx0XHRcdC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG5cdFx0XHRcdGlmIChtb2RpZmllZE9wdGlvbnMpIHtcblx0XHRcdFx0XHRleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuXHRcdFx0XHRpZiAob3B0aW9ucy5uYW1lKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvcHRpb25zXG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG5cdFx0dmFyIG1vZGlmaWVkO1xuXHRcdHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG5cdFx0dmFyIGV4dGVuZGVkID0gQ3Rvci5leHRlbmRPcHRpb25zO1xuXHRcdHZhciBzZWFsZWQgPSBDdG9yLnNlYWxlZE9wdGlvbnM7XG5cdFx0Zm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuXHRcdFx0aWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuXHRcdFx0XHRpZiAoIW1vZGlmaWVkKSB7IG1vZGlmaWVkID0ge307IH1cblx0XHRcdFx0bW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbW9kaWZpZWRcblx0fVxuXG5cdGZ1bmN0aW9uIGRlZHVwZSAobGF0ZXN0LCBleHRlbmRlZCwgc2VhbGVkKSB7XG5cdFx0Ly8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcblx0XHQvLyBiZXR3ZWVuIG1lcmdlc1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGxhdGVzdCkpIHtcblx0XHRcdHZhciByZXMgPSBbXTtcblx0XHRcdHNlYWxlZCA9IEFycmF5LmlzQXJyYXkoc2VhbGVkKSA/IHNlYWxlZCA6IFtzZWFsZWRdO1xuXHRcdFx0ZXh0ZW5kZWQgPSBBcnJheS5pc0FycmF5KGV4dGVuZGVkKSA/IGV4dGVuZGVkIDogW2V4dGVuZGVkXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdC8vIHB1c2ggb3JpZ2luYWwgb3B0aW9ucyBhbmQgbm90IHNlYWxlZCBvcHRpb25zIHRvIGV4Y2x1ZGUgZHVwbGljYXRlZCBvcHRpb25zXG5cdFx0XHRcdGlmIChleHRlbmRlZC5pbmRleE9mKGxhdGVzdFtpXSkgPj0gMCB8fCBzZWFsZWQuaW5kZXhPZihsYXRlc3RbaV0pIDwgMCkge1xuXHRcdFx0XHRcdHJlcy5wdXNoKGxhdGVzdFtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGxhdGVzdFxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIFZ1ZSQzIChvcHRpb25zKSB7XG5cdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG5cdFx0XHQhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMylcblx0XHQpIHtcblx0XHRcdHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcblx0XHR9XG5cdFx0dGhpcy5faW5pdChvcHRpb25zKTtcblx0fVxuXG5cdGluaXRNaXhpbihWdWUkMyk7XG5cdHN0YXRlTWl4aW4oVnVlJDMpO1xuXHRldmVudHNNaXhpbihWdWUkMyk7XG5cdGxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcblx0cmVuZGVyTWl4aW4oVnVlJDMpO1xuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuXHRcdFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzXG5cdFx0XHR9XG5cdFx0XHQvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcblx0XHRcdHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuXHRcdFx0YXJncy51bnNoaWZ0KHRoaXMpO1xuXHRcdFx0aWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgcGx1Z2luID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcblx0XHRcdH1cblx0XHRcdHBsdWdpbi5pbnN0YWxsZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9O1xuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuXHRcdFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuXHRcdFx0dGhpcy5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgbWl4aW4pO1xuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9O1xuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gaW5pdEV4dGVuZCAoVnVlKSB7XG5cdFx0LyoqXG5cdFx0ICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG5cdFx0ICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuXHRcdCAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuXHRcdCAqL1xuXHRcdFZ1ZS5jaWQgPSAwO1xuXHRcdHZhciBjaWQgPSAxO1xuXG5cdFx0LyoqXG5cdFx0ICogQ2xhc3MgaW5oZXJpdGFuY2Vcblx0XHQgKi9cblx0XHRWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcblx0XHRcdGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuXHRcdFx0dmFyIFN1cGVyID0gdGhpcztcblx0XHRcdHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuXHRcdFx0dmFyIGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcblx0XHRcdGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuXHRcdFx0XHRyZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cblx0XHRcdH1cblxuXHRcdFx0dmFyIG5hbWUgPSBleHRlbmRPcHRpb25zLm5hbWUgfHwgU3VwZXIub3B0aW9ucy5uYW1lO1xuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIS9eW2EtekEtWl1bXFx3LV0qJC8udGVzdChuYW1lKSkge1xuXHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHQnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuXHRcdFx0XHRcdFx0J2NhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIHRoZSBoeXBoZW4sICcgK1xuXHRcdFx0XHRcdFx0J2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuXHRcdFx0XHR0aGlzLl9pbml0KG9wdGlvbnMpO1xuXHRcdFx0fTtcblx0XHRcdFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG5cdFx0XHRTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuXHRcdFx0U3ViLmNpZCA9IGNpZCsrO1xuXHRcdFx0U3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG5cdFx0XHRcdFN1cGVyLm9wdGlvbnMsXG5cdFx0XHRcdGV4dGVuZE9wdGlvbnNcblx0XHRcdCk7XG5cdFx0XHRTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuXHRcdFx0Ly8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cblx0XHRcdC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG5cdFx0XHQvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG5cdFx0XHRpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcblx0XHRcdFx0aW5pdFByb3BzJDEoU3ViKTtcblx0XHRcdH1cblx0XHRcdGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuXHRcdFx0XHRpbml0Q29tcHV0ZWQkMShTdWIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2Vcblx0XHRcdFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG5cdFx0XHRTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcblx0XHRcdFN1Yi51c2UgPSBTdXBlci51c2U7XG5cblx0XHRcdC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcblx0XHRcdC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cblx0XHRcdEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRcdFx0U3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG5cdFx0XHR9KTtcblx0XHRcdC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcblx0XHRcdGlmIChuYW1lKSB7XG5cdFx0XHRcdFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG5cdFx0XHQvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuXHRcdFx0Ly8gYmVlbiB1cGRhdGVkLlxuXHRcdFx0U3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG5cdFx0XHRTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG5cdFx0XHRTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG5cdFx0XHQvLyBjYWNoZSBjb25zdHJ1Y3RvclxuXHRcdFx0Y2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG5cdFx0XHRyZXR1cm4gU3ViXG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG5cdFx0dmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuXHRcdGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuXHRcdFx0cHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcblx0XHR2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG5cdFx0Zm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG5cdFx0XHRkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cblx0XHQgKi9cblx0XHRBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0XHRWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG5cdFx0XHRcdGlkLFxuXHRcdFx0XHRkZWZpbml0aW9uXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKCFkZWZpbml0aW9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgY29uZmlnLmlzUmVzZXJ2ZWRUYWcoaWQpKSB7XG5cdFx0XHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHRcdFx0J0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG5cdFx0XHRcdFx0XHRcdFx0J2lkOiAnICsgaWRcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcblx0XHRcdFx0XHRcdGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcblx0XHRcdFx0XHRcdGRlZmluaXRpb24gPSB0aGlzLm9wdGlvbnMuX2Jhc2UuZXh0ZW5kKGRlZmluaXRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcblx0XHRcdFx0XHRyZXR1cm4gZGVmaW5pdGlvblxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9XG5cblx0LyogICovXG5cblx0dmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cF07XG5cblx0ZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSAob3B0cykge1xuXHRcdHJldHVybiBvcHRzICYmIChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxuXHR9XG5cblx0ZnVuY3Rpb24gbWF0Y2hlcyAocGF0dGVybiwgbmFtZSkge1xuXHRcdGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBwYXR0ZXJuLnNwbGl0KCcsJykuaW5kZXhPZihuYW1lKSA+IC0xXG5cdFx0fSBlbHNlIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuXHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuXHRcdH1cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJ1bmVDYWNoZSAoY2FjaGUsIGN1cnJlbnQsIGZpbHRlcikge1xuXHRcdGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuXHRcdFx0dmFyIGNhY2hlZE5vZGUgPSBjYWNoZVtrZXldO1xuXHRcdFx0aWYgKGNhY2hlZE5vZGUpIHtcblx0XHRcdFx0dmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG5cdFx0XHRcdGlmIChuYW1lICYmICFmaWx0ZXIobmFtZSkpIHtcblx0XHRcdFx0XHRpZiAoY2FjaGVkTm9kZSAhPT0gY3VycmVudCkge1xuXHRcdFx0XHRcdFx0cHJ1bmVDYWNoZUVudHJ5KGNhY2hlZE5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWNoZVtrZXldID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHBydW5lQ2FjaGVFbnRyeSAodm5vZGUpIHtcblx0XHRpZiAodm5vZGUpIHtcblx0XHRcdHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRkZXN0cm95KCk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIEtlZXBBbGl2ZSA9IHtcblx0XHRuYW1lOiAna2VlcC1hbGl2ZScsXG5cdFx0YWJzdHJhY3Q6IHRydWUsXG5cblx0XHRwcm9wczoge1xuXHRcdFx0aW5jbHVkZTogcGF0dGVyblR5cGVzLFxuXHRcdFx0ZXhjbHVkZTogcGF0dGVyblR5cGVzXG5cdFx0fSxcblxuXHRcdGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuXHRcdFx0dGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0fSxcblxuXHRcdGRlc3Ryb3llZDogZnVuY3Rpb24gZGVzdHJveWVkICgpIHtcblx0XHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG5cdFx0XHRcdHBydW5lQ2FjaGVFbnRyeSh0aGlzJDEuY2FjaGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHdhdGNoOiB7XG5cdFx0XHRpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcblx0XHRcdFx0cHJ1bmVDYWNoZSh0aGlzLmNhY2hlLCB0aGlzLl92bm9kZSwgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG5cdFx0XHR9LFxuXHRcdFx0ZXhjbHVkZTogZnVuY3Rpb24gZXhjbHVkZSAodmFsKSB7XG5cdFx0XHRcdHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiAhbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuXHRcdFx0dmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcblx0XHRcdHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcblx0XHRcdGlmIChjb21wb25lbnRPcHRpb25zKSB7XG5cdFx0XHRcdC8vIGNoZWNrIHBhdHRlcm5cblx0XHRcdFx0dmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuXHRcdFx0XHRpZiAobmFtZSAmJiAoXG5cdFx0XHRcdFx0XHQodGhpcy5pbmNsdWRlICYmICFtYXRjaGVzKHRoaXMuaW5jbHVkZSwgbmFtZSkpIHx8XG5cdFx0XHRcdFx0XHQodGhpcy5leGNsdWRlICYmIG1hdGNoZXModGhpcy5leGNsdWRlLCBuYW1lKSlcblx0XHRcdFx0XHQpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZub2RlXG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG5cdFx0XHRcdFx0Ly8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcblx0XHRcdFx0XHQvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG5cdFx0XHRcdFx0PyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG5cdFx0XHRcdFx0OiB2bm9kZS5rZXk7XG5cdFx0XHRcdGlmICh0aGlzLmNhY2hlW2tleV0pIHtcblx0XHRcdFx0XHR2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuY2FjaGVba2V5XS5jb21wb25lbnRJbnN0YW5jZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLmNhY2hlW2tleV0gPSB2bm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdm5vZGVcblx0XHR9XG5cdH07XG5cblx0dmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuXHRcdEtlZXBBbGl2ZTogS2VlcEFsaXZlXG5cdH07XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG5cdFx0Ly8gY29uZmlnXG5cdFx0dmFyIGNvbmZpZ0RlZiA9IHt9O1xuXHRcdGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG5cdFx0e1xuXHRcdFx0Y29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHQnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG5cdFx0XHRcdCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuXHRcdC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuXHRcdC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuXHRcdC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG5cdFx0VnVlLnV0aWwgPSB7XG5cdFx0XHR3YXJuOiB3YXJuLFxuXHRcdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0XHRtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcblx0XHRcdGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuXHRcdH07XG5cblx0XHRWdWUuc2V0ID0gc2V0O1xuXHRcdFZ1ZS5kZWxldGUgPSBkZWw7XG5cdFx0VnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cblx0XHRWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0QVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuXHRcdFx0VnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gdGhpcyBpcyB1c2VkIHRvIGlkZW50aWZ5IHRoZSBcImJhc2VcIiBjb25zdHJ1Y3RvciB0byBleHRlbmQgYWxsIHBsYWluLW9iamVjdFxuXHRcdC8vIGNvbXBvbmVudHMgd2l0aCBpbiBXZWV4J3MgbXVsdGktaW5zdGFuY2Ugc2NlbmFyaW9zLlxuXHRcdFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG5cdFx0ZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIGJ1aWx0SW5Db21wb25lbnRzKTtcblxuXHRcdGluaXRVc2UoVnVlKTtcblx0XHRpbml0TWl4aW4kMShWdWUpO1xuXHRcdGluaXRFeHRlbmQoVnVlKTtcblx0XHRpbml0QXNzZXRSZWdpc3RlcnMoVnVlKTtcblx0fVxuXG5cdGluaXRHbG9iYWxBUEkoVnVlJDMpO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG5cdFx0Z2V0OiBpc1NlcnZlclJlbmRlcmluZ1xuXHR9KTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJHNzckNvbnRleHQnLCB7XG5cdFx0Z2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdHJldHVybiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0XG5cdFx0fVxuXHR9KTtcblxuXHRWdWUkMy52ZXJzaW9uID0gJzIuMy40JztcblxuXHQvKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cblx0dmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuLy8gYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSB1c2luZyBwcm9wcyBmb3IgYmluZGluZ1xuXHR2YXIgYWNjZXB0VmFsdWUgPSBtYWtlTWFwKCdpbnB1dCx0ZXh0YXJlYSxvcHRpb24sc2VsZWN0Jyk7XG5cdHZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0KGF0dHIgPT09ICd2YWx1ZScgJiYgYWNjZXB0VmFsdWUodGFnKSkgJiYgdHlwZSAhPT0gJ2J1dHRvbicgfHxcblx0XHRcdChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG5cdFx0XHQoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcblx0XHRcdChhdHRyID09PSAnbXV0ZWQnICYmIHRhZyA9PT0gJ3ZpZGVvJylcblx0XHQpXG5cdH07XG5cblx0dmFyIGlzRW51bWVyYXRlZEF0dHIgPSBtYWtlTWFwKCdjb250ZW50ZWRpdGFibGUsZHJhZ2dhYmxlLHNwZWxsY2hlY2snKTtcblxuXHR2YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG5cdFx0J2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG5cdFx0J2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcblx0XHQnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcblx0XHQnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcblx0XHQncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcblx0XHQndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcblx0KTtcblxuXHR2YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxuXHR2YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xuXHR9O1xuXG5cdHZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xuXHR9O1xuXG5cdHZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuXHRcdHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG5cdH07XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcblx0XHR2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG5cdFx0dmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcblx0XHR2YXIgY2hpbGROb2RlID0gdm5vZGU7XG5cdFx0d2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcblx0XHRcdGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG5cdFx0XHRpZiAoY2hpbGROb2RlLmRhdGEpIHtcblx0XHRcdFx0ZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKGlzRGVmKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcblx0XHRcdGlmIChwYXJlbnROb2RlLmRhdGEpIHtcblx0XHRcdFx0ZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBnZW5DbGFzc0Zyb21EYXRhKGRhdGEpXG5cdH1cblxuXHRmdW5jdGlvbiBtZXJnZUNsYXNzRGF0YSAoY2hpbGQsIHBhcmVudCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuXHRcdFx0Y2xhc3M6IGlzRGVmKGNoaWxkLmNsYXNzKVxuXHRcdFx0XHQ/IFtjaGlsZC5jbGFzcywgcGFyZW50LmNsYXNzXVxuXHRcdFx0XHQ6IHBhcmVudC5jbGFzc1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbkNsYXNzRnJvbURhdGEgKGRhdGEpIHtcblx0XHR2YXIgZHluYW1pY0NsYXNzID0gZGF0YS5jbGFzcztcblx0XHR2YXIgc3RhdGljQ2xhc3MgPSBkYXRhLnN0YXRpY0NsYXNzO1xuXHRcdGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuXHRcdFx0cmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcblx0XHR9XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRyZXR1cm4gJydcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuXHRcdHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG5cdH1cblxuXHRmdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcblx0XHRpZiAoaXNVbmRlZih2YWx1ZSkpIHtcblx0XHRcdHJldHVybiAnJ1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0fVxuXHRcdHZhciByZXMgPSAnJztcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHZhciBzdHJpbmdpZmllZDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChpc0RlZih2YWx1ZVtpXSkpIHtcblx0XHRcdFx0XHRpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuXHRcdFx0XHRcdFx0cmVzICs9IHN0cmluZ2lmaWVkICsgJyAnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlcy5zbGljZSgwLCAtMSlcblx0XHR9XG5cdFx0aWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRcdGlmICh2YWx1ZVtrZXldKSB7IHJlcyArPSBrZXkgKyAnICc7IH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG5cdFx0fVxuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cblx0LyogICovXG5cblx0dmFyIG5hbWVzcGFjZU1hcCA9IHtcblx0XHRzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0bWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG5cdH07XG5cblx0dmFyIGlzSFRNTFRhZyA9IG1ha2VNYXAoXG5cdFx0J2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuXHRcdCdhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoMSxoMixoMyxoNCxoNSxoNixoZ3JvdXAsbmF2LHNlY3Rpb24sJyArXG5cdFx0J2RpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxocixpbWcsbGksbWFpbixvbCxwLHByZSx1bCwnICtcblx0XHQnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuXHRcdCdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcblx0XHQnZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsJyArXG5cdFx0J2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuXHRcdCdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuXHRcdCdvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLCcgK1xuXHRcdCdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG5cdFx0J2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUnXG5cdCk7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cblx0dmFyIGlzU1ZHID0gbWFrZU1hcChcblx0XHQnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuXHRcdCdmb3JlaWduT2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcblx0XHQncG9seWdvbixwb2x5bGluZSxyZWN0LHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0cGF0aCx0c3Bhbix1c2UsdmlldycsXG5cdFx0dHJ1ZVxuXHQpO1xuXG5cdHZhciBpc1ByZVRhZyA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHRhZyA9PT0gJ3ByZSc7IH07XG5cblx0dmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG5cdFx0cmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZylcblx0fTtcblxuXHRmdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuXHRcdGlmIChpc1NWRyh0YWcpKSB7XG5cdFx0XHRyZXR1cm4gJ3N2Zydcblx0XHR9XG5cdFx0Ly8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG5cdFx0Ly8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuXHRcdGlmICh0YWcgPT09ICdtYXRoJykge1xuXHRcdFx0cmV0dXJuICdtYXRoJ1xuXHRcdH1cblx0fVxuXG5cdHZhciB1bmtub3duRWxlbWVudENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCAodGFnKSB7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKCFpbkJyb3dzZXIpIHtcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdGlmIChpc1Jlc2VydmVkVGFnKHRhZykpIHtcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdH1cblx0XHR0YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcblx0XHRcdHJldHVybiB1bmtub3duRWxlbWVudENhY2hlW3RhZ11cblx0XHR9XG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuXHRcdGlmICh0YWcuaW5kZXhPZignLScpID4gLTEpIHtcblx0XHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI4MjEwMzY0LzEwNzAyNDRcblx0XHRcdHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuXHRcdFx0XHRlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxVbmtub3duRWxlbWVudCB8fFxuXHRcdFx0XHRlbC5jb25zdHJ1Y3RvciA9PT0gd2luZG93LkhUTUxFbGVtZW50XG5cdFx0XHQpKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpXG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0LyoqXG5cdCAqIFF1ZXJ5IGFuIGVsZW1lbnQgc2VsZWN0b3IgaWYgaXQncyBub3QgYW4gZWxlbWVudCBhbHJlYWR5LlxuXHQgKi9cblx0ZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG5cdFx0aWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuXHRcdFx0aWYgKCFzZWxlY3RlZCkge1xuXHRcdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHRcdCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWxcblx0XHRcdFx0KTtcblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2VsZWN0ZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGVsXG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuXHRcdHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuXHRcdGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuXHRcdFx0cmV0dXJuIGVsbVxuXHRcdH1cblx0XHQvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuXHRcdGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuXHRcdH1cblx0XHRyZXR1cm4gZWxtXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMgKG5hbWVzcGFjZSwgdGFnTmFtZSkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSAodGV4dCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlQ29tbWVudCAodGV4dCkge1xuXHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG5cdH1cblxuXHRmdW5jdGlvbiBpbnNlcnRCZWZvcmUgKHBhcmVudE5vZGUsIG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpIHtcblx0XHRwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZUNoaWxkIChub2RlLCBjaGlsZCkge1xuXHRcdG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXBwZW5kQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG5cdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJlbnROb2RlIChub2RlKSB7XG5cdFx0cmV0dXJuIG5vZGUucGFyZW50Tm9kZVxuXHR9XG5cblx0ZnVuY3Rpb24gbmV4dFNpYmxpbmcgKG5vZGUpIHtcblx0XHRyZXR1cm4gbm9kZS5uZXh0U2libGluZ1xuXHR9XG5cblx0ZnVuY3Rpb24gdGFnTmFtZSAobm9kZSkge1xuXHRcdHJldHVybiBub2RlLnRhZ05hbWVcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFRleHRDb250ZW50IChub2RlLCB0ZXh0KSB7XG5cdFx0bm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5vZGUsIGtleSwgdmFsKSB7XG5cdFx0bm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xuXHR9XG5cblxuXHR2YXIgbm9kZU9wcyA9IE9iamVjdC5mcmVlemUoe1xuXHRcdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0XHRjcmVhdGVFbGVtZW50TlM6IGNyZWF0ZUVsZW1lbnROUyxcblx0XHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUsXG5cdFx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0XHRpbnNlcnRCZWZvcmU6IGluc2VydEJlZm9yZSxcblx0XHRyZW1vdmVDaGlsZDogcmVtb3ZlQ2hpbGQsXG5cdFx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRcdHBhcmVudE5vZGU6IHBhcmVudE5vZGUsXG5cdFx0bmV4dFNpYmxpbmc6IG5leHRTaWJsaW5nLFxuXHRcdHRhZ05hbWU6IHRhZ05hbWUsXG5cdFx0c2V0VGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXHRcdHNldEF0dHJpYnV0ZTogc2V0QXR0cmlidXRlXG5cdH0pO1xuXG5cdC8qICAqL1xuXG5cdHZhciByZWYgPSB7XG5cdFx0Y3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG5cdFx0XHRyZWdpc3RlclJlZih2bm9kZSk7XG5cdFx0fSxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG5cdFx0XHRpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG5cdFx0XHRcdHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcblx0XHRcdFx0cmVnaXN0ZXJSZWYodm5vZGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcblx0XHRcdHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcblx0XHR2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG5cdFx0aWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuXHRcdHZhciB2bSA9IHZub2RlLmNvbnRleHQ7XG5cdFx0dmFyIHJlZiA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcblx0XHR2YXIgcmVmcyA9IHZtLiRyZWZzO1xuXHRcdGlmIChpc1JlbW92YWwpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcblx0XHRcdFx0cmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcblx0XHRcdH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcblx0XHRcdFx0cmVmc1trZXldID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodm5vZGUuZGF0YS5yZWZJbkZvcikge1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pICYmIHJlZnNba2V5XS5pbmRleE9mKHJlZikgPCAwKSB7XG5cdFx0XHRcdFx0cmVmc1trZXldLnB1c2gocmVmKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZWZzW2tleV0gPSBbcmVmXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVmc1trZXldID0gcmVmO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcblx0ICogU2ltb24gRnJpaXMgVmluZHVtIChAcGFsZGVwaW5kKVxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2Vcblx0ICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cdCAqXG5cdCAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuXHQgKlxuXG5cdCAvKlxuXHQgKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGJlY2F1c2UgdGhpcyBmaWxlIGlzIHBlcmYtY3JpdGljYWwgYW5kIHRoZSBjb3N0XG5cdCAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuXHQgKi9cblxuXHR2YXIgZW1wdHlOb2RlID0gbmV3IFZOb2RlKCcnLCB7fSwgW10pO1xuXG5cdHZhciBob29rcyA9IFsnY3JlYXRlJywgJ2FjdGl2YXRlJywgJ3VwZGF0ZScsICdyZW1vdmUnLCAnZGVzdHJveSddO1xuXG5cdGZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuXHRcdHJldHVybiAoXG5cdFx0XHRhLmtleSA9PT0gYi5rZXkgJiZcblx0XHRcdGEudGFnID09PSBiLnRhZyAmJlxuXHRcdFx0YS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG5cdFx0XHRpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG5cdFx0XHRzYW1lSW5wdXRUeXBlKGEsIGIpXG5cdFx0KVxuXHR9XG5cbi8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IHN1cHBvcnQgZHluYW1pY2FsbHkgY2hhbmdpbmcgdHlwZSBmb3IgPGlucHV0PlxuLy8gc28gdGhleSBuZWVkIHRvIGJlIHRyZWF0ZWQgYXMgZGlmZmVyZW50IG5vZGVzXG5cdGZ1bmN0aW9uIHNhbWVJbnB1dFR5cGUgKGEsIGIpIHtcblx0XHRpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuXHRcdHZhciBpO1xuXHRcdHZhciB0eXBlQSA9IGlzRGVmKGkgPSBhLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG5cdFx0dmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcblx0XHRyZXR1cm4gdHlwZUEgPT09IHR5cGVCXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcblx0XHR2YXIgaSwga2V5O1xuXHRcdHZhciBtYXAgPSB7fTtcblx0XHRmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuXHRcdFx0a2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuXHRcdFx0aWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcblx0XHR2YXIgaSwgajtcblx0XHR2YXIgY2JzID0ge307XG5cblx0XHR2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcblx0XHR2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuXHRcdFx0Y2JzW2hvb2tzW2ldXSA9IFtdO1xuXHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0aWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuXHRcdFx0XHRcdGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuXHRcdFx0ZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcblx0XHRcdFx0aWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuXHRcdFx0XHRcdHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuXHRcdFx0cmV0dXJuIHJlbW92ZSQkMVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcblx0XHRcdC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuXHRcdFx0aWYgKGlzRGVmKHBhcmVudCkpIHtcblx0XHRcdFx0bm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgaW5QcmUgPSAwO1xuXHRcdGZ1bmN0aW9uIGNyZWF0ZUVsbSAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0sIG5lc3RlZCkge1xuXHRcdFx0dm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcblx0XHRcdGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcblx0XHRcdHZhciB0YWcgPSB2bm9kZS50YWc7XG5cdFx0XHRpZiAoaXNEZWYodGFnKSkge1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcblx0XHRcdFx0XHRcdGluUHJlKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdCFpblByZSAmJlxuXHRcdFx0XHRcdFx0IXZub2RlLm5zICYmXG5cdFx0XHRcdFx0XHQhKGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG5cdFx0XHRcdFx0XHRjb25maWcuaXNVbmtub3duRWxlbWVudCh0YWcpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0XHQnVW5rbm93biBjdXN0b20gZWxlbWVudDogPCcgKyB0YWcgKyAnPiAtIGRpZCB5b3UgJyArXG5cdFx0XHRcdFx0XHRcdCdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcblx0XHRcdFx0XHRcdFx0J21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcblx0XHRcdFx0XHRcdFx0dm5vZGUuY29udGV4dFxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dm5vZGUuZWxtID0gdm5vZGUubnNcblx0XHRcdFx0XHQ/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG5cdFx0XHRcdFx0OiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG5cdFx0XHRcdHNldFNjb3BlKHZub2RlKTtcblxuXHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0XHRcdFx0XHRpZiAoaXNEZWYoZGF0YSkpIHtcblx0XHRcdFx0XHRcdGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZGF0YSAmJiBkYXRhLnByZSkge1xuXHRcdFx0XHRcdGluUHJlLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkpIHtcblx0XHRcdFx0dm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuXHRcdFx0XHRpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuXHRcdFx0XHRpbnNlcnQocGFyZW50RWxtLCB2bm9kZS5lbG0sIHJlZkVsbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuXHRcdFx0dmFyIGkgPSB2bm9kZS5kYXRhO1xuXHRcdFx0aWYgKGlzRGVmKGkpKSB7XG5cdFx0XHRcdHZhciBpc1JlYWN0aXZhdGVkID0gaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpICYmIGkua2VlcEFsaXZlO1xuXHRcdFx0XHRpZiAoaXNEZWYoaSA9IGkuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHtcblx0XHRcdFx0XHRpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuXHRcdFx0XHQvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcblx0XHRcdFx0Ly8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG5cdFx0XHRcdC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG5cdFx0XHRcdGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcblx0XHRcdFx0XHRpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHRcdFx0XHRcdGlmIChpc1RydWUoaXNSZWFjdGl2YXRlZCkpIHtcblx0XHRcdFx0XHRcdHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuXHRcdFx0aWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcblx0XHRcdFx0aW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuXHRcdFx0XHR2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0dm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuXHRcdFx0aWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuXHRcdFx0XHRpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0XHRcdFx0c2V0U2NvcGUodm5vZGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZW1wdHkgY29tcG9uZW50IHJvb3QuXG5cdFx0XHRcdC8vIHNraXAgYWxsIGVsZW1lbnQtcmVsYXRlZCBtb2R1bGVzIGV4Y2VwdCBmb3IgcmVmICgjMzQ1NSlcblx0XHRcdFx0cmVnaXN0ZXJSZWYodm5vZGUpO1xuXHRcdFx0XHQvLyBtYWtlIHN1cmUgdG8gaW52b2tlIHRoZSBpbnNlcnQgaG9va1xuXHRcdFx0XHRpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVhY3RpdmF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0Ly8gaGFjayBmb3IgIzQzMzk6IGEgcmVhY3RpdmF0ZWQgY29tcG9uZW50IHdpdGggaW5uZXIgdHJhbnNpdGlvblxuXHRcdFx0Ly8gZG9lcyBub3QgdHJpZ2dlciBiZWNhdXNlIHRoZSBpbm5lciBub2RlJ3MgY3JlYXRlZCBob29rcyBhcmUgbm90IGNhbGxlZFxuXHRcdFx0Ly8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG5cdFx0XHQvLyB0aGVyZSBkb2Vzbid0IHNlZW0gdG8gYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIGl0LlxuXHRcdFx0dmFyIGlubmVyTm9kZSA9IHZub2RlO1xuXHRcdFx0d2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuXHRcdFx0XHRpbm5lck5vZGUgPSBpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuXHRcdFx0XHRpZiAoaXNEZWYoaSA9IGlubmVyTm9kZS5kYXRhKSAmJiBpc0RlZihpID0gaS50cmFuc2l0aW9uKSkge1xuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRcdGNicy5hY3RpdmF0ZVtpXShlbXB0eU5vZGUsIGlubmVyTm9kZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gdW5saWtlIGEgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQsXG5cdFx0XHQvLyBhIHJlYWN0aXZhdGVkIGtlZXAtYWxpdmUgY29tcG9uZW50IGRvZXNuJ3QgaW5zZXJ0IGl0c2VsZlxuXHRcdFx0aW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluc2VydCAocGFyZW50LCBlbG0sIHJlZikge1xuXHRcdFx0aWYgKGlzRGVmKHBhcmVudCkpIHtcblx0XHRcdFx0aWYgKGlzRGVmKHJlZikpIHtcblx0XHRcdFx0XHRpZiAocmVmLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuXHRcdFx0XHRcdFx0bm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQ2hpbGRyZW4gKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG5cdFx0XHRcdG5vZGVPcHMuYXBwZW5kQ2hpbGQodm5vZGUuZWxtLCBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1BhdGNoYWJsZSAodm5vZGUpIHtcblx0XHRcdHdoaWxlICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuXHRcdFx0XHR2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpc0RlZih2bm9kZS50YWcpXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3MgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcblx0XHRcdGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kkMSkge1xuXHRcdFx0XHRjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRpID0gdm5vZGUuZGF0YS5ob29rOyAvLyBSZXVzZSB2YXJpYWJsZVxuXHRcdFx0aWYgKGlzRGVmKGkpKSB7XG5cdFx0XHRcdGlmIChpc0RlZihpLmNyZWF0ZSkpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cblx0XHRcdFx0aWYgKGlzRGVmKGkuaW5zZXJ0KSkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuXHRcdC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG5cdFx0Ly8gb2YgZ29pbmcgdGhyb3VnaCB0aGUgbm9ybWFsIGF0dHJpYnV0ZSBwYXRjaGluZyBwcm9jZXNzLlxuXHRcdGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuXHRcdFx0dmFyIGk7XG5cdFx0XHR2YXIgYW5jZXN0b3IgPSB2bm9kZTtcblx0XHRcdHdoaWxlIChhbmNlc3Rvcikge1xuXHRcdFx0XHRpZiAoaXNEZWYoaSA9IGFuY2VzdG9yLmNvbnRleHQpICYmIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkge1xuXHRcdFx0XHRcdG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0Ly8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuXHRcdFx0aWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcblx0XHRcdFx0aSAhPT0gdm5vZGUuY29udGV4dCAmJlxuXHRcdFx0XHRpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZClcblx0XHRcdCkge1xuXHRcdFx0XHRub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRWbm9kZXMgKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuXHRcdFx0Zm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuXHRcdFx0XHRjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG5cdFx0XHR2YXIgaSwgajtcblx0XHRcdHZhciBkYXRhID0gdm5vZGUuZGF0YTtcblx0XHRcdGlmIChpc0RlZihkYXRhKSkge1xuXHRcdFx0XHRpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcblx0XHRcdFx0Zm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdFx0aW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuXHRcdFx0Zm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuXHRcdFx0XHR2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuXHRcdFx0XHRpZiAoaXNEZWYoY2gpKSB7XG5cdFx0XHRcdFx0aWYgKGlzRGVmKGNoLnRhZykpIHtcblx0XHRcdFx0XHRcdHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuXHRcdFx0XHRcdFx0aW52b2tlRGVzdHJveUhvb2soY2gpO1xuXHRcdFx0XHRcdH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuXHRcdFx0XHRcdFx0cmVtb3ZlTm9kZShjaC5lbG0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuXHRcdFx0aWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0dmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcblx0XHRcdFx0aWYgKGlzRGVmKHJtKSkge1xuXHRcdFx0XHRcdC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuXHRcdFx0XHRcdC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcblx0XHRcdFx0XHRybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIGRpcmVjdGx5IHJlbW92aW5nXG5cdFx0XHRcdFx0cm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuXHRcdFx0XHRpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcblx0XHRcdFx0XHRyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuXHRcdFx0XHRcdGkodm5vZGUsIHJtKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRybSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZW1vdmVOb2RlKHZub2RlLmVsbSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcblx0XHRcdHZhciBvbGRTdGFydElkeCA9IDA7XG5cdFx0XHR2YXIgbmV3U3RhcnRJZHggPSAwO1xuXHRcdFx0dmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG5cdFx0XHR2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuXHRcdFx0dmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcblx0XHRcdHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuXHRcdFx0dmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcblx0XHRcdHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG5cdFx0XHR2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCBlbG1Ub01vdmUsIHJlZkVsbTtcblxuXHRcdFx0Ly8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG5cdFx0XHQvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG5cdFx0XHQvLyBkdXJpbmcgbGVhdmluZyB0cmFuc2l0aW9uc1xuXHRcdFx0dmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuXHRcdFx0d2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcblx0XHRcdFx0aWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcblx0XHRcdFx0XHRvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcblx0XHRcdFx0fSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuXHRcdFx0XHRcdG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuXHRcdFx0XHRcdHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0XHRcdFx0XHRvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG5cdFx0XHRcdFx0bmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG5cdFx0XHRcdFx0cGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdFx0XHRcdFx0b2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG5cdFx0XHRcdFx0bmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuXHRcdFx0XHRcdHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdFx0XHRcdFx0Y2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuXHRcdFx0XHRcdG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcblx0XHRcdFx0XHRuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcblx0XHRcdFx0fSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcblx0XHRcdFx0XHRwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHRcdFx0XHRcdGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcblx0XHRcdFx0XHRvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcblx0XHRcdFx0XHRuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG5cdFx0XHRcdFx0aWR4SW5PbGQgPSBpc0RlZihuZXdTdGFydFZub2RlLmtleSkgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV0gOiBudWxsO1xuXHRcdFx0XHRcdGlmIChpc1VuZGVmKGlkeEluT2xkKSkgeyAvLyBOZXcgZWxlbWVudFxuXHRcdFx0XHRcdFx0Y3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG5cdFx0XHRcdFx0XHRuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVsbVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcblx0XHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0XHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFlbG1Ub01vdmUpIHtcblx0XHRcdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdFx0XHQnSXQgc2VlbXMgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzIHRoYXQgaXMgY2F1c2luZyBhbiB1cGRhdGUgZXJyb3IuICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdNYWtlIHN1cmUgZWFjaCB2LWZvciBpdGVtIGhhcyBhIHVuaXF1ZSBrZXkuJ1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKHNhbWVWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG5cdFx0XHRcdFx0XHRcdHBhdGNoVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHRcdFx0XHRcdFx0XHRvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBuZXdTdGFydFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuXHRcdFx0XHRcdFx0XHRuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHQvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuXHRcdFx0XHRcdFx0XHRuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcblx0XHRcdFx0cmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuXHRcdFx0XHRhZGRWbm9kZXMocGFyZW50RWxtLCByZWZFbG0sIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHRcdFx0fSBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuXHRcdFx0XHRyZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcblx0XHRcdGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHQvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG5cdFx0XHQvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cblx0XHRcdC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuXHRcdFx0Ly8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cblx0XHRcdGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG5cdFx0XHRcdGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcblx0XHRcdFx0dm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcblx0XHRcdFx0KGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG5cdFx0XHQpIHtcblx0XHRcdFx0dm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXHRcdFx0XHR2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHZhciBpO1xuXHRcdFx0dmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuXHRcdFx0aWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuXHRcdFx0XHRpKG9sZFZub2RlLCB2bm9kZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXHRcdFx0dmFyIG9sZENoID0gb2xkVm5vZGUuY2hpbGRyZW47XG5cdFx0XHR2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcblx0XHRcdGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNicy51cGRhdGUubGVuZ3RoOyArK2kpIHsgY2JzLnVwZGF0ZVtpXShvbGRWbm9kZSwgdm5vZGUpOyB9XG5cdFx0XHRcdGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS51cGRhdGUpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlzVW5kZWYodm5vZGUudGV4dCkpIHtcblx0XHRcdFx0aWYgKGlzRGVmKG9sZENoKSAmJiBpc0RlZihjaCkpIHtcblx0XHRcdFx0XHRpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG5cdFx0XHRcdFx0aWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7IG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7IH1cblx0XHRcdFx0XHRhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcblx0XHRcdFx0XHRyZW1vdmVWbm9kZXMoZWxtLCBvbGRDaCwgMCwgb2xkQ2gubGVuZ3RoIC0gMSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcblx0XHRcdFx0XHRub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcblx0XHRcdFx0bm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sIHZub2RlLnRleHQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlzRGVmKGRhdGEpKSB7XG5cdFx0XHRcdGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuXHRcdFx0Ly8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG5cdFx0XHQvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuXHRcdFx0aWYgKGlzVHJ1ZShpbml0aWFsKSAmJiBpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG5cdFx0XHRcdHZub2RlLnBhcmVudC5kYXRhLnBlbmRpbmdJbnNlcnQgPSBxdWV1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRxdWV1ZVtpXS5kYXRhLmhvb2suaW5zZXJ0KHF1ZXVlW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBiYWlsZWQgPSBmYWxzZTtcblx0XHQvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuXHRcdC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG5cdFx0dmFyIGlzUmVuZGVyZWRNb2R1bGUgPSBtYWtlTWFwKCdhdHRycyxzdHlsZSxjbGFzcyxzdGF0aWNDbGFzcyxzdGF0aWNTdHlsZSxrZXknKTtcblxuXHRcdC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG5cdFx0ZnVuY3Rpb24gaHlkcmF0ZSAoZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG5cdFx0XHR7XG5cdFx0XHRcdGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZub2RlLmVsbSA9IGVsbTtcblx0XHRcdHZhciB0YWcgPSB2bm9kZS50YWc7XG5cdFx0XHR2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcblx0XHRcdGlmIChpc0RlZihkYXRhKSkge1xuXHRcdFx0XHRpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG5cdFx0XHRcdGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG5cdFx0XHRcdFx0Ly8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG5cdFx0XHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaXNEZWYodGFnKSkge1xuXHRcdFx0XHRpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdFx0Ly8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG5cdFx0XHRcdFx0aWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG5cdFx0XHRcdFx0XHRjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBjaGlsZHJlbk1hdGNoID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFjaGlsZE5vZGUgfHwgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y2hpbGROb2RlID0gY2hpbGROb2RlLm5leHRTaWJsaW5nO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuXHRcdFx0XHRcdFx0Ly8gbG9uZ2VyIHRoYW4gdGhlIHZpcnR1YWwgY2hpbGRyZW4gbGlzdC5cblx0XHRcdFx0XHRcdGlmICghY2hpbGRyZW5NYXRjaCB8fCBjaGlsZE5vZGUpIHtcblx0XHRcdFx0XHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRcdFx0XHRcdFx0IWJhaWxlZFxuXHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRiYWlsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBlbG0uY2hpbGROb2RlcywgY2hpbGRyZW4pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaXNEZWYoZGF0YSkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHRcdFx0XHRcdFx0aWYgKCFpc1JlbmRlcmVkTW9kdWxlKGtleSkpIHtcblx0XHRcdFx0XHRcdFx0aW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG5cdFx0XHRcdGVsbS5kYXRhID0gdm5vZGUudGV4dDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSkge1xuXHRcdFx0aWYgKGlzRGVmKHZub2RlLnRhZykpIHtcblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHR2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG5cdFx0XHRcdFx0dm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdClcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcblx0XHRcdGlmIChpc1VuZGVmKHZub2RlKSkge1xuXHRcdFx0XHRpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG5cdFx0XHR2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cblx0XHRcdGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuXHRcdFx0XHQvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG5cdFx0XHRcdGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcblx0XHRcdFx0Y3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuXHRcdFx0XHRpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcblx0XHRcdFx0XHQvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcblx0XHRcdFx0XHRwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoaXNSZWFsRWxlbWVudCkge1xuXHRcdFx0XHRcdFx0Ly8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG5cdFx0XHRcdFx0XHQvLyBhIHN1Y2Nlc3NmdWwgaHlkcmF0aW9uLlxuXHRcdFx0XHRcdFx0aWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcblx0XHRcdFx0XHRcdFx0b2xkVm5vZGUucmVtb3ZlQXR0cmlidXRlKFNTUl9BVFRSKTtcblx0XHRcdFx0XHRcdFx0aHlkcmF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChpc1RydWUoaHlkcmF0aW5nKSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBvbGRWbm9kZVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHRcdFx0XHQnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0J3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0J0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcblx0XHRcdFx0XHRcdFx0XHRcdCc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG5cdFx0XHRcdFx0XHRcdFx0XHQnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuXHRcdFx0XHRcdFx0Ly8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcblx0XHRcdFx0XHRcdG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyByZXBsYWNpbmcgZXhpc3RpbmcgZWxlbWVudFxuXHRcdFx0XHRcdHZhciBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG5cdFx0XHRcdFx0dmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cdFx0XHRcdFx0Y3JlYXRlRWxtKFxuXHRcdFx0XHRcdFx0dm5vZGUsXG5cdFx0XHRcdFx0XHRpbnNlcnRlZFZub2RlUXVldWUsXG5cdFx0XHRcdFx0XHQvLyBleHRyZW1lbHkgcmFyZSBlZGdlIGNhc2U6IGRvIG5vdCBpbnNlcnQgaWYgb2xkIGVsZW1lbnQgaXMgaW4gYVxuXHRcdFx0XHRcdFx0Ly8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG5cdFx0XHRcdFx0XHQvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuXHRcdFx0XHRcdFx0b2xkRWxtLl9sZWF2ZUNiID8gbnVsbCA6IHBhcmVudEVsbSQxLFxuXHRcdFx0XHRcdFx0bm9kZU9wcy5uZXh0U2libGluZyhvbGRFbG0pXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG5cdFx0XHRcdFx0XHQvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHR2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG5cdFx0XHRcdFx0XHR3aGlsZSAoYW5jZXN0b3IpIHtcblx0XHRcdFx0XHRcdFx0YW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuXHRcdFx0XHRcdFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcblx0XHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2JzLmNyZWF0ZVtpXShlbXB0eU5vZGUsIHZub2RlLnBhcmVudCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVWbm9kZXMocGFyZW50RWxtJDEsIFtvbGRWbm9kZV0sIDAsIDApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuXHRcdFx0XHRcdFx0aW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcblx0XHRcdHJldHVybiB2bm9kZS5lbG1cblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgZGlyZWN0aXZlcyA9IHtcblx0XHRjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG5cdFx0dXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG5cdFx0XHR1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcblx0XHRpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuXHRcdFx0X3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuXHRcdHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG5cdFx0dmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG5cdFx0dmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcblx0XHR2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG5cdFx0dmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG5cdFx0dmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cblx0XHR2YXIga2V5LCBvbGREaXIsIGRpcjtcblx0XHRmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG5cdFx0XHRvbGREaXIgPSBvbGREaXJzW2tleV07XG5cdFx0XHRkaXIgPSBuZXdEaXJzW2tleV07XG5cdFx0XHRpZiAoIW9sZERpcikge1xuXHRcdFx0XHQvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG5cdFx0XHRcdGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG5cdFx0XHRcdGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcblx0XHRcdFx0XHRkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG5cdFx0XHRcdGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcblx0XHRcdFx0Y2FsbEhvb2skMShkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuXHRcdFx0XHRpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcblx0XHRcdFx0XHRkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGlyc1dpdGhJbnNlcnQubGVuZ3RoKSB7XG5cdFx0XHR2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aEluc2VydC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNhbGxIb29rJDEoZGlyc1dpdGhJbnNlcnRbaV0sICdpbnNlcnRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRpZiAoaXNDcmVhdGUpIHtcblx0XHRcdFx0bWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbGxJbnNlcnQoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoKSB7XG5cdFx0XHRtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNhbGxIb29rJDEoZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpc0NyZWF0ZSkge1xuXHRcdFx0Zm9yIChrZXkgaW4gb2xkRGlycykge1xuXHRcdFx0XHRpZiAoIW5ld0RpcnNba2V5XSkge1xuXHRcdFx0XHRcdC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcblx0XHRcdFx0XHRjYWxsSG9vayQxKG9sZERpcnNba2V5XSwgJ3VuYmluZCcsIG9sZFZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0ZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyQxIChcblx0XHRkaXJzLFxuXHRcdHZtXG5cdCkge1xuXHRcdHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdGlmICghZGlycykge1xuXHRcdFx0cmV0dXJuIHJlc1xuXHRcdH1cblx0XHR2YXIgaSwgZGlyO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkaXIgPSBkaXJzW2ldO1xuXHRcdFx0aWYgKCFkaXIubW9kaWZpZXJzKSB7XG5cdFx0XHRcdGRpci5tb2RpZmllcnMgPSBlbXB0eU1vZGlmaWVycztcblx0XHRcdH1cblx0XHRcdHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuXHRcdFx0ZGlyLmRlZiA9IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuXHRcdHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG5cdH1cblxuXHRmdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KSB7XG5cdFx0dmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgKFwiZGlyZWN0aXZlIFwiICsgKGRpci5uYW1lKSArIFwiIFwiICsgaG9vayArIFwiIGhvb2tcIikpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBiYXNlTW9kdWxlcyA9IFtcblx0XHRyZWYsXG5cdFx0ZGlyZWN0aXZlc1xuXHRdO1xuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIHVwZGF0ZUF0dHJzIChvbGRWbm9kZSwgdm5vZGUpIHtcblx0XHRpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dmFyIGtleSwgY3VyLCBvbGQ7XG5cdFx0dmFyIGVsbSA9IHZub2RlLmVsbTtcblx0XHR2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuXHRcdHZhciBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgfHwge307XG5cdFx0Ly8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG5cdFx0aWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcblx0XHRcdGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyA9IGV4dGVuZCh7fSwgYXR0cnMpO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIGF0dHJzKSB7XG5cdFx0XHRjdXIgPSBhdHRyc1trZXldO1xuXHRcdFx0b2xkID0gb2xkQXR0cnNba2V5XTtcblx0XHRcdGlmIChvbGQgIT09IGN1cikge1xuXHRcdFx0XHRzZXRBdHRyKGVsbSwga2V5LCBjdXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmIChpc0lFOSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcblx0XHRcdHNldEF0dHIoZWxtLCAndmFsdWUnLCBhdHRycy52YWx1ZSk7XG5cdFx0fVxuXHRcdGZvciAoa2V5IGluIG9sZEF0dHJzKSB7XG5cdFx0XHRpZiAoaXNVbmRlZihhdHRyc1trZXldKSkge1xuXHRcdFx0XHRpZiAoaXNYbGluayhrZXkpKSB7XG5cdFx0XHRcdFx0ZWxtLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcblx0XHRcdFx0fSBlbHNlIGlmICghaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG5cdFx0XHRcdFx0ZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0QXR0ciAoZWwsIGtleSwgdmFsdWUpIHtcblx0XHRpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG5cdFx0XHQvLyBzZXQgYXR0cmlidXRlIGZvciBibGFuayB2YWx1ZVxuXHRcdFx0Ly8gZS5nLiA8b3B0aW9uIGRpc2FibGVkPlNlbGVjdCBvbmU8L29wdGlvbj5cblx0XHRcdGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuXHRcdFx0XHRlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcblx0XHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG5cdFx0fSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcblx0XHRcdGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuXHRcdFx0XHRlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG5cdFx0XHRcdGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBhdHRycyA9IHtcblx0XHRjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuXHRcdHVwZGF0ZTogdXBkYXRlQXR0cnNcblx0fTtcblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiB1cGRhdGVDbGFzcyAob2xkVm5vZGUsIHZub2RlKSB7XG5cdFx0dmFyIGVsID0gdm5vZGUuZWxtO1xuXHRcdHZhciBkYXRhID0gdm5vZGUuZGF0YTtcblx0XHR2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cdFx0aWYgKFxuXHRcdFx0aXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuXHRcdFx0aXNVbmRlZihkYXRhLmNsYXNzKSAmJiAoXG5cdFx0XHRcdGlzVW5kZWYob2xkRGF0YSkgfHwgKFxuXHRcdFx0XHRcdGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcblx0XHRcdFx0XHRpc1VuZGVmKG9sZERhdGEuY2xhc3MpXG5cdFx0XHRcdClcblx0XHRcdClcblx0XHQpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuXHRcdC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcblx0XHR2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuXHRcdGlmIChpc0RlZih0cmFuc2l0aW9uQ2xhc3MpKSB7XG5cdFx0XHRjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcblx0XHR9XG5cblx0XHQvLyBzZXQgdGhlIGNsYXNzXG5cdFx0aWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuXHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG5cdFx0XHRlbC5fcHJldkNsYXNzID0gY2xzO1xuXHRcdH1cblx0fVxuXG5cdHZhciBrbGFzcyA9IHtcblx0XHRjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuXHRcdHVwZGF0ZTogdXBkYXRlQ2xhc3Ncblx0fTtcblxuXHQvKiAgKi9cblxuXHR2YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuXHRmdW5jdGlvbiBwYXJzZUZpbHRlcnMgKGV4cCkge1xuXHRcdHZhciBpblNpbmdsZSA9IGZhbHNlO1xuXHRcdHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuXHRcdHZhciBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7XG5cdFx0dmFyIGluUmVnZXggPSBmYWxzZTtcblx0XHR2YXIgY3VybHkgPSAwO1xuXHRcdHZhciBzcXVhcmUgPSAwO1xuXHRcdHZhciBwYXJlbiA9IDA7XG5cdFx0dmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG5cdFx0dmFyIGMsIHByZXYsIGksIGV4cHJlc3Npb24sIGZpbHRlcnM7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgZXhwLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRwcmV2ID0gYztcblx0XHRcdGMgPSBleHAuY2hhckNvZGVBdChpKTtcblx0XHRcdGlmIChpblNpbmdsZSkge1xuXHRcdFx0XHRpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cblx0XHRcdH0gZWxzZSBpZiAoaW5Eb3VibGUpIHtcblx0XHRcdFx0aWYgKGMgPT09IDB4MjIgJiYgcHJldiAhPT0gMHg1QykgeyBpbkRvdWJsZSA9IGZhbHNlOyB9XG5cdFx0XHR9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcblx0XHRcdFx0aWYgKGMgPT09IDB4NjAgJiYgcHJldiAhPT0gMHg1QykgeyBpblRlbXBsYXRlU3RyaW5nID0gZmFsc2U7IH1cblx0XHRcdH0gZWxzZSBpZiAoaW5SZWdleCkge1xuXHRcdFx0XHRpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0YyA9PT0gMHg3QyAmJiAvLyBwaXBlXG5cdFx0XHRcdGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuXHRcdFx0XHRleHAuY2hhckNvZGVBdChpIC0gMSkgIT09IDB4N0MgJiZcblx0XHRcdFx0IWN1cmx5ICYmICFzcXVhcmUgJiYgIXBhcmVuXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cblx0XHRcdFx0XHRsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcblx0XHRcdFx0XHRleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwdXNoRmlsdGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHN3aXRjaCAoYykge1xuXHRcdFx0XHRcdGNhc2UgMHgyMjogaW5Eb3VibGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vIFwiXG5cdFx0XHRcdFx0Y2FzZSAweDI3OiBpblNpbmdsZSA9IHRydWU7IGJyZWFrICAgICAgICAgLy8gJ1xuXHRcdFx0XHRcdGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcblx0XHRcdFx0XHRjYXNlIDB4Mjg6IHBhcmVuKys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyAoXG5cdFx0XHRcdFx0Y2FzZSAweDI5OiBwYXJlbi0tOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKVxuXHRcdFx0XHRcdGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcblx0XHRcdFx0XHRjYXNlIDB4NUQ6IHNxdWFyZS0tOyBicmVhayAgICAgICAgICAgICAgICAvLyBdXG5cdFx0XHRcdFx0Y2FzZSAweDdCOiBjdXJseSsrOyBicmVhayAgICAgICAgICAgICAgICAgLy8ge1xuXHRcdFx0XHRcdGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYyA9PT0gMHgyZikgeyAvLyAvXG5cdFx0XHRcdFx0dmFyIGogPSBpIC0gMTtcblx0XHRcdFx0XHR2YXIgcCA9ICh2b2lkIDApO1xuXHRcdFx0XHRcdC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG5cdFx0XHRcdFx0Zm9yICg7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHRwID0gZXhwLmNoYXJBdChqKTtcblx0XHRcdFx0XHRcdGlmIChwICE9PSAnICcpIHsgYnJlYWsgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIXAgfHwgIXZhbGlkRGl2aXNpb25DaGFyUkUudGVzdChwKSkge1xuXHRcdFx0XHRcdFx0aW5SZWdleCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcblx0XHRcdHB1c2hGaWx0ZXIoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcblx0XHRcdChmaWx0ZXJzIHx8IChmaWx0ZXJzID0gW10pKS5wdXNoKGV4cC5zbGljZShsYXN0RmlsdGVySW5kZXgsIGkpLnRyaW0oKSk7XG5cdFx0XHRsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcblx0XHR9XG5cblx0XHRpZiAoZmlsdGVycykge1xuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0ZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV4cHJlc3Npb25cblx0fVxuXG5cdGZ1bmN0aW9uIHdyYXBGaWx0ZXIgKGV4cCwgZmlsdGVyKSB7XG5cdFx0dmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuXHRcdGlmIChpIDwgMCkge1xuXHRcdFx0Ly8gX2Y6IHJlc29sdmVGaWx0ZXJcblx0XHRcdHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBuYW1lID0gZmlsdGVyLnNsaWNlKDAsIGkpO1xuXHRcdFx0dmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuXHRcdFx0cmV0dXJuIChcIl9mKFxcXCJcIiArIG5hbWUgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIsXCIgKyBhcmdzKVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGJhc2VXYXJuIChtc2cpIHtcblx0XHRjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG5cdFx0bW9kdWxlcyxcblx0XHRrZXlcblx0KSB7XG5cdFx0cmV0dXJuIG1vZHVsZXNcblx0XHRcdD8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuXHRcdFx0OiBbXVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlKSB7XG5cdFx0KGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSkge1xuXHRcdChlbC5hdHRycyB8fCAoZWwuYXR0cnMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGREaXJlY3RpdmUgKFxuXHRcdGVsLFxuXHRcdG5hbWUsXG5cdFx0cmF3TmFtZSxcblx0XHR2YWx1ZSxcblx0XHRhcmcsXG5cdFx0bW9kaWZpZXJzXG5cdCkge1xuXHRcdChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRIYW5kbGVyIChcblx0XHRlbCxcblx0XHRuYW1lLFxuXHRcdHZhbHVlLFxuXHRcdG1vZGlmaWVycyxcblx0XHRpbXBvcnRhbnQsXG5cdFx0d2FyblxuXHQpIHtcblx0XHQvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoXG5cdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuICYmXG5cdFx0XHRtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByZXZlbnQgJiYgbW9kaWZpZXJzLnBhc3NpdmVcblx0XHQpIHtcblx0XHRcdHdhcm4oXG5cdFx0XHRcdCdwYXNzaXZlIGFuZCBwcmV2ZW50IGNhblxcJ3QgYmUgdXNlZCB0b2dldGhlci4gJyArXG5cdFx0XHRcdCdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0Ly8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuXHRcdGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLmNhcHR1cmUpIHtcblx0XHRcdGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcblx0XHRcdG5hbWUgPSAnIScgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBjYXB0dXJlZFxuXHRcdH1cblx0XHRpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5vbmNlKSB7XG5cdFx0XHRkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG5cdFx0XHRuYW1lID0gJ34nICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgb25jZVxuXHRcdH1cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wYXNzaXZlKSB7XG5cdFx0XHRkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG5cdFx0XHRuYW1lID0gJyYnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgcGFzc2l2ZVxuXHRcdH1cblx0XHR2YXIgZXZlbnRzO1xuXHRcdGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm5hdGl2ZSkge1xuXHRcdFx0ZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG5cdFx0XHRldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG5cdFx0fVxuXHRcdHZhciBuZXdIYW5kbGVyID0geyB2YWx1ZTogdmFsdWUsIG1vZGlmaWVyczogbW9kaWZpZXJzIH07XG5cdFx0dmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuXHRcdFx0aW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG5cdFx0fSBlbHNlIGlmIChoYW5kbGVycykge1xuXHRcdFx0ZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0QmluZGluZ0F0dHIgKFxuXHRcdGVsLFxuXHRcdG5hbWUsXG5cdFx0Z2V0U3RhdGljXG5cdCkge1xuXHRcdHZhciBkeW5hbWljVmFsdWUgPVxuXHRcdFx0Z2V0QW5kUmVtb3ZlQXR0cihlbCwgJzonICsgbmFtZSkgfHxcblx0XHRcdGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWJpbmQ6JyArIG5hbWUpO1xuXHRcdGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpXG5cdFx0fSBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG5cdFx0XHR2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcblx0XHRcdGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShzdGF0aWNWYWx1ZSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChlbCwgbmFtZSkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuXHRcdFx0dmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcblx0XHRcdFx0XHRsaXN0LnNwbGljZShpLCAxKTtcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB2YWxcblx0fVxuXG5cdC8qICAqL1xuXG5cdC8qKlxuXHQgKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG5cdCAqL1xuXHRmdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbCAoXG5cdFx0ZWwsXG5cdFx0dmFsdWUsXG5cdFx0bW9kaWZpZXJzXG5cdCkge1xuXHRcdHZhciByZWYgPSBtb2RpZmllcnMgfHwge307XG5cdFx0dmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG5cdFx0dmFyIHRyaW0gPSByZWYudHJpbTtcblxuXHRcdHZhciBiYXNlVmFsdWVFeHByZXNzaW9uID0gJyQkdic7XG5cdFx0dmFyIHZhbHVlRXhwcmVzc2lvbiA9IGJhc2VWYWx1ZUV4cHJlc3Npb247XG5cdFx0aWYgKHRyaW0pIHtcblx0XHRcdHZhbHVlRXhwcmVzc2lvbiA9XG5cdFx0XHRcdFwiKHR5cGVvZiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIiA9PT0gJ3N0cmluZydcIiArXG5cdFx0XHRcdFwiPyBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIi50cmltKClcIiArXG5cdFx0XHRcdFwiOiBcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcblx0XHR9XG5cdFx0aWYgKG51bWJlcikge1xuXHRcdFx0dmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuXHRcdH1cblx0XHR2YXIgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuXG5cdFx0ZWwubW9kZWwgPSB7XG5cdFx0XHR2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG5cdFx0XHRleHByZXNzaW9uOiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSxcblx0XHRcdGNhbGxiYWNrOiAoXCJmdW5jdGlvbiAoXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpIHtcIiArIGFzc2lnbm1lbnQgKyBcIn1cIilcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUgKFxuXHRcdHZhbHVlLFxuXHRcdGFzc2lnbm1lbnRcblx0KSB7XG5cdFx0dmFyIG1vZGVsUnMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcblx0XHRpZiAobW9kZWxScy5pZHggPT09IG51bGwpIHtcblx0XHRcdHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBcInZhciAkJGV4cCA9IFwiICsgKG1vZGVsUnMuZXhwKSArIFwiLCAkJGlkeCA9IFwiICsgKG1vZGVsUnMuaWR4KSArIFwiO1wiICtcblx0XHRcdFx0XCJpZiAoIUFycmF5LmlzQXJyYXkoJCRleHApKXtcIiArXG5cdFx0XHRcdHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIgK1xuXHRcdFx0XHRcImVsc2V7JCRleHAuc3BsaWNlKCQkaWR4LCAxLCBcIiArIGFzc2lnbm1lbnQgKyBcIil9XCJcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogcGFyc2UgZGlyZWN0aXZlIG1vZGVsIHRvIGRvIHRoZSBhcnJheSB1cGRhdGUgdHJhbnNmb3JtLiBhW2lkeF0gPSB2YWwgPT4gJCRhLnNwbGljZSgkJGlkeCwgMSwgdmFsKVxuXHQgKlxuXHQgKiBmb3IgbG9vcCBwb3NzaWJsZSBjYXNlczpcblx0ICpcblx0ICogLSB0ZXN0XG5cdCAqIC0gdGVzdFtpZHhdXG5cdCAqIC0gdGVzdFt0ZXN0MVtpZHhdXVxuXHQgKiAtIHRlc3RbXCJhXCJdW2lkeF1cblx0ICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2lkeF1dXG5cdCAqIC0gdGVzdC54eHguYVtcImFzYVwiXVt0ZXN0MVtpZHhdXVxuXHQgKlxuXHQgKi9cblxuXHR2YXIgbGVuO1xuXHR2YXIgc3RyO1xuXHR2YXIgY2hyO1xuXHR2YXIgaW5kZXgkMTtcblx0dmFyIGV4cHJlc3Npb25Qb3M7XG5cdHZhciBleHByZXNzaW9uRW5kUG9zO1xuXG5cdGZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuXHRcdHN0ciA9IHZhbDtcblx0XHRsZW4gPSBzdHIubGVuZ3RoO1xuXHRcdGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cblx0XHRpZiAodmFsLmluZGV4T2YoJ1snKSA8IDAgfHwgdmFsLmxhc3RJbmRleE9mKCddJykgPCBsZW4gLSAxKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHA6IHZhbCxcblx0XHRcdFx0aWR4OiBudWxsXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0d2hpbGUgKCFlb2YoKSkge1xuXHRcdFx0Y2hyID0gbmV4dCgpO1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG5cdFx0XHRcdHBhcnNlU3RyaW5nKGNocik7XG5cdFx0XHR9IGVsc2UgaWYgKGNociA9PT0gMHg1Qikge1xuXHRcdFx0XHRwYXJzZUJyYWNrZXQoY2hyKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXhwOiB2YWwuc3Vic3RyaW5nKDAsIGV4cHJlc3Npb25Qb3MpLFxuXHRcdFx0aWR4OiB2YWwuc3Vic3RyaW5nKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG5leHQgKCkge1xuXHRcdHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG5cdH1cblxuXHRmdW5jdGlvbiBlb2YgKCkge1xuXHRcdHJldHVybiBpbmRleCQxID49IGxlblxuXHR9XG5cblx0ZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG5cdFx0cmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4Mjdcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG5cdFx0dmFyIGluQnJhY2tldCA9IDE7XG5cdFx0ZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG5cdFx0d2hpbGUgKCFlb2YoKSkge1xuXHRcdFx0Y2hyID0gbmV4dCgpO1xuXHRcdFx0aWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuXHRcdFx0XHRwYXJzZVN0cmluZyhjaHIpO1xuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuXHRcdFx0aWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuXHRcdFx0aWYgKGluQnJhY2tldCA9PT0gMCkge1xuXHRcdFx0XHRleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG5cdFx0dmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuXHRcdHdoaWxlICghZW9mKCkpIHtcblx0XHRcdGNociA9IG5leHQoKTtcblx0XHRcdGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0dmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cblx0dmFyIFJBTkdFX1RPS0VOID0gJ19fcic7XG5cdHZhciBDSEVDS0JPWF9SQURJT19UT0tFTiA9ICdfX2MnO1xuXG5cdGZ1bmN0aW9uIG1vZGVsIChcblx0XHRlbCxcblx0XHRkaXIsXG5cdFx0X3dhcm5cblx0KSB7XG5cdFx0d2FybiQxID0gX3dhcm47XG5cdFx0dmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuXHRcdHZhciBtb2RpZmllcnMgPSBkaXIubW9kaWZpZXJzO1xuXHRcdHZhciB0YWcgPSBlbC50YWc7XG5cdFx0dmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG5cdFx0e1xuXHRcdFx0dmFyIGR5bmFtaWNUeXBlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG5cdFx0XHRpZiAodGFnID09PSAnaW5wdXQnICYmIGR5bmFtaWNUeXBlKSB7XG5cdFx0XHRcdHdhcm4kMShcblx0XHRcdFx0XHRcIjxpbnB1dCA6dHlwZT1cXFwiXCIgKyBkeW5hbWljVHlwZSArIFwiXFxcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjpcXG5cIiArXG5cdFx0XHRcdFx0XCJ2LW1vZGVsIGRvZXMgbm90IHN1cHBvcnQgZHluYW1pYyBpbnB1dCB0eXBlcy4gVXNlIHYtaWYgYnJhbmNoZXMgaW5zdGVhZC5cIlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG5cdFx0XHQvLyB2YWx1ZSB3aWxsIHRocm93IGFuIGVycm9yLlxuXHRcdFx0aWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcblx0XHRcdFx0d2FybiQxKFxuXHRcdFx0XHRcdFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiIHR5cGU9XFxcImZpbGVcXFwiPjpcXG5cIiArXG5cdFx0XHRcdFx0XCJGaWxlIGlucHV0cyBhcmUgcmVhZCBvbmx5LiBVc2UgYSB2LW9uOmNoYW5nZSBsaXN0ZW5lciBpbnN0ZWFkLlwiXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcblx0XHRcdGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG5cdFx0fSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xuXHRcdFx0Z2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG5cdFx0fSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuXHRcdFx0Z2VuUmFkaW9Nb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG5cdFx0fSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG5cdFx0XHRnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuXHRcdH0gZWxzZSBpZiAoIWNvbmZpZy5pc1Jlc2VydmVkVGFnKHRhZykpIHtcblx0XHRcdGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcblx0XHRcdC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2FybiQxKFxuXHRcdFx0XHRcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcblx0XHRcdFx0XCJ2LW1vZGVsIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBlbGVtZW50IHR5cGUuIFwiICtcblx0XHRcdFx0J0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuXHRcdFx0XHQnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuXHRcdHJldHVybiB0cnVlXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcblx0XHRlbCxcblx0XHR2YWx1ZSxcblx0XHRtb2RpZmllcnNcblx0KSB7XG5cdFx0dmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuXHRcdHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuXHRcdHZhciB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuXHRcdHZhciBmYWxzZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnZmFsc2UtdmFsdWUnKSB8fCAnZmFsc2UnO1xuXHRcdGFkZFByb3AoZWwsICdjaGVja2VkJyxcblx0XHRcdFwiQXJyYXkuaXNBcnJheShcIiArIHZhbHVlICsgXCIpXCIgK1xuXHRcdFx0XCI/X2koXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpPi0xXCIgKyAoXG5cdFx0XHRcdHRydWVWYWx1ZUJpbmRpbmcgPT09ICd0cnVlJ1xuXHRcdFx0XHRcdD8gKFwiOihcIiArIHZhbHVlICsgXCIpXCIpXG5cdFx0XHRcdFx0OiAoXCI6X3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKVwiKVxuXHRcdFx0KVxuXHRcdCk7XG5cdFx0YWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sXG5cdFx0XHRcInZhciAkJGE9XCIgKyB2YWx1ZSArIFwiLFwiICtcblx0XHRcdCckJGVsPSRldmVudC50YXJnZXQsJyArXG5cdFx0XHRcIiQkYz0kJGVsLmNoZWNrZWQ/KFwiICsgdHJ1ZVZhbHVlQmluZGluZyArIFwiKTooXCIgKyBmYWxzZVZhbHVlQmluZGluZyArIFwiKTtcIiArXG5cdFx0XHQnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcblx0XHRcdFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG5cdFx0XHQnJCRpPV9pKCQkYSwkJHYpOycgK1xuXHRcdFx0XCJpZigkJGMpeyQkaTwwJiYoXCIgKyB2YWx1ZSArIFwiPSQkYS5jb25jYXQoJCR2KSl9XCIgK1xuXHRcdFx0XCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xuXHRcdFx0XCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuXHRcdFx0bnVsbCwgdHJ1ZVxuXHRcdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcblx0XHRlbCxcblx0XHR2YWx1ZSxcblx0XHRtb2RpZmllcnNcblx0KSB7XG5cdFx0dmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuXHRcdHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuXHRcdHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuXHRcdGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcblx0XHRhZGRIYW5kbGVyKGVsLCBDSEVDS0JPWF9SQURJT19UT0tFTiwgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuU2VsZWN0IChcblx0XHRlbCxcblx0XHR2YWx1ZSxcblx0XHRtb2RpZmllcnNcblx0KSB7XG5cdFx0dmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuXHRcdHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcblx0XHRcdFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG5cdFx0XHRcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuXHRcdFx0XCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG5cdFx0dmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcblx0XHR2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG5cdFx0Y29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuXHRcdGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG5cdFx0ZWwsXG5cdFx0dmFsdWUsXG5cdFx0bW9kaWZpZXJzXG5cdCkge1xuXHRcdHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblx0XHR2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuXHRcdHZhciBsYXp5ID0gcmVmLmxhenk7XG5cdFx0dmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG5cdFx0dmFyIHRyaW0gPSByZWYudHJpbTtcblx0XHR2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuXHRcdHZhciBldmVudCA9IGxhenlcblx0XHRcdD8gJ2NoYW5nZSdcblx0XHRcdDogdHlwZSA9PT0gJ3JhbmdlJ1xuXHRcdFx0PyBSQU5HRV9UT0tFTlxuXHRcdFx0OiAnaW5wdXQnO1xuXG5cdFx0dmFyIHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcblx0XHRpZiAodHJpbSkge1xuXHRcdFx0dmFsdWVFeHByZXNzaW9uID0gXCIkZXZlbnQudGFyZ2V0LnZhbHVlLnRyaW0oKVwiO1xuXHRcdH1cblx0XHRpZiAobnVtYmVyKSB7XG5cdFx0XHR2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblx0XHRpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcblx0XHRcdGNvZGUgPSBcImlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjtcIiArIGNvZGU7XG5cdFx0fVxuXG5cdFx0YWRkUHJvcChlbCwgJ3ZhbHVlJywgKFwiKFwiICsgdmFsdWUgKyBcIilcIikpO1xuXHRcdGFkZEhhbmRsZXIoZWwsIGV2ZW50LCBjb2RlLCBudWxsLCB0cnVlKTtcblx0XHRpZiAodHJpbSB8fCBudW1iZXIgfHwgdHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdGFkZEhhbmRsZXIoZWwsICdibHVyJywgJyRmb3JjZVVwZGF0ZSgpJyk7XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cbi8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbi8vIGl0J3MgaW1wb3J0YW50IHRvIHBsYWNlIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5IGJlY2F1c2Vcbi8vIHRoZSB3aG9sZSBwb2ludCBpcyBlbnN1cmluZyB0aGUgdi1tb2RlbCBjYWxsYmFjayBnZXRzIGNhbGxlZCBiZWZvcmVcbi8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcblx0XHR2YXIgZXZlbnQ7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcblx0XHRcdC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcblx0XHRcdGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0Jztcblx0XHRcdG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG5cdFx0XHRkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuXHRcdH1cblx0XHRpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuXHRcdFx0Ly8gQ2hyb21lIGZpcmVzIG1pY3JvdGFza3MgaW4gYmV0d2VlbiBjbGljay9jaGFuZ2UsIGxlYWRzIHRvICM0NTIxXG5cdFx0XHRldmVudCA9IGlzQ2hyb21lID8gJ2NsaWNrJyA6ICdjaGFuZ2UnO1xuXHRcdFx0b25bZXZlbnRdID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb25bZXZlbnRdIHx8IFtdKTtcblx0XHRcdGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG5cdFx0fVxuXHR9XG5cblx0dmFyIHRhcmdldCQxO1xuXG5cdGZ1bmN0aW9uIGFkZCQxIChcblx0XHRldmVudCxcblx0XHRoYW5kbGVyLFxuXHRcdG9uY2UkJDEsXG5cdFx0Y2FwdHVyZSxcblx0XHRwYXNzaXZlXG5cdCkge1xuXHRcdGlmIChvbmNlJCQxKSB7XG5cdFx0XHR2YXIgb2xkSGFuZGxlciA9IGhhbmRsZXI7XG5cdFx0XHR2YXIgX3RhcmdldCA9IHRhcmdldCQxOyAvLyBzYXZlIGN1cnJlbnQgdGFyZ2V0IGVsZW1lbnQgaW4gY2xvc3VyZVxuXHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuXHRcdFx0XHR2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuXHRcdFx0XHRcdD8gb2xkSGFuZGxlcihldilcblx0XHRcdFx0XHQ6IG9sZEhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0XHRcdFx0aWYgKHJlcyAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJlbW92ZSQyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0dGFyZ2V0JDEuYWRkRXZlbnRMaXN0ZW5lcihcblx0XHRcdGV2ZW50LFxuXHRcdFx0aGFuZGxlcixcblx0XHRcdHN1cHBvcnRzUGFzc2l2ZVxuXHRcdFx0XHQ/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG5cdFx0XHRcdDogY2FwdHVyZVxuXHRcdCk7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmUkMiAoXG5cdFx0ZXZlbnQsXG5cdFx0aGFuZGxlcixcblx0XHRjYXB0dXJlLFxuXHRcdF90YXJnZXRcblx0KSB7XG5cdFx0KF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGNhcHR1cmUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRE9NTGlzdGVuZXJzIChvbGRWbm9kZSwgdm5vZGUpIHtcblx0XHRpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcblx0XHR2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuXHRcdHRhcmdldCQxID0gdm5vZGUuZWxtO1xuXHRcdG5vcm1hbGl6ZUV2ZW50cyhvbik7XG5cdFx0dXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkJDEsIHJlbW92ZSQyLCB2bm9kZS5jb250ZXh0KTtcblx0fVxuXG5cdHZhciBldmVudHMgPSB7XG5cdFx0Y3JlYXRlOiB1cGRhdGVET01MaXN0ZW5lcnMsXG5cdFx0dXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcblx0fTtcblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG5cdFx0aWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5kb21Qcm9wcykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmRvbVByb3BzKSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHZhciBrZXksIGN1cjtcblx0XHR2YXIgZWxtID0gdm5vZGUuZWxtO1xuXHRcdHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG5cdFx0dmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcblx0XHQvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcblx0XHRpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuXHRcdFx0cHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG5cdFx0fVxuXG5cdFx0Zm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcblx0XHRcdGlmIChpc1VuZGVmKHByb3BzW2tleV0pKSB7XG5cdFx0XHRcdGVsbVtrZXldID0gJyc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAoa2V5IGluIHByb3BzKSB7XG5cdFx0XHRjdXIgPSBwcm9wc1trZXldO1xuXHRcdFx0Ly8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG5cdFx0XHQvLyBhcyB0aGVzZSB3aWxsIHRocm93IGF3YXkgZXhpc3RpbmcgRE9NIG5vZGVzIGFuZCBjYXVzZSByZW1vdmFsIGVycm9yc1xuXHRcdFx0Ly8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcblx0XHRcdGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuXHRcdFx0XHRpZiAodm5vZGUuY2hpbGRyZW4pIHsgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDsgfVxuXHRcdFx0XHRpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuXHRcdFx0XHQvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuXHRcdFx0XHQvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG5cdFx0XHRcdGVsbS5fdmFsdWUgPSBjdXI7XG5cdFx0XHRcdC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuXHRcdFx0XHR2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcblx0XHRcdFx0aWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgdm5vZGUsIHN0ckN1cikpIHtcblx0XHRcdFx0XHRlbG0udmFsdWUgPSBzdHJDdXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsbVtrZXldID0gY3VyO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5cdGZ1bmN0aW9uIHNob3VsZFVwZGF0ZVZhbHVlIChcblx0XHRlbG0sXG5cdFx0dm5vZGUsXG5cdFx0Y2hlY2tWYWxcblx0KSB7XG5cdFx0cmV0dXJuICghZWxtLmNvbXBvc2luZyAmJiAoXG5cdFx0XHR2bm9kZS50YWcgPT09ICdvcHRpb24nIHx8XG5cdFx0XHRpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG5cdFx0XHRpc0lucHV0Q2hhbmdlZChlbG0sIGNoZWNrVmFsKVxuXHRcdCkpXG5cdH1cblxuXHRmdW5jdGlvbiBpc0RpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG5cdFx0Ly8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpcyBub3QgZXF1YWwgdG8gdGhlIHVwZGF0ZWQgdmFsdWVcblx0XHRyZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtICYmIGVsbS52YWx1ZSAhPT0gY2hlY2tWYWxcblx0fVxuXG5cdGZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuXHRcdHZhciB2YWx1ZSA9IGVsbS52YWx1ZTtcblx0XHR2YXIgbW9kaWZpZXJzID0gZWxtLl92TW9kaWZpZXJzOyAvLyBpbmplY3RlZCBieSB2LW1vZGVsIHJ1bnRpbWVcblx0XHRpZiAoKGlzRGVmKG1vZGlmaWVycykgJiYgbW9kaWZpZXJzLm51bWJlcikgfHwgZWxtLnR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRyZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG5cdFx0fVxuXHRcdGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUudHJpbSgpICE9PSBuZXdWYWwudHJpbSgpXG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG5cdH1cblxuXHR2YXIgZG9tUHJvcHMgPSB7XG5cdFx0Y3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcblx0XHR1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG5cdH07XG5cblx0LyogICovXG5cblx0dmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG5cdFx0dmFyIHJlcyA9IHt9O1xuXHRcdHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcblx0XHR2YXIgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuXHRcdGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0aWYgKGl0ZW0pIHtcblx0XHRcdFx0dmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuXHRcdFx0XHR0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHJlc1xuXHR9KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcblx0ZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG5cdFx0dmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuXHRcdC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuXHRcdC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG5cdFx0cmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcblx0XHRcdD8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuXHRcdFx0OiBzdHlsZVxuXHR9XG5cbi8vIG5vcm1hbGl6ZSBwb3NzaWJsZSBhcnJheSAvIHN0cmluZyB2YWx1ZXMgaW50byBPYmplY3Rcblx0ZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG5cdFx0XHRyZXR1cm4gdG9PYmplY3QoYmluZGluZ1N0eWxlKVxuXHRcdH1cblx0XHRpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBwYXJzZVN0eWxlVGV4dChiaW5kaW5nU3R5bGUpXG5cdFx0fVxuXHRcdHJldHVybiBiaW5kaW5nU3R5bGVcblx0fVxuXG5cdC8qKlxuXHQgKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG5cdCAqIHNvIHRoYXQgcGFyZW50IGNvbXBvbmVudCdzIHN0eWxlIGNvdWxkIG92ZXJyaWRlIGl0XG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcblx0XHR2YXIgcmVzID0ge307XG5cdFx0dmFyIHN0eWxlRGF0YTtcblxuXHRcdGlmIChjaGVja0NoaWxkKSB7XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gdm5vZGU7XG5cdFx0XHR3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG5cdFx0XHRcdGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG5cdFx0XHRcdGlmIChjaGlsZE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKGNoaWxkTm9kZS5kYXRhKSkpIHtcblx0XHRcdFx0XHRleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG5cdFx0XHRleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuXHRcdH1cblxuXHRcdHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG5cdFx0d2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG5cdFx0XHRpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcblx0XHRcdFx0ZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cblx0LyogICovXG5cblx0dmFyIGNzc1ZhclJFID0gL14tLS87XG5cdHZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuXHR2YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcblx0XHRcdGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG5cdFx0fSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcblx0XHRcdGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbC5yZXBsYWNlKGltcG9ydGFudFJFLCAnJyksICdpbXBvcnRhbnQnKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5vcm1hbGl6ZWROYW1lID0gbm9ybWFsaXplKG5hbWUpO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0XHQvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuXHRcdFx0XHQvLyB7ZGlzcGxheTogW1wiLXdlYmtpdC1ib3hcIiwgXCItbXMtZmxleGJveFwiLCBcImZsZXhcIl19XG5cdFx0XHRcdC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRcdGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbFtpXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR2YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcblxuXHR2YXIgdGVzdEVsO1xuXHR2YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG5cdFx0dGVzdEVsID0gdGVzdEVsIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcblx0XHRpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gdGVzdEVsLnN0eWxlKSkge1xuXHRcdFx0cmV0dXJuIHByb3Bcblx0XHR9XG5cdFx0dmFyIHVwcGVyID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHByZWZpeGVkID0gcHJlZml4ZXNbaV0gKyB1cHBlcjtcblx0XHRcdGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcblx0XHRcdFx0cmV0dXJuIHByZWZpeGVkXG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRmdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG5cdFx0dmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuXHRcdHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcblxuXHRcdGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcblx0XHRcdGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihvbGREYXRhLnN0eWxlKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dmFyIGN1ciwgbmFtZTtcblx0XHR2YXIgZWwgPSB2bm9kZS5lbG07XG5cdFx0dmFyIG9sZFN0YXRpY1N0eWxlID0gb2xkRGF0YS5zdGF0aWNTdHlsZTtcblx0XHR2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkRGF0YS5ub3JtYWxpemVkU3R5bGUgfHwgb2xkRGF0YS5zdHlsZSB8fCB7fTtcblxuXHRcdC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG5cdFx0dmFyIG9sZFN0eWxlID0gb2xkU3RhdGljU3R5bGUgfHwgb2xkU3R5bGVCaW5kaW5nO1xuXG5cdFx0dmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG5cdFx0Ly8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuXHRcdC8vIG1ha2Ugc3VyZSB0byBjbG9uZSBpdCBpZiBpdCdzIHJlYWN0aXZlLCBzaW5jZSB0aGUgdXNlciBsaWtsZXkgd2FudHNcblx0XHQvLyB0byBtdXRhdGUgaXQuXG5cdFx0dm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG5cdFx0XHQ/IGV4dGVuZCh7fSwgc3R5bGUpXG5cdFx0XHQ6IHN0eWxlO1xuXG5cdFx0dmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG5cdFx0Zm9yIChuYW1lIGluIG9sZFN0eWxlKSB7XG5cdFx0XHRpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcblx0XHRcdFx0c2V0UHJvcChlbCwgbmFtZSwgJycpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcblx0XHRcdGN1ciA9IG5ld1N0eWxlW25hbWVdO1xuXHRcdFx0aWYgKGN1ciAhPT0gb2xkU3R5bGVbbmFtZV0pIHtcblx0XHRcdFx0Ly8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcblx0XHRcdFx0c2V0UHJvcChlbCwgbmFtZSwgY3VyID09IG51bGwgPyAnJyA6IGN1cik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIHN0eWxlID0ge1xuXHRcdGNyZWF0ZTogdXBkYXRlU3R5bGUsXG5cdFx0dXBkYXRlOiB1cGRhdGVTdHlsZVxuXHR9O1xuXG5cdC8qICAqL1xuXG5cdC8qKlxuXHQgKiBBZGQgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cblx0ICogU1ZHIGVsZW1lbnRzIGluIElFXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRDbGFzcyAoZWwsIGNscykge1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmICghY2xzIHx8ICEoY2xzID0gY2xzLnRyaW0oKSkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdFx0aWYgKGVsLmNsYXNzTGlzdCkge1xuXHRcdFx0aWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuXHRcdFx0XHRjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QuYWRkKGMpOyB9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcblx0XHRcdGlmIChjdXIuaW5kZXhPZignICcgKyBjbHMgKyAnICcpIDwgMCkge1xuXHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG5cdCAqIFNWRyBlbGVtZW50cyBpbiBJRVxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlQ2xhc3MgKGVsLCBjbHMpIHtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRcdGlmIChlbC5jbGFzc0xpc3QpIHtcblx0XHRcdGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcblx0XHRcdFx0Y2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKGNscyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG5cdFx0XHR2YXIgdGFyID0gJyAnICsgY2xzICsgJyAnO1xuXHRcdFx0d2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuXHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG5cdFx0XHR9XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyLnRyaW0oKSk7XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gcmVzb2x2ZVRyYW5zaXRpb24gKGRlZiQkMSkge1xuXHRcdGlmICghZGVmJCQxKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHZhciByZXMgPSB7fTtcblx0XHRcdGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuXHRcdFx0XHRleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEubmFtZSB8fCAndicpKTtcblx0XHRcdH1cblx0XHRcdGV4dGVuZChyZXMsIGRlZiQkMSk7XG5cdFx0XHRyZXR1cm4gcmVzXG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZGVmJCQxID09PSAnc3RyaW5nJykge1xuXHRcdFx0cmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcblx0XHR9XG5cdH1cblxuXHR2YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZW50ZXJDbGFzczogKG5hbWUgKyBcIi1lbnRlclwiKSxcblx0XHRcdGVudGVyVG9DbGFzczogKG5hbWUgKyBcIi1lbnRlci10b1wiKSxcblx0XHRcdGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuXHRcdFx0bGVhdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZVwiKSxcblx0XHRcdGxlYXZlVG9DbGFzczogKG5hbWUgKyBcIi1sZWF2ZS10b1wiKSxcblx0XHRcdGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG5cdFx0fVxuXHR9KTtcblxuXHR2YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG5cdHZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuXHR2YXIgQU5JTUFUSU9OID0gJ2FuaW1hdGlvbic7XG5cbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcblx0dmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xuXHR2YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xuXHR2YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xuXHR2YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcblx0aWYgKGhhc1RyYW5zaXRpb24pIHtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHR3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcblx0XHQpIHtcblx0XHRcdHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuXHRcdFx0dHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuXHRcdH1cblx0XHRpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcblx0XHRcdHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG5cdFx0KSB7XG5cdFx0XHRhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG5cdFx0XHRhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuXHRcdH1cblx0fVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcblx0dmFyIHJhZiA9IGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0PyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuXHRcdDogc2V0VGltZW91dDtcblxuXHRmdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG5cdFx0cmFmKGZ1bmN0aW9uICgpIHtcblx0XHRcdHJhZihmbik7XG5cdFx0fSk7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcblx0XHQoZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSkpLnB1c2goY2xzKTtcblx0XHRhZGRDbGFzcyhlbCwgY2xzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuXHRcdGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcblx0XHRcdHJlbW92ZShlbC5fdHJhbnNpdGlvbkNsYXNzZXMsIGNscyk7XG5cdFx0fVxuXHRcdHJlbW92ZUNsYXNzKGVsLCBjbHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcblx0XHRlbCxcblx0XHRleHBlY3RlZFR5cGUsXG5cdFx0Y2Jcblx0KSB7XG5cdFx0dmFyIHJlZiA9IGdldFRyYW5zaXRpb25JbmZvKGVsLCBleHBlY3RlZFR5cGUpO1xuXHRcdHZhciB0eXBlID0gcmVmLnR5cGU7XG5cdFx0dmFyIHRpbWVvdXQgPSByZWYudGltZW91dDtcblx0XHR2YXIgcHJvcENvdW50ID0gcmVmLnByb3BDb3VudDtcblx0XHRpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuXHRcdHZhciBldmVudCA9IHR5cGUgPT09IFRSQU5TSVRJT04gPyB0cmFuc2l0aW9uRW5kRXZlbnQgOiBhbmltYXRpb25FbmRFdmVudDtcblx0XHR2YXIgZW5kZWQgPSAwO1xuXHRcdHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG5cdFx0XHRjYigpO1xuXHRcdH07XG5cdFx0dmFyIG9uRW5kID0gZnVuY3Rpb24gKGUpIHtcblx0XHRcdGlmIChlLnRhcmdldCA9PT0gZWwpIHtcblx0XHRcdFx0aWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG5cdFx0XHRcdFx0ZW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG5cdFx0XHRcdGVuZCgpO1xuXHRcdFx0fVxuXHRcdH0sIHRpbWVvdXQgKyAxKTtcblx0XHRlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG5cdH1cblxuXHR2YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5cdGZ1bmN0aW9uIGdldFRyYW5zaXRpb25JbmZvIChlbCwgZXhwZWN0ZWRUeXBlKSB7XG5cdFx0dmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcblx0XHR2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuXHRcdHZhciB0cmFuc2l0aW9uRHVyYXRpb25zID0gc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG5cdFx0dmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uRGVsYXlzLCB0cmFuc2l0aW9uRHVyYXRpb25zKTtcblx0XHR2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcblx0XHR2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcblx0XHR2YXIgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuXG5cdFx0dmFyIHR5cGU7XG5cdFx0dmFyIHRpbWVvdXQgPSAwO1xuXHRcdHZhciBwcm9wQ291bnQgPSAwO1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcblx0XHRcdGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcblx0XHRcdFx0dHlwZSA9IFRSQU5TSVRJT047XG5cdFx0XHRcdHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcblx0XHRcdFx0cHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuXHRcdFx0aWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG5cdFx0XHRcdHR5cGUgPSBBTklNQVRJT047XG5cdFx0XHRcdHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuXHRcdFx0XHRwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuXHRcdFx0dHlwZSA9IHRpbWVvdXQgPiAwXG5cdFx0XHRcdD8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG5cdFx0XHRcdD8gVFJBTlNJVElPTlxuXHRcdFx0XHQ6IEFOSU1BVElPTlxuXHRcdFx0XHQ6IG51bGw7XG5cdFx0XHRwcm9wQ291bnQgPSB0eXBlXG5cdFx0XHRcdD8gdHlwZSA9PT0gVFJBTlNJVElPTlxuXHRcdFx0XHQ/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG5cdFx0XHRcdDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuXHRcdFx0XHQ6IDA7XG5cdFx0fVxuXHRcdHZhciBoYXNUcmFuc2Zvcm0gPVxuXHRcdFx0dHlwZSA9PT0gVFJBTlNJVElPTiAmJlxuXHRcdFx0dHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHR0aW1lb3V0OiB0aW1lb3V0LFxuXHRcdFx0cHJvcENvdW50OiBwcm9wQ291bnQsXG5cdFx0XHRoYXNUcmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFRpbWVvdXQgKGRlbGF5cywgZHVyYXRpb25zKSB7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHR3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcblx0XHRcdGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuXHRcdFx0cmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSlcblx0XHR9KSlcblx0fVxuXG5cdGZ1bmN0aW9uIHRvTXMgKHMpIHtcblx0XHRyZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuXHRcdHZhciBlbCA9IHZub2RlLmVsbTtcblxuXHRcdC8vIGNhbGwgbGVhdmUgY2FsbGJhY2sgbm93XG5cdFx0aWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuXHRcdFx0ZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcblx0XHRcdGVsLl9sZWF2ZUNiKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuXHRcdGlmIChpc1VuZGVmKGRhdGEpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHR2YXIgY3NzID0gZGF0YS5jc3M7XG5cdFx0dmFyIHR5cGUgPSBkYXRhLnR5cGU7XG5cdFx0dmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG5cdFx0dmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuXHRcdHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuXHRcdHZhciBhcHBlYXJDbGFzcyA9IGRhdGEuYXBwZWFyQ2xhc3M7XG5cdFx0dmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG5cdFx0dmFyIGFwcGVhckFjdGl2ZUNsYXNzID0gZGF0YS5hcHBlYXJBY3RpdmVDbGFzcztcblx0XHR2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuXHRcdHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG5cdFx0dmFyIGFmdGVyRW50ZXIgPSBkYXRhLmFmdGVyRW50ZXI7XG5cdFx0dmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcblx0XHR2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG5cdFx0dmFyIGFwcGVhciA9IGRhdGEuYXBwZWFyO1xuXHRcdHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG5cdFx0dmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuXHRcdHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cblx0XHQvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG5cdFx0Ly8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG5cdFx0Ly8gYXMgdGhlIHJvb3Qgbm9kZSBvZiBhIGNoaWxkIGNvbXBvbmVudC4gSW4gdGhhdCBjYXNlIHdlIG5lZWQgdG8gY2hlY2tcblx0XHQvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cblx0XHR2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuXHRcdHZhciB0cmFuc2l0aW9uTm9kZSA9IGFjdGl2ZUluc3RhbmNlLiR2bm9kZTtcblx0XHR3aGlsZSAodHJhbnNpdGlvbk5vZGUgJiYgdHJhbnNpdGlvbk5vZGUucGFyZW50KSB7XG5cdFx0XHR0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcblx0XHRcdGNvbnRleHQgPSB0cmFuc2l0aW9uTm9kZS5jb250ZXh0O1xuXHRcdH1cblxuXHRcdHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuXHRcdGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHZhciBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3Ncblx0XHRcdD8gYXBwZWFyQ2xhc3Ncblx0XHRcdDogZW50ZXJDbGFzcztcblx0XHR2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzc1xuXHRcdFx0PyBhcHBlYXJBY3RpdmVDbGFzc1xuXHRcdFx0OiBlbnRlckFjdGl2ZUNsYXNzO1xuXHRcdHZhciB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzc1xuXHRcdFx0PyBhcHBlYXJUb0NsYXNzXG5cdFx0XHQ6IGVudGVyVG9DbGFzcztcblxuXHRcdHZhciBiZWZvcmVFbnRlckhvb2sgPSBpc0FwcGVhclxuXHRcdFx0PyAoYmVmb3JlQXBwZWFyIHx8IGJlZm9yZUVudGVyKVxuXHRcdFx0OiBiZWZvcmVFbnRlcjtcblx0XHR2YXIgZW50ZXJIb29rID0gaXNBcHBlYXJcblx0XHRcdD8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcilcblx0XHRcdDogZW50ZXI7XG5cdFx0dmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXJcblx0XHRcdD8gKGFmdGVyQXBwZWFyIHx8IGFmdGVyRW50ZXIpXG5cdFx0XHQ6IGFmdGVyRW50ZXI7XG5cdFx0dmFyIGVudGVyQ2FuY2VsbGVkSG9vayA9IGlzQXBwZWFyXG5cdFx0XHQ/IChhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWQpXG5cdFx0XHQ6IGVudGVyQ2FuY2VsbGVkO1xuXG5cdFx0dmFyIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiA9IHRvTnVtYmVyKFxuXHRcdFx0aXNPYmplY3QoZHVyYXRpb24pXG5cdFx0XHRcdD8gZHVyYXRpb24uZW50ZXJcblx0XHRcdFx0OiBkdXJhdGlvblxuXHRcdCk7XG5cblx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcblx0XHRcdGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG5cdFx0fVxuXG5cdFx0dmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcblx0XHR2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuXHRcdHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoZXhwZWN0c0NTUykge1xuXHRcdFx0XHRyZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuXHRcdFx0XHRyZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcblx0XHRcdH1cblx0XHRcdGlmIChjYi5jYW5jZWxsZWQpIHtcblx0XHRcdFx0aWYgKGV4cGVjdHNDU1MpIHtcblx0XHRcdFx0XHRyZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuXHRcdFx0fVxuXHRcdFx0ZWwuX2VudGVyQ2IgPSBudWxsO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcblx0XHRcdC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG5cdFx0XHRtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0dmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG5cdFx0XHRcdHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG5cdFx0XHRcdGlmIChwZW5kaW5nTm9kZSAmJlxuXHRcdFx0XHRcdHBlbmRpbmdOb2RlLnRhZyA9PT0gdm5vZGUudGFnICYmXG5cdFx0XHRcdFx0cGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cblx0XHRiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcblx0XHRpZiAoZXhwZWN0c0NTUykge1xuXHRcdFx0YWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcblx0XHRcdGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuXHRcdFx0bmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0YWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcblx0XHRcdFx0cmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcblx0XHRcdFx0aWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcblx0XHRcdFx0XHRpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0RW50ZXJEdXJhdGlvbik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHZub2RlLmRhdGEuc2hvdykge1xuXHRcdFx0dG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG5cdFx0XHRlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG5cdFx0fVxuXG5cdFx0aWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG5cdFx0XHRjYigpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGxlYXZlICh2bm9kZSwgcm0pIHtcblx0XHR2YXIgZWwgPSB2bm9kZS5lbG07XG5cblx0XHQvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuXHRcdGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcblx0XHRcdGVsLl9lbnRlckNiLmNhbmNlbGxlZCA9IHRydWU7XG5cdFx0XHRlbC5fZW50ZXJDYigpO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcblx0XHRpZiAoaXNVbmRlZihkYXRhKSkge1xuXHRcdFx0cmV0dXJuIHJtKClcblx0XHR9XG5cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoaXNEZWYoZWwuX2xlYXZlQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHR2YXIgY3NzID0gZGF0YS5jc3M7XG5cdFx0dmFyIHR5cGUgPSBkYXRhLnR5cGU7XG5cdFx0dmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG5cdFx0dmFyIGxlYXZlVG9DbGFzcyA9IGRhdGEubGVhdmVUb0NsYXNzO1xuXHRcdHZhciBsZWF2ZUFjdGl2ZUNsYXNzID0gZGF0YS5sZWF2ZUFjdGl2ZUNsYXNzO1xuXHRcdHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG5cdFx0dmFyIGxlYXZlID0gZGF0YS5sZWF2ZTtcblx0XHR2YXIgYWZ0ZXJMZWF2ZSA9IGRhdGEuYWZ0ZXJMZWF2ZTtcblx0XHR2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuXHRcdHZhciBkZWxheUxlYXZlID0gZGF0YS5kZWxheUxlYXZlO1xuXHRcdHZhciBkdXJhdGlvbiA9IGRhdGEuZHVyYXRpb247XG5cblx0XHR2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuXHRcdHZhciB1c2VyV2FudHNDb250cm9sID0gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChsZWF2ZSk7XG5cblx0XHR2YXIgZXhwbGljaXRMZWF2ZUR1cmF0aW9uID0gdG9OdW1iZXIoXG5cdFx0XHRpc09iamVjdChkdXJhdGlvbilcblx0XHRcdFx0PyBkdXJhdGlvbi5sZWF2ZVxuXHRcdFx0XHQ6IGR1cmF0aW9uXG5cdFx0KTtcblxuXHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG5cdFx0XHRjaGVja0R1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbiwgJ2xlYXZlJywgdm5vZGUpO1xuXHRcdH1cblxuXHRcdHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG5cdFx0XHRcdGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZXhwZWN0c0NTUykge1xuXHRcdFx0XHRyZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG5cdFx0XHRcdHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2IuY2FuY2VsbGVkKSB7XG5cdFx0XHRcdGlmIChleHBlY3RzQ1NTKSB7XG5cdFx0XHRcdFx0cmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRybSgpO1xuXHRcdFx0XHRhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuXHRcdFx0fVxuXHRcdFx0ZWwuX2xlYXZlQ2IgPSBudWxsO1xuXHRcdH0pO1xuXG5cdFx0aWYgKGRlbGF5TGVhdmUpIHtcblx0XHRcdGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGVyZm9ybUxlYXZlKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcblx0XHRcdC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcblx0XHRcdGlmIChjYi5jYW5jZWxsZWQpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHQvLyByZWNvcmQgbGVhdmluZyBlbGVtZW50XG5cdFx0XHRpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuXHRcdFx0XHQoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbKHZub2RlLmtleSldID0gdm5vZGU7XG5cdFx0XHR9XG5cdFx0XHRiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG5cdFx0XHRpZiAoZXhwZWN0c0NTUykge1xuXHRcdFx0XHRhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuXHRcdFx0XHRhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuXHRcdFx0XHRuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcblx0XHRcdFx0XHRyZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuXHRcdFx0XHRcdGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG5cdFx0XHRcdFx0XHRpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuXHRcdFx0aWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuXHRmdW5jdGlvbiBjaGVja0R1cmF0aW9uICh2YWwsIG5hbWUsIHZub2RlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWwgIT09ICdudW1iZXInKSB7XG5cdFx0XHR3YXJuKFxuXHRcdFx0XHRcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBub3QgYSB2YWxpZCBudW1iZXIgLSBcIiArXG5cdFx0XHRcdFwiZ290IFwiICsgKEpTT04uc3RyaW5naWZ5KHZhbCkpICsgXCIuXCIsXG5cdFx0XHRcdHZub2RlLmNvbnRleHRcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChpc05hTih2YWwpKSB7XG5cdFx0XHR3YXJuKFxuXHRcdFx0XHRcIjx0cmFuc2l0aW9uPiBleHBsaWNpdCBcIiArIG5hbWUgKyBcIiBkdXJhdGlvbiBpcyBOYU4gLSBcIiArXG5cdFx0XHRcdCd0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuJyxcblx0XHRcdFx0dm5vZGUuY29udGV4dFxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpc1ZhbGlkRHVyYXRpb24gKHZhbCkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsKVxuXHR9XG5cblx0LyoqXG5cdCAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuXHQgKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcblx0ICogLSBhIHdyYXBwZWQgY29tcG9uZW50IG1ldGhvZCAoY2hlY2sgLl9sZW5ndGgpXG5cdCAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcblx0ICovXG5cdGZ1bmN0aW9uIGdldEhvb2tBcmd1bWVudHNMZW5ndGggKGZuKSB7XG5cdFx0aWYgKGlzVW5kZWYoZm4pKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHR9XG5cdFx0dmFyIGludm9rZXJGbnMgPSBmbi5mbnM7XG5cdFx0aWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG5cdFx0XHQvLyBpbnZva2VyXG5cdFx0XHRyZXR1cm4gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChcblx0XHRcdFx0QXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuXHRcdFx0XHRcdD8gaW52b2tlckZuc1swXVxuXHRcdFx0XHRcdDogaW52b2tlckZuc1xuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKGZuLl9sZW5ndGggfHwgZm4ubGVuZ3RoKSA+IDFcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBfZW50ZXIgKF8sIHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuXHRcdFx0ZW50ZXIodm5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdHZhciB0cmFuc2l0aW9uID0gaW5Ccm93c2VyID8ge1xuXHRcdGNyZWF0ZTogX2VudGVyLFxuXHRcdGFjdGl2YXRlOiBfZW50ZXIsXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUkJDEgKHZub2RlLCBybSkge1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRcdGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcblx0XHRcdFx0bGVhdmUodm5vZGUsIHJtKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJtKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IDoge307XG5cblx0dmFyIHBsYXRmb3JtTW9kdWxlcyA9IFtcblx0XHRhdHRycyxcblx0XHRrbGFzcyxcblx0XHRldmVudHMsXG5cdFx0ZG9tUHJvcHMsXG5cdFx0c3R5bGUsXG5cdFx0dHJhbnNpdGlvblxuXHRdO1xuXG5cdC8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG5cdHZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cblx0dmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cblx0LyoqXG5cdCAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuXHQgKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuXHQgKi9cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0aWYgKGlzSUU5KSB7XG5cdFx0Ly8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblx0XHRcdGlmIChlbCAmJiBlbC52bW9kZWwpIHtcblx0XHRcdFx0dHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHR2YXIgbW9kZWwkMSA9IHtcblx0XHRpbnNlcnRlZDogZnVuY3Rpb24gaW5zZXJ0ZWQgKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuXHRcdFx0aWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcblx0XHRcdFx0dmFyIGNiID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0Y2IoKTtcblx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRcdGlmIChpc0lFIHx8IGlzRWRnZSkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoY2IsIDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBlbC50eXBlID09PSAndGV4dCcgfHwgZWwudHlwZSA9PT0gJ3Bhc3N3b3JkJykge1xuXHRcdFx0XHRlbC5fdk1vZGlmaWVycyA9IGJpbmRpbmcubW9kaWZpZXJzO1xuXHRcdFx0XHRpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcblx0XHRcdFx0XHQvLyBTYWZhcmkgPCAxMC4yICYgVUlXZWJWaWV3IGRvZXNuJ3QgZmlyZSBjb21wb3NpdGlvbmVuZCB3aGVuXG5cdFx0XHRcdFx0Ly8gc3dpdGNoaW5nIGZvY3VzIGJlZm9yZSBjb25maXJtaW5nIGNvbXBvc2l0aW9uIGNob2ljZVxuXHRcdFx0XHRcdC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcblx0XHRcdFx0XHQvLyBmaXJlcyBcImNoYW5nZVwiIGluc3RlYWQgb2YgXCJpbnB1dFwiIG9uIGF1dG9jb21wbGV0ZS5cblx0XHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNvbXBvc2l0aW9uRW5kKTtcblx0XHRcdFx0XHRpZiAoIWlzQW5kcm9pZCkge1xuXHRcdFx0XHRcdFx0ZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydCk7XG5cdFx0XHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIG9uQ29tcG9zaXRpb25FbmQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdFx0XHRpZiAoaXNJRTkpIHtcblx0XHRcdFx0XHRcdGVsLnZtb2RlbCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcblx0XHRcdGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRcdHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcblx0XHRcdFx0Ly8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG5cdFx0XHRcdC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cblx0XHRcdFx0Ly8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG5cdFx0XHRcdC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuXHRcdFx0XHR2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcblx0XHRcdFx0XHQ/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBlbC5vcHRpb25zKTsgfSlcblx0XHRcdFx0XHQ6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcblx0XHRcdFx0aWYgKG5lZWRSZXNldCkge1xuXHRcdFx0XHRcdHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBzZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG5cdFx0dmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcblx0XHR2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuXHRcdGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybihcblx0XHRcdFx0XCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcblx0XHRcdFx0XCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG5cdFx0XHRcdHZtXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG5cdFx0XHRpZiAoaXNNdWx0aXBsZSkge1xuXHRcdFx0XHRzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcblx0XHRcdFx0aWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG5cdFx0XHRcdFx0aWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcblx0XHRcdFx0XHRcdGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIWlzTXVsdGlwbGUpIHtcblx0XHRcdGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbnNbaV0pLCB2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG5cdFx0cmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuXHRcdFx0PyBvcHRpb24uX3ZhbHVlXG5cdFx0XHQ6IG9wdGlvbi52YWx1ZVxuXHR9XG5cblx0ZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG5cdFx0ZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcblx0XHQvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuXHRcdGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG5cdFx0ZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG5cdFx0dHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuXHRcdHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcblx0XHRlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcblx0XHRlbC5kaXNwYXRjaEV2ZW50KGUpO1xuXHR9XG5cblx0LyogICovXG5cbi8vIHJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgcG9zc2libGUgdHJhbnNpdGlvbiBkZWZpbmVkIGluc2lkZSB0aGUgY29tcG9uZW50IHJvb3Rcblx0ZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcblx0XHRyZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG5cdFx0XHQ/IGxvY2F0ZU5vZGUodm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKVxuXHRcdFx0OiB2bm9kZVxuXHR9XG5cblx0dmFyIHNob3cgPSB7XG5cdFx0YmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuXHRcdFx0dm5vZGUgPSBsb2NhdGVOb2RlKHZub2RlKTtcblx0XHRcdHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG5cdFx0XHR2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cblx0XHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnID8gJycgOiBlbC5zdHlsZS5kaXNwbGF5O1xuXHRcdFx0aWYgKHZhbHVlICYmIHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG5cdFx0XHRcdHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG5cdFx0XHRcdGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBvcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlIChlbCwgcmVmLCB2bm9kZSkge1xuXHRcdFx0dmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXHRcdFx0dmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cblx0XHRcdHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG5cdFx0XHR2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuXHRcdFx0aWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG5cdFx0XHRcdHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG5cdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxlYXZlKHZub2RlLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbC5zdHlsZS5kaXNwbGF5ID0gdmFsdWUgPyBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgOiAnbm9uZSc7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHVuYmluZDogZnVuY3Rpb24gdW5iaW5kIChcblx0XHRcdGVsLFxuXHRcdFx0YmluZGluZyxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVm5vZGUsXG5cdFx0XHRpc0Rlc3Ryb3lcblx0XHQpIHtcblx0XHRcdGlmICghaXNEZXN0cm95KSB7XG5cdFx0XHRcdGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG5cdFx0bW9kZWw6IG1vZGVsJDEsXG5cdFx0c2hvdzogc2hvd1xuXHR9O1xuXG5cdC8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuLy8gc3VwcG9ydHMgdHJhbnNpdGlvbiBtb2RlIChvdXQtaW4gLyBpbi1vdXQpXG5cblx0dmFyIHRyYW5zaXRpb25Qcm9wcyA9IHtcblx0XHRuYW1lOiBTdHJpbmcsXG5cdFx0YXBwZWFyOiBCb29sZWFuLFxuXHRcdGNzczogQm9vbGVhbixcblx0XHRtb2RlOiBTdHJpbmcsXG5cdFx0dHlwZTogU3RyaW5nLFxuXHRcdGVudGVyQ2xhc3M6IFN0cmluZyxcblx0XHRsZWF2ZUNsYXNzOiBTdHJpbmcsXG5cdFx0ZW50ZXJUb0NsYXNzOiBTdHJpbmcsXG5cdFx0bGVhdmVUb0NsYXNzOiBTdHJpbmcsXG5cdFx0ZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuXHRcdGxlYXZlQWN0aXZlQ2xhc3M6IFN0cmluZyxcblx0XHRhcHBlYXJDbGFzczogU3RyaW5nLFxuXHRcdGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG5cdFx0YXBwZWFyVG9DbGFzczogU3RyaW5nLFxuXHRcdGR1cmF0aW9uOiBbTnVtYmVyLCBTdHJpbmcsIE9iamVjdF1cblx0fTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuXHRmdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG5cdFx0dmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcblx0XHRpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG5cdFx0XHRyZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdm5vZGVcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcblx0XHR2YXIgZGF0YSA9IHt9O1xuXHRcdHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcblx0XHQvLyBwcm9wc1xuXHRcdGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuXHRcdFx0ZGF0YVtrZXldID0gY29tcFtrZXldO1xuXHRcdH1cblx0XHQvLyBldmVudHMuXG5cdFx0Ly8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG5cdFx0dmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcblx0XHRmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcblx0XHRcdGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblxuXHRmdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcblx0XHRpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG5cdFx0XHRyZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcblx0XHRcdFx0cHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG5cdFx0d2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcblx0XHRcdGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG5cdFx0cmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG5cdH1cblxuXHR2YXIgVHJhbnNpdGlvbiA9IHtcblx0XHRuYW1lOiAndHJhbnNpdGlvbicsXG5cdFx0cHJvcHM6IHRyYW5zaXRpb25Qcm9wcyxcblx0XHRhYnN0cmFjdDogdHJ1ZSxcblxuXHRcdHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG5cdFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcblx0XHRcdGlmICghY2hpbGRyZW4pIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG5cdFx0XHRjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0Ly8gd2FybiBtdWx0aXBsZSBlbGVtZW50c1xuXHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHQnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuXHRcdFx0XHRcdCc8dHJhbnNpdGlvbi1ncm91cD4gZm9yIGxpc3RzLicsXG5cdFx0XHRcdFx0dGhpcy4kcGFyZW50XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG5cdFx0XHQvLyB3YXJuIGludmFsaWQgbW9kZVxuXHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG5cdFx0XHRcdG1vZGUgJiYgbW9kZSAhPT0gJ2luLW91dCcgJiYgbW9kZSAhPT0gJ291dC1pbidcblx0XHRcdCkge1xuXHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdCdpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAnICsgbW9kZSxcblx0XHRcdFx0XHR0aGlzLiRwYXJlbnRcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG5cblx0XHRcdC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3Ncblx0XHRcdC8vIHBhcmVudCBjb250YWluZXIgbm9kZSBhbHNvIGhhcyB0cmFuc2l0aW9uLCBza2lwLlxuXHRcdFx0aWYgKGhhc1BhcmVudFRyYW5zaXRpb24odGhpcy4kdm5vZGUpKSB7XG5cdFx0XHRcdHJldHVybiByYXdDaGlsZFxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhcHBseSB0cmFuc2l0aW9uIGRhdGEgdG8gY2hpbGRcblx0XHRcdC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcblx0XHRcdHZhciBjaGlsZCA9IGdldFJlYWxDaGlsZChyYXdDaGlsZCk7XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdGlmICghY2hpbGQpIHtcblx0XHRcdFx0cmV0dXJuIHJhd0NoaWxkXG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9sZWF2aW5nKSB7XG5cdFx0XHRcdHJldHVybiBwbGFjZWhvbGRlcihoLCByYXdDaGlsZClcblx0XHRcdH1cblxuXHRcdFx0Ly8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cblx0XHRcdC8vIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHJlbW92ZSBwZW5kaW5nIGxlYXZpbmcgbm9kZXNcblx0XHRcdC8vIGR1cmluZyBlbnRlcmluZy5cblx0XHRcdHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcblx0XHRcdGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsXG5cdFx0XHRcdD8gaWQgKyBjaGlsZC50YWdcblx0XHRcdFx0OiBpc1ByaW1pdGl2ZShjaGlsZC5rZXkpXG5cdFx0XHRcdD8gKFN0cmluZyhjaGlsZC5rZXkpLmluZGV4T2YoaWQpID09PSAwID8gY2hpbGQua2V5IDogaWQgKyBjaGlsZC5rZXkpXG5cdFx0XHRcdDogY2hpbGQua2V5O1xuXG5cdFx0XHR2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXHRcdFx0dmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG5cdFx0XHR2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG5cdFx0XHQvLyBtYXJrIHYtc2hvd1xuXHRcdFx0Ly8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG5cdFx0XHRpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLm5hbWUgPT09ICdzaG93JzsgfSkpIHtcblx0XHRcdFx0Y2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9sZENoaWxkICYmIG9sZENoaWxkLmRhdGEgJiYgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkpIHtcblx0XHRcdFx0Ly8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG5cdFx0XHRcdC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcblx0XHRcdFx0dmFyIG9sZERhdGEgPSBvbGRDaGlsZCAmJiAob2xkQ2hpbGQuZGF0YS50cmFuc2l0aW9uID0gZXh0ZW5kKHt9LCBkYXRhKSk7XG5cdFx0XHRcdC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcblx0XHRcdFx0aWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG5cdFx0XHRcdFx0Ly8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG5cdFx0XHRcdFx0dGhpcy5fbGVhdmluZyA9IHRydWU7XG5cdFx0XHRcdFx0bWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHRcdHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG5cdFx0XHRcdH0gZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcblx0XHRcdFx0XHR2YXIgZGVsYXllZExlYXZlO1xuXHRcdFx0XHRcdHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuXHRcdFx0XHRcdG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcblx0XHRcdFx0XHRtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuXHRcdFx0XHRcdG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcmF3Q2hpbGRcblx0XHR9XG5cdH07XG5cblx0LyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkZXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cblx0dmFyIHByb3BzID0gZXh0ZW5kKHtcblx0XHR0YWc6IFN0cmluZyxcblx0XHRtb3ZlQ2xhc3M6IFN0cmluZ1xuXHR9LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5cdGRlbGV0ZSBwcm9wcy5tb2RlO1xuXG5cdHZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG5cdFx0cHJvcHM6IHByb3BzLFxuXG5cdFx0cmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcblx0XHRcdHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG5cdFx0XHR2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cdFx0XHR2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuXHRcdFx0dmFyIHRyYW5zaXRpb25EYXRhID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChjLnRhZykge1xuXHRcdFx0XHRcdGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG5cdFx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKGMpO1xuXHRcdFx0XHRcdFx0bWFwW2Mua2V5XSA9IGNcblx0XHRcdFx0XHRcdDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG5cdFx0XHRcdFx0XHR2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcblx0XHRcdFx0XHRcdHdhcm4oKFwiPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuIG11c3QgYmUga2V5ZWQ6IDxcIiArIG5hbWUgKyBcIj5cIikpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAocHJldkNoaWxkcmVuKSB7XG5cdFx0XHRcdHZhciBrZXB0ID0gW107XG5cdFx0XHRcdHZhciByZW1vdmVkID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHByZXZDaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG5cdFx0XHRcdFx0dmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuXHRcdFx0XHRcdGMkMS5kYXRhLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcblx0XHRcdFx0XHRjJDEuZGF0YS5wb3MgPSBjJDEuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0XHRcdGlmIChtYXBbYyQxLmtleV0pIHtcblx0XHRcdFx0XHRcdGtlcHQucHVzaChjJDEpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVkLnB1c2goYyQxKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuXHRcdFx0XHR0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuXHRcdH0sXG5cblx0XHRiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uIGJlZm9yZVVwZGF0ZSAoKSB7XG5cdFx0XHQvLyBmb3JjZSByZW1vdmluZyBwYXNzXG5cdFx0XHR0aGlzLl9fcGF0Y2hfXyhcblx0XHRcdFx0dGhpcy5fdm5vZGUsXG5cdFx0XHRcdHRoaXMua2VwdCxcblx0XHRcdFx0ZmFsc2UsIC8vIGh5ZHJhdGluZ1xuXHRcdFx0XHR0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3Zlcylcblx0XHRcdCk7XG5cdFx0XHR0aGlzLl92bm9kZSA9IHRoaXMua2VwdDtcblx0XHR9LFxuXG5cdFx0dXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcblx0XHRcdHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG5cdFx0XHRpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0Ly8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG5cdFx0XHQvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cblx0XHRcdGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuXHRcdFx0Y2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG5cdFx0XHRjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG5cdFx0XHQvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cblx0XHRcdHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblx0XHRcdHZhciBmID0gYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuXHRcdFx0Y2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRpZiAoYy5kYXRhLm1vdmVkKSB7XG5cdFx0XHRcdFx0dmFyIGVsID0gYy5lbG07XG5cdFx0XHRcdFx0dmFyIHMgPSBlbC5zdHlsZTtcblx0XHRcdFx0XHRhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG5cdFx0XHRcdFx0cy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG5cdFx0XHRcdFx0ZWwuYWRkRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYiAoZSkge1xuXHRcdFx0XHRcdFx0aWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuXHRcdFx0XHRcdFx0XHRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuXHRcdFx0XHRcdFx0XHRlbC5fbW92ZUNiID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0bWV0aG9kczoge1xuXHRcdFx0aGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuXHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdFx0aWYgKCFoYXNUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuX2hhc01vdmUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9oYXNNb3ZlXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG5cdFx0XHRcdC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuXHRcdFx0XHQvLyB0cmFuc2l0aW9uIGF0IHRoaXMgdmVyeSBtb21lbnQsIHdlIG1ha2UgYSBjbG9uZSBvZiBpdCBhbmQgcmVtb3ZlXG5cdFx0XHRcdC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuXHRcdFx0XHQvLyBpcyBhcHBsaWVkLlxuXHRcdFx0XHR2YXIgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcblx0XHRcdFx0aWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuXHRcdFx0XHRcdGVsLl90cmFuc2l0aW9uQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChjbHMpIHsgcmVtb3ZlQ2xhc3MoY2xvbmUsIGNscyk7IH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuXHRcdFx0XHRjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0XHR0aGlzLiRlbC5hcHBlbmRDaGlsZChjbG9uZSk7XG5cdFx0XHRcdHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuXHRcdFx0XHR0aGlzLiRlbC5yZW1vdmVDaGlsZChjbG9uZSk7XG5cdFx0XHRcdHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmIChjLmVsbS5fbW92ZUNiKSB7XG5cdFx0XHRjLmVsbS5fbW92ZUNiKCk7XG5cdFx0fVxuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmIChjLmVsbS5fZW50ZXJDYikge1xuXHRcdFx0Yy5lbG0uX2VudGVyQ2IoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZWNvcmRQb3NpdGlvbiAoYykge1xuXHRcdGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5VHJhbnNsYXRpb24gKGMpIHtcblx0XHR2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcblx0XHR2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1Bvcztcblx0XHR2YXIgZHggPSBvbGRQb3MubGVmdCAtIG5ld1Bvcy5sZWZ0O1xuXHRcdHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuXHRcdGlmIChkeCB8fCBkeSkge1xuXHRcdFx0Yy5kYXRhLm1vdmVkID0gdHJ1ZTtcblx0XHRcdHZhciBzID0gYy5lbG0uc3R5bGU7XG5cdFx0XHRzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG5cdFx0XHRzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHBsYXRmb3JtQ29tcG9uZW50cyA9IHtcblx0XHRUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuXHRcdFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG5cdH07XG5cblx0LyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblx0VnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5cdFZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblx0VnVlJDMuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG5cdFZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5cdFZ1ZSQzLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5cdGV4dGVuZChWdWUkMy5vcHRpb25zLmRpcmVjdGl2ZXMsIHBsYXRmb3JtRGlyZWN0aXZlcyk7XG5cdGV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblx0VnVlJDMucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuLy8gcHVibGljIG1vdW50IG1ldGhvZFxuXHRWdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuXHRcdGVsLFxuXHRcdGh5ZHJhdGluZ1xuXHQpIHtcblx0XHRlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcblx0XHRyZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcblx0fTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKGNvbmZpZy5kZXZ0b29scykge1xuXHRcdFx0aWYgKGRldnRvb2xzKSB7XG5cdFx0XHRcdGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUkMyk7XG5cdFx0XHR9IGVsc2UgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGlzQ2hyb21lKSB7XG5cdFx0XHRcdGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuXHRcdFx0XHRcdCdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGV4dGVuc2lvbiBmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTpcXG4nICtcblx0XHRcdFx0XHQnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG5cdFx0XHRjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcblx0XHRcdGluQnJvd3NlciAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcblx0XHQpIHtcblx0XHRcdGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuXHRcdFx0XHRcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG5cdFx0XHRcdFwiTWFrZSBzdXJlIHRvIHR1cm4gb24gcHJvZHVjdGlvbiBtb2RlIHdoZW4gZGVwbG95aW5nIGZvciBwcm9kdWN0aW9uLlxcblwiICtcblx0XHRcdFx0XCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG5cdFx0XHQpO1xuXHRcdH1cblx0fSwgMCk7XG5cblx0LyogICovXG5cbi8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG5cdGZ1bmN0aW9uIHNob3VsZERlY29kZSAoY29udGVudCwgZW5jb2RlZCkge1xuXHRcdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCI8ZGl2IGE9XFxcIlwiICsgY29udGVudCArIFwiXFxcIj5cIjtcblx0XHRyZXR1cm4gZGl2LmlubmVySFRNTC5pbmRleE9mKGVuY29kZWQpID4gMFxuXHR9XG5cbi8vICMzNjYzXG4vLyBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG5cdHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IHNob3VsZERlY29kZSgnXFxuJywgJyYjMTA7JykgOiBmYWxzZTtcblxuXHQvKiAgKi9cblxuXHR2YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG5cdFx0J2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuXHRcdCdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicidcblx0KTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG5cdHZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcblx0XHQnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcblx0KTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG5cdHZhciBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcChcblx0XHQnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuXHRcdCdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG5cdFx0J2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuXHRcdCdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG5cdFx0J3RpdGxlLHRyLHRyYWNrJ1xuXHQpO1xuXG5cdC8qICAqL1xuXG5cdHZhciBkZWNvZGVyO1xuXG5cdGZ1bmN0aW9uIGRlY29kZSAoaHRtbCkge1xuXHRcdGRlY29kZXIgPSBkZWNvZGVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcblx0XHRyZXR1cm4gZGVjb2Rlci50ZXh0Q29udGVudFxuXHR9XG5cblx0LyoqXG5cdCAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGl0J3MgbW9zdGx5IHZlbmRvciBjb2RlLlxuXHQgKi9cblxuXHQvKiFcblx0ICogSFRNTCBQYXJzZXIgQnkgSm9obiBSZXNpZyAoZWpvaG4ub3JnKVxuXHQgKiBNb2RpZmllZCBieSBKdXJpeSBcImthbmdheFwiIFpheXRzZXZcblx0ICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuXHQgKiBodHRwOi8vZXJpay5lYWUubmV0L3NpbXBsZWh0bWxwYXJzZXIvc2ltcGxlaHRtbHBhcnNlci5qc1xuXHQgKi9cblxuLy8gUmVndWxhciBFeHByZXNzaW9ucyBmb3IgcGFyc2luZyB0YWdzIGFuZCBhdHRyaWJ1dGVzXG5cdHZhciBzaW5nbGVBdHRySWRlbnRpZmllciA9IC8oW15cXHNcIic8Pi89XSspLztcblx0dmFyIHNpbmdsZUF0dHJBc3NpZ24gPSAvKD86PSkvO1xuXHR2YXIgc2luZ2xlQXR0clZhbHVlcyA9IFtcblx0XHQvLyBhdHRyIHZhbHVlIGRvdWJsZSBxdW90ZXNcblx0XHQvXCIoW15cIl0qKVwiKy8uc291cmNlLFxuXHRcdC8vIGF0dHIgdmFsdWUsIHNpbmdsZSBxdW90ZXNcblx0XHQvJyhbXiddKiknKy8uc291cmNlLFxuXHRcdC8vIGF0dHIgdmFsdWUsIG5vIHF1b3Rlc1xuXHRcdC8oW15cXHNcIic9PD5gXSspLy5zb3VyY2Vcblx0XTtcblx0dmFyIGF0dHJpYnV0ZSA9IG5ldyBSZWdFeHAoXG5cdFx0J15cXFxccyonICsgc2luZ2xlQXR0cklkZW50aWZpZXIuc291cmNlICtcblx0XHQnKD86XFxcXHMqKCcgKyBzaW5nbGVBdHRyQXNzaWduLnNvdXJjZSArICcpJyArXG5cdFx0J1xcXFxzKig/OicgKyBzaW5nbGVBdHRyVmFsdWVzLmpvaW4oJ3wnKSArICcpKT8nXG5cdCk7XG5cbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcblx0dmFyIG5jbmFtZSA9ICdbYS16QS1aX11bXFxcXHdcXFxcLVxcXFwuXSonO1xuXHR2YXIgcW5hbWVDYXB0dXJlID0gJygoPzonICsgbmNuYW1lICsgJ1xcXFw6KT8nICsgbmNuYW1lICsgJyknO1xuXHR2YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgnXjwnICsgcW5hbWVDYXB0dXJlKTtcblx0dmFyIHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+Lztcblx0dmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoJ148XFxcXC8nICsgcW5hbWVDYXB0dXJlICsgJ1tePl0qPicpO1xuXHR2YXIgZG9jdHlwZSA9IC9ePCFET0NUWVBFIFtePl0rPi9pO1xuXHR2YXIgY29tbWVudCA9IC9ePCEtLS87XG5cdHZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxuXHR2YXIgSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGZhbHNlO1xuXHQneCcucmVwbGFjZSgveCguKT8vZywgZnVuY3Rpb24gKG0sIGcpIHtcblx0XHRJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG5cdH0pO1xuXG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcblx0dmFyIGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xuXHR2YXIgcmVDYWNoZSA9IHt9O1xuXG5cdHZhciBkZWNvZGluZ01hcCA9IHtcblx0XHQnJmx0Oyc6ICc8Jyxcblx0XHQnJmd0Oyc6ICc+Jyxcblx0XHQnJnF1b3Q7JzogJ1wiJyxcblx0XHQnJmFtcDsnOiAnJicsXG5cdFx0JyYjMTA7JzogJ1xcbidcblx0fTtcblx0dmFyIGVuY29kZWRBdHRyID0gLyYoPzpsdHxndHxxdW90fGFtcCk7L2c7XG5cdHZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwKTsvZztcblxuXHRmdW5jdGlvbiBkZWNvZGVBdHRyICh2YWx1ZSwgc2hvdWxkRGVjb2RlTmV3bGluZXMpIHtcblx0XHR2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG5cdFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gZGVjb2RpbmdNYXBbbWF0Y2hdOyB9KVxuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG5cdFx0dmFyIHN0YWNrID0gW107XG5cdFx0dmFyIGV4cGVjdEhUTUwgPSBvcHRpb25zLmV4cGVjdEhUTUw7XG5cdFx0dmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG5cdFx0dmFyIGNhbkJlTGVmdE9wZW5UYWckJDEgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG5cdFx0dmFyIGluZGV4ID0gMDtcblx0XHR2YXIgbGFzdCwgbGFzdFRhZztcblx0XHR3aGlsZSAoaHRtbCkge1xuXHRcdFx0bGFzdCA9IGh0bWw7XG5cdFx0XHQvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuXHRcdFx0aWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcblx0XHRcdFx0dmFyIHRleHRFbmQgPSBodG1sLmluZGV4T2YoJzwnKTtcblx0XHRcdFx0aWYgKHRleHRFbmQgPT09IDApIHtcblx0XHRcdFx0XHQvLyBDb21tZW50OlxuXHRcdFx0XHRcdGlmIChjb21tZW50LnRlc3QoaHRtbCkpIHtcblx0XHRcdFx0XHRcdHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuXHRcdFx0XHRcdFx0aWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcblx0XHRcdFx0XHRpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcblx0XHRcdFx0XHRcdHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuXHRcdFx0XHRcdFx0aWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcblx0XHRcdFx0XHRcdFx0YWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERvY3R5cGU6XG5cdFx0XHRcdFx0dmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG5cdFx0XHRcdFx0aWYgKGRvY3R5cGVNYXRjaCkge1xuXHRcdFx0XHRcdFx0YWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRW5kIHRhZzpcblx0XHRcdFx0XHR2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG5cdFx0XHRcdFx0aWYgKGVuZFRhZ01hdGNoKSB7XG5cdFx0XHRcdFx0XHR2YXIgY3VySW5kZXggPSBpbmRleDtcblx0XHRcdFx0XHRcdGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcblx0XHRcdFx0XHRcdHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdGFydCB0YWc6XG5cdFx0XHRcdFx0dmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG5cdFx0XHRcdFx0aWYgKHN0YXJ0VGFnTWF0Y2gpIHtcblx0XHRcdFx0XHRcdGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuXHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0JDEgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuXHRcdFx0XHRpZiAodGV4dEVuZCA+PSAwKSB7XG5cdFx0XHRcdFx0cmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcblx0XHRcdFx0XHR3aGlsZSAoXG5cdFx0XHRcdFx0IWVuZFRhZy50ZXN0KHJlc3QkMSkgJiZcblx0XHRcdFx0XHQhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCQxKSAmJlxuXHRcdFx0XHRcdCFjb21tZW50LnRlc3QocmVzdCQxKSAmJlxuXHRcdFx0XHRcdCFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0JDEpXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG5cdFx0XHRcdFx0XHRuZXh0ID0gcmVzdCQxLmluZGV4T2YoJzwnLCAxKTtcblx0XHRcdFx0XHRcdGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG5cdFx0XHRcdFx0XHR0ZXh0RW5kICs9IG5leHQ7XG5cdFx0XHRcdFx0XHRyZXN0JDEgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZXh0ID0gaHRtbC5zdWJzdHJpbmcoMCwgdGV4dEVuZCk7XG5cdFx0XHRcdFx0YWR2YW5jZSh0ZXh0RW5kKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0ZXh0RW5kIDwgMCkge1xuXHRcdFx0XHRcdHRleHQgPSBodG1sO1xuXHRcdFx0XHRcdGh0bWwgPSAnJztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcblx0XHRcdFx0XHRvcHRpb25zLmNoYXJzKHRleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0dmFyIHJlU3RhY2tlZFRhZyA9IHJlQ2FjaGVbc3RhY2tlZFRhZ10gfHwgKHJlQ2FjaGVbc3RhY2tlZFRhZ10gPSBuZXcgUmVnRXhwKCcoW1xcXFxzXFxcXFNdKj8pKDwvJyArIHN0YWNrZWRUYWcgKyAnW14+XSo+KScsICdpJykpO1xuXHRcdFx0XHR2YXIgZW5kVGFnTGVuZ3RoID0gMDtcblx0XHRcdFx0dmFyIHJlc3QgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcblx0XHRcdFx0XHRlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuXHRcdFx0XHRcdGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcblx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0XG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC88IS0tKFtcXHNcXFNdKj8pLS0+L2csICckMScpXG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAob3B0aW9ucy5jaGFycykge1xuXHRcdFx0XHRcdFx0b3B0aW9ucy5jaGFycyh0ZXh0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuICcnXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpbmRleCArPSBodG1sLmxlbmd0aCAtIHJlc3QubGVuZ3RoO1xuXHRcdFx0XHRodG1sID0gcmVzdDtcblx0XHRcdFx0cGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGh0bWwgPT09IGxhc3QpIHtcblx0XHRcdFx0b3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuXHRcdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcblx0XHRcdFx0XHRvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuXHRcdHBhcnNlRW5kVGFnKCk7XG5cblx0XHRmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG5cdFx0XHRpbmRleCArPSBuO1xuXHRcdFx0aHRtbCA9IGh0bWwuc3Vic3RyaW5nKG4pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlU3RhcnRUYWcgKCkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gaHRtbC5tYXRjaChzdGFydFRhZ09wZW4pO1xuXHRcdFx0aWYgKHN0YXJ0KSB7XG5cdFx0XHRcdHZhciBtYXRjaCA9IHtcblx0XHRcdFx0XHR0YWdOYW1lOiBzdGFydFsxXSxcblx0XHRcdFx0XHRhdHRyczogW10sXG5cdFx0XHRcdFx0c3RhcnQ6IGluZGV4XG5cdFx0XHRcdH07XG5cdFx0XHRcdGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcblx0XHRcdFx0dmFyIGVuZCwgYXR0cjtcblx0XHRcdFx0d2hpbGUgKCEoZW5kID0gaHRtbC5tYXRjaChzdGFydFRhZ0Nsb3NlKSkgJiYgKGF0dHIgPSBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG5cdFx0XHRcdFx0YWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG5cdFx0XHRcdFx0bWF0Y2guYXR0cnMucHVzaChhdHRyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZW5kKSB7XG5cdFx0XHRcdFx0bWF0Y2gudW5hcnlTbGFzaCA9IGVuZFsxXTtcblx0XHRcdFx0XHRhZHZhbmNlKGVuZFswXS5sZW5ndGgpO1xuXHRcdFx0XHRcdG1hdGNoLmVuZCA9IGluZGV4O1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlU3RhcnRUYWcgKG1hdGNoKSB7XG5cdFx0XHR2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG5cdFx0XHR2YXIgdW5hcnlTbGFzaCA9IG1hdGNoLnVuYXJ5U2xhc2g7XG5cblx0XHRcdGlmIChleHBlY3RIVE1MKSB7XG5cdFx0XHRcdGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuXHRcdFx0XHRcdHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcblx0XHRcdFx0XHRwYXJzZUVuZFRhZyh0YWdOYW1lKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdW5hcnkgPSBpc1VuYXJ5VGFnJCQxKHRhZ05hbWUpIHx8IHRhZ05hbWUgPT09ICdodG1sJyAmJiBsYXN0VGFnID09PSAnaGVhZCcgfHwgISF1bmFyeVNsYXNoO1xuXG5cdFx0XHR2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcblx0XHRcdHZhciBhdHRycyA9IG5ldyBBcnJheShsKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG5cdFx0XHRcdC8vIGhhY2tpc2ggd29yayBhcm91bmQgRkYgYnVnIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTM2OTc3OFxuXHRcdFx0XHRpZiAoSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiAmJiBhcmdzWzBdLmluZGV4T2YoJ1wiXCInKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cblx0XHRcdFx0XHRpZiAoYXJnc1s0XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNF07IH1cblx0XHRcdFx0XHRpZiAoYXJnc1s1XSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbNV07IH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcblx0XHRcdFx0YXR0cnNbaV0gPSB7XG5cdFx0XHRcdFx0bmFtZTogYXJnc1sxXSxcblx0XHRcdFx0XHR2YWx1ZTogZGVjb2RlQXR0cihcblx0XHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc1xuXHRcdFx0XHRcdClcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCF1bmFyeSkge1xuXHRcdFx0XHRzdGFjay5wdXNoKHsgdGFnOiB0YWdOYW1lLCBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGF0dHJzOiBhdHRycyB9KTtcblx0XHRcdFx0bGFzdFRhZyA9IHRhZ05hbWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zLnN0YXJ0KSB7XG5cdFx0XHRcdG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgYXR0cnMsIHVuYXJ5LCBtYXRjaC5zdGFydCwgbWF0Y2guZW5kKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUVuZFRhZyAodGFnTmFtZSwgc3RhcnQsIGVuZCkge1xuXHRcdFx0dmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG5cdFx0XHRpZiAoc3RhcnQgPT0gbnVsbCkgeyBzdGFydCA9IGluZGV4OyB9XG5cdFx0XHRpZiAoZW5kID09IG51bGwpIHsgZW5kID0gaW5kZXg7IH1cblxuXHRcdFx0aWYgKHRhZ05hbWUpIHtcblx0XHRcdFx0bG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG5cdFx0XHRpZiAodGFnTmFtZSkge1xuXHRcdFx0XHRmb3IgKHBvcyA9IHN0YWNrLmxlbmd0aCAtIDE7IHBvcyA+PSAwOyBwb3MtLSkge1xuXHRcdFx0XHRcdGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3Bcblx0XHRcdFx0cG9zID0gMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHBvcyA+PSAwKSB7XG5cdFx0XHRcdC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG5cdFx0XHRcdGZvciAodmFyIGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IHBvczsgaS0tKSB7XG5cdFx0XHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG5cdFx0XHRcdFx0XHQoaSA+IHBvcyB8fCAhdGFnTmFtZSkgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMud2FyblxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9ucy53YXJuKFxuXHRcdFx0XHRcdFx0XHQoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAob3B0aW9ucy5lbmQpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCA9IHBvcztcblx0XHRcdFx0bGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG5cdFx0XHR9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAnYnInKSB7XG5cdFx0XHRcdGlmIChvcHRpb25zLnN0YXJ0KSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdwJykge1xuXHRcdFx0XHRpZiAob3B0aW9ucy5zdGFydCkge1xuXHRcdFx0XHRcdG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob3B0aW9ucy5lbmQpIHtcblx0XHRcdFx0XHRvcHRpb25zLmVuZCh0YWdOYW1lLCBzdGFydCwgZW5kKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBkZWZhdWx0VGFnUkUgPSAvXFx7XFx7KCg/Oi58XFxuKSs/KVxcfVxcfS9nO1xuXHR2YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cblx0dmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcblx0XHR2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG5cdFx0dmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcblx0XHRyZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxuXHR9KTtcblxuXHRmdW5jdGlvbiBwYXJzZVRleHQgKFxuXHRcdHRleHQsXG5cdFx0ZGVsaW1pdGVyc1xuXHQpIHtcblx0XHR2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcblx0XHRpZiAoIXRhZ1JFLnRlc3QodGV4dCkpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHR2YXIgdG9rZW5zID0gW107XG5cdFx0dmFyIGxhc3RJbmRleCA9IHRhZ1JFLmxhc3RJbmRleCA9IDA7XG5cdFx0dmFyIG1hdGNoLCBpbmRleDtcblx0XHR3aGlsZSAoKG1hdGNoID0gdGFnUkUuZXhlYyh0ZXh0KSkpIHtcblx0XHRcdGluZGV4ID0gbWF0Y2guaW5kZXg7XG5cdFx0XHQvLyBwdXNoIHRleHQgdG9rZW5cblx0XHRcdGlmIChpbmRleCA+IGxhc3RJbmRleCkge1xuXHRcdFx0XHR0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKSk7XG5cdFx0XHR9XG5cdFx0XHQvLyB0YWcgdG9rZW5cblx0XHRcdHZhciBleHAgPSBwYXJzZUZpbHRlcnMobWF0Y2hbMV0udHJpbSgpKTtcblx0XHRcdHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcblx0XHRcdGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXHRcdH1cblx0XHRpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcblx0XHRcdHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4KSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxuXHR9XG5cblx0LyogICovXG5cblx0dmFyIG9uUkUgPSAvXkB8XnYtb246Lztcblx0dmFyIGRpclJFID0gL152LXxeQHxeOi87XG5cdHZhciBmb3JBbGlhc1JFID0gLyguKj8pXFxzKyg/OmlufG9mKVxccysoLiopLztcblx0dmFyIGZvckl0ZXJhdG9yUkUgPSAvXFwoKFxce1tefV0qXFx9fFteLF0qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG5cblx0dmFyIGFyZ1JFID0gLzooLiopJC87XG5cdHZhciBiaW5kUkUgPSAvXjp8XnYtYmluZDovO1xuXHR2YXIgbW9kaWZpZXJSRSA9IC9cXC5bXi5dKy9nO1xuXG5cdHZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxuXHR2YXIgd2FybiQyO1xuXHR2YXIgZGVsaW1pdGVycztcblx0dmFyIHRyYW5zZm9ybXM7XG5cdHZhciBwcmVUcmFuc2Zvcm1zO1xuXHR2YXIgcG9zdFRyYW5zZm9ybXM7XG5cdHZhciBwbGF0Zm9ybUlzUHJlVGFnO1xuXHR2YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcblx0dmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cblx0ICovXG5cdGZ1bmN0aW9uIHBhcnNlIChcblx0XHR0ZW1wbGF0ZSxcblx0XHRvcHRpb25zXG5cdCkge1xuXHRcdHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2Fybjtcblx0XHRwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuXHRcdHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuXHRcdHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuXHRcdHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcblx0XHR0cmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Ob2RlJyk7XG5cdFx0cG9zdFRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3Bvc3RUcmFuc2Zvcm1Ob2RlJyk7XG5cdFx0ZGVsaW1pdGVycyA9IG9wdGlvbnMuZGVsaW1pdGVycztcblxuXHRcdHZhciBzdGFjayA9IFtdO1xuXHRcdHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG5cdFx0dmFyIHJvb3Q7XG5cdFx0dmFyIGN1cnJlbnRQYXJlbnQ7XG5cdFx0dmFyIGluVlByZSA9IGZhbHNlO1xuXHRcdHZhciBpblByZSA9IGZhbHNlO1xuXHRcdHZhciB3YXJuZWQgPSBmYWxzZTtcblxuXHRcdGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcblx0XHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRcdHdhcm4kMihtc2cpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGVuZFByZSAoZWxlbWVudCkge1xuXHRcdFx0Ly8gY2hlY2sgcHJlIHN0YXRlXG5cdFx0XHRpZiAoZWxlbWVudC5wcmUpIHtcblx0XHRcdFx0aW5WUHJlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcblx0XHRcdFx0aW5QcmUgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwYXJzZUhUTUwodGVtcGxhdGUsIHtcblx0XHRcdHdhcm46IHdhcm4kMixcblx0XHRcdGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcblx0XHRcdGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcblx0XHRcdGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcblx0XHRcdHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuXHRcdFx0c3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0ICh0YWcsIGF0dHJzLCB1bmFyeSkge1xuXHRcdFx0XHQvLyBjaGVjayBuYW1lc3BhY2UuXG5cdFx0XHRcdC8vIGluaGVyaXQgcGFyZW50IG5zIGlmIHRoZXJlIGlzIG9uZVxuXHRcdFx0XHR2YXIgbnMgPSAoY3VycmVudFBhcmVudCAmJiBjdXJyZW50UGFyZW50Lm5zKSB8fCBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSh0YWcpO1xuXG5cdFx0XHRcdC8vIGhhbmRsZSBJRSBzdmcgYnVnXG5cdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0XHRpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcblx0XHRcdFx0XHRhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGVsZW1lbnQgPSB7XG5cdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR0YWc6IHRhZyxcblx0XHRcdFx0XHRhdHRyc0xpc3Q6IGF0dHJzLFxuXHRcdFx0XHRcdGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuXHRcdFx0XHRcdHBhcmVudDogY3VycmVudFBhcmVudCxcblx0XHRcdFx0XHRjaGlsZHJlbjogW11cblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKG5zKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5ucyA9IG5zO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzRm9yYmlkZGVuVGFnKGVsZW1lbnQpICYmICFpc1NlcnZlclJlbmRlcmluZygpKSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuXHRcdFx0XHRcdFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcblx0XHRcdFx0XHRcdCdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcblx0XHRcdFx0XHRcdCdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuXHRcdFx0XHRcdFx0XCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcmVUcmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0cHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghaW5WUHJlKSB7XG5cdFx0XHRcdFx0cHJvY2Vzc1ByZShlbGVtZW50KTtcblx0XHRcdFx0XHRpZiAoZWxlbWVudC5wcmUpIHtcblx0XHRcdFx0XHRcdGluVlByZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuXHRcdFx0XHRcdGluUHJlID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW5WUHJlKSB7XG5cdFx0XHRcdFx0cHJvY2Vzc1Jhd0F0dHJzKGVsZW1lbnQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb2Nlc3NGb3IoZWxlbWVudCk7XG5cdFx0XHRcdFx0cHJvY2Vzc0lmKGVsZW1lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NLZXkoZWxlbWVudCk7XG5cblx0XHRcdFx0XHQvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuXHRcdFx0XHRcdC8vIHJlbW92aW5nIHN0cnVjdHVyYWwgYXR0cmlidXRlc1xuXHRcdFx0XHRcdGVsZW1lbnQucGxhaW4gPSAhZWxlbWVudC5rZXkgJiYgIWF0dHJzLmxlbmd0aDtcblxuXHRcdFx0XHRcdHByb2Nlc3NSZWYoZWxlbWVudCk7XG5cdFx0XHRcdFx0cHJvY2Vzc1Nsb3QoZWxlbWVudCk7XG5cdFx0XHRcdFx0cHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcblx0XHRcdFx0XHRmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSQxKyspIHtcblx0XHRcdFx0XHRcdHRyYW5zZm9ybXNbaSQxXShlbGVtZW50LCBvcHRpb25zKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJvY2Vzc0F0dHJzKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuXHRcdFx0XHRcdFx0XHR3YXJuT25jZShcblx0XHRcdFx0XHRcdFx0XHRcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG5cdFx0XHRcdFx0XHRcdFx0J2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG5cdFx0XHRcdFx0XHRcdHdhcm5PbmNlKFxuXHRcdFx0XHRcdFx0XHRcdCdDYW5ub3QgdXNlIHYtZm9yIG9uIHN0YXRlZnVsIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSAnICtcblx0XHRcdFx0XHRcdFx0XHQnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gdHJlZSBtYW5hZ2VtZW50XG5cdFx0XHRcdGlmICghcm9vdCkge1xuXHRcdFx0XHRcdHJvb3QgPSBlbGVtZW50O1xuXHRcdFx0XHRcdGNoZWNrUm9vdENvbnN0cmFpbnRzKHJvb3QpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcblx0XHRcdFx0XHQvLyBhbGxvdyByb290IGVsZW1lbnRzIHdpdGggdi1pZiwgdi1lbHNlLWlmIGFuZCB2LWVsc2Vcblx0XHRcdFx0XHRpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuXHRcdFx0XHRcdFx0Y2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG5cdFx0XHRcdFx0XHRhZGRJZkNvbmRpdGlvbihyb290LCB7XG5cdFx0XHRcdFx0XHRcdGV4cDogZWxlbWVudC5lbHNlaWYsXG5cdFx0XHRcdFx0XHRcdGJsb2NrOiBlbGVtZW50XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0d2Fybk9uY2UoXG5cdFx0XHRcdFx0XHRcdFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuXHRcdFx0XHRcdFx0XHRcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuXHRcdFx0XHRcdFx0XHRcInVzZSB2LWVsc2UtaWYgdG8gY2hhaW4gdGhlbSBpbnN0ZWFkLlwiXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcblx0XHRcdFx0XHRpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG5cdFx0XHRcdFx0XHRwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoZWxlbWVudC5zbG90U2NvcGUpIHsgLy8gc2NvcGVkIHNsb3Rcblx0XHRcdFx0XHRcdGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcblx0XHRcdFx0XHRcdHZhciBuYW1lID0gZWxlbWVudC5zbG90VGFyZ2V0IHx8ICdcImRlZmF1bHRcIic7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0ZWxlbWVudC5wYXJlbnQgPSBjdXJyZW50UGFyZW50O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXVuYXJ5KSB7XG5cdFx0XHRcdFx0Y3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG5cdFx0XHRcdFx0c3RhY2sucHVzaChlbGVtZW50KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbmRQcmUoZWxlbWVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYXBwbHkgcG9zdC10cmFuc2Zvcm1zXG5cdFx0XHRcdGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3RUcmFuc2Zvcm1zLmxlbmd0aDsgaSQyKyspIHtcblx0XHRcdFx0XHRwb3N0VHJhbnNmb3Jtc1tpJDJdKGVsZW1lbnQsIG9wdGlvbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG5cdFx0XHRcdC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlXG5cdFx0XHRcdHZhciBlbGVtZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdFx0XHRcdHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcblx0XHRcdFx0aWYgKGxhc3ROb2RlICYmIGxhc3ROb2RlLnR5cGUgPT09IDMgJiYgbGFzdE5vZGUudGV4dCA9PT0gJyAnICYmICFpblByZSkge1xuXHRcdFx0XHRcdGVsZW1lbnQuY2hpbGRyZW4ucG9wKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gcG9wIHN0YWNrXG5cdFx0XHRcdHN0YWNrLmxlbmd0aCAtPSAxO1xuXHRcdFx0XHRjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cdFx0XHRcdGVuZFByZShlbGVtZW50KTtcblx0XHRcdH0sXG5cblx0XHRcdGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuXHRcdFx0XHRpZiAoIWN1cnJlbnRQYXJlbnQpIHtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcblx0XHRcdFx0XHRcdFx0d2Fybk9uY2UoXG5cdFx0XHRcdFx0XHRcdFx0J0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0Lidcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoKHRleHQgPSB0ZXh0LnRyaW0oKSkpIHtcblx0XHRcdFx0XHRcdFx0d2Fybk9uY2UoXG5cdFx0XHRcdFx0XHRcdFx0KFwidGV4dCBcXFwiXCIgKyB0ZXh0ICsgXCJcXFwiIG91dHNpZGUgcm9vdCBlbGVtZW50IHdpbGwgYmUgaWdub3JlZC5cIilcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG5cdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0XHRpZiAoaXNJRSAmJlxuXHRcdFx0XHRcdGN1cnJlbnRQYXJlbnQudGFnID09PSAndGV4dGFyZWEnICYmXG5cdFx0XHRcdFx0Y3VycmVudFBhcmVudC5hdHRyc01hcC5wbGFjZWhvbGRlciA9PT0gdGV4dFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuXHRcdFx0XHR0ZXh0ID0gaW5QcmUgfHwgdGV4dC50cmltKClcblx0XHRcdFx0XHQ/IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpXG5cdFx0XHRcdFx0Ly8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcblx0XHRcdFx0XHQ6IHByZXNlcnZlV2hpdGVzcGFjZSAmJiBjaGlsZHJlbi5sZW5ndGggPyAnICcgOiAnJztcblx0XHRcdFx0aWYgKHRleHQpIHtcblx0XHRcdFx0XHR2YXIgZXhwcmVzc2lvbjtcblx0XHRcdFx0XHRpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKGV4cHJlc3Npb24gPSBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykpKSB7XG5cdFx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKHtcblx0XHRcdFx0XHRcdFx0dHlwZTogMixcblx0XHRcdFx0XHRcdFx0ZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcblx0XHRcdFx0XHRcdFx0dGV4dDogdGV4dFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0ZXh0ICE9PSAnICcgfHwgIWNoaWxkcmVuLmxlbmd0aCB8fCBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXS50ZXh0ICE9PSAnICcpIHtcblx0XHRcdFx0XHRcdGNoaWxkcmVuLnB1c2goe1xuXHRcdFx0XHRcdFx0XHR0eXBlOiAzLFxuXHRcdFx0XHRcdFx0XHR0ZXh0OiB0ZXh0XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gcm9vdFxuXHR9XG5cblx0ZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcblx0XHRpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuXHRcdFx0ZWwucHJlID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG5cdFx0dmFyIGwgPSBlbC5hdHRyc0xpc3QubGVuZ3RoO1xuXHRcdGlmIChsKSB7XG5cdFx0XHR2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGF0dHJzW2ldID0ge1xuXHRcdFx0XHRcdG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuXHRcdFx0XHRcdHZhbHVlOiBKU09OLnN0cmluZ2lmeShlbC5hdHRyc0xpc3RbaV0udmFsdWUpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICghZWwucHJlKSB7XG5cdFx0XHQvLyBub24gcm9vdCBub2RlIGluIHByZSBibG9ja3Mgd2l0aCBubyBhdHRyaWJ1dGVzXG5cdFx0XHRlbC5wbGFpbiA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcblx0XHR2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcblx0XHRpZiAoZXhwKSB7XG5cdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG5cdFx0XHRcdHdhcm4kMihcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG5cdFx0XHR9XG5cdFx0XHRlbC5rZXkgPSBleHA7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJvY2Vzc1JlZiAoZWwpIHtcblx0XHR2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcblx0XHRpZiAocmVmKSB7XG5cdFx0XHRlbC5yZWYgPSByZWY7XG5cdFx0XHRlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG5cdFx0dmFyIGV4cDtcblx0XHRpZiAoKGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWZvcicpKSkge1xuXHRcdFx0dmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG5cdFx0XHRpZiAoIWluTWF0Y2gpIHtcblx0XHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQyKFxuXHRcdFx0XHRcdChcIkludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogXCIgKyBleHApXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZWwuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG5cdFx0XHR2YXIgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKTtcblx0XHRcdHZhciBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG5cdFx0XHRpZiAoaXRlcmF0b3JNYXRjaCkge1xuXHRcdFx0XHRlbC5hbGlhcyA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuXHRcdFx0XHRlbC5pdGVyYXRvcjEgPSBpdGVyYXRvck1hdGNoWzJdLnRyaW0oKTtcblx0XHRcdFx0aWYgKGl0ZXJhdG9yTWF0Y2hbM10pIHtcblx0XHRcdFx0XHRlbC5pdGVyYXRvcjIgPSBpdGVyYXRvck1hdGNoWzNdLnRyaW0oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwuYWxpYXMgPSBhbGlhcztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzSWYgKGVsKSB7XG5cdFx0dmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG5cdFx0aWYgKGV4cCkge1xuXHRcdFx0ZWwuaWYgPSBleHA7XG5cdFx0XHRhZGRJZkNvbmRpdGlvbihlbCwge1xuXHRcdFx0XHRleHA6IGV4cCxcblx0XHRcdFx0YmxvY2s6IGVsXG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnKSAhPSBudWxsKSB7XG5cdFx0XHRcdGVsLmVsc2UgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcblx0XHRcdGlmIChlbHNlaWYpIHtcblx0XHRcdFx0ZWwuZWxzZWlmID0gZWxzZWlmO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NJZkNvbmRpdGlvbnMgKGVsLCBwYXJlbnQpIHtcblx0XHR2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuXHRcdGlmIChwcmV2ICYmIHByZXYuaWYpIHtcblx0XHRcdGFkZElmQ29uZGl0aW9uKHByZXYsIHtcblx0XHRcdFx0ZXhwOiBlbC5lbHNlaWYsXG5cdFx0XHRcdGJsb2NrOiBlbFxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdhcm4kMihcblx0XHRcdFx0XCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG5cdFx0XHRcdFwidXNlZCBvbiBlbGVtZW50IDxcIiArIChlbC50YWcpICsgXCI+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLlwiXG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGZpbmRQcmV2RWxlbWVudCAoY2hpbGRyZW4pIHtcblx0XHR2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcblx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRpZiAoY2hpbGRyZW5baV0udHlwZSA9PT0gMSkge1xuXHRcdFx0XHRyZXR1cm4gY2hpbGRyZW5baV1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbltpXS50ZXh0ICE9PSAnICcpIHtcblx0XHRcdFx0XHR3YXJuJDIoXG5cdFx0XHRcdFx0XHRcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcblx0XHRcdFx0XHRcdFwid2lsbCBiZSBpZ25vcmVkLlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZHJlbi5wb3AoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRJZkNvbmRpdGlvbiAoZWwsIGNvbmRpdGlvbikge1xuXHRcdGlmICghZWwuaWZDb25kaXRpb25zKSB7XG5cdFx0XHRlbC5pZkNvbmRpdGlvbnMgPSBbXTtcblx0XHR9XG5cdFx0ZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NPbmNlIChlbCkge1xuXHRcdHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuXHRcdGlmIChvbmNlJCQxICE9IG51bGwpIHtcblx0XHRcdGVsLm9uY2UgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NTbG90IChlbCkge1xuXHRcdGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuXHRcdFx0ZWwuc2xvdE5hbWUgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ25hbWUnKTtcblx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5rZXkpIHtcblx0XHRcdFx0d2FybiQyKFxuXHRcdFx0XHRcdFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG5cdFx0XHRcdFx0XCJhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBcIiArXG5cdFx0XHRcdFx0XCJVc2UgdGhlIGtleSBvbiBhIHdyYXBwaW5nIGVsZW1lbnQgaW5zdGVhZC5cIlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc2xvdFRhcmdldCA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc2xvdCcpO1xuXHRcdFx0aWYgKHNsb3RUYXJnZXQpIHtcblx0XHRcdFx0ZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuXHRcdFx0XHRlbC5zbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2NvcGUnKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50IChlbCkge1xuXHRcdHZhciBiaW5kaW5nO1xuXHRcdGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcblx0XHRcdGVsLmNvbXBvbmVudCA9IGJpbmRpbmc7XG5cdFx0fVxuXHRcdGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuXHRcdFx0ZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NBdHRycyAoZWwpIHtcblx0XHR2YXIgbGlzdCA9IGVsLmF0dHJzTGlzdDtcblx0XHR2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuXHRcdGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG5cdFx0XHR2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG5cdFx0XHRpZiAoZGlyUkUudGVzdChuYW1lKSkge1xuXHRcdFx0XHQvLyBtYXJrIGVsZW1lbnQgYXMgZHluYW1pY1xuXHRcdFx0XHRlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG5cdFx0XHRcdC8vIG1vZGlmaWVyc1xuXHRcdFx0XHRtb2RpZmllcnMgPSBwYXJzZU1vZGlmaWVycyhuYW1lKTtcblx0XHRcdFx0aWYgKG1vZGlmaWVycykge1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UobW9kaWZpZXJSRSwgJycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcblx0XHRcdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKGJpbmRSRSwgJycpO1xuXHRcdFx0XHRcdHZhbHVlID0gcGFyc2VGaWx0ZXJzKHZhbHVlKTtcblx0XHRcdFx0XHRpc1Byb3AgPSBmYWxzZTtcblx0XHRcdFx0XHRpZiAobW9kaWZpZXJzKSB7XG5cdFx0XHRcdFx0XHRpZiAobW9kaWZpZXJzLnByb3ApIHtcblx0XHRcdFx0XHRcdFx0aXNQcm9wID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuXHRcdFx0XHRcdFx0XHRpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobW9kaWZpZXJzLmNhbWVsKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChtb2RpZmllcnMuc3luYykge1xuXHRcdFx0XHRcdFx0XHRhZGRIYW5kbGVyKFxuXHRcdFx0XHRcdFx0XHRcdGVsLFxuXHRcdFx0XHRcdFx0XHRcdChcInVwZGF0ZTpcIiArIChjYW1lbGl6ZShuYW1lKSkpLFxuXHRcdFx0XHRcdFx0XHRcdGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCBcIiRldmVudFwiKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaXNQcm9wIHx8IHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKSkge1xuXHRcdFx0XHRcdFx0YWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkgeyAvLyB2LW9uXG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUucmVwbGFjZShvblJFLCAnJyk7XG5cdFx0XHRcdFx0YWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMik7XG5cdFx0XHRcdH0gZWxzZSB7IC8vIG5vcm1hbCBkaXJlY3RpdmVzXG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuXHRcdFx0XHRcdC8vIHBhcnNlIGFyZ1xuXHRcdFx0XHRcdHZhciBhcmdNYXRjaCA9IG5hbWUubWF0Y2goYXJnUkUpO1xuXHRcdFx0XHRcdHZhciBhcmcgPSBhcmdNYXRjaCAmJiBhcmdNYXRjaFsxXTtcblx0XHRcdFx0XHRpZiAoYXJnKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gbmFtZS5zbGljZSgwLCAtKGFyZy5sZW5ndGggKyAxKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcblx0XHRcdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuXHRcdFx0XHRcdFx0Y2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBsaXRlcmFsIGF0dHJpYnV0ZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuXHRcdFx0XHRcdGlmIChleHByZXNzaW9uKSB7XG5cdFx0XHRcdFx0XHR3YXJuJDIoXG5cdFx0XHRcdFx0XHRcdG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuXHRcdFx0XHRcdFx0XHQnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcblx0XHRcdFx0XHRcdFx0J1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG5cdFx0XHRcdFx0XHRcdCdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsO1xuXHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcblx0XHR2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuXHRcdGlmIChtYXRjaCkge1xuXHRcdFx0dmFyIHJldCA9IHt9O1xuXHRcdFx0bWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcblx0XHRcdHJldHVybiByZXRcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG5cdFx0dmFyIG1hcCA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG5cdFx0XHRcdG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG5cdFx0XHQpIHtcblx0XHRcdFx0d2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSk7XG5cdFx0XHR9XG5cdFx0XHRtYXBbYXR0cnNbaV0ubmFtZV0gPSBhdHRyc1tpXS52YWx1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG5cbi8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuXHRmdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG5cdFx0cmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG5cdH1cblxuXHRmdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0ZWwudGFnID09PSAnc3R5bGUnIHx8XG5cdFx0XHQoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG5cdFx0XHRcdCFlbC5hdHRyc01hcC50eXBlIHx8XG5cdFx0XHRcdGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG5cdFx0XHQpKVxuXHRcdClcblx0fVxuXG5cdHZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xuXHR2YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcblx0XHR2YXIgcmVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGF0dHIgPSBhdHRyc1tpXTtcblx0XHRcdGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcblx0XHRcdFx0YXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuXHRcdFx0XHRyZXMucHVzaChhdHRyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcblx0XHR2YXIgX2VsID0gZWw7XG5cdFx0d2hpbGUgKF9lbCkge1xuXHRcdFx0aWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuXHRcdFx0XHR3YXJuJDIoXG5cdFx0XHRcdFx0XCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG5cdFx0XHRcdFx0XCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuXHRcdFx0XHRcdFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuXHRcdFx0XHRcdFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuXHRcdFx0XHRcdFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCJcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdF9lbCA9IF9lbC5wYXJlbnQ7XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0dmFyIGlzU3RhdGljS2V5O1xuXHR2YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG5cdHZhciBnZW5TdGF0aWNLZXlzQ2FjaGVkID0gY2FjaGVkKGdlblN0YXRpY0tleXMkMSk7XG5cblx0LyoqXG5cdCAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG5cdCAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2Zcblx0ICogdGhlIERPTSB0aGF0IG5ldmVyIG5lZWRzIHRvIGNoYW5nZS5cblx0ICpcblx0ICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG5cdCAqXG5cdCAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cblx0ICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuXHQgKiAyLiBDb21wbGV0ZWx5IHNraXAgdGhlbSBpbiB0aGUgcGF0Y2hpbmcgcHJvY2Vzcy5cblx0ICovXG5cdGZ1bmN0aW9uIG9wdGltaXplIChyb290LCBvcHRpb25zKSB7XG5cdFx0aWYgKCFyb290KSB7IHJldHVybiB9XG5cdFx0aXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG5cdFx0aXNQbGF0Zm9ybVJlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuXHRcdC8vIGZpcnN0IHBhc3M6IG1hcmsgYWxsIG5vbi1zdGF0aWMgbm9kZXMuXG5cdFx0bWFya1N0YXRpYyQxKHJvb3QpO1xuXHRcdC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cblx0XHRtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyQxIChrZXlzKSB7XG5cdFx0cmV0dXJuIG1ha2VNYXAoXG5cdFx0XHQndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xuXHRcdFx0KGtleXMgPyAnLCcgKyBrZXlzIDogJycpXG5cdFx0KVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFya1N0YXRpYyQxIChub2RlKSB7XG5cdFx0bm9kZS5zdGF0aWMgPSBpc1N0YXRpYyhub2RlKTtcblx0XHRpZiAobm9kZS50eXBlID09PSAxKSB7XG5cdFx0XHQvLyBkbyBub3QgbWFrZSBjb21wb25lbnQgc2xvdCBjb250ZW50IHN0YXRpYy4gdGhpcyBhdm9pZHNcblx0XHRcdC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcblx0XHRcdC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcblx0XHRcdGlmIChcblx0XHRcdFx0IWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcblx0XHRcdFx0bm9kZS50YWcgIT09ICdzbG90JyAmJlxuXHRcdFx0XHRub2RlLmF0dHJzTWFwWydpbmxpbmUtdGVtcGxhdGUnXSA9PSBudWxsXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG5cdFx0XHRcdG1hcmtTdGF0aWMkMShjaGlsZCk7XG5cdFx0XHRcdGlmICghY2hpbGQuc3RhdGljKSB7XG5cdFx0XHRcdFx0bm9kZS5zdGF0aWMgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuXHRcdGlmIChub2RlLnR5cGUgPT09IDEpIHtcblx0XHRcdGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcblx0XHRcdFx0bm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG5cdFx0XHR9XG5cdFx0XHQvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuXHRcdFx0Ly8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcblx0XHRcdC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cblx0XHRcdGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuXHRcdFx0XHRcdG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG5cdFx0XHRcdFx0bm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0bm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmIChub2RlLmNoaWxkcmVuKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG5cdFx0XHRcdHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2Nrcyhub2RlLmlmQ29uZGl0aW9ucywgaXNJbkZvcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gd2Fsa1Rocm91Z2hDb25kaXRpb25zQmxvY2tzIChjb25kaXRpb25CbG9ja3MsIGlzSW5Gb3IpIHtcblx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gY29uZGl0aW9uQmxvY2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRtYXJrU3RhdGljUm9vdHMoY29uZGl0aW9uQmxvY2tzW2ldLmJsb2NrLCBpc0luRm9yKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpc1N0YXRpYyAobm9kZSkge1xuXHRcdGlmIChub2RlLnR5cGUgPT09IDIpIHsgLy8gZXhwcmVzc2lvblxuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0fVxuXHRcdGlmIChub2RlLnR5cGUgPT09IDMpIHsgLy8gdGV4dFxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0cmV0dXJuICEhKG5vZGUucHJlIHx8IChcblx0XHRcdCFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3Ncblx0XHRcdCFub2RlLmlmICYmICFub2RlLmZvciAmJiAvLyBub3Qgdi1pZiBvciB2LWZvciBvciB2LWVsc2Vcblx0XHRcdCFpc0J1aWx0SW5UYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGJ1aWx0LWluXG5cdFx0XHRpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuXHRcdFx0IWlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yKG5vZGUpICYmXG5cdFx0XHRPYmplY3Qua2V5cyhub2RlKS5ldmVyeShpc1N0YXRpY0tleSlcblx0XHQpKVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IgKG5vZGUpIHtcblx0XHR3aGlsZSAobm9kZS5wYXJlbnQpIHtcblx0XHRcdG5vZGUgPSBub2RlLnBhcmVudDtcblx0XHRcdGlmIChub2RlLnRhZyAhPT0gJ3RlbXBsYXRlJykge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblx0XHRcdGlmIChub2RlLmZvcikge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG5cdHZhciBzaW1wbGVQYXRoUkUgPSAvXlxccypbQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWycuKj8nXXxcXFtcIi4qP1wiXXxcXFtcXGQrXXxcXFtbQS1aYS16XyRdW1xcdyRdKl0pKlxccyokLztcblxuLy8ga2V5Q29kZSBhbGlhc2VzXG5cdHZhciBrZXlDb2RlcyA9IHtcblx0XHRlc2M6IDI3LFxuXHRcdHRhYjogOSxcblx0XHRlbnRlcjogMTMsXG5cdFx0c3BhY2U6IDMyLFxuXHRcdHVwOiAzOCxcblx0XHRsZWZ0OiAzNyxcblx0XHRyaWdodDogMzksXG5cdFx0ZG93bjogNDAsXG5cdFx0J2RlbGV0ZSc6IFs4LCA0Nl1cblx0fTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2Vcblx0dmFyIGdlbkd1YXJkID0gZnVuY3Rpb24gKGNvbmRpdGlvbikgeyByZXR1cm4gKFwiaWYoXCIgKyBjb25kaXRpb24gKyBcIilyZXR1cm4gbnVsbDtcIik7IH07XG5cblx0dmFyIG1vZGlmaWVyQ29kZSA9IHtcblx0XHRzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG5cdFx0cHJldmVudDogJyRldmVudC5wcmV2ZW50RGVmYXVsdCgpOycsXG5cdFx0c2VsZjogZ2VuR3VhcmQoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxcblx0XHRjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcblx0XHRzaGlmdDogZ2VuR3VhcmQoXCIhJGV2ZW50LnNoaWZ0S2V5XCIpLFxuXHRcdGFsdDogZ2VuR3VhcmQoXCIhJGV2ZW50LmFsdEtleVwiKSxcblx0XHRtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcblx0XHRsZWZ0OiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwXCIpLFxuXHRcdG1pZGRsZTogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxcblx0XHRyaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxuXHR9O1xuXG5cdGZ1bmN0aW9uIGdlbkhhbmRsZXJzIChcblx0XHRldmVudHMsXG5cdFx0aXNOYXRpdmUsXG5cdFx0d2FyblxuXHQpIHtcblx0XHR2YXIgcmVzID0gaXNOYXRpdmUgPyAnbmF0aXZlT246eycgOiAnb246eyc7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBldmVudHMpIHtcblx0XHRcdHZhciBoYW5kbGVyID0gZXZlbnRzW25hbWVdO1xuXHRcdFx0Ly8gIzUzMzA6IHdhcm4gY2xpY2sucmlnaHQsIHNpbmNlIHJpZ2h0IGNsaWNrcyBkbyBub3QgYWN0dWFsbHkgZmlyZSBjbGljayBldmVudHMuXG5cdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcblx0XHRcdFx0bmFtZSA9PT0gJ2NsaWNrJyAmJlxuXHRcdFx0XHRoYW5kbGVyICYmIGhhbmRsZXIubW9kaWZpZXJzICYmIGhhbmRsZXIubW9kaWZpZXJzLnJpZ2h0XG5cdFx0XHQpIHtcblx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcIlVzZSBcXFwiY29udGV4dG1lbnVcXFwiIGluc3RlYWQgb2YgXFxcImNsaWNrLnJpZ2h0XFxcIiBzaW5jZSByaWdodCBjbGlja3MgXCIgK1xuXHRcdFx0XHRcdFwiZG8gbm90IGFjdHVhbGx5IGZpcmUgXFxcImNsaWNrXFxcIiBldmVudHMuXCJcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKSkgKyBcIixcIjtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnfSdcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuXHRcdG5hbWUsXG5cdFx0aGFuZGxlclxuXHQpIHtcblx0XHRpZiAoIWhhbmRsZXIpIHtcblx0XHRcdHJldHVybiAnZnVuY3Rpb24oKXt9J1xuXHRcdH1cblxuXHRcdGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG5cdFx0XHRyZXR1cm4gKFwiW1wiICsgKGhhbmRsZXIubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBnZW5IYW5kbGVyKG5hbWUsIGhhbmRsZXIpOyB9KS5qb2luKCcsJykpICsgXCJdXCIpXG5cdFx0fVxuXG5cdFx0dmFyIGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXHRcdHZhciBpc0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGZuRXhwUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblxuXHRcdGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcblx0XHRcdHJldHVybiBpc01ldGhvZFBhdGggfHwgaXNGdW5jdGlvbkV4cHJlc3Npb25cblx0XHRcdFx0PyBoYW5kbGVyLnZhbHVlXG5cdFx0XHRcdDogKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjb2RlID0gJyc7XG5cdFx0XHR2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG5cdFx0XHR2YXIga2V5cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGhhbmRsZXIubW9kaWZpZXJzKSB7XG5cdFx0XHRcdGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuXHRcdFx0XHRcdGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcblx0XHRcdFx0XHQvLyBsZWZ0L3JpZ2h0XG5cdFx0XHRcdFx0aWYgKGtleUNvZGVzW2tleV0pIHtcblx0XHRcdFx0XHRcdGtleXMucHVzaChrZXkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGtleXMubGVuZ3RoKSB7XG5cdFx0XHRcdGNvZGUgKz0gZ2VuS2V5RmlsdGVyKGtleXMpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcblx0XHRcdGlmIChnZW5Nb2RpZmllckNvZGUpIHtcblx0XHRcdFx0Y29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcblx0XHRcdFx0PyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuXHRcdFx0XHQ6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG5cdFx0XHRcdD8gKFwiKFwiICsgKGhhbmRsZXIudmFsdWUpICsgXCIpKCRldmVudClcIilcblx0XHRcdFx0OiBoYW5kbGVyLnZhbHVlO1xuXHRcdFx0cmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyBjb2RlICsgaGFuZGxlckNvZGUgKyBcIn1cIilcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5LZXlGaWx0ZXIgKGtleXMpIHtcblx0XHRyZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG5cdFx0dmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuXHRcdGlmIChrZXlWYWwpIHtcblx0XHRcdHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuXHRcdH1cblx0XHR2YXIgYWxpYXMgPSBrZXlDb2Rlc1trZXldO1xuXHRcdHJldHVybiAoXCJfaygkZXZlbnQua2V5Q29kZSxcIiArIChKU09OLnN0cmluZ2lmeShrZXkpKSArIChhbGlhcyA/ICcsJyArIEpTT04uc3RyaW5naWZ5KGFsaWFzKSA6ICcnKSArIFwiKVwiKVxuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG5cdFx0ZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuXHRcdFx0cmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnByb3AgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG5cdFx0fTtcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBiYXNlRGlyZWN0aXZlcyA9IHtcblx0XHRiaW5kOiBiaW5kJDEsXG5cdFx0Y2xvYWs6IG5vb3Bcblx0fTtcblxuXHQvKiAgKi9cblxuLy8gY29uZmlndXJhYmxlIHN0YXRlXG5cdHZhciB3YXJuJDM7XG5cdHZhciB0cmFuc2Zvcm1zJDE7XG5cdHZhciBkYXRhR2VuRm5zO1xuXHR2YXIgcGxhdGZvcm1EaXJlY3RpdmVzJDE7XG5cdHZhciBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMTtcblx0dmFyIHN0YXRpY1JlbmRlckZucztcblx0dmFyIG9uY2VDb3VudDtcblx0dmFyIGN1cnJlbnRPcHRpb25zO1xuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlIChcblx0XHRhc3QsXG5cdFx0b3B0aW9uc1xuXHQpIHtcblx0XHQvLyBzYXZlIHByZXZpb3VzIHN0YXRpY1JlbmRlckZucyBzbyBnZW5lcmF0ZSBjYWxscyBjYW4gYmUgbmVzdGVkXG5cdFx0dmFyIHByZXZTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cdFx0dmFyIGN1cnJlbnRTdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnMgPSBbXTtcblx0XHR2YXIgcHJldk9uY2VDb3VudCA9IG9uY2VDb3VudDtcblx0XHRvbmNlQ291bnQgPSAwO1xuXHRcdGN1cnJlbnRPcHRpb25zID0gb3B0aW9ucztcblx0XHR3YXJuJDMgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cdFx0dHJhbnNmb3JtcyQxID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICd0cmFuc2Zvcm1Db2RlJyk7XG5cdFx0ZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuXHRcdHBsYXRmb3JtRGlyZWN0aXZlcyQxID0gb3B0aW9ucy5kaXJlY3RpdmVzIHx8IHt9O1xuXHRcdGlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuXHRcdHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QpIDogJ19jKFwiZGl2XCIpJztcblx0XHRzdGF0aWNSZW5kZXJGbnMgPSBwcmV2U3RhdGljUmVuZGVyRm5zO1xuXHRcdG9uY2VDb3VudCA9IHByZXZPbmNlQ291bnQ7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuXHRcdFx0c3RhdGljUmVuZGVyRm5zOiBjdXJyZW50U3RhdGljUmVuZGVyRm5zXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuRWxlbWVudCAoZWwpIHtcblx0XHRpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG5cdFx0XHRyZXR1cm4gZ2VuU3RhdGljKGVsKVxuXHRcdH0gZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuXHRcdFx0cmV0dXJuIGdlbk9uY2UoZWwpXG5cdFx0fSBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuXHRcdFx0cmV0dXJuIGdlbkZvcihlbClcblx0XHR9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuXHRcdFx0cmV0dXJuIGdlbklmKGVsKVxuXHRcdH0gZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG5cdFx0fSBlbHNlIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuXHRcdFx0cmV0dXJuIGdlblNsb3QoZWwpXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGNvbXBvbmVudCBvciBlbGVtZW50XG5cdFx0XHR2YXIgY29kZTtcblx0XHRcdGlmIChlbC5jb21wb25lbnQpIHtcblx0XHRcdFx0Y29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBkYXRhID0gZWwucGxhaW4gPyB1bmRlZmluZWQgOiBnZW5EYXRhKGVsKTtcblxuXHRcdFx0XHR2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG5cdFx0XHRcdGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG5cdFx0XHR9XG5cdFx0XHQvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zJDEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29kZSA9IHRyYW5zZm9ybXMkMVtpXShlbCwgY29kZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29kZVxuXHRcdH1cblx0fVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuXHRmdW5jdGlvbiBnZW5TdGF0aWMgKGVsKSB7XG5cdFx0ZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcblx0XHRzdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgKyBcIn1cIikpO1xuXHRcdHJldHVybiAoXCJfbShcIiArIChzdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG5cdH1cblxuLy8gdi1vbmNlXG5cdGZ1bmN0aW9uIGdlbk9uY2UgKGVsKSB7XG5cdFx0ZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG5cdFx0aWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuXHRcdFx0cmV0dXJuIGdlbklmKGVsKVxuXHRcdH0gZWxzZSBpZiAoZWwuc3RhdGljSW5Gb3IpIHtcblx0XHRcdHZhciBrZXkgPSAnJztcblx0XHRcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG5cdFx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRcdGlmIChwYXJlbnQuZm9yKSB7XG5cdFx0XHRcdFx0a2V5ID0gcGFyZW50LmtleTtcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWtleSkge1xuXHRcdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDMoXG5cdFx0XHRcdFx0XCJ2LW9uY2UgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgdi1mb3IgdGhhdCBpcyBrZXllZC4gXCJcblx0XHRcdFx0KTtcblx0XHRcdFx0cmV0dXJuIGdlbkVsZW1lbnQoZWwpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gKFwiX28oXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCIsXCIgKyAob25jZUNvdW50KyspICsgKGtleSA/IChcIixcIiArIGtleSkgOiBcIlwiKSArIFwiKVwiKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZ2VuU3RhdGljKGVsKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbklmIChlbCkge1xuXHRcdGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG5cdFx0cmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSlcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoY29uZGl0aW9ucykge1xuXHRcdGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiAnX2UoKSdcblx0XHR9XG5cblx0XHR2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuXHRcdGlmIChjb25kaXRpb24uZXhwKSB7XG5cdFx0XHRyZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucykpKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFwiXCIgKyAoZ2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spKSlcblx0XHR9XG5cblx0XHQvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG5cdFx0ZnVuY3Rpb24gZ2VuVGVybmFyeUV4cCAoZWwpIHtcblx0XHRcdHJldHVybiBlbC5vbmNlID8gZ2VuT25jZShlbCkgOiBnZW5FbGVtZW50KGVsKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbkZvciAoZWwpIHtcblx0XHR2YXIgZXhwID0gZWwuZm9yO1xuXHRcdHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuXHRcdHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcblx0XHR2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cblx0XHRpZiAoXG5cdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuXHRcdFx0bWF5YmVDb21wb25lbnQoZWwpICYmIGVsLnRhZyAhPT0gJ3Nsb3QnICYmIGVsLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJiAhZWwua2V5XG5cdFx0KSB7XG5cdFx0XHR3YXJuJDMoXG5cdFx0XHRcdFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LWZvcj1cXFwiXCIgKyBhbGlhcyArIFwiIGluIFwiICsgZXhwICsgXCJcXFwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggXCIgK1xuXHRcdFx0XHRcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcblx0XHRcdFx0XCJTZWUgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvbGlzdC5odG1sI2tleSBmb3IgbW9yZSBpbmZvLlwiLFxuXHRcdFx0XHR0cnVlIC8qIHRpcCAqL1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cblx0XHRyZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuXHRcdFx0XCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcblx0XHRcdFwicmV0dXJuIFwiICsgKGdlbkVsZW1lbnQoZWwpKSArXG5cdFx0XHQnfSknXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuXHRcdHZhciBkYXRhID0gJ3snO1xuXG5cdFx0Ly8gZGlyZWN0aXZlcyBmaXJzdC5cblx0XHQvLyBkaXJlY3RpdmVzIG1heSBtdXRhdGUgdGhlIGVsJ3Mgb3RoZXIgcHJvcGVydGllcyBiZWZvcmUgdGhleSBhcmUgZ2VuZXJhdGVkLlxuXHRcdHZhciBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCk7XG5cdFx0aWYgKGRpcnMpIHsgZGF0YSArPSBkaXJzICsgJywnOyB9XG5cblx0XHQvLyBrZXlcblx0XHRpZiAoZWwua2V5KSB7XG5cdFx0XHRkYXRhICs9IFwia2V5OlwiICsgKGVsLmtleSkgKyBcIixcIjtcblx0XHR9XG5cdFx0Ly8gcmVmXG5cdFx0aWYgKGVsLnJlZikge1xuXHRcdFx0ZGF0YSArPSBcInJlZjpcIiArIChlbC5yZWYpICsgXCIsXCI7XG5cdFx0fVxuXHRcdGlmIChlbC5yZWZJbkZvcikge1xuXHRcdFx0ZGF0YSArPSBcInJlZkluRm9yOnRydWUsXCI7XG5cdFx0fVxuXHRcdC8vIHByZVxuXHRcdGlmIChlbC5wcmUpIHtcblx0XHRcdGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcblx0XHR9XG5cdFx0Ly8gcmVjb3JkIG9yaWdpbmFsIHRhZyBuYW1lIGZvciBjb21wb25lbnRzIHVzaW5nIFwiaXNcIiBhdHRyaWJ1dGVcblx0XHRpZiAoZWwuY29tcG9uZW50KSB7XG5cdFx0XHRkYXRhICs9IFwidGFnOlxcXCJcIiArIChlbC50YWcpICsgXCJcXFwiLFwiO1xuXHRcdH1cblx0XHQvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZGF0YSArPSBkYXRhR2VuRm5zW2ldKGVsKTtcblx0XHR9XG5cdFx0Ly8gYXR0cmlidXRlc1xuXHRcdGlmIChlbC5hdHRycykge1xuXHRcdFx0ZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuXHRcdH1cblx0XHQvLyBET00gcHJvcHNcblx0XHRpZiAoZWwucHJvcHMpIHtcblx0XHRcdGRhdGEgKz0gXCJkb21Qcm9wczp7XCIgKyAoZ2VuUHJvcHMoZWwucHJvcHMpKSArIFwifSxcIjtcblx0XHR9XG5cdFx0Ly8gZXZlbnQgaGFuZGxlcnNcblx0XHRpZiAoZWwuZXZlbnRzKSB7XG5cdFx0XHRkYXRhICs9IChnZW5IYW5kbGVycyhlbC5ldmVudHMsIGZhbHNlLCB3YXJuJDMpKSArIFwiLFwiO1xuXHRcdH1cblx0XHRpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG5cdFx0XHRkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHdhcm4kMykpICsgXCIsXCI7XG5cdFx0fVxuXHRcdC8vIHNsb3QgdGFyZ2V0XG5cdFx0aWYgKGVsLnNsb3RUYXJnZXQpIHtcblx0XHRcdGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG5cdFx0fVxuXHRcdC8vIHNjb3BlZCBzbG90c1xuXHRcdGlmIChlbC5zY29wZWRTbG90cykge1xuXHRcdFx0ZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwuc2NvcGVkU2xvdHMpKSArIFwiLFwiO1xuXHRcdH1cblx0XHQvLyBjb21wb25lbnQgdi1tb2RlbFxuXHRcdGlmIChlbC5tb2RlbCkge1xuXHRcdFx0ZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuXHRcdH1cblx0XHQvLyBpbmxpbmUtdGVtcGxhdGVcblx0XHRpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcblx0XHRcdHZhciBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsKTtcblx0XHRcdGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuXHRcdFx0XHRkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuXHRcdC8vIHYtYmluZCBkYXRhIHdyYXBcblx0XHRpZiAoZWwud3JhcERhdGEpIHtcblx0XHRcdGRhdGEgPSBlbC53cmFwRGF0YShkYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGFcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMgKGVsKSB7XG5cdFx0dmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuXHRcdGlmICghZGlycykgeyByZXR1cm4gfVxuXHRcdHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcblx0XHR2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuXHRcdHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuXHRcdGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0ZGlyID0gZGlyc1tpXTtcblx0XHRcdG5lZWRSdW50aW1lID0gdHJ1ZTtcblx0XHRcdHZhciBnZW4gPSBwbGF0Zm9ybURpcmVjdGl2ZXMkMVtkaXIubmFtZV0gfHwgYmFzZURpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuXHRcdFx0aWYgKGdlbikge1xuXHRcdFx0XHQvLyBjb21waWxlLXRpbWUgZGlyZWN0aXZlIHRoYXQgbWFuaXB1bGF0ZXMgQVNULlxuXHRcdFx0XHQvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG5cdFx0XHRcdG5lZWRSdW50aW1lID0gISFnZW4oZWwsIGRpciwgd2FybiQzKTtcblx0XHRcdH1cblx0XHRcdGlmIChuZWVkUnVudGltZSkge1xuXHRcdFx0XHRoYXNSdW50aW1lID0gdHJ1ZTtcblx0XHRcdFx0cmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChoYXNSdW50aW1lKSB7XG5cdFx0XHRyZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCkge1xuXHRcdHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcblx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgKFxuXHRcdFx0XHRlbC5jaGlsZHJlbi5sZW5ndGggPiAxIHx8IGFzdC50eXBlICE9PSAxXG5cdFx0XHQpKSB7XG5cdFx0XHR3YXJuJDMoJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicpO1xuXHRcdH1cblx0XHRpZiAoYXN0LnR5cGUgPT09IDEpIHtcblx0XHRcdHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIGN1cnJlbnRPcHRpb25zKTtcblx0XHRcdHJldHVybiAoXCJpbmxpbmVUZW1wbGF0ZTp7cmVuZGVyOmZ1bmN0aW9uKCl7XCIgKyAoaW5saW5lUmVuZGVyRm5zLnJlbmRlcikgKyBcIn0sc3RhdGljUmVuZGVyRm5zOltcIiArIChpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkgeyByZXR1cm4gKFwiZnVuY3Rpb24oKXtcIiArIGNvZGUgKyBcIn1cIik7IH0pLmpvaW4oJywnKSkgKyBcIl19XCIpXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMgKHNsb3RzKSB7XG5cdFx0cmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIChPYmplY3Qua2V5cyhzbG90cykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGdlblNjb3BlZFNsb3Qoa2V5LCBzbG90c1trZXldKTsgfSkuam9pbignLCcpKSArIFwiXSlcIilcblx0fVxuXG5cdGZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKGtleSwgZWwpIHtcblx0XHRpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcblx0XHRcdHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwpXG5cdFx0fVxuXHRcdHJldHVybiBcIntrZXk6XCIgKyBrZXkgKyBcIixmbjpmdW5jdGlvbihcIiArIChTdHJpbmcoZWwuYXR0cnNNYXAuc2NvcGUpKSArIFwiKXtcIiArXG5cdFx0XHRcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcblx0XHRcdFx0PyBnZW5DaGlsZHJlbihlbCkgfHwgJ3ZvaWQgMCdcblx0XHRcdFx0OiBnZW5FbGVtZW50KGVsKSkgKyBcIn19XCJcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbkZvclNjb3BlZFNsb3QgKGtleSwgZWwpIHtcblx0XHR2YXIgZXhwID0gZWwuZm9yO1xuXHRcdHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuXHRcdHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcblx0XHR2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cdFx0ZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG5cdFx0cmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcblx0XHRcdFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG5cdFx0XHRcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwpKSArXG5cdFx0XHQnfSknXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5DaGlsZHJlbiAoZWwsIGNoZWNrU2tpcCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdHZhciBlbCQxID0gY2hpbGRyZW5bMF07XG5cdFx0XHQvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3Jcblx0XHRcdGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDEgJiZcblx0XHRcdFx0ZWwkMS5mb3IgJiZcblx0XHRcdFx0ZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcblx0XHRcdFx0ZWwkMS50YWcgIT09ICdzbG90J1xuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiBnZW5FbGVtZW50KGVsJDEpXG5cdFx0XHR9XG5cdFx0XHR2YXIgbm9ybWFsaXphdGlvblR5cGUgPSBjaGVja1NraXAgPyBnZXROb3JtYWxpemF0aW9uVHlwZShjaGlsZHJlbikgOiAwO1xuXHRcdFx0cmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZ2VuTm9kZSkuam9pbignLCcpKSArIFwiXVwiICsgKG5vcm1hbGl6YXRpb25UeXBlID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUpIDogJycpKVxuXHRcdH1cblx0fVxuXG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuXHRmdW5jdGlvbiBnZXROb3JtYWxpemF0aW9uVHlwZSAoY2hpbGRyZW4pIHtcblx0XHR2YXIgcmVzID0gMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZWwgPSBjaGlsZHJlbltpXTtcblx0XHRcdGlmIChlbC50eXBlICE9PSAxKSB7XG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHR9XG5cdFx0XHRpZiAobmVlZHNOb3JtYWxpemF0aW9uKGVsKSB8fFxuXHRcdFx0XHQoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBuZWVkc05vcm1hbGl6YXRpb24oYy5ibG9jayk7IH0pKSkge1xuXHRcdFx0XHRyZXMgPSAyO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuXHRcdFx0XHQoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG5cdFx0XHRcdHJlcyA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcblx0XHRyZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG5cdH1cblxuXHRmdW5jdGlvbiBtYXliZUNvbXBvbmVudCAoZWwpIHtcblx0XHRyZXR1cm4gIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyQxKGVsLnRhZylcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUpIHtcblx0XHRpZiAobm9kZS50eXBlID09PSAxKSB7XG5cdFx0XHRyZXR1cm4gZ2VuRWxlbWVudChub2RlKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZ2VuVGV4dChub2RlKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcblx0XHRyZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG5cdFx0XHQ/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG5cdFx0XHQ6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcblx0fVxuXG5cdGZ1bmN0aW9uIGdlblNsb3QgKGVsKSB7XG5cdFx0dmFyIHNsb3ROYW1lID0gZWwuc2xvdE5hbWUgfHwgJ1wiZGVmYXVsdFwiJztcblx0XHR2YXIgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCk7XG5cdFx0dmFyIHJlcyA9IFwiX3QoXCIgKyBzbG90TmFtZSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKTtcblx0XHR2YXIgYXR0cnMgPSBlbC5hdHRycyAmJiAoXCJ7XCIgKyAoZWwuYXR0cnMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiAoKGNhbWVsaXplKGEubmFtZSkpICsgXCI6XCIgKyAoYS52YWx1ZSkpOyB9KS5qb2luKCcsJykpICsgXCJ9XCIpO1xuXHRcdHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuXHRcdGlmICgoYXR0cnMgfHwgYmluZCQkMSkgJiYgIWNoaWxkcmVuKSB7XG5cdFx0XHRyZXMgKz0gXCIsbnVsbFwiO1xuXHRcdH1cblx0XHRpZiAoYXR0cnMpIHtcblx0XHRcdHJlcyArPSBcIixcIiArIGF0dHJzO1xuXHRcdH1cblx0XHRpZiAoYmluZCQkMSkge1xuXHRcdFx0cmVzICs9IChhdHRycyA/ICcnIDogJyxudWxsJykgKyBcIixcIiArIGJpbmQkJDE7XG5cdFx0fVxuXHRcdHJldHVybiByZXMgKyAnKSdcblx0fVxuXG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5cdGZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoY29tcG9uZW50TmFtZSwgZWwpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgdHJ1ZSk7XG5cdFx0cmV0dXJuIChcIl9jKFwiICsgY29tcG9uZW50TmFtZSArIFwiLFwiICsgKGdlbkRhdGEoZWwpKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiKVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG5cdFx0dmFyIHJlcyA9ICcnO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwcm9wID0gcHJvcHNbaV07XG5cdFx0XHRyZXMgKz0gXCJcXFwiXCIgKyAocHJvcC5uYW1lKSArIFwiXFxcIjpcIiArICh0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSkpICsgXCIsXCI7XG5cdFx0fVxuXHRcdHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG5cdH1cblxuLy8gIzM4OTUsICM0MjY4XG5cdGZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuXHRcdHJldHVybiB0ZXh0XG5cdFx0XHQucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4Jylcblx0XHRcdC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxuXHR9XG5cblx0LyogICovXG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG5cdHZhciBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuXHRcdFx0J2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG5cdFx0XHQnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuXHRcdFx0J2V4dGVuZHMsZmluYWxseSxjb250aW51ZSxkZWJ1Z2dlcixmdW5jdGlvbixhcmd1bWVudHMnXG5cdFx0KS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcblx0dmFyIHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG5cdFx0XHQnZGVsZXRlLHR5cGVvZix2b2lkJ1xuXHRcdCkuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBjaGVjayB2YWxpZCBpZGVudGlmaWVyIGZvciB2LWZvclxuXHR2YXIgaWRlbnRSRSA9IC9bQS1aYS16XyRdW1xcdyRdKi87XG5cbi8vIHN0cmlwIHN0cmluZ3MgaW4gZXhwcmVzc2lvbnNcblx0dmFyIHN0cmlwU3RyaW5nUkUgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcblxuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcblx0ZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcblx0XHR2YXIgZXJyb3JzID0gW107XG5cdFx0aWYgKGFzdCkge1xuXHRcdFx0Y2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVycm9yc1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tOb2RlIChub2RlLCBlcnJvcnMpIHtcblx0XHRpZiAobm9kZS50eXBlID09PSAxKSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcblx0XHRcdFx0aWYgKGRpclJFLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRcdFx0aWYgKG5hbWUgPT09ICd2LWZvcicpIHtcblx0XHRcdFx0XHRcdFx0Y2hlY2tGb3Iobm9kZSwgKFwidi1mb3I9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIGVycm9ycyk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuXHRcdFx0XHRcdFx0XHRjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG5vZGUuY2hpbGRyZW4pIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y2hlY2tOb2RlKG5vZGUuY2hpbGRyZW5baV0sIGVycm9ycyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuXHRcdFx0Y2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCBlcnJvcnMpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG5cdFx0dmFyIHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG5cdFx0dmFyIGtleXdvcmRNYXRjaCA9IHN0aXBwZWQubWF0Y2godW5hcnlPcGVyYXRvcnNSRSk7XG5cdFx0aWYgKGtleXdvcmRNYXRjaCAmJiBzdGlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG5cdFx0XHRlcnJvcnMucHVzaChcblx0XHRcdFx0XCJhdm9pZCB1c2luZyBKYXZhU2NyaXB0IHVuYXJ5IG9wZXJhdG9yIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcblx0XHRcdFx0XCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0Y2hlY2tFeHByZXNzaW9uKGV4cCwgdGV4dCwgZXJyb3JzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrRm9yIChub2RlLCB0ZXh0LCBlcnJvcnMpIHtcblx0XHRjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIGVycm9ycyk7XG5cdFx0Y2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG5cdFx0Y2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xuXHRcdGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrSWRlbnRpZmllciAoaWRlbnQsIHR5cGUsIHRleHQsIGVycm9ycykge1xuXHRcdGlmICh0eXBlb2YgaWRlbnQgPT09ICdzdHJpbmcnICYmICFpZGVudFJFLnRlc3QoaWRlbnQpKSB7XG5cdFx0XHRlcnJvcnMucHVzaCgoXCJpbnZhbGlkIFwiICsgdHlwZSArIFwiIFxcXCJcIiArIGlkZW50ICsgXCJcXFwiIGluIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbiAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcblx0XHR0cnkge1xuXHRcdFx0bmV3IEZ1bmN0aW9uKChcInJldHVybiBcIiArIGV4cCkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG5cdFx0XHRpZiAoa2V5d29yZE1hdGNoKSB7XG5cdFx0XHRcdGVycm9ycy5wdXNoKFxuXHRcdFx0XHRcdFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcblx0XHRcdFx0XHRcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlcnJvcnMucHVzaCgoXCJpbnZhbGlkIGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGJhc2VDb21waWxlIChcblx0XHR0ZW1wbGF0ZSxcblx0XHRvcHRpb25zXG5cdCkge1xuXHRcdHZhciBhc3QgPSBwYXJzZSh0ZW1wbGF0ZS50cmltKCksIG9wdGlvbnMpO1xuXHRcdG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG5cdFx0dmFyIGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRhc3Q6IGFzdCxcblx0XHRcdHJlbmRlcjogY29kZS5yZW5kZXIsXG5cdFx0XHRzdGF0aWNSZW5kZXJGbnM6IGNvZGUuc3RhdGljUmVuZGVyRm5zXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuXHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0ZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcblx0XHRcdHJldHVybiBub29wXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXIgKGJhc2VPcHRpb25zKSB7XG5cdFx0dmFyIGZ1bmN0aW9uQ29tcGlsZUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRcdGZ1bmN0aW9uIGNvbXBpbGUgKFxuXHRcdFx0dGVtcGxhdGUsXG5cdFx0XHRvcHRpb25zXG5cdFx0KSB7XG5cdFx0XHR2YXIgZmluYWxPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucyk7XG5cdFx0XHR2YXIgZXJyb3JzID0gW107XG5cdFx0XHR2YXIgdGlwcyA9IFtdO1xuXHRcdFx0ZmluYWxPcHRpb25zLndhcm4gPSBmdW5jdGlvbiAobXNnLCB0aXAkJDEpIHtcblx0XHRcdFx0KHRpcCQkMSA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcblx0XHRcdH07XG5cblx0XHRcdGlmIChvcHRpb25zKSB7XG5cdFx0XHRcdC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG5cdFx0XHRcdGlmIChvcHRpb25zLm1vZHVsZXMpIHtcblx0XHRcdFx0XHRmaW5hbE9wdGlvbnMubW9kdWxlcyA9IChiYXNlT3B0aW9ucy5tb2R1bGVzIHx8IFtdKS5jb25jYXQob3B0aW9ucy5tb2R1bGVzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuXHRcdFx0XHRpZiAob3B0aW9ucy5kaXJlY3RpdmVzKSB7XG5cdFx0XHRcdFx0ZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG5cdFx0XHRcdFx0XHRPYmplY3QuY3JlYXRlKGJhc2VPcHRpb25zLmRpcmVjdGl2ZXMpLFxuXHRcdFx0XHRcdFx0b3B0aW9ucy5kaXJlY3RpdmVzXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBjb3B5IG90aGVyIG9wdGlvbnNcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG9wdGlvbnMpIHtcblx0XHRcdFx0XHRpZiAoa2V5ICE9PSAnbW9kdWxlcycgJiYga2V5ICE9PSAnZGlyZWN0aXZlcycpIHtcblx0XHRcdFx0XHRcdGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgZmluYWxPcHRpb25zKTtcblx0XHRcdHtcblx0XHRcdFx0ZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG5cdFx0XHR9XG5cdFx0XHRjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG5cdFx0XHRjb21waWxlZC50aXBzID0gdGlwcztcblx0XHRcdHJldHVybiBjb21waWxlZFxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG5cdFx0XHR0ZW1wbGF0ZSxcblx0XHRcdG9wdGlvbnMsXG5cdFx0XHR2bVxuXHRcdCkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0e1xuXHRcdFx0XHQvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0bmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0aWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcblx0XHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHRcdCdJdCBzZWVtcyB5b3UgYXJlIHVzaW5nIHRoZSBzdGFuZGFsb25lIGJ1aWxkIG9mIFZ1ZS5qcyBpbiBhbiAnICtcblx0XHRcdFx0XHRcdFx0J2Vudmlyb25tZW50IHdpdGggQ29udGVudCBTZWN1cml0eSBQb2xpY3kgdGhhdCBwcm9oaWJpdHMgdW5zYWZlLWV2YWwuICcgK1xuXHRcdFx0XHRcdFx0XHQnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuXHRcdFx0XHRcdFx0XHQncmVsYXhpbmcgdGhlIHBvbGljeSB0byBhbGxvdyB1bnNhZmUtZXZhbCBvciBwcmUtY29tcGlsaW5nIHlvdXIgJyArXG5cdFx0XHRcdFx0XHRcdCd0ZW1wbGF0ZXMgaW50byByZW5kZXIgZnVuY3Rpb25zLidcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGNhY2hlXG5cdFx0XHR2YXIga2V5ID0gb3B0aW9ucy5kZWxpbWl0ZXJzXG5cdFx0XHRcdD8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuXHRcdFx0XHQ6IHRlbXBsYXRlO1xuXHRcdFx0aWYgKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0pIHtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV1cblx0XHRcdH1cblxuXHRcdFx0Ly8gY29tcGlsZVxuXHRcdFx0dmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cblx0XHRcdC8vIGNoZWNrIGNvbXBpbGF0aW9uIGVycm9ycy90aXBzXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChjb21waWxlZC5lcnJvcnMgJiYgY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHRcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG5cdFx0XHRcdFx0XHRjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG5cdFx0XHRcdFx0XHR2bVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGNvbXBpbGVkLnRpcHMgJiYgY29tcGlsZWQudGlwcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcblx0XHRcdHZhciByZXMgPSB7fTtcblx0XHRcdHZhciBmbkdlbkVycm9ycyA9IFtdO1xuXHRcdFx0cmVzLnJlbmRlciA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5yZW5kZXIsIGZuR2VuRXJyb3JzKTtcblx0XHRcdHZhciBsID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLmxlbmd0aDtcblx0XHRcdHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBuZXcgQXJyYXkobCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRyZXMuc3RhdGljUmVuZGVyRm5zW2ldID0gbWFrZUZ1bmN0aW9uKGNvbXBpbGVkLnN0YXRpY1JlbmRlckZuc1tpXSwgZm5HZW5FcnJvcnMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cblx0XHRcdC8vIHRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZXJlIGlzIGEgYnVnIGluIHRoZSBjb21waWxlciBpdHNlbGYuXG5cdFx0XHQvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdHtcblx0XHRcdFx0aWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcblx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0XCJGYWlsZWQgdG8gZ2VuZXJhdGUgcmVuZGVyIGZ1bmN0aW9uOlxcblxcblwiICtcblx0XHRcdFx0XHRcdGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBlcnIgPSByZWYuZXJyO1xuXHRcdFx0XHRcdFx0XHR2YXIgY29kZSA9IHJlZi5jb2RlO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG5cdFx0XHRcdFx0XHR9KS5qb2luKCdcXG4nKSxcblx0XHRcdFx0XHRcdHZtXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKGZ1bmN0aW9uQ29tcGlsZUNhY2hlW2tleV0gPSByZXMpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbXBpbGU6IGNvbXBpbGUsXG5cdFx0XHRjb21waWxlVG9GdW5jdGlvbnM6IGNvbXBpbGVUb0Z1bmN0aW9uc1xuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG5cdFx0dmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cdFx0dmFyIHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG5cdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0YXRpY0NsYXNzKSB7XG5cdFx0XHR2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcblx0XHRcdGlmIChleHByZXNzaW9uKSB7XG5cdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuXHRcdFx0XHRcdCdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuXHRcdFx0XHRcdCdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuXHRcdFx0XHRcdCdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzdGF0aWNDbGFzcykge1xuXHRcdFx0ZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG5cdFx0fVxuXHRcdHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcblx0XHRpZiAoY2xhc3NCaW5kaW5nKSB7XG5cdFx0XHRlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuXHRcdHZhciBkYXRhID0gJyc7XG5cdFx0aWYgKGVsLnN0YXRpY0NsYXNzKSB7XG5cdFx0XHRkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG5cdFx0fVxuXHRcdGlmIChlbC5jbGFzc0JpbmRpbmcpIHtcblx0XHRcdGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblxuXHR2YXIga2xhc3MkMSA9IHtcblx0XHRzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG5cdFx0dHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcblx0XHRnZW5EYXRhOiBnZW5EYXRhJDFcblx0fTtcblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEgKGVsLCBvcHRpb25zKSB7XG5cdFx0dmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cdFx0dmFyIHN0YXRpY1N0eWxlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3N0eWxlJyk7XG5cdFx0aWYgKHN0YXRpY1N0eWxlKSB7XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdHtcblx0XHRcdFx0dmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG5cdFx0XHRcdGlmIChleHByZXNzaW9uKSB7XG5cdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcblx0XHRcdFx0XHRcdCdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuXHRcdFx0XHRcdFx0J1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG5cdFx0XHRcdFx0XHQnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsLnN0YXRpY1N0eWxlID0gSlNPTi5zdHJpbmdpZnkocGFyc2VTdHlsZVRleHQoc3RhdGljU3R5bGUpKTtcblx0XHR9XG5cblx0XHR2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG5cdFx0aWYgKHN0eWxlQmluZGluZykge1xuXHRcdFx0ZWwuc3R5bGVCaW5kaW5nID0gc3R5bGVCaW5kaW5nO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbkRhdGEkMiAoZWwpIHtcblx0XHR2YXIgZGF0YSA9ICcnO1xuXHRcdGlmIChlbC5zdGF0aWNTdHlsZSkge1xuXHRcdFx0ZGF0YSArPSBcInN0YXRpY1N0eWxlOlwiICsgKGVsLnN0YXRpY1N0eWxlKSArIFwiLFwiO1xuXHRcdH1cblx0XHRpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG5cdFx0XHRkYXRhICs9IFwic3R5bGU6KFwiICsgKGVsLnN0eWxlQmluZGluZykgKyBcIiksXCI7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblxuXHR2YXIgc3R5bGUkMSA9IHtcblx0XHRzdGF0aWNLZXlzOiBbJ3N0YXRpY1N0eWxlJ10sXG5cdFx0dHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuXHRcdGdlbkRhdGE6IGdlbkRhdGEkMlxuXHR9O1xuXG5cdHZhciBtb2R1bGVzJDEgPSBbXG5cdFx0a2xhc3MkMSxcblx0XHRzdHlsZSQxXG5cdF07XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gdGV4dCAoZWwsIGRpcikge1xuXHRcdGlmIChkaXIudmFsdWUpIHtcblx0XHRcdGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGh0bWwgKGVsLCBkaXIpIHtcblx0XHRpZiAoZGlyLnZhbHVlKSB7XG5cdFx0XHRhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG5cdFx0fVxuXHR9XG5cblx0dmFyIGRpcmVjdGl2ZXMkMSA9IHtcblx0XHRtb2RlbDogbW9kZWwsXG5cdFx0dGV4dDogdGV4dCxcblx0XHRodG1sOiBodG1sXG5cdH07XG5cblx0LyogICovXG5cblx0dmFyIGJhc2VPcHRpb25zID0ge1xuXHRcdGV4cGVjdEhUTUw6IHRydWUsXG5cdFx0bW9kdWxlczogbW9kdWxlcyQxLFxuXHRcdGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcblx0XHRpc1ByZVRhZzogaXNQcmVUYWcsXG5cdFx0aXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcblx0XHRtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG5cdFx0Y2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcblx0XHRpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuXHRcdGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuXHRcdHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxuXHR9O1xuXG5cdHZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcblx0dmFyIGNvbXBpbGVUb0Z1bmN0aW9ucyA9IHJlZiQxLmNvbXBpbGVUb0Z1bmN0aW9ucztcblxuXHQvKiAgKi9cblxuXHR2YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuXHRcdHZhciBlbCA9IHF1ZXJ5KGlkKTtcblx0XHRyZXR1cm4gZWwgJiYgZWwuaW5uZXJIVE1MXG5cdH0pO1xuXG5cdHZhciBtb3VudCA9IFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQ7XG5cdFZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG5cdFx0ZWwsXG5cdFx0aHlkcmF0aW5nXG5cdCkge1xuXHRcdGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcblx0XHRcdFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG5cdFx0XHRcdFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcblx0XHQvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuXHRcdGlmICghb3B0aW9ucy5yZW5kZXIpIHtcblx0XHRcdHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHRpZiAodGVtcGxhdGUpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHRpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcblx0XHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0XHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuXHRcdFx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0XHRcdChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG5cdFx0XHRcdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoZWwpIHtcblx0XHRcdFx0dGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRlbXBsYXRlKSB7XG5cdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcblx0XHRcdFx0XHRtYXJrKCdjb21waWxlJyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG5cdFx0XHRcdFx0c2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuXHRcdFx0XHRcdGRlbGltaXRlcnM6IG9wdGlvbnMuZGVsaW1pdGVyc1xuXHRcdFx0XHR9LCB0aGlzKTtcblx0XHRcdFx0dmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG5cdFx0XHRcdHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuXHRcdFx0XHRvcHRpb25zLnJlbmRlciA9IHJlbmRlcjtcblx0XHRcdFx0b3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG5cblx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuXHRcdFx0XHRcdG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG5cdFx0XHRcdFx0bWVhc3VyZSgoKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuXHQgKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cblx0ICovXG5cdGZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcblx0XHRpZiAoZWwub3V0ZXJIVE1MKSB7XG5cdFx0XHRyZXR1cm4gZWwub3V0ZXJIVE1MXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuXHRcdFx0cmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcblx0XHR9XG5cdH1cblxuXHRWdWUkMy5jb21waWxlID0gY29tcGlsZVRvRnVuY3Rpb25zO1xuXG5cdHJldHVybiBWdWUkMztcblxufSkpKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcHVibGljL3NjcmlwdHMvbGliL3Z1ZS5qcyJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztBQUtBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBWUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUE5RUE7QUFDQTtBQWdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpDQTtBQW1DQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFJQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFPQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFNQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhFQTtBQUNBO0FBa0VBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQU1BO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFOQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2REE7QUFDQTtBQXlEQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVpBO0FBQ0E7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQU1BO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUVBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBVEE7QUFXQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFZQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUdBO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1Q0E7QUFDQTtBQThDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBcERBO0FBQ0E7QUFzREE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBQ0E7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBeEdBO0FBQ0E7QUEwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhCQTtBQTNGQTtBQUNBO0FBc0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUE3TEE7QUErTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBV0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQUE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFHQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8\n");

/***/ }),

/***/ 9:
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/MzY5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMyA3IDkgMTQgMTUgMTgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ })

/******/ });