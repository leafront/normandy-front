/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 42);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/*!**************************************!*\
  !*** ./public/scripts/lib/jquery.js ***!
  \**************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */\n!function (a, b) {\n\t\"use strict\";\n\t\"object\" == ( false ? \"undefined\" : _typeof(module)) && \"object\" == _typeof(module.exports) ? module.exports = a.document ? b(a, !0) : function (a) {\n\t\tif (!a.document) throw new Error(\"jQuery requires a window with a document\");return b(a);\n\t} : b(a);\n}(\"undefined\" != typeof window ? window : undefined, function (a, b) {\n\t\"use strict\";\n\tvar c = [],\n\t    d = a.document,\n\t    e = Object.getPrototypeOf,\n\t    f = c.slice,\n\t    g = c.concat,\n\t    h = c.push,\n\t    i = c.indexOf,\n\t    j = {},\n\t    k = j.toString,\n\t    l = j.hasOwnProperty,\n\t    m = l.toString,\n\t    n = m.call(Object),\n\t    o = {};function p(a, b) {\n\t\tb = b || d;var c = b.createElement(\"script\");c.text = a, b.head.appendChild(c).parentNode.removeChild(c);\n\t}var q = \"3.2.1\",\n\t    r = function r(a, b) {\n\t\treturn new r.fn.init(a, b);\n\t},\n\t    s = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\t    t = /^-ms-/,\n\t    u = /-([a-z])/g,\n\t    v = function v(a, b) {\n\t\treturn b.toUpperCase();\n\t};r.fn = r.prototype = { jquery: q, constructor: r, length: 0, toArray: function toArray() {\n\t\t\treturn f.call(this);\n\t\t}, get: function get(a) {\n\t\t\treturn null == a ? f.call(this) : a < 0 ? this[a + this.length] : this[a];\n\t\t}, pushStack: function pushStack(a) {\n\t\t\tvar b = r.merge(this.constructor(), a);return b.prevObject = this, b;\n\t\t}, each: function each(a) {\n\t\t\treturn r.each(this, a);\n\t\t}, map: function map(a) {\n\t\t\treturn this.pushStack(r.map(this, function (b, c) {\n\t\t\t\treturn a.call(b, c, b);\n\t\t\t}));\n\t\t}, slice: function slice() {\n\t\t\treturn this.pushStack(f.apply(this, arguments));\n\t\t}, first: function first() {\n\t\t\treturn this.eq(0);\n\t\t}, last: function last() {\n\t\t\treturn this.eq(-1);\n\t\t}, eq: function eq(a) {\n\t\t\tvar b = this.length,\n\t\t\t    c = +a + (a < 0 ? b : 0);return this.pushStack(c >= 0 && c < b ? [this[c]] : []);\n\t\t}, end: function end() {\n\t\t\treturn this.prevObject || this.constructor();\n\t\t}, push: h, sort: c.sort, splice: c.splice }, r.extend = r.fn.extend = function () {\n\t\tvar a,\n\t\t    b,\n\t\t    c,\n\t\t    d,\n\t\t    e,\n\t\t    f,\n\t\t    g = arguments[0] || {},\n\t\t    h = 1,\n\t\t    i = arguments.length,\n\t\t    j = !1;for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == (typeof g === \"undefined\" ? \"undefined\" : _typeof(g)) || r.isFunction(g) || (g = {}), h === i && (g = this, h--); h < i; h++) {\n\t\t\tif (null != (a = arguments[h])) for (b in a) {\n\t\t\t\tc = g[b], d = a[b], g !== d && (j && d && (r.isPlainObject(d) || (e = Array.isArray(d))) ? (e ? (e = !1, f = c && Array.isArray(c) ? c : []) : f = c && r.isPlainObject(c) ? c : {}, g[b] = r.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n\t\t\t}\n\t\t}return g;\n\t}, r.extend({ expando: \"jQuery\" + (q + Math.random()).replace(/\\D/g, \"\"), isReady: !0, error: function error(a) {\n\t\t\tthrow new Error(a);\n\t\t}, noop: function noop() {}, isFunction: function isFunction(a) {\n\t\t\treturn \"function\" === r.type(a);\n\t\t}, isWindow: function isWindow(a) {\n\t\t\treturn null != a && a === a.window;\n\t\t}, isNumeric: function isNumeric(a) {\n\t\t\tvar b = r.type(a);return (\"number\" === b || \"string\" === b) && !isNaN(a - parseFloat(a));\n\t\t}, isPlainObject: function isPlainObject(a) {\n\t\t\tvar b, c;return !(!a || \"[object Object]\" !== k.call(a)) && (!(b = e(a)) || (c = l.call(b, \"constructor\") && b.constructor, \"function\" == typeof c && m.call(c) === n));\n\t\t}, isEmptyObject: function isEmptyObject(a) {\n\t\t\tvar b;for (b in a) {\n\t\t\t\treturn !1;\n\t\t\t}return !0;\n\t\t}, type: function type(a) {\n\t\t\treturn null == a ? a + \"\" : \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) || \"function\" == typeof a ? j[k.call(a)] || \"object\" : typeof a === \"undefined\" ? \"undefined\" : _typeof(a);\n\t\t}, globalEval: function globalEval(a) {\n\t\t\tp(a);\n\t\t}, camelCase: function camelCase(a) {\n\t\t\treturn a.replace(t, \"ms-\").replace(u, v);\n\t\t}, each: function each(a, b) {\n\t\t\tvar c,\n\t\t\t    d = 0;if (w(a)) {\n\t\t\t\tfor (c = a.length; d < c; d++) {\n\t\t\t\t\tif (b.call(a[d], d, a[d]) === !1) break;\n\t\t\t\t}\n\t\t\t} else for (d in a) {\n\t\t\t\tif (b.call(a[d], d, a[d]) === !1) break;\n\t\t\t}return a;\n\t\t}, trim: function trim(a) {\n\t\t\treturn null == a ? \"\" : (a + \"\").replace(s, \"\");\n\t\t}, makeArray: function makeArray(a, b) {\n\t\t\tvar c = b || [];return null != a && (w(Object(a)) ? r.merge(c, \"string\" == typeof a ? [a] : a) : h.call(c, a)), c;\n\t\t}, inArray: function inArray(a, b, c) {\n\t\t\treturn null == b ? -1 : i.call(b, a, c);\n\t\t}, merge: function merge(a, b) {\n\t\t\tfor (var c = +b.length, d = 0, e = a.length; d < c; d++) {\n\t\t\t\ta[e++] = b[d];\n\t\t\t}return a.length = e, a;\n\t\t}, grep: function grep(a, b, c) {\n\t\t\tfor (var d, e = [], f = 0, g = a.length, h = !c; f < g; f++) {\n\t\t\t\td = !b(a[f], f), d !== h && e.push(a[f]);\n\t\t\t}return e;\n\t\t}, map: function map(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e,\n\t\t\t    f = 0,\n\t\t\t    h = [];if (w(a)) for (d = a.length; f < d; f++) {\n\t\t\t\te = b(a[f], f, c), null != e && h.push(e);\n\t\t\t} else for (f in a) {\n\t\t\t\te = b(a[f], f, c), null != e && h.push(e);\n\t\t\t}return g.apply([], h);\n\t\t}, guid: 1, proxy: function proxy(a, b) {\n\t\t\tvar c, d, e;if (\"string\" == typeof b && (c = a[b], b = a, a = c), r.isFunction(a)) return d = f.call(arguments, 2), e = function e() {\n\t\t\t\treturn a.apply(b || this, d.concat(f.call(arguments)));\n\t\t\t}, e.guid = a.guid = a.guid || r.guid++, e;\n\t\t}, now: Date.now, support: o }), \"function\" == typeof Symbol && (r.fn[Symbol.iterator] = c[Symbol.iterator]), r.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (a, b) {\n\t\tj[\"[object \" + b + \"]\"] = b.toLowerCase();\n\t});function w(a) {\n\t\tvar b = !!a && \"length\" in a && a.length,\n\t\t    c = r.type(a);return \"function\" !== c && !r.isWindow(a) && (\"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a);\n\t}var x = function (a) {\n\t\tvar b,\n\t\t    c,\n\t\t    d,\n\t\t    e,\n\t\t    f,\n\t\t    g,\n\t\t    h,\n\t\t    i,\n\t\t    j,\n\t\t    k,\n\t\t    l,\n\t\t    m,\n\t\t    n,\n\t\t    o,\n\t\t    p,\n\t\t    q,\n\t\t    r,\n\t\t    s,\n\t\t    t,\n\t\t    u = \"sizzle\" + 1 * new Date(),\n\t\t    v = a.document,\n\t\t    w = 0,\n\t\t    x = 0,\n\t\t    y = ha(),\n\t\t    z = ha(),\n\t\t    A = ha(),\n\t\t    B = function B(a, b) {\n\t\t\treturn a === b && (l = !0), 0;\n\t\t},\n\t\t    C = {}.hasOwnProperty,\n\t\t    D = [],\n\t\t    E = D.pop,\n\t\t    F = D.push,\n\t\t    G = D.push,\n\t\t    H = D.slice,\n\t\t    I = function I(a, b) {\n\t\t\tfor (var c = 0, d = a.length; c < d; c++) {\n\t\t\t\tif (a[c] === b) return c;\n\t\t\t}return -1;\n\t\t},\n\t\t    J = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\t\t    K = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t\t    L = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\t\t    M = \"\\\\[\" + K + \"*(\" + L + \")(?:\" + K + \"*([*^$|!~]?=)\" + K + \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + L + \"))|)\" + K + \"*\\\\]\",\n\t\t    N = \":(\" + L + \")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + M + \")*)|.*)\\\\)|)\",\n\t\t    O = new RegExp(K + \"+\", \"g\"),\n\t\t    P = new RegExp(\"^\" + K + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + K + \"+$\", \"g\"),\n\t\t    Q = new RegExp(\"^\" + K + \"*,\" + K + \"*\"),\n\t\t    R = new RegExp(\"^\" + K + \"*([>+~]|\" + K + \")\" + K + \"*\"),\n\t\t    S = new RegExp(\"=\" + K + \"*([^\\\\]'\\\"]*?)\" + K + \"*\\\\]\", \"g\"),\n\t\t    T = new RegExp(N),\n\t\t    U = new RegExp(\"^\" + L + \"$\"),\n\t\t    V = { ID: new RegExp(\"^#(\" + L + \")\"), CLASS: new RegExp(\"^\\\\.(\" + L + \")\"), TAG: new RegExp(\"^(\" + L + \"|[*])\"), ATTR: new RegExp(\"^\" + M), PSEUDO: new RegExp(\"^\" + N), CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + K + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + K + \"*(?:([+-]|)\" + K + \"*(\\\\d+)|))\" + K + \"*\\\\)|)\", \"i\"), bool: new RegExp(\"^(?:\" + J + \")$\", \"i\"), needsContext: new RegExp(\"^\" + K + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + K + \"*((?:-\\\\d)?\\\\d*)\" + K + \"*\\\\)|)(?=[^-]|$)\", \"i\") },\n\t\t    W = /^(?:input|select|textarea|button)$/i,\n\t\t    X = /^h\\d$/i,\n\t\t    Y = /^[^{]+\\{\\s*\\[native \\w/,\n\t\t    Z = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t\t    $ = /[+~]/,\n\t\t    _ = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + K + \"?|(\" + K + \")|.)\", \"ig\"),\n\t\t    aa = function aa(a, b, c) {\n\t\t\tvar d = \"0x\" + b - 65536;return d !== d || c ? b : d < 0 ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);\n\t\t},\n\t\t    ba = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\t\t    ca = function ca(a, b) {\n\t\t\treturn b ? \"\\0\" === a ? \"\\uFFFD\" : a.slice(0, -1) + \"\\\\\" + a.charCodeAt(a.length - 1).toString(16) + \" \" : \"\\\\\" + a;\n\t\t},\n\t\t    da = function da() {\n\t\t\tm();\n\t\t},\n\t\t    ea = ta(function (a) {\n\t\t\treturn a.disabled === !0 && (\"form\" in a || \"label\" in a);\n\t\t}, { dir: \"parentNode\", next: \"legend\" });try {\n\t\t\tG.apply(D = H.call(v.childNodes), v.childNodes), D[v.childNodes.length].nodeType;\n\t\t} catch (fa) {\n\t\t\tG = { apply: D.length ? function (a, b) {\n\t\t\t\t\tF.apply(a, H.call(b));\n\t\t\t\t} : function (a, b) {\n\t\t\t\t\tvar c = a.length,\n\t\t\t\t\t    d = 0;while (a[c++] = b[d++]) {}a.length = c - 1;\n\t\t\t\t} };\n\t\t}function ga(a, b, d, e) {\n\t\t\tvar f,\n\t\t\t    h,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    l,\n\t\t\t    o,\n\t\t\t    r,\n\t\t\t    s = b && b.ownerDocument,\n\t\t\t    w = b ? b.nodeType : 9;if (d = d || [], \"string\" != typeof a || !a || 1 !== w && 9 !== w && 11 !== w) return d;if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {\n\t\t\t\tif (11 !== w && (l = Z.exec(a))) if (f = l[1]) {\n\t\t\t\t\tif (9 === w) {\n\t\t\t\t\t\tif (!(j = b.getElementById(f))) return d;if (j.id === f) return d.push(j), d;\n\t\t\t\t\t} else if (s && (j = s.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d;\n\t\t\t\t} else {\n\t\t\t\t\tif (l[2]) return G.apply(d, b.getElementsByTagName(a)), d;if ((f = l[3]) && c.getElementsByClassName && b.getElementsByClassName) return G.apply(d, b.getElementsByClassName(f)), d;\n\t\t\t\t}if (c.qsa && !A[a + \" \"] && (!q || !q.test(a))) {\n\t\t\t\t\tif (1 !== w) s = b, r = a;else if (\"object\" !== b.nodeName.toLowerCase()) {\n\t\t\t\t\t\t(k = b.getAttribute(\"id\")) ? k = k.replace(ba, ca) : b.setAttribute(\"id\", k = u), o = g(a), h = o.length;while (h--) {\n\t\t\t\t\t\t\to[h] = \"#\" + k + \" \" + sa(o[h]);\n\t\t\t\t\t\t}r = o.join(\",\"), s = $.test(a) && qa(b.parentNode) || b;\n\t\t\t\t\t}if (r) try {\n\t\t\t\t\t\treturn G.apply(d, s.querySelectorAll(r)), d;\n\t\t\t\t\t} catch (x) {} finally {\n\t\t\t\t\t\tk === u && b.removeAttribute(\"id\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}return i(a.replace(P, \"$1\"), b, d, e);\n\t\t}function ha() {\n\t\t\tvar a = [];function b(c, e) {\n\t\t\t\treturn a.push(c + \" \") > d.cacheLength && delete b[a.shift()], b[c + \" \"] = e;\n\t\t\t}return b;\n\t\t}function ia(a) {\n\t\t\treturn a[u] = !0, a;\n\t\t}function ja(a) {\n\t\t\tvar b = n.createElement(\"fieldset\");try {\n\t\t\t\treturn !!a(b);\n\t\t\t} catch (c) {\n\t\t\t\treturn !1;\n\t\t\t} finally {\n\t\t\t\tb.parentNode && b.parentNode.removeChild(b), b = null;\n\t\t\t}\n\t\t}function ka(a, b) {\n\t\t\tvar c = a.split(\"|\"),\n\t\t\t    e = c.length;while (e--) {\n\t\t\t\td.attrHandle[c[e]] = b;\n\t\t\t}\n\t\t}function la(a, b) {\n\t\t\tvar c = b && a,\n\t\t\t    d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;if (d) return d;if (c) while (c = c.nextSibling) {\n\t\t\t\tif (c === b) return -1;\n\t\t\t}return a ? 1 : -1;\n\t\t}function ma(a) {\n\t\t\treturn function (b) {\n\t\t\t\tvar c = b.nodeName.toLowerCase();return \"input\" === c && b.type === a;\n\t\t\t};\n\t\t}function na(a) {\n\t\t\treturn function (b) {\n\t\t\t\tvar c = b.nodeName.toLowerCase();return (\"input\" === c || \"button\" === c) && b.type === a;\n\t\t\t};\n\t\t}function oa(a) {\n\t\t\treturn function (b) {\n\t\t\t\treturn \"form\" in b ? b.parentNode && b.disabled === !1 ? \"label\" in b ? \"label\" in b.parentNode ? b.parentNode.disabled === a : b.disabled === a : b.isDisabled === a || b.isDisabled !== !a && ea(b) === a : b.disabled === a : \"label\" in b && b.disabled === a;\n\t\t\t};\n\t\t}function pa(a) {\n\t\t\treturn ia(function (b) {\n\t\t\t\treturn b = +b, ia(function (c, d) {\n\t\t\t\t\tvar e,\n\t\t\t\t\t    f = a([], c.length, b),\n\t\t\t\t\t    g = f.length;while (g--) {\n\t\t\t\t\t\tc[e = f[g]] && (c[e] = !(d[e] = c[e]));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}function qa(a) {\n\t\t\treturn a && \"undefined\" != typeof a.getElementsByTagName && a;\n\t\t}c = ga.support = {}, f = ga.isXML = function (a) {\n\t\t\tvar b = a && (a.ownerDocument || a).documentElement;return !!b && \"HTML\" !== b.nodeName;\n\t\t}, m = ga.setDocument = function (a) {\n\t\t\tvar b,\n\t\t\t    e,\n\t\t\t    g = a ? a.ownerDocument || a : v;return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), v !== n && (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener(\"unload\", da, !1) : e.attachEvent && e.attachEvent(\"onunload\", da)), c.attributes = ja(function (a) {\n\t\t\t\treturn a.className = \"i\", !a.getAttribute(\"className\");\n\t\t\t}), c.getElementsByTagName = ja(function (a) {\n\t\t\t\treturn a.appendChild(n.createComment(\"\")), !a.getElementsByTagName(\"*\").length;\n\t\t\t}), c.getElementsByClassName = Y.test(n.getElementsByClassName), c.getById = ja(function (a) {\n\t\t\t\treturn o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length;\n\t\t\t}), c.getById ? (d.filter.ID = function (a) {\n\t\t\t\tvar b = a.replace(_, aa);return function (a) {\n\t\t\t\t\treturn a.getAttribute(\"id\") === b;\n\t\t\t\t};\n\t\t\t}, d.find.ID = function (a, b) {\n\t\t\t\tif (\"undefined\" != typeof b.getElementById && p) {\n\t\t\t\t\tvar c = b.getElementById(a);return c ? [c] : [];\n\t\t\t\t}\n\t\t\t}) : (d.filter.ID = function (a) {\n\t\t\t\tvar b = a.replace(_, aa);return function (a) {\n\t\t\t\t\tvar c = \"undefined\" != typeof a.getAttributeNode && a.getAttributeNode(\"id\");return c && c.value === b;\n\t\t\t\t};\n\t\t\t}, d.find.ID = function (a, b) {\n\t\t\t\tif (\"undefined\" != typeof b.getElementById && p) {\n\t\t\t\t\tvar c,\n\t\t\t\t\t    d,\n\t\t\t\t\t    e,\n\t\t\t\t\t    f = b.getElementById(a);if (f) {\n\t\t\t\t\t\tif (c = f.getAttributeNode(\"id\"), c && c.value === a) return [f];e = b.getElementsByName(a), d = 0;while (f = e[d++]) {\n\t\t\t\t\t\t\tif (c = f.getAttributeNode(\"id\"), c && c.value === a) return [f];\n\t\t\t\t\t\t}\n\t\t\t\t\t}return [];\n\t\t\t\t}\n\t\t\t}), d.find.TAG = c.getElementsByTagName ? function (a, b) {\n\t\t\t\treturn \"undefined\" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;\n\t\t\t} : function (a, b) {\n\t\t\t\tvar c,\n\t\t\t\t    d = [],\n\t\t\t\t    e = 0,\n\t\t\t\t    f = b.getElementsByTagName(a);if (\"*\" === a) {\n\t\t\t\t\twhile (c = f[e++]) {\n\t\t\t\t\t\t1 === c.nodeType && d.push(c);\n\t\t\t\t\t}return d;\n\t\t\t\t}return f;\n\t\t\t}, d.find.CLASS = c.getElementsByClassName && function (a, b) {\n\t\t\t\tif (\"undefined\" != typeof b.getElementsByClassName && p) return b.getElementsByClassName(a);\n\t\t\t}, r = [], q = [], (c.qsa = Y.test(n.querySelectorAll)) && (ja(function (a) {\n\t\t\t\to.appendChild(a).innerHTML = \"<a id='\" + u + \"'></a><select id='\" + u + \"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\", a.querySelectorAll(\"[msallowcapture^='']\").length && q.push(\"[*^$]=\" + K + \"*(?:''|\\\"\\\")\"), a.querySelectorAll(\"[selected]\").length || q.push(\"\\\\[\" + K + \"*(?:value|\" + J + \")\"), a.querySelectorAll(\"[id~=\" + u + \"-]\").length || q.push(\"~=\"), a.querySelectorAll(\":checked\").length || q.push(\":checked\"), a.querySelectorAll(\"a#\" + u + \"+*\").length || q.push(\".#.+[+~]\");\n\t\t\t}), ja(function (a) {\n\t\t\t\ta.innerHTML = \"<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>\";var b = n.createElement(\"input\");b.setAttribute(\"type\", \"hidden\"), a.appendChild(b).setAttribute(\"name\", \"D\"), a.querySelectorAll(\"[name=d]\").length && q.push(\"name\" + K + \"*[*^$|!~]?=\"), 2 !== a.querySelectorAll(\":enabled\").length && q.push(\":enabled\", \":disabled\"), o.appendChild(a).disabled = !0, 2 !== a.querySelectorAll(\":disabled\").length && q.push(\":enabled\", \":disabled\"), a.querySelectorAll(\"*,:x\"), q.push(\",.*:\");\n\t\t\t})), (c.matchesSelector = Y.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function (a) {\n\t\t\t\tc.disconnectedMatch = s.call(a, \"*\"), s.call(a, \"[s!='']:x\"), r.push(\"!=\", N);\n\t\t\t}), q = q.length && new RegExp(q.join(\"|\")), r = r.length && new RegExp(r.join(\"|\")), b = Y.test(o.compareDocumentPosition), t = b || Y.test(o.contains) ? function (a, b) {\n\t\t\t\tvar c = 9 === a.nodeType ? a.documentElement : a,\n\t\t\t\t    d = b && b.parentNode;return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));\n\t\t\t} : function (a, b) {\n\t\t\t\tif (b) while (b = b.parentNode) {\n\t\t\t\t\tif (b === a) return !0;\n\t\t\t\t}return !1;\n\t\t\t}, B = b ? function (a, b) {\n\t\t\t\tif (a === b) return l = !0, 0;var d = !a.compareDocumentPosition - !b.compareDocumentPosition;return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? I(k, a) - I(k, b) : 0 : 4 & d ? -1 : 1);\n\t\t\t} : function (a, b) {\n\t\t\t\tif (a === b) return l = !0, 0;var c,\n\t\t\t\t    d = 0,\n\t\t\t\t    e = a.parentNode,\n\t\t\t\t    f = b.parentNode,\n\t\t\t\t    g = [a],\n\t\t\t\t    h = [b];if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? I(k, a) - I(k, b) : 0;if (e === f) return la(a, b);c = a;while (c = c.parentNode) {\n\t\t\t\t\tg.unshift(c);\n\t\t\t\t}c = b;while (c = c.parentNode) {\n\t\t\t\t\th.unshift(c);\n\t\t\t\t}while (g[d] === h[d]) {\n\t\t\t\t\td++;\n\t\t\t\t}return d ? la(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0;\n\t\t\t}, n) : n;\n\t\t}, ga.matches = function (a, b) {\n\t\t\treturn ga(a, null, null, b);\n\t\t}, ga.matchesSelector = function (a, b) {\n\t\t\tif ((a.ownerDocument || a) !== n && m(a), b = b.replace(S, \"='$1']\"), c.matchesSelector && p && !A[b + \" \"] && (!r || !r.test(b)) && (!q || !q.test(b))) try {\n\t\t\t\tvar d = s.call(a, b);if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;\n\t\t\t} catch (e) {}return ga(b, n, null, [a]).length > 0;\n\t\t}, ga.contains = function (a, b) {\n\t\t\treturn (a.ownerDocument || a) !== n && m(a), t(a, b);\n\t\t}, ga.attr = function (a, b) {\n\t\t\t(a.ownerDocument || a) !== n && m(a);var e = d.attrHandle[b.toLowerCase()],\n\t\t\t    f = e && C.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;\n\t\t}, ga.escape = function (a) {\n\t\t\treturn (a + \"\").replace(ba, ca);\n\t\t}, ga.error = function (a) {\n\t\t\tthrow new Error(\"Syntax error, unrecognized expression: \" + a);\n\t\t}, ga.uniqueSort = function (a) {\n\t\t\tvar b,\n\t\t\t    d = [],\n\t\t\t    e = 0,\n\t\t\t    f = 0;if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {\n\t\t\t\twhile (b = a[f++]) {\n\t\t\t\t\tb === a[f] && (e = d.push(f));\n\t\t\t\t}while (e--) {\n\t\t\t\t\ta.splice(d[e], 1);\n\t\t\t\t}\n\t\t\t}return k = null, a;\n\t\t}, e = ga.getText = function (a) {\n\t\t\tvar b,\n\t\t\t    c = \"\",\n\t\t\t    d = 0,\n\t\t\t    f = a.nodeType;if (f) {\n\t\t\t\tif (1 === f || 9 === f || 11 === f) {\n\t\t\t\t\tif (\"string\" == typeof a.textContent) return a.textContent;for (a = a.firstChild; a; a = a.nextSibling) {\n\t\t\t\t\t\tc += e(a);\n\t\t\t\t\t}\n\t\t\t\t} else if (3 === f || 4 === f) return a.nodeValue;\n\t\t\t} else while (b = a[d++]) {\n\t\t\t\tc += e(b);\n\t\t\t}return c;\n\t\t}, d = ga.selectors = { cacheLength: 50, createPseudo: ia, match: V, attrHandle: {}, find: {}, relative: { \">\": { dir: \"parentNode\", first: !0 }, \" \": { dir: \"parentNode\" }, \"+\": { dir: \"previousSibling\", first: !0 }, \"~\": { dir: \"previousSibling\" } }, preFilter: { ATTR: function ATTR(a) {\n\t\t\t\t\treturn a[1] = a[1].replace(_, aa), a[3] = (a[3] || a[4] || a[5] || \"\").replace(_, aa), \"~=\" === a[2] && (a[3] = \" \" + a[3] + \" \"), a.slice(0, 4);\n\t\t\t\t}, CHILD: function CHILD(a) {\n\t\t\t\t\treturn a[1] = a[1].toLowerCase(), \"nth\" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * (\"even\" === a[3] || \"odd\" === a[3])), a[5] = +(a[7] + a[8] || \"odd\" === a[3])) : a[3] && ga.error(a[0]), a;\n\t\t\t\t}, PSEUDO: function PSEUDO(a) {\n\t\t\t\t\tvar b,\n\t\t\t\t\t    c = !a[6] && a[2];return V.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || \"\" : c && T.test(c) && (b = g(c, !0)) && (b = c.indexOf(\")\", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));\n\t\t\t\t} }, filter: { TAG: function TAG(a) {\n\t\t\t\t\tvar b = a.replace(_, aa).toLowerCase();return \"*\" === a ? function () {\n\t\t\t\t\t\treturn !0;\n\t\t\t\t\t} : function (a) {\n\t\t\t\t\t\treturn a.nodeName && a.nodeName.toLowerCase() === b;\n\t\t\t\t\t};\n\t\t\t\t}, CLASS: function CLASS(a) {\n\t\t\t\t\tvar b = y[a + \" \"];return b || (b = new RegExp(\"(^|\" + K + \")\" + a + \"(\" + K + \"|$)\")) && y(a, function (a) {\n\t\t\t\t\t\treturn b.test(\"string\" == typeof a.className && a.className || \"undefined\" != typeof a.getAttribute && a.getAttribute(\"class\") || \"\");\n\t\t\t\t\t});\n\t\t\t\t}, ATTR: function ATTR(a, b, c) {\n\t\t\t\t\treturn function (d) {\n\t\t\t\t\t\tvar e = ga.attr(d, a);return null == e ? \"!=\" === b : !b || (e += \"\", \"=\" === b ? e === c : \"!=\" === b ? e !== c : \"^=\" === b ? c && 0 === e.indexOf(c) : \"*=\" === b ? c && e.indexOf(c) > -1 : \"$=\" === b ? c && e.slice(-c.length) === c : \"~=\" === b ? (\" \" + e.replace(O, \" \") + \" \").indexOf(c) > -1 : \"|=\" === b && (e === c || e.slice(0, c.length + 1) === c + \"-\"));\n\t\t\t\t\t};\n\t\t\t\t}, CHILD: function CHILD(a, b, c, d, e) {\n\t\t\t\t\tvar f = \"nth\" !== a.slice(0, 3),\n\t\t\t\t\t    g = \"last\" !== a.slice(-4),\n\t\t\t\t\t    h = \"of-type\" === b;return 1 === d && 0 === e ? function (a) {\n\t\t\t\t\t\treturn !!a.parentNode;\n\t\t\t\t\t} : function (b, c, i) {\n\t\t\t\t\t\tvar j,\n\t\t\t\t\t\t    k,\n\t\t\t\t\t\t    l,\n\t\t\t\t\t\t    m,\n\t\t\t\t\t\t    n,\n\t\t\t\t\t\t    o,\n\t\t\t\t\t\t    p = f !== g ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\t    q = b.parentNode,\n\t\t\t\t\t\t    r = h && b.nodeName.toLowerCase(),\n\t\t\t\t\t\t    s = !i && !h,\n\t\t\t\t\t\t    t = !1;if (q) {\n\t\t\t\t\t\t\tif (f) {\n\t\t\t\t\t\t\t\twhile (p) {\n\t\t\t\t\t\t\t\t\tm = b;while (m = m[p]) {\n\t\t\t\t\t\t\t\t\t\tif (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;\n\t\t\t\t\t\t\t\t\t}o = p = \"only\" === a && !o && \"nextSibling\";\n\t\t\t\t\t\t\t\t}return !0;\n\t\t\t\t\t\t\t}if (o = [g ? q.firstChild : q.lastChild], g && s) {\n\t\t\t\t\t\t\t\tm = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n\t\t\t\t\t\t\t\t\tif (1 === m.nodeType && ++t && m === b) {\n\t\t\t\t\t\t\t\t\t\tk[a] = [w, n, t];break;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n\t\t\t\t\t\t\t\tif ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;\n\t\t\t\t\t\t\t}return t -= e, t === d || t % d === 0 && t / d >= 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}, PSEUDO: function PSEUDO(a, b) {\n\t\t\t\t\tvar c,\n\t\t\t\t\t    e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error(\"unsupported pseudo: \" + a);return e[u] ? e(b) : e.length > 1 ? (c = [a, a, \"\", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function (a, c) {\n\t\t\t\t\t\tvar d,\n\t\t\t\t\t\t    f = e(a, b),\n\t\t\t\t\t\t    g = f.length;while (g--) {\n\t\t\t\t\t\t\td = I(a, f[g]), a[d] = !(c[d] = f[g]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}) : function (a) {\n\t\t\t\t\t\treturn e(a, 0, c);\n\t\t\t\t\t}) : e;\n\t\t\t\t} }, pseudos: { not: ia(function (a) {\n\t\t\t\t\tvar b = [],\n\t\t\t\t\t    c = [],\n\t\t\t\t\t    d = h(a.replace(P, \"$1\"));return d[u] ? ia(function (a, b, c, e) {\n\t\t\t\t\t\tvar f,\n\t\t\t\t\t\t    g = d(a, null, e, []),\n\t\t\t\t\t\t    h = a.length;while (h--) {\n\t\t\t\t\t\t\t(f = g[h]) && (a[h] = !(b[h] = f));\n\t\t\t\t\t\t}\n\t\t\t\t\t}) : function (a, e, f) {\n\t\t\t\t\t\treturn b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();\n\t\t\t\t\t};\n\t\t\t\t}), has: ia(function (a) {\n\t\t\t\t\treturn function (b) {\n\t\t\t\t\t\treturn ga(a, b).length > 0;\n\t\t\t\t\t};\n\t\t\t\t}), contains: ia(function (a) {\n\t\t\t\t\treturn a = a.replace(_, aa), function (b) {\n\t\t\t\t\t\treturn (b.textContent || b.innerText || e(b)).indexOf(a) > -1;\n\t\t\t\t\t};\n\t\t\t\t}), lang: ia(function (a) {\n\t\t\t\t\treturn U.test(a || \"\") || ga.error(\"unsupported lang: \" + a), a = a.replace(_, aa).toLowerCase(), function (b) {\n\t\t\t\t\t\tvar c;do {\n\t\t\t\t\t\t\tif (c = p ? b.lang : b.getAttribute(\"xml:lang\") || b.getAttribute(\"lang\")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + \"-\");\n\t\t\t\t\t\t} while ((b = b.parentNode) && 1 === b.nodeType);return !1;\n\t\t\t\t\t};\n\t\t\t\t}), target: function target(b) {\n\t\t\t\t\tvar c = a.location && a.location.hash;return c && c.slice(1) === b.id;\n\t\t\t\t}, root: function root(a) {\n\t\t\t\t\treturn a === o;\n\t\t\t\t}, focus: function focus(a) {\n\t\t\t\t\treturn a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);\n\t\t\t\t}, enabled: oa(!1), disabled: oa(!0), checked: function checked(a) {\n\t\t\t\t\tvar b = a.nodeName.toLowerCase();return \"input\" === b && !!a.checked || \"option\" === b && !!a.selected;\n\t\t\t\t}, selected: function selected(a) {\n\t\t\t\t\treturn a.parentNode && a.parentNode.selectedIndex, a.selected === !0;\n\t\t\t\t}, empty: function empty(a) {\n\t\t\t\t\tfor (a = a.firstChild; a; a = a.nextSibling) {\n\t\t\t\t\t\tif (a.nodeType < 6) return !1;\n\t\t\t\t\t}return !0;\n\t\t\t\t}, parent: function parent(a) {\n\t\t\t\t\treturn !d.pseudos.empty(a);\n\t\t\t\t}, header: function header(a) {\n\t\t\t\t\treturn X.test(a.nodeName);\n\t\t\t\t}, input: function input(a) {\n\t\t\t\t\treturn W.test(a.nodeName);\n\t\t\t\t}, button: function button(a) {\n\t\t\t\t\tvar b = a.nodeName.toLowerCase();return \"input\" === b && \"button\" === a.type || \"button\" === b;\n\t\t\t\t}, text: function text(a) {\n\t\t\t\t\tvar b;return \"input\" === a.nodeName.toLowerCase() && \"text\" === a.type && (null == (b = a.getAttribute(\"type\")) || \"text\" === b.toLowerCase());\n\t\t\t\t}, first: pa(function () {\n\t\t\t\t\treturn [0];\n\t\t\t\t}), last: pa(function (a, b) {\n\t\t\t\t\treturn [b - 1];\n\t\t\t\t}), eq: pa(function (a, b, c) {\n\t\t\t\t\treturn [c < 0 ? c + b : c];\n\t\t\t\t}), even: pa(function (a, b) {\n\t\t\t\t\tfor (var c = 0; c < b; c += 2) {\n\t\t\t\t\t\ta.push(c);\n\t\t\t\t\t}return a;\n\t\t\t\t}), odd: pa(function (a, b) {\n\t\t\t\t\tfor (var c = 1; c < b; c += 2) {\n\t\t\t\t\t\ta.push(c);\n\t\t\t\t\t}return a;\n\t\t\t\t}), lt: pa(function (a, b, c) {\n\t\t\t\t\tfor (var d = c < 0 ? c + b : c; --d >= 0;) {\n\t\t\t\t\t\ta.push(d);\n\t\t\t\t\t}return a;\n\t\t\t\t}), gt: pa(function (a, b, c) {\n\t\t\t\t\tfor (var d = c < 0 ? c + b : c; ++d < b;) {\n\t\t\t\t\t\ta.push(d);\n\t\t\t\t\t}return a;\n\t\t\t\t}) } }, d.pseudos.nth = d.pseudos.eq;for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) {\n\t\t\td.pseudos[b] = ma(b);\n\t\t}for (b in { submit: !0, reset: !0 }) {\n\t\t\td.pseudos[b] = na(b);\n\t\t}function ra() {}ra.prototype = d.filters = d.pseudos, d.setFilters = new ra(), g = ga.tokenize = function (a, b) {\n\t\t\tvar c,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k = z[a + \" \"];if (k) return b ? 0 : k.slice(0);h = a, i = [], j = d.preFilter;while (h) {\n\t\t\t\tc && !(e = Q.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = R.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(P, \" \") }), h = h.slice(c.length));for (g in d.filter) {\n\t\t\t\t\t!(e = V[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length));\n\t\t\t\t}if (!c) break;\n\t\t\t}return b ? h.length : h ? ga.error(a) : z(a, i).slice(0);\n\t\t};function sa(a) {\n\t\t\tfor (var b = 0, c = a.length, d = \"\"; b < c; b++) {\n\t\t\t\td += a[b].value;\n\t\t\t}return d;\n\t\t}function ta(a, b, c) {\n\t\t\tvar d = b.dir,\n\t\t\t    e = b.next,\n\t\t\t    f = e || d,\n\t\t\t    g = c && \"parentNode\" === f,\n\t\t\t    h = x++;return b.first ? function (b, c, e) {\n\t\t\t\twhile (b = b[d]) {\n\t\t\t\t\tif (1 === b.nodeType || g) return a(b, c, e);\n\t\t\t\t}return !1;\n\t\t\t} : function (b, c, i) {\n\t\t\t\tvar j,\n\t\t\t\t    k,\n\t\t\t\t    l,\n\t\t\t\t    m = [w, h];if (i) {\n\t\t\t\t\twhile (b = b[d]) {\n\t\t\t\t\t\tif ((1 === b.nodeType || g) && a(b, c, i)) return !0;\n\t\t\t\t\t}\n\t\t\t\t} else while (b = b[d]) {\n\t\t\t\t\tif (1 === b.nodeType || g) if (l = b[u] || (b[u] = {}), k = l[b.uniqueID] || (l[b.uniqueID] = {}), e && e === b.nodeName.toLowerCase()) b = b[d] || b;else {\n\t\t\t\t\t\tif ((j = k[f]) && j[0] === w && j[1] === h) return m[2] = j[2];if (k[f] = m, m[2] = a(b, c, i)) return !0;\n\t\t\t\t\t}\n\t\t\t\t}return !1;\n\t\t\t};\n\t\t}function ua(a) {\n\t\t\treturn a.length > 1 ? function (b, c, d) {\n\t\t\t\tvar e = a.length;while (e--) {\n\t\t\t\t\tif (!a[e](b, c, d)) return !1;\n\t\t\t\t}return !0;\n\t\t\t} : a[0];\n\t\t}function va(a, b, c) {\n\t\t\tfor (var d = 0, e = b.length; d < e; d++) {\n\t\t\t\tga(a, b[d], c);\n\t\t\t}return c;\n\t\t}function wa(a, b, c, d, e) {\n\t\t\tfor (var f, g = [], h = 0, i = a.length, j = null != b; h < i; h++) {\n\t\t\t\t(f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));\n\t\t\t}return g;\n\t\t}function xa(a, b, c, d, e, f) {\n\t\t\treturn d && !d[u] && (d = xa(d)), e && !e[u] && (e = xa(e, f)), ia(function (f, g, h, i) {\n\t\t\t\tvar j,\n\t\t\t\t    k,\n\t\t\t\t    l,\n\t\t\t\t    m = [],\n\t\t\t\t    n = [],\n\t\t\t\t    o = g.length,\n\t\t\t\t    p = f || va(b || \"*\", h.nodeType ? [h] : h, []),\n\t\t\t\t    q = !a || !f && b ? p : wa(p, m, a, h, i),\n\t\t\t\t    r = c ? e || (f ? a : o || d) ? [] : g : q;if (c && c(q, r, h, i), d) {\n\t\t\t\t\tj = wa(r, n), d(j, [], h, i), k = j.length;while (k--) {\n\t\t\t\t\t\t(l = j[k]) && (r[n[k]] = !(q[n[k]] = l));\n\t\t\t\t\t}\n\t\t\t\t}if (f) {\n\t\t\t\t\tif (e || a) {\n\t\t\t\t\t\tif (e) {\n\t\t\t\t\t\t\tj = [], k = r.length;while (k--) {\n\t\t\t\t\t\t\t\t(l = r[k]) && j.push(q[k] = l);\n\t\t\t\t\t\t\t}e(null, r = [], j, i);\n\t\t\t\t\t\t}k = r.length;while (k--) {\n\t\t\t\t\t\t\t(l = r[k]) && (j = e ? I(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else r = wa(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : G.apply(g, r);\n\t\t\t});\n\t\t}function ya(a) {\n\t\t\tfor (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[\" \"], i = g ? 1 : 0, k = ta(function (a) {\n\t\t\t\treturn a === b;\n\t\t\t}, h, !0), l = ta(function (a) {\n\t\t\t\treturn I(b, a) > -1;\n\t\t\t}, h, !0), m = [function (a, c, d) {\n\t\t\t\tvar e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));return b = null, e;\n\t\t\t}]; i < f; i++) {\n\t\t\t\tif (c = d.relative[a[i].type]) m = [ta(ua(m), c)];else {\n\t\t\t\t\tif (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {\n\t\t\t\t\t\tfor (e = ++i; e < f; e++) {\n\t\t\t\t\t\t\tif (d.relative[a[e].type]) break;\n\t\t\t\t\t\t}return xa(i > 1 && ua(m), i > 1 && sa(a.slice(0, i - 1).concat({ value: \" \" === a[i - 2].type ? \"*\" : \"\" })).replace(P, \"$1\"), c, i < e && ya(a.slice(i, e)), e < f && ya(a = a.slice(e)), e < f && sa(a));\n\t\t\t\t\t}m.push(c);\n\t\t\t\t}\n\t\t\t}return ua(m);\n\t\t}function za(a, b) {\n\t\t\tvar c = b.length > 0,\n\t\t\t    e = a.length > 0,\n\t\t\t    f = function f(_f, g, h, i, k) {\n\t\t\t\tvar l,\n\t\t\t\t    o,\n\t\t\t\t    q,\n\t\t\t\t    r = 0,\n\t\t\t\t    s = \"0\",\n\t\t\t\t    t = _f && [],\n\t\t\t\t    u = [],\n\t\t\t\t    v = j,\n\t\t\t\t    x = _f || e && d.find.TAG(\"*\", k),\n\t\t\t\t    y = w += null == v ? 1 : Math.random() || .1,\n\t\t\t\t    z = x.length;for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {\n\t\t\t\t\tif (e && l) {\n\t\t\t\t\t\to = 0, g || l.ownerDocument === n || (m(l), h = !p);while (q = a[o++]) {\n\t\t\t\t\t\t\tif (q(l, g || n, h)) {\n\t\t\t\t\t\t\t\ti.push(l);break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}k && (w = y);\n\t\t\t\t\t}c && ((l = !q && l) && r--, _f && t.push(l));\n\t\t\t\t}if (r += s, c && s !== r) {\n\t\t\t\t\to = 0;while (q = b[o++]) {\n\t\t\t\t\t\tq(t, u, g, h);\n\t\t\t\t\t}if (_f) {\n\t\t\t\t\t\tif (r > 0) while (s--) {\n\t\t\t\t\t\t\tt[s] || u[s] || (u[s] = E.call(i));\n\t\t\t\t\t\t}u = wa(u);\n\t\t\t\t\t}G.apply(i, u), k && !_f && u.length > 0 && r + b.length > 1 && ga.uniqueSort(i);\n\t\t\t\t}return k && (w = y, j = v), t;\n\t\t\t};return c ? ia(f) : f;\n\t\t}return h = ga.compile = function (a, b) {\n\t\t\tvar c,\n\t\t\t    d = [],\n\t\t\t    e = [],\n\t\t\t    f = A[a + \" \"];if (!f) {\n\t\t\t\tb || (b = g(a)), c = b.length;while (c--) {\n\t\t\t\t\tf = ya(b[c]), f[u] ? d.push(f) : e.push(f);\n\t\t\t\t}f = A(a, za(e, d)), f.selector = a;\n\t\t\t}return f;\n\t\t}, i = ga.select = function (a, b, c, e) {\n\t\t\tvar f,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    l,\n\t\t\t    m = \"function\" == typeof a && a,\n\t\t\t    n = !e && g(a = m.selector || a);if (c = c || [], 1 === n.length) {\n\t\t\t\tif (i = n[0] = n[0].slice(0), i.length > 2 && \"ID\" === (j = i[0]).type && 9 === b.nodeType && p && d.relative[i[1].type]) {\n\t\t\t\t\tif (b = (d.find.ID(j.matches[0].replace(_, aa), b) || [])[0], !b) return c;m && (b = b.parentNode), a = a.slice(i.shift().value.length);\n\t\t\t\t}f = V.needsContext.test(a) ? 0 : i.length;while (f--) {\n\t\t\t\t\tif (j = i[f], d.relative[k = j.type]) break;if ((l = d.find[k]) && (e = l(j.matches[0].replace(_, aa), $.test(i[0].type) && qa(b.parentNode) || b))) {\n\t\t\t\t\t\tif (i.splice(f, 1), a = e.length && sa(i), !a) return G.apply(c, e), c;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}return (m || h(a, n))(e, b, !p, c, !b || $.test(a) && qa(b.parentNode) || b), c;\n\t\t}, c.sortStable = u.split(\"\").sort(B).join(\"\") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ja(function (a) {\n\t\t\treturn 1 & a.compareDocumentPosition(n.createElement(\"fieldset\"));\n\t\t}), ja(function (a) {\n\t\t\treturn a.innerHTML = \"<a href='#'></a>\", \"#\" === a.firstChild.getAttribute(\"href\");\n\t\t}) || ka(\"type|href|height|width\", function (a, b, c) {\n\t\t\tif (!c) return a.getAttribute(b, \"type\" === b.toLowerCase() ? 1 : 2);\n\t\t}), c.attributes && ja(function (a) {\n\t\t\treturn a.innerHTML = \"<input/>\", a.firstChild.setAttribute(\"value\", \"\"), \"\" === a.firstChild.getAttribute(\"value\");\n\t\t}) || ka(\"value\", function (a, b, c) {\n\t\t\tif (!c && \"input\" === a.nodeName.toLowerCase()) return a.defaultValue;\n\t\t}), ja(function (a) {\n\t\t\treturn null == a.getAttribute(\"disabled\");\n\t\t}) || ka(J, function (a, b, c) {\n\t\t\tvar d;if (!c) return a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;\n\t\t}), ga;\n\t}(a);r.find = x, r.expr = x.selectors, r.expr[\":\"] = r.expr.pseudos, r.uniqueSort = r.unique = x.uniqueSort, r.text = x.getText, r.isXMLDoc = x.isXML, r.contains = x.contains, r.escapeSelector = x.escape;var y = function y(a, b, c) {\n\t\tvar d = [],\n\t\t    e = void 0 !== c;while ((a = a[b]) && 9 !== a.nodeType) {\n\t\t\tif (1 === a.nodeType) {\n\t\t\t\tif (e && r(a).is(c)) break;d.push(a);\n\t\t\t}\n\t\t}return d;\n\t},\n\t    z = function z(a, b) {\n\t\tfor (var c = []; a; a = a.nextSibling) {\n\t\t\t1 === a.nodeType && a !== b && c.push(a);\n\t\t}return c;\n\t},\n\t    A = r.expr.match.needsContext;function B(a, b) {\n\t\treturn a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();\n\t}var C = /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i,\n\t    D = /^.[^:#\\[\\.,]*$/;function E(a, b, c) {\n\t\treturn r.isFunction(b) ? r.grep(a, function (a, d) {\n\t\t\treturn !!b.call(a, d, a) !== c;\n\t\t}) : b.nodeType ? r.grep(a, function (a) {\n\t\t\treturn a === b !== c;\n\t\t}) : \"string\" != typeof b ? r.grep(a, function (a) {\n\t\t\treturn i.call(b, a) > -1 !== c;\n\t\t}) : D.test(b) ? r.filter(b, a, c) : (b = r.filter(b, a), r.grep(a, function (a) {\n\t\t\treturn i.call(b, a) > -1 !== c && 1 === a.nodeType;\n\t\t}));\n\t}r.filter = function (a, b, c) {\n\t\tvar d = b[0];return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? r.find.matchesSelector(d, a) ? [d] : [] : r.find.matches(a, r.grep(b, function (a) {\n\t\t\treturn 1 === a.nodeType;\n\t\t}));\n\t}, r.fn.extend({ find: function find(a) {\n\t\t\tvar b,\n\t\t\t    c,\n\t\t\t    d = this.length,\n\t\t\t    e = this;if (\"string\" != typeof a) return this.pushStack(r(a).filter(function () {\n\t\t\t\tfor (b = 0; b < d; b++) {\n\t\t\t\t\tif (r.contains(e[b], this)) return !0;\n\t\t\t\t}\n\t\t\t}));for (c = this.pushStack([]), b = 0; b < d; b++) {\n\t\t\t\tr.find(a, e[b], c);\n\t\t\t}return d > 1 ? r.uniqueSort(c) : c;\n\t\t}, filter: function filter(a) {\n\t\t\treturn this.pushStack(E(this, a || [], !1));\n\t\t}, not: function not(a) {\n\t\t\treturn this.pushStack(E(this, a || [], !0));\n\t\t}, is: function is(a) {\n\t\t\treturn !!E(this, \"string\" == typeof a && A.test(a) ? r(a) : a || [], !1).length;\n\t\t} });var F,\n\t    G = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\t    H = r.fn.init = function (a, b, c) {\n\t\tvar e, f;if (!a) return this;if (c = c || F, \"string\" == typeof a) {\n\t\t\tif (e = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : G.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);if (e[1]) {\n\t\t\t\tif (b = b instanceof r ? b[0] : b, r.merge(this, r.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), C.test(e[1]) && r.isPlainObject(b)) for (e in b) {\n\t\t\t\t\tr.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);\n\t\t\t\t}return this;\n\t\t\t}return f = d.getElementById(e[2]), f && (this[0] = f, this.length = 1), this;\n\t\t}return a.nodeType ? (this[0] = a, this.length = 1, this) : r.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(r) : r.makeArray(a, this);\n\t};H.prototype = r.fn, F = r(d);var I = /^(?:parents|prev(?:Until|All))/,\n\t    J = { children: !0, contents: !0, next: !0, prev: !0 };r.fn.extend({ has: function has(a) {\n\t\t\tvar b = r(a, this),\n\t\t\t    c = b.length;return this.filter(function () {\n\t\t\t\tfor (var a = 0; a < c; a++) {\n\t\t\t\t\tif (r.contains(this, b[a])) return !0;\n\t\t\t\t}\n\t\t\t});\n\t\t}, closest: function closest(a, b) {\n\t\t\tvar c,\n\t\t\t    d = 0,\n\t\t\t    e = this.length,\n\t\t\t    f = [],\n\t\t\t    g = \"string\" != typeof a && r(a);if (!A.test(a)) for (; d < e; d++) {\n\t\t\t\tfor (c = this[d]; c && c !== b; c = c.parentNode) {\n\t\t\t\t\tif (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && r.find.matchesSelector(c, a))) {\n\t\t\t\t\t\tf.push(c);break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}return this.pushStack(f.length > 1 ? r.uniqueSort(f) : f);\n\t\t}, index: function index(a) {\n\t\t\treturn a ? \"string\" == typeof a ? i.call(r(a), this[0]) : i.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n\t\t}, add: function add(a, b) {\n\t\t\treturn this.pushStack(r.uniqueSort(r.merge(this.get(), r(a, b))));\n\t\t}, addBack: function addBack(a) {\n\t\t\treturn this.add(null == a ? this.prevObject : this.prevObject.filter(a));\n\t\t} });function K(a, b) {\n\t\twhile ((a = a[b]) && 1 !== a.nodeType) {}return a;\n\t}r.each({ parent: function parent(a) {\n\t\t\tvar b = a.parentNode;return b && 11 !== b.nodeType ? b : null;\n\t\t}, parents: function parents(a) {\n\t\t\treturn y(a, \"parentNode\");\n\t\t}, parentsUntil: function parentsUntil(a, b, c) {\n\t\t\treturn y(a, \"parentNode\", c);\n\t\t}, next: function next(a) {\n\t\t\treturn K(a, \"nextSibling\");\n\t\t}, prev: function prev(a) {\n\t\t\treturn K(a, \"previousSibling\");\n\t\t}, nextAll: function nextAll(a) {\n\t\t\treturn y(a, \"nextSibling\");\n\t\t}, prevAll: function prevAll(a) {\n\t\t\treturn y(a, \"previousSibling\");\n\t\t}, nextUntil: function nextUntil(a, b, c) {\n\t\t\treturn y(a, \"nextSibling\", c);\n\t\t}, prevUntil: function prevUntil(a, b, c) {\n\t\t\treturn y(a, \"previousSibling\", c);\n\t\t}, siblings: function siblings(a) {\n\t\t\treturn z((a.parentNode || {}).firstChild, a);\n\t\t}, children: function children(a) {\n\t\t\treturn z(a.firstChild);\n\t\t}, contents: function contents(a) {\n\t\t\treturn B(a, \"iframe\") ? a.contentDocument : (B(a, \"template\") && (a = a.content || a), r.merge([], a.childNodes));\n\t\t} }, function (a, b) {\n\t\tr.fn[a] = function (c, d) {\n\t\t\tvar e = r.map(this, b, c);return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = r.filter(d, e)), this.length > 1 && (J[a] || r.uniqueSort(e), I.test(a) && e.reverse()), this.pushStack(e);\n\t\t};\n\t});var L = /[^\\x20\\t\\r\\n\\f]+/g;function M(a) {\n\t\tvar b = {};return r.each(a.match(L) || [], function (a, c) {\n\t\t\tb[c] = !0;\n\t\t}), b;\n\t}r.Callbacks = function (a) {\n\t\ta = \"string\" == typeof a ? M(a) : r.extend({}, a);var b,\n\t\t    c,\n\t\t    d,\n\t\t    e,\n\t\t    f = [],\n\t\t    g = [],\n\t\t    h = -1,\n\t\t    i = function i() {\n\t\t\tfor (e = e || a.once, d = b = !0; g.length; h = -1) {\n\t\t\t\tc = g.shift();while (++h < f.length) {\n\t\t\t\t\tf[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1);\n\t\t\t\t}\n\t\t\t}a.memory || (c = !1), b = !1, e && (f = c ? [] : \"\");\n\t\t},\n\t\t    j = { add: function add() {\n\t\t\t\treturn f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {\n\t\t\t\t\tr.each(b, function (b, c) {\n\t\t\t\t\t\tr.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && \"string\" !== r.type(c) && d(c);\n\t\t\t\t\t});\n\t\t\t\t}(arguments), c && !b && i()), this;\n\t\t\t}, remove: function remove() {\n\t\t\t\treturn r.each(arguments, function (a, b) {\n\t\t\t\t\tvar c;while ((c = r.inArray(b, f, c)) > -1) {\n\t\t\t\t\t\tf.splice(c, 1), c <= h && h--;\n\t\t\t\t\t}\n\t\t\t\t}), this;\n\t\t\t}, has: function has(a) {\n\t\t\t\treturn a ? r.inArray(a, f) > -1 : f.length > 0;\n\t\t\t}, empty: function empty() {\n\t\t\t\treturn f && (f = []), this;\n\t\t\t}, disable: function disable() {\n\t\t\t\treturn e = g = [], f = c = \"\", this;\n\t\t\t}, disabled: function disabled() {\n\t\t\t\treturn !f;\n\t\t\t}, lock: function lock() {\n\t\t\t\treturn e = g = [], c || b || (f = c = \"\"), this;\n\t\t\t}, locked: function locked() {\n\t\t\t\treturn !!e;\n\t\t\t}, fireWith: function fireWith(a, c) {\n\t\t\t\treturn e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this;\n\t\t\t}, fire: function fire() {\n\t\t\t\treturn j.fireWith(this, arguments), this;\n\t\t\t}, fired: function fired() {\n\t\t\t\treturn !!d;\n\t\t\t} };return j;\n\t};function N(a) {\n\t\treturn a;\n\t}function O(a) {\n\t\tthrow a;\n\t}function P(a, b, c, d) {\n\t\tvar e;try {\n\t\t\ta && r.isFunction(e = a.promise) ? e.call(a).done(b).fail(c) : a && r.isFunction(e = a.then) ? e.call(a, b, c) : b.apply(void 0, [a].slice(d));\n\t\t} catch (a) {\n\t\t\tc.apply(void 0, [a]);\n\t\t}\n\t}r.extend({ Deferred: function Deferred(b) {\n\t\t\tvar c = [[\"notify\", \"progress\", r.Callbacks(\"memory\"), r.Callbacks(\"memory\"), 2], [\"resolve\", \"done\", r.Callbacks(\"once memory\"), r.Callbacks(\"once memory\"), 0, \"resolved\"], [\"reject\", \"fail\", r.Callbacks(\"once memory\"), r.Callbacks(\"once memory\"), 1, \"rejected\"]],\n\t\t\t    d = \"pending\",\n\t\t\t    e = { state: function state() {\n\t\t\t\t\treturn d;\n\t\t\t\t}, always: function always() {\n\t\t\t\t\treturn f.done(arguments).fail(arguments), this;\n\t\t\t\t}, \"catch\": function _catch(a) {\n\t\t\t\t\treturn e.then(null, a);\n\t\t\t\t}, pipe: function pipe() {\n\t\t\t\t\tvar a = arguments;return r.Deferred(function (b) {\n\t\t\t\t\t\tr.each(c, function (c, d) {\n\t\t\t\t\t\t\tvar e = r.isFunction(a[d[4]]) && a[d[4]];f[d[1]](function () {\n\t\t\t\t\t\t\t\tvar a = e && e.apply(this, arguments);a && r.isFunction(a.promise) ? a.promise().progress(b.notify).done(b.resolve).fail(b.reject) : b[d[0] + \"With\"](this, e ? [a] : arguments);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}), a = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t}, then: function then(b, d, e) {\n\t\t\t\t\tvar f = 0;function g(b, c, d, e) {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tvar h = this,\n\t\t\t\t\t\t\t    i = arguments,\n\t\t\t\t\t\t\t    j = function j() {\n\t\t\t\t\t\t\t\tvar a, j;if (!(b < f)) {\n\t\t\t\t\t\t\t\t\tif (a = d.apply(h, i), a === c.promise()) throw new TypeError(\"Thenable self-resolution\");j = a && (\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) || \"function\" == typeof a) && a.then, r.isFunction(j) ? e ? j.call(a, g(f, c, N, e), g(f, c, O, e)) : (f++, j.call(a, g(f, c, N, e), g(f, c, O, e), g(f, c, N, c.notifyWith))) : (d !== N && (h = void 0, i = [a]), (e || c.resolveWith)(h, i));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t    k = e ? j : function () {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tj();\n\t\t\t\t\t\t\t\t} catch (a) {\n\t\t\t\t\t\t\t\t\tr.Deferred.exceptionHook && r.Deferred.exceptionHook(a, k.stackTrace), b + 1 >= f && (d !== O && (h = void 0, i = [a]), c.rejectWith(h, i));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};b ? k() : (r.Deferred.getStackHook && (k.stackTrace = r.Deferred.getStackHook()), a.setTimeout(k));\n\t\t\t\t\t\t};\n\t\t\t\t\t}return r.Deferred(function (a) {\n\t\t\t\t\t\tc[0][3].add(g(0, a, r.isFunction(e) ? e : N, a.notifyWith)), c[1][3].add(g(0, a, r.isFunction(b) ? b : N)), c[2][3].add(g(0, a, r.isFunction(d) ? d : O));\n\t\t\t\t\t}).promise();\n\t\t\t\t}, promise: function promise(a) {\n\t\t\t\t\treturn null != a ? r.extend(a, e) : e;\n\t\t\t\t} },\n\t\t\t    f = {};return r.each(c, function (a, b) {\n\t\t\t\tvar g = b[2],\n\t\t\t\t    h = b[5];e[b[1]] = g.add, h && g.add(function () {\n\t\t\t\t\td = h;\n\t\t\t\t}, c[3 - a][2].disable, c[0][2].lock), g.add(b[3].fire), f[b[0]] = function () {\n\t\t\t\t\treturn f[b[0] + \"With\"](this === f ? void 0 : this, arguments), this;\n\t\t\t\t}, f[b[0] + \"With\"] = g.fireWith;\n\t\t\t}), e.promise(f), b && b.call(f, f), f;\n\t\t}, when: function when(a) {\n\t\t\tvar b = arguments.length,\n\t\t\t    c = b,\n\t\t\t    d = Array(c),\n\t\t\t    e = f.call(arguments),\n\t\t\t    g = r.Deferred(),\n\t\t\t    h = function h(a) {\n\t\t\t\treturn function (c) {\n\t\t\t\t\td[a] = this, e[a] = arguments.length > 1 ? f.call(arguments) : c, --b || g.resolveWith(d, e);\n\t\t\t\t};\n\t\t\t};if (b <= 1 && (P(a, g.done(h(c)).resolve, g.reject, !b), \"pending\" === g.state() || r.isFunction(e[c] && e[c].then))) return g.then();while (c--) {\n\t\t\t\tP(e[c], h(c), g.reject);\n\t\t\t}return g.promise();\n\t\t} });var Q = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook = function (b, c) {\n\t\ta.console && a.console.warn && b && Q.test(b.name) && a.console.warn(\"jQuery.Deferred exception: \" + b.message, b.stack, c);\n\t}, r.readyException = function (b) {\n\t\ta.setTimeout(function () {\n\t\t\tthrow b;\n\t\t});\n\t};var R = r.Deferred();r.fn.ready = function (a) {\n\t\treturn R.then(a)[\"catch\"](function (a) {\n\t\t\tr.readyException(a);\n\t\t}), this;\n\t}, r.extend({ isReady: !1, readyWait: 1, ready: function ready(a) {\n\t\t\t(a === !0 ? --r.readyWait : r.isReady) || (r.isReady = !0, a !== !0 && --r.readyWait > 0 || R.resolveWith(d, [r]));\n\t\t} }), r.ready.then = R.then;function S() {\n\t\td.removeEventListener(\"DOMContentLoaded\", S), a.removeEventListener(\"load\", S), r.ready();\n\t}\"complete\" === d.readyState || \"loading\" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(r.ready) : (d.addEventListener(\"DOMContentLoaded\", S), a.addEventListener(\"load\", S));var T = function T(a, b, c, d, e, f, g) {\n\t\tvar h = 0,\n\t\t    i = a.length,\n\t\t    j = null == c;if (\"object\" === r.type(c)) {\n\t\t\te = !0;for (h in c) {\n\t\t\t\tT(a, b, h, c[h], !0, f, g);\n\t\t\t}\n\t\t} else if (void 0 !== d && (e = !0, r.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function b(a, _b, c) {\n\t\t\treturn j.call(r(a), c);\n\t\t})), b)) for (; h < i; h++) {\n\t\t\tb(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n\t\t}return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;\n\t},\n\t    U = function U(a) {\n\t\treturn 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;\n\t};function V() {\n\t\tthis.expando = r.expando + V.uid++;\n\t}V.uid = 1, V.prototype = { cache: function cache(a) {\n\t\t\tvar b = a[this.expando];return b || (b = {}, U(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, { value: b, configurable: !0 }))), b;\n\t\t}, set: function set(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e = this.cache(a);if (\"string\" == typeof b) e[r.camelCase(b)] = c;else for (d in b) {\n\t\t\t\te[r.camelCase(d)] = b[d];\n\t\t\t}return e;\n\t\t}, get: function get(a, b) {\n\t\t\treturn void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][r.camelCase(b)];\n\t\t}, access: function access(a, b, c) {\n\t\t\treturn void 0 === b || b && \"string\" == typeof b && void 0 === c ? this.get(a, b) : (this.set(a, b, c), void 0 !== c ? c : b);\n\t\t}, remove: function remove(a, b) {\n\t\t\tvar c,\n\t\t\t    d = a[this.expando];if (void 0 !== d) {\n\t\t\t\tif (void 0 !== b) {\n\t\t\t\t\tArray.isArray(b) ? b = b.map(r.camelCase) : (b = r.camelCase(b), b = b in d ? [b] : b.match(L) || []), c = b.length;while (c--) {\n\t\t\t\t\t\tdelete d[b[c]];\n\t\t\t\t\t}\n\t\t\t\t}(void 0 === b || r.isEmptyObject(d)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando]);\n\t\t\t}\n\t\t}, hasData: function hasData(a) {\n\t\t\tvar b = a[this.expando];return void 0 !== b && !r.isEmptyObject(b);\n\t\t} };var W = new V(),\n\t    X = new V(),\n\t    Y = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\t    Z = /[A-Z]/g;function $(a) {\n\t\treturn \"true\" === a || \"false\" !== a && (\"null\" === a ? null : a === +a + \"\" ? +a : Y.test(a) ? JSON.parse(a) : a);\n\t}function _(a, b, c) {\n\t\tvar d;if (void 0 === c && 1 === a.nodeType) if (d = \"data-\" + b.replace(Z, \"-$&\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n\t\t\ttry {\n\t\t\t\tc = $(c);\n\t\t\t} catch (e) {}X.set(a, b, c);\n\t\t} else c = void 0;return c;\n\t}r.extend({ hasData: function hasData(a) {\n\t\t\treturn X.hasData(a) || W.hasData(a);\n\t\t}, data: function data(a, b, c) {\n\t\t\treturn X.access(a, b, c);\n\t\t}, removeData: function removeData(a, b) {\n\t\t\tX.remove(a, b);\n\t\t}, _data: function _data(a, b, c) {\n\t\t\treturn W.access(a, b, c);\n\t\t}, _removeData: function _removeData(a, b) {\n\t\t\tW.remove(a, b);\n\t\t} }), r.fn.extend({ data: function data(a, b) {\n\t\t\tvar c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f = this[0],\n\t\t\t    g = f && f.attributes;if (void 0 === a) {\n\t\t\t\tif (this.length && (e = X.get(f), 1 === f.nodeType && !W.get(f, \"hasDataAttrs\"))) {\n\t\t\t\t\tc = g.length;while (c--) {\n\t\t\t\t\t\tg[c] && (d = g[c].name, 0 === d.indexOf(\"data-\") && (d = r.camelCase(d.slice(5)), _(f, d, e[d])));\n\t\t\t\t\t}W.set(f, \"hasDataAttrs\", !0);\n\t\t\t\t}return e;\n\t\t\t}return \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? this.each(function () {\n\t\t\t\tX.set(this, a);\n\t\t\t}) : T(this, function (b) {\n\t\t\t\tvar c;if (f && void 0 === b) {\n\t\t\t\t\tif (c = X.get(f, a), void 0 !== c) return c;if (c = _(f, a), void 0 !== c) return c;\n\t\t\t\t} else this.each(function () {\n\t\t\t\t\tX.set(this, a, b);\n\t\t\t\t});\n\t\t\t}, null, b, arguments.length > 1, null, !0);\n\t\t}, removeData: function removeData(a) {\n\t\t\treturn this.each(function () {\n\t\t\t\tX.remove(this, a);\n\t\t\t});\n\t\t} }), r.extend({ queue: function queue(a, b, c) {\n\t\t\tvar d;if (a) return b = (b || \"fx\") + \"queue\", d = W.get(a, b), c && (!d || Array.isArray(c) ? d = W.access(a, b, r.makeArray(c)) : d.push(c)), d || [];\n\t\t}, dequeue: function dequeue(a, b) {\n\t\t\tb = b || \"fx\";var c = r.queue(a, b),\n\t\t\t    d = c.length,\n\t\t\t    e = c.shift(),\n\t\t\t    f = r._queueHooks(a, b),\n\t\t\t    g = function g() {\n\t\t\t\tr.dequeue(a, b);\n\t\t\t};\"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();\n\t\t}, _queueHooks: function _queueHooks(a, b) {\n\t\t\tvar c = b + \"queueHooks\";return W.get(a, c) || W.access(a, c, { empty: r.Callbacks(\"once memory\").add(function () {\n\t\t\t\t\tW.remove(a, [b + \"queue\", c]);\n\t\t\t\t}) });\n\t\t} }), r.fn.extend({ queue: function queue(a, b) {\n\t\t\tvar c = 2;return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? r.queue(this[0], a) : void 0 === b ? this : this.each(function () {\n\t\t\t\tvar c = r.queue(this, a, b);r._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && r.dequeue(this, a);\n\t\t\t});\n\t\t}, dequeue: function dequeue(a) {\n\t\t\treturn this.each(function () {\n\t\t\t\tr.dequeue(this, a);\n\t\t\t});\n\t\t}, clearQueue: function clearQueue(a) {\n\t\t\treturn this.queue(a || \"fx\", []);\n\t\t}, promise: function promise(a, b) {\n\t\t\tvar c,\n\t\t\t    d = 1,\n\t\t\t    e = r.Deferred(),\n\t\t\t    f = this,\n\t\t\t    g = this.length,\n\t\t\t    h = function h() {\n\t\t\t\t--d || e.resolveWith(f, [f]);\n\t\t\t};\"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";while (g--) {\n\t\t\t\tc = W.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n\t\t\t}return h(), e.promise(b);\n\t\t} });var aa = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n\t    ba = new RegExp(\"^(?:([+-])=|)(\" + aa + \")([a-z%]*)$\", \"i\"),\n\t    ca = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n\t    da = function da(a, b) {\n\t\treturn a = b || a, \"none\" === a.style.display || \"\" === a.style.display && r.contains(a.ownerDocument, a) && \"none\" === r.css(a, \"display\");\n\t},\n\t    ea = function ea(a, b, c, d) {\n\t\tvar e,\n\t\t    f,\n\t\t    g = {};for (f in b) {\n\t\t\tg[f] = a.style[f], a.style[f] = b[f];\n\t\t}e = c.apply(a, d || []);for (f in b) {\n\t\t\ta.style[f] = g[f];\n\t\t}return e;\n\t};function fa(a, b, c, d) {\n\t\tvar e,\n\t\t    f = 1,\n\t\t    g = 20,\n\t\t    h = d ? function () {\n\t\t\treturn d.cur();\n\t\t} : function () {\n\t\t\treturn r.css(a, b, \"\");\n\t\t},\n\t\t    i = h(),\n\t\t    j = c && c[3] || (r.cssNumber[b] ? \"\" : \"px\"),\n\t\t    k = (r.cssNumber[b] || \"px\" !== j && +i) && ba.exec(r.css(a, b));if (k && k[3] !== j) {\n\t\t\tj = j || k[3], c = c || [], k = +i || 1;do {\n\t\t\t\tf = f || \".5\", k /= f, r.style(a, b, k + j);\n\t\t\t} while (f !== (f = h() / i) && 1 !== f && --g);\n\t\t}return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e;\n\t}var ga = {};function ha(a) {\n\t\tvar b,\n\t\t    c = a.ownerDocument,\n\t\t    d = a.nodeName,\n\t\t    e = ga[d];return e ? e : (b = c.body.appendChild(c.createElement(d)), e = r.css(b, \"display\"), b.parentNode.removeChild(b), \"none\" === e && (e = \"block\"), ga[d] = e, e);\n\t}function ia(a, b) {\n\t\tfor (var c, d, e = [], f = 0, g = a.length; f < g; f++) {\n\t\t\td = a[f], d.style && (c = d.style.display, b ? (\"none\" === c && (e[f] = W.get(d, \"display\") || null, e[f] || (d.style.display = \"\")), \"\" === d.style.display && da(d) && (e[f] = ha(d))) : \"none\" !== c && (e[f] = \"none\", W.set(d, \"display\", c)));\n\t\t}for (f = 0; f < g; f++) {\n\t\t\tnull != e[f] && (a[f].style.display = e[f]);\n\t\t}return a;\n\t}r.fn.extend({ show: function show() {\n\t\t\treturn ia(this, !0);\n\t\t}, hide: function hide() {\n\t\t\treturn ia(this);\n\t\t}, toggle: function toggle(a) {\n\t\t\treturn \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function () {\n\t\t\t\tda(this) ? r(this).show() : r(this).hide();\n\t\t\t});\n\t\t} });var ja = /^(?:checkbox|radio)$/i,\n\t    ka = /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i,\n\t    la = /^$|\\/(?:java|ecma)script/i,\n\t    ma = { option: [1, \"<select multiple='multiple'>\", \"</select>\"], thead: [1, \"<table>\", \"</table>\"], col: [2, \"<table><colgroup>\", \"</colgroup></table>\"], tr: [2, \"<table><tbody>\", \"</tbody></table>\"], td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"], _default: [0, \"\", \"\"] };ma.optgroup = ma.option, ma.tbody = ma.tfoot = ma.colgroup = ma.caption = ma.thead, ma.th = ma.td;function na(a, b) {\n\t\tvar c;return c = \"undefined\" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : \"undefined\" != typeof a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [], void 0 === b || b && B(a, b) ? r.merge([a], c) : c;\n\t}function oa(a, b) {\n\t\tfor (var c = 0, d = a.length; c < d; c++) {\n\t\t\tW.set(a[c], \"globalEval\", !b || W.get(b[c], \"globalEval\"));\n\t\t}\n\t}var pa = /<|&#?\\w+;/;function qa(a, b, c, d, e) {\n\t\tfor (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], n = 0, o = a.length; n < o; n++) {\n\t\t\tif (f = a[n], f || 0 === f) if (\"object\" === r.type(f)) r.merge(m, f.nodeType ? [f] : f);else if (pa.test(f)) {\n\t\t\t\tg = g || l.appendChild(b.createElement(\"div\")), h = (ka.exec(f) || [\"\", \"\"])[1].toLowerCase(), i = ma[h] || ma._default, g.innerHTML = i[1] + r.htmlPrefilter(f) + i[2], k = i[0];while (k--) {\n\t\t\t\t\tg = g.lastChild;\n\t\t\t\t}r.merge(m, g.childNodes), g = l.firstChild, g.textContent = \"\";\n\t\t\t} else m.push(b.createTextNode(f));\n\t\t}l.textContent = \"\", n = 0;while (f = m[n++]) {\n\t\t\tif (d && r.inArray(f, d) > -1) e && e.push(f);else if (j = r.contains(f.ownerDocument, f), g = na(l.appendChild(f), \"script\"), j && oa(g), c) {\n\t\t\t\tk = 0;while (f = g[k++]) {\n\t\t\t\t\tla.test(f.type || \"\") && c.push(f);\n\t\t\t\t}\n\t\t\t}\n\t\t}return l;\n\t}!function () {\n\t\tvar a = d.createDocumentFragment(),\n\t\t    b = a.appendChild(d.createElement(\"div\")),\n\t\t    c = d.createElement(\"input\");c.setAttribute(\"type\", \"radio\"), c.setAttribute(\"checked\", \"checked\"), c.setAttribute(\"name\", \"t\"), b.appendChild(c), o.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", o.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;\n\t}();var ra = d.documentElement,\n\t    sa = /^key/,\n\t    ta = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\t    ua = /^([^.]*)(?:\\.(.+)|)/;function va() {\n\t\treturn !0;\n\t}function wa() {\n\t\treturn !1;\n\t}function xa() {\n\t\ttry {\n\t\t\treturn d.activeElement;\n\t\t} catch (a) {}\n\t}function ya(a, b, c, d, e, f) {\n\t\tvar g, h;if (\"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b))) {\n\t\t\t\"string\" != typeof c && (d = d || c, c = void 0);for (h in b) {\n\t\t\t\tya(a, h, c, d, b[h], f);\n\t\t\t}return a;\n\t\t}if (null == d && null == e ? (e = c, d = c = void 0) : null == e && (\"string\" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = wa;else if (!e) return a;return 1 === f && (g = e, e = function e(a) {\n\t\t\treturn r().off(a), g.apply(this, arguments);\n\t\t}, e.guid = g.guid || (g.guid = r.guid++)), a.each(function () {\n\t\t\tr.event.add(this, b, e, d, c);\n\t\t});\n\t}r.event = { global: {}, add: function add(a, b, c, d, e) {\n\t\t\tvar f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    l,\n\t\t\t    m,\n\t\t\t    n,\n\t\t\t    o,\n\t\t\t    p,\n\t\t\t    q = W.get(a);if (q) {\n\t\t\t\tc.handler && (f = c, c = f.handler, e = f.selector), e && r.find.matchesSelector(ra, e), c.guid || (c.guid = r.guid++), (i = q.events) || (i = q.events = {}), (g = q.handle) || (g = q.handle = function (b) {\n\t\t\t\t\treturn \"undefined\" != typeof r && r.event.triggered !== b.type ? r.event.dispatch.apply(a, arguments) : void 0;\n\t\t\t\t}), b = (b || \"\").match(L) || [\"\"], j = b.length;while (j--) {\n\t\t\t\t\th = ua.exec(b[j]) || [], n = p = h[1], o = (h[2] || \"\").split(\".\").sort(), n && (l = r.event.special[n] || {}, n = (e ? l.delegateType : l.bindType) || n, l = r.event.special[n] || {}, k = r.extend({ type: n, origType: p, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && r.expr.match.needsContext.test(e), namespace: o.join(\".\") }, f), (m = i[n]) || (m = i[n] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, o, g) !== !1 || a.addEventListener && a.addEventListener(n, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), r.event.global[n] = !0);\n\t\t\t\t}\n\t\t\t}\n\t\t}, remove: function remove(a, b, c, d, e) {\n\t\t\tvar f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    l,\n\t\t\t    m,\n\t\t\t    n,\n\t\t\t    o,\n\t\t\t    p,\n\t\t\t    q = W.hasData(a) && W.get(a);if (q && (i = q.events)) {\n\t\t\t\tb = (b || \"\").match(L) || [\"\"], j = b.length;while (j--) {\n\t\t\t\t\tif (h = ua.exec(b[j]) || [], n = p = h[1], o = (h[2] || \"\").split(\".\").sort(), n) {\n\t\t\t\t\t\tl = r.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, m = i[n] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + o.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;while (f--) {\n\t\t\t\t\t\t\tk = m[f], !e && p !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n\t\t\t\t\t\t}g && !m.length && (l.teardown && l.teardown.call(a, o, q.handle) !== !1 || r.removeEvent(a, n, q.handle), delete i[n]);\n\t\t\t\t\t} else for (n in i) {\n\t\t\t\t\t\tr.event.remove(a, n + b[j], c, d, !0);\n\t\t\t\t\t}\n\t\t\t\t}r.isEmptyObject(i) && W.remove(a, \"handle events\");\n\t\t\t}\n\t\t}, dispatch: function dispatch(a) {\n\t\t\tvar b = r.event.fix(a),\n\t\t\t    c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i = new Array(arguments.length),\n\t\t\t    j = (W.get(this, \"events\") || {})[b.type] || [],\n\t\t\t    k = r.event.special[b.type] || {};for (i[0] = b, c = 1; c < arguments.length; c++) {\n\t\t\t\ti[c] = arguments[c];\n\t\t\t}if (b.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, b) !== !1) {\n\t\t\t\th = r.event.handlers.call(this, b, j), c = 0;while ((f = h[c++]) && !b.isPropagationStopped()) {\n\t\t\t\t\tb.currentTarget = f.elem, d = 0;while ((g = f.handlers[d++]) && !b.isImmediatePropagationStopped()) {\n\t\t\t\t\t\tb.rnamespace && !b.rnamespace.test(g.namespace) || (b.handleObj = g, b.data = g.data, e = ((r.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== e && (b.result = e) === !1 && (b.preventDefault(), b.stopPropagation()));\n\t\t\t\t\t}\n\t\t\t\t}return k.postDispatch && k.postDispatch.call(this, b), b.result;\n\t\t\t}\n\t\t}, handlers: function handlers(a, b) {\n\t\t\tvar c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h = [],\n\t\t\t    i = b.delegateCount,\n\t\t\t    j = a.target;if (i && j.nodeType && !(\"click\" === a.type && a.button >= 1)) for (; j !== this; j = j.parentNode || this) {\n\t\t\t\tif (1 === j.nodeType && (\"click\" !== a.type || j.disabled !== !0)) {\n\t\t\t\t\tfor (f = [], g = {}, c = 0; c < i; c++) {\n\t\t\t\t\t\td = b[c], e = d.selector + \" \", void 0 === g[e] && (g[e] = d.needsContext ? r(e, this).index(j) > -1 : r.find(e, this, null, [j]).length), g[e] && f.push(d);\n\t\t\t\t\t}f.length && h.push({ elem: j, handlers: f });\n\t\t\t\t}\n\t\t\t}return j = this, i < b.length && h.push({ elem: j, handlers: b.slice(i) }), h;\n\t\t}, addProp: function addProp(a, b) {\n\t\t\tObject.defineProperty(r.Event.prototype, a, { enumerable: !0, configurable: !0, get: r.isFunction(b) ? function () {\n\t\t\t\t\tif (this.originalEvent) return b(this.originalEvent);\n\t\t\t\t} : function () {\n\t\t\t\t\tif (this.originalEvent) return this.originalEvent[a];\n\t\t\t\t}, set: function set(b) {\n\t\t\t\t\tObject.defineProperty(this, a, { enumerable: !0, configurable: !0, writable: !0, value: b });\n\t\t\t\t} });\n\t\t}, fix: function fix(a) {\n\t\t\treturn a[r.expando] ? a : new r.Event(a);\n\t\t}, special: { load: { noBubble: !0 }, focus: { trigger: function trigger() {\n\t\t\t\t\tif (this !== xa() && this.focus) return this.focus(), !1;\n\t\t\t\t}, delegateType: \"focusin\" }, blur: { trigger: function trigger() {\n\t\t\t\t\tif (this === xa() && this.blur) return this.blur(), !1;\n\t\t\t\t}, delegateType: \"focusout\" }, click: { trigger: function trigger() {\n\t\t\t\t\tif (\"checkbox\" === this.type && this.click && B(this, \"input\")) return this.click(), !1;\n\t\t\t\t}, _default: function _default(a) {\n\t\t\t\t\treturn B(a.target, \"a\");\n\t\t\t\t} }, beforeunload: { postDispatch: function postDispatch(a) {\n\t\t\t\t\tvoid 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);\n\t\t\t\t} } } }, r.removeEvent = function (a, b, c) {\n\t\ta.removeEventListener && a.removeEventListener(b, c);\n\t}, r.Event = function (a, b) {\n\t\treturn this instanceof r.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? va : wa, this.target = a.target && 3 === a.target.nodeType ? a.target.parentNode : a.target, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget) : this.type = a, b && r.extend(this, b), this.timeStamp = a && a.timeStamp || r.now(), void (this[r.expando] = !0)) : new r.Event(a, b);\n\t}, r.Event.prototype = { constructor: r.Event, isDefaultPrevented: wa, isPropagationStopped: wa, isImmediatePropagationStopped: wa, isSimulated: !1, preventDefault: function preventDefault() {\n\t\t\tvar a = this.originalEvent;this.isDefaultPrevented = va, a && !this.isSimulated && a.preventDefault();\n\t\t}, stopPropagation: function stopPropagation() {\n\t\t\tvar a = this.originalEvent;this.isPropagationStopped = va, a && !this.isSimulated && a.stopPropagation();\n\t\t}, stopImmediatePropagation: function stopImmediatePropagation() {\n\t\t\tvar a = this.originalEvent;this.isImmediatePropagationStopped = va, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation();\n\t\t} }, r.each({ altKey: !0, bubbles: !0, cancelable: !0, changedTouches: !0, ctrlKey: !0, detail: !0, eventPhase: !0, metaKey: !0, pageX: !0, pageY: !0, shiftKey: !0, view: !0, \"char\": !0, charCode: !0, key: !0, keyCode: !0, button: !0, buttons: !0, clientX: !0, clientY: !0, offsetX: !0, offsetY: !0, pointerId: !0, pointerType: !0, screenX: !0, screenY: !0, targetTouches: !0, toElement: !0, touches: !0, which: function which(a) {\n\t\t\tvar b = a.button;return null == a.which && sa.test(a.type) ? null != a.charCode ? a.charCode : a.keyCode : !a.which && void 0 !== b && ta.test(a.type) ? 1 & b ? 1 : 2 & b ? 3 : 4 & b ? 2 : 0 : a.which;\n\t\t} }, r.event.addProp), r.each({ mouseenter: \"mouseover\", mouseleave: \"mouseout\", pointerenter: \"pointerover\", pointerleave: \"pointerout\" }, function (a, b) {\n\t\tr.event.special[a] = { delegateType: b, bindType: b, handle: function handle(a) {\n\t\t\t\tvar c,\n\t\t\t\t    d = this,\n\t\t\t\t    e = a.relatedTarget,\n\t\t\t\t    f = a.handleObj;return e && (e === d || r.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;\n\t\t\t} };\n\t}), r.fn.extend({ on: function on(a, b, c, d) {\n\t\t\treturn ya(this, a, b, c, d);\n\t\t}, one: function one(a, b, c, d) {\n\t\t\treturn ya(this, a, b, c, d, 1);\n\t\t}, off: function off(a, b, c) {\n\t\t\tvar d, e;if (a && a.preventDefault && a.handleObj) return d = a.handleObj, r(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;if (\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a))) {\n\t\t\t\tfor (e in a) {\n\t\t\t\t\tthis.off(e, b, a[e]);\n\t\t\t\t}return this;\n\t\t\t}return b !== !1 && \"function\" != typeof b || (c = b, b = void 0), c === !1 && (c = wa), this.each(function () {\n\t\t\t\tr.event.remove(this, a, c, b);\n\t\t\t});\n\t\t} });var za = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\t    Aa = /<script|<style|<link/i,\n\t    Ba = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\t    Ca = /^true\\/(.*)/,\n\t    Da = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function Ea(a, b) {\n\t\treturn B(a, \"table\") && B(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? r(\">tbody\", a)[0] || a : a;\n\t}function Fa(a) {\n\t\treturn a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a;\n\t}function Ga(a) {\n\t\tvar b = Ca.exec(a.type);return b ? a.type = b[1] : a.removeAttribute(\"type\"), a;\n\t}function Ha(a, b) {\n\t\tvar c, d, e, f, g, h, i, j;if (1 === b.nodeType) {\n\t\t\tif (W.hasData(a) && (f = W.access(a), g = W.set(b, f), j = f.events)) {\n\t\t\t\tdelete g.handle, g.events = {};for (e in j) {\n\t\t\t\t\tfor (c = 0, d = j[e].length; c < d; c++) {\n\t\t\t\t\t\tr.event.add(b, e, j[e][c]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}X.hasData(a) && (h = X.access(a), i = r.extend({}, h), X.set(b, i));\n\t\t}\n\t}function Ia(a, b) {\n\t\tvar c = b.nodeName.toLowerCase();\"input\" === c && ja.test(a.type) ? b.checked = a.checked : \"input\" !== c && \"textarea\" !== c || (b.defaultValue = a.defaultValue);\n\t}function Ja(a, b, c, d) {\n\t\tb = g.apply([], b);var e,\n\t\t    f,\n\t\t    h,\n\t\t    i,\n\t\t    j,\n\t\t    k,\n\t\t    l = 0,\n\t\t    m = a.length,\n\t\t    n = m - 1,\n\t\t    q = b[0],\n\t\t    s = r.isFunction(q);if (s || m > 1 && \"string\" == typeof q && !o.checkClone && Ba.test(q)) return a.each(function (e) {\n\t\t\tvar f = a.eq(e);s && (b[0] = q.call(this, e, f.html())), Ja(f, b, c, d);\n\t\t});if (m && (e = qa(b, a[0].ownerDocument, !1, a, d), f = e.firstChild, 1 === e.childNodes.length && (e = f), f || d)) {\n\t\t\tfor (h = r.map(na(e, \"script\"), Fa), i = h.length; l < m; l++) {\n\t\t\t\tj = e, l !== n && (j = r.clone(j, !0, !0), i && r.merge(h, na(j, \"script\"))), c.call(a[l], j, l);\n\t\t\t}if (i) for (k = h[h.length - 1].ownerDocument, r.map(h, Ga), l = 0; l < i; l++) {\n\t\t\t\tj = h[l], la.test(j.type || \"\") && !W.access(j, \"globalEval\") && r.contains(k, j) && (j.src ? r._evalUrl && r._evalUrl(j.src) : p(j.textContent.replace(Da, \"\"), k));\n\t\t\t}\n\t\t}return a;\n\t}function Ka(a, b, c) {\n\t\tfor (var d, e = b ? r.filter(b, a) : a, f = 0; null != (d = e[f]); f++) {\n\t\t\tc || 1 !== d.nodeType || r.cleanData(na(d)), d.parentNode && (c && r.contains(d.ownerDocument, d) && oa(na(d, \"script\")), d.parentNode.removeChild(d));\n\t\t}return a;\n\t}r.extend({ htmlPrefilter: function htmlPrefilter(a) {\n\t\t\treturn a.replace(za, \"<$1></$2>\");\n\t\t}, clone: function clone(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h = a.cloneNode(!0),\n\t\t\t    i = r.contains(a.ownerDocument, a);if (!(o.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || r.isXMLDoc(a))) for (g = na(h), f = na(a), d = 0, e = f.length; d < e; d++) {\n\t\t\t\tIa(f[d], g[d]);\n\t\t\t}if (b) if (c) for (f = f || na(a), g = g || na(h), d = 0, e = f.length; d < e; d++) {\n\t\t\t\tHa(f[d], g[d]);\n\t\t\t} else Ha(a, h);return g = na(h, \"script\"), g.length > 0 && oa(g, !i && na(a, \"script\")), h;\n\t\t}, cleanData: function cleanData(a) {\n\t\t\tfor (var b, c, d, e = r.event.special, f = 0; void 0 !== (c = a[f]); f++) {\n\t\t\t\tif (U(c)) {\n\t\t\t\t\tif (b = c[W.expando]) {\n\t\t\t\t\t\tif (b.events) for (d in b.events) {\n\t\t\t\t\t\t\te[d] ? r.event.remove(c, d) : r.removeEvent(c, d, b.handle);\n\t\t\t\t\t\t}c[W.expando] = void 0;\n\t\t\t\t\t}c[X.expando] && (c[X.expando] = void 0);\n\t\t\t\t}\n\t\t\t}\n\t\t} }), r.fn.extend({ detach: function detach(a) {\n\t\t\treturn Ka(this, a, !0);\n\t\t}, remove: function remove(a) {\n\t\t\treturn Ka(this, a);\n\t\t}, text: function text(a) {\n\t\t\treturn T(this, function (a) {\n\t\t\t\treturn void 0 === a ? r.text(this) : this.empty().each(function () {\n\t\t\t\t\t1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a);\n\t\t\t\t});\n\t\t\t}, null, a, arguments.length);\n\t\t}, append: function append() {\n\t\t\treturn Ja(this, arguments, function (a) {\n\t\t\t\tif (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n\t\t\t\t\tvar b = Ea(this, a);b.appendChild(a);\n\t\t\t\t}\n\t\t\t});\n\t\t}, prepend: function prepend() {\n\t\t\treturn Ja(this, arguments, function (a) {\n\t\t\t\tif (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n\t\t\t\t\tvar b = Ea(this, a);b.insertBefore(a, b.firstChild);\n\t\t\t\t}\n\t\t\t});\n\t\t}, before: function before() {\n\t\t\treturn Ja(this, arguments, function (a) {\n\t\t\t\tthis.parentNode && this.parentNode.insertBefore(a, this);\n\t\t\t});\n\t\t}, after: function after() {\n\t\t\treturn Ja(this, arguments, function (a) {\n\t\t\t\tthis.parentNode && this.parentNode.insertBefore(a, this.nextSibling);\n\t\t\t});\n\t\t}, empty: function empty() {\n\t\t\tfor (var a, b = 0; null != (a = this[b]); b++) {\n\t\t\t\t1 === a.nodeType && (r.cleanData(na(a, !1)), a.textContent = \"\");\n\t\t\t}return this;\n\t\t}, clone: function clone(a, b) {\n\t\t\treturn a = null != a && a, b = null == b ? a : b, this.map(function () {\n\t\t\t\treturn r.clone(this, a, b);\n\t\t\t});\n\t\t}, html: function html(a) {\n\t\t\treturn T(this, function (a) {\n\t\t\t\tvar b = this[0] || {},\n\t\t\t\t    c = 0,\n\t\t\t\t    d = this.length;if (void 0 === a && 1 === b.nodeType) return b.innerHTML;if (\"string\" == typeof a && !Aa.test(a) && !ma[(ka.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n\t\t\t\t\ta = r.htmlPrefilter(a);try {\n\t\t\t\t\t\tfor (; c < d; c++) {\n\t\t\t\t\t\t\tb = this[c] || {}, 1 === b.nodeType && (r.cleanData(na(b, !1)), b.innerHTML = a);\n\t\t\t\t\t\t}b = 0;\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t}b && this.empty().append(a);\n\t\t\t}, null, a, arguments.length);\n\t\t}, replaceWith: function replaceWith() {\n\t\t\tvar a = [];return Ja(this, arguments, function (b) {\n\t\t\t\tvar c = this.parentNode;r.inArray(this, a) < 0 && (r.cleanData(na(this)), c && c.replaceChild(b, this));\n\t\t\t}, a);\n\t\t} }), r.each({ appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\" }, function (a, b) {\n\t\tr.fn[a] = function (a) {\n\t\t\tfor (var c, d = [], e = r(a), f = e.length - 1, g = 0; g <= f; g++) {\n\t\t\t\tc = g === f ? this : this.clone(!0), r(e[g])[b](c), h.apply(d, c.get());\n\t\t\t}return this.pushStack(d);\n\t\t};\n\t});var La = /^margin/,\n\t    Ma = new RegExp(\"^(\" + aa + \")(?!px)[a-z%]+$\", \"i\"),\n\t    Na = function Na(b) {\n\t\tvar c = b.ownerDocument.defaultView;return c && c.opener || (c = a), c.getComputedStyle(b);\n\t};!function () {\n\t\tfunction b() {\n\t\t\tif (i) {\n\t\t\t\ti.style.cssText = \"box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%\", i.innerHTML = \"\", ra.appendChild(h);var b = a.getComputedStyle(i);c = \"1%\" !== b.top, g = \"2px\" === b.marginLeft, e = \"4px\" === b.width, i.style.marginRight = \"50%\", f = \"4px\" === b.marginRight, ra.removeChild(h), i = null;\n\t\t\t}\n\t\t}var c,\n\t\t    e,\n\t\t    f,\n\t\t    g,\n\t\t    h = d.createElement(\"div\"),\n\t\t    i = d.createElement(\"div\");i.style && (i.style.backgroundClip = \"content-box\", i.cloneNode(!0).style.backgroundClip = \"\", o.clearCloneStyle = \"content-box\" === i.style.backgroundClip, h.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute\", h.appendChild(i), r.extend(o, { pixelPosition: function pixelPosition() {\n\t\t\t\treturn b(), c;\n\t\t\t}, boxSizingReliable: function boxSizingReliable() {\n\t\t\t\treturn b(), e;\n\t\t\t}, pixelMarginRight: function pixelMarginRight() {\n\t\t\t\treturn b(), f;\n\t\t\t}, reliableMarginLeft: function reliableMarginLeft() {\n\t\t\t\treturn b(), g;\n\t\t\t} }));\n\t}();function Oa(a, b, c) {\n\t\tvar d,\n\t\t    e,\n\t\t    f,\n\t\t    g,\n\t\t    h = a.style;return c = c || Na(a), c && (g = c.getPropertyValue(b) || c[b], \"\" !== g || r.contains(a.ownerDocument, a) || (g = r.style(a, b)), !o.pixelMarginRight() && Ma.test(g) && La.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 !== g ? g + \"\" : g;\n\t}function Pa(a, b) {\n\t\treturn { get: function get() {\n\t\t\t\treturn a() ? void delete this.get : (this.get = b).apply(this, arguments);\n\t\t\t} };\n\t}var Qa = /^(none|table(?!-c[ea]).+)/,\n\t    Ra = /^--/,\n\t    Sa = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\t    Ta = { letterSpacing: \"0\", fontWeight: \"400\" },\n\t    Ua = [\"Webkit\", \"Moz\", \"ms\"],\n\t    Va = d.createElement(\"div\").style;function Wa(a) {\n\t\tif (a in Va) return a;var b = a[0].toUpperCase() + a.slice(1),\n\t\t    c = Ua.length;while (c--) {\n\t\t\tif (a = Ua[c] + b, a in Va) return a;\n\t\t}\n\t}function Xa(a) {\n\t\tvar b = r.cssProps[a];return b || (b = r.cssProps[a] = Wa(a) || a), b;\n\t}function Ya(a, b, c) {\n\t\tvar d = ba.exec(b);return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || \"px\") : b;\n\t}function Za(a, b, c, d, e) {\n\t\tvar f,\n\t\t    g = 0;for (f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0; f < 4; f += 2) {\n\t\t\t\"margin\" === c && (g += r.css(a, c + ca[f], !0, e)), d ? (\"content\" === c && (g -= r.css(a, \"padding\" + ca[f], !0, e)), \"margin\" !== c && (g -= r.css(a, \"border\" + ca[f] + \"Width\", !0, e))) : (g += r.css(a, \"padding\" + ca[f], !0, e), \"padding\" !== c && (g += r.css(a, \"border\" + ca[f] + \"Width\", !0, e)));\n\t\t}return g;\n\t}function $a(a, b, c) {\n\t\tvar d,\n\t\t    e = Na(a),\n\t\t    f = Oa(a, b, e),\n\t\t    g = \"border-box\" === r.css(a, \"boxSizing\", !1, e);return Ma.test(f) ? f : (d = g && (o.boxSizingReliable() || f === a.style[b]), \"auto\" === f && (f = a[\"offset\" + b[0].toUpperCase() + b.slice(1)]), f = parseFloat(f) || 0, f + Za(a, b, c || (g ? \"border\" : \"content\"), d, e) + \"px\");\n\t}r.extend({ cssHooks: { opacity: { get: function get(a, b) {\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\tvar c = Oa(a, \"opacity\");return \"\" === c ? \"1\" : c;\n\t\t\t\t\t}\n\t\t\t\t} } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { \"float\": \"cssFloat\" }, style: function style(a, b, c, d) {\n\t\t\tif (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n\t\t\t\tvar e,\n\t\t\t\t    f,\n\t\t\t\t    g,\n\t\t\t\t    h = r.camelCase(b),\n\t\t\t\t    i = Ra.test(b),\n\t\t\t\t    j = a.style;return i || (b = Xa(h)), g = r.cssHooks[b] || r.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : j[b] : (f = typeof c === \"undefined\" ? \"undefined\" : _typeof(c), \"string\" === f && (e = ba.exec(c)) && e[1] && (c = fa(a, b, e), f = \"number\"), null != c && c === c && (\"number\" === f && (c += e && e[3] || (r.cssNumber[h] ? \"\" : \"px\")), o.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (j[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i ? j.setProperty(b, c) : j[b] = c)), void 0);\n\t\t\t}\n\t\t}, css: function css(a, b, c, d) {\n\t\t\tvar e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h = r.camelCase(b),\n\t\t\t    i = Ra.test(b);return i || (b = Xa(h)), g = r.cssHooks[b] || r.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Oa(a, b, d)), \"normal\" === e && b in Ta && (e = Ta[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e;\n\t\t} }), r.each([\"height\", \"width\"], function (a, b) {\n\t\tr.cssHooks[b] = { get: function get(a, c, d) {\n\t\t\t\tif (c) return !Qa.test(r.css(a, \"display\")) || a.getClientRects().length && a.getBoundingClientRect().width ? $a(a, b, d) : ea(a, Sa, function () {\n\t\t\t\t\treturn $a(a, b, d);\n\t\t\t\t});\n\t\t\t}, set: function set(a, c, d) {\n\t\t\t\tvar e,\n\t\t\t\t    f = d && Na(a),\n\t\t\t\t    g = d && Za(a, b, d, \"border-box\" === r.css(a, \"boxSizing\", !1, f), f);return g && (e = ba.exec(c)) && \"px\" !== (e[3] || \"px\") && (a.style[b] = c, c = r.css(a, b)), Ya(a, c, g);\n\t\t\t} };\n\t}), r.cssHooks.marginLeft = Pa(o.reliableMarginLeft, function (a, b) {\n\t\tif (b) return (parseFloat(Oa(a, \"marginLeft\")) || a.getBoundingClientRect().left - ea(a, { marginLeft: 0 }, function () {\n\t\t\treturn a.getBoundingClientRect().left;\n\t\t})) + \"px\";\n\t}), r.each({ margin: \"\", padding: \"\", border: \"Width\" }, function (a, b) {\n\t\tr.cssHooks[a + b] = { expand: function expand(c) {\n\t\t\t\tfor (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; d < 4; d++) {\n\t\t\t\t\te[a + ca[d] + b] = f[d] || f[d - 2] || f[0];\n\t\t\t\t}return e;\n\t\t\t} }, La.test(a) || (r.cssHooks[a + b].set = Ya);\n\t}), r.fn.extend({ css: function css(a, b) {\n\t\t\treturn T(this, function (a, b, c) {\n\t\t\t\tvar d,\n\t\t\t\t    e,\n\t\t\t\t    f = {},\n\t\t\t\t    g = 0;if (Array.isArray(b)) {\n\t\t\t\t\tfor (d = Na(a), e = b.length; g < e; g++) {\n\t\t\t\t\t\tf[b[g]] = r.css(a, b[g], !1, d);\n\t\t\t\t\t}return f;\n\t\t\t\t}return void 0 !== c ? r.style(a, b, c) : r.css(a, b);\n\t\t\t}, a, b, arguments.length > 1);\n\t\t} });function _a(a, b, c, d, e) {\n\t\treturn new _a.prototype.init(a, b, c, d, e);\n\t}r.Tween = _a, _a.prototype = { constructor: _a, init: function init(a, b, c, d, e, f) {\n\t\t\tthis.elem = a, this.prop = c, this.easing = e || r.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (r.cssNumber[c] ? \"\" : \"px\");\n\t\t}, cur: function cur() {\n\t\t\tvar a = _a.propHooks[this.prop];return a && a.get ? a.get(this) : _a.propHooks._default.get(this);\n\t\t}, run: function run(a) {\n\t\t\tvar b,\n\t\t\t    c = _a.propHooks[this.prop];return this.options.duration ? this.pos = b = r.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : _a.propHooks._default.set(this), this;\n\t\t} }, _a.prototype.init.prototype = _a.prototype, _a.propHooks = { _default: { get: function get(a) {\n\t\t\t\tvar b;return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = r.css(a.elem, a.prop, \"\"), b && \"auto\" !== b ? b : 0);\n\t\t\t}, set: function set(a) {\n\t\t\t\tr.fx.step[a.prop] ? r.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[r.cssProps[a.prop]] && !r.cssHooks[a.prop] ? a.elem[a.prop] = a.now : r.style(a.elem, a.prop, a.now + a.unit);\n\t\t\t} } }, _a.propHooks.scrollTop = _a.propHooks.scrollLeft = { set: function set(a) {\n\t\t\ta.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);\n\t\t} }, r.easing = { linear: function linear(a) {\n\t\t\treturn a;\n\t\t}, swing: function swing(a) {\n\t\t\treturn .5 - Math.cos(a * Math.PI) / 2;\n\t\t}, _default: \"swing\" }, r.fx = _a.prototype.init, r.fx.step = {};var ab,\n\t    bb,\n\t    cb = /^(?:toggle|show|hide)$/,\n\t    db = /queueHooks$/;function eb() {\n\t\tbb && (d.hidden === !1 && a.requestAnimationFrame ? a.requestAnimationFrame(eb) : a.setTimeout(eb, r.fx.interval), r.fx.tick());\n\t}function fb() {\n\t\treturn a.setTimeout(function () {\n\t\t\tab = void 0;\n\t\t}), ab = r.now();\n\t}function gb(a, b) {\n\t\tvar c,\n\t\t    d = 0,\n\t\t    e = { height: a };for (b = b ? 1 : 0; d < 4; d += 2 - b) {\n\t\t\tc = ca[d], e[\"margin\" + c] = e[\"padding\" + c] = a;\n\t\t}return b && (e.opacity = e.width = a), e;\n\t}function hb(a, b, c) {\n\t\tfor (var d, e = (kb.tweeners[b] || []).concat(kb.tweeners[\"*\"]), f = 0, g = e.length; f < g; f++) {\n\t\t\tif (d = e[f].call(c, b, a)) return d;\n\t\t}\n\t}function ib(a, b, c) {\n\t\tvar d,\n\t\t    e,\n\t\t    f,\n\t\t    g,\n\t\t    h,\n\t\t    i,\n\t\t    j,\n\t\t    k,\n\t\t    l = \"width\" in b || \"height\" in b,\n\t\t    m = this,\n\t\t    n = {},\n\t\t    o = a.style,\n\t\t    p = a.nodeType && da(a),\n\t\t    q = W.get(a, \"fxshow\");c.queue || (g = r._queueHooks(a, \"fx\"), null == g.unqueued && (g.unqueued = 0, h = g.empty.fire, g.empty.fire = function () {\n\t\t\tg.unqueued || h();\n\t\t}), g.unqueued++, m.always(function () {\n\t\t\tm.always(function () {\n\t\t\t\tg.unqueued--, r.queue(a, \"fx\").length || g.empty.fire();\n\t\t\t});\n\t\t}));for (d in b) {\n\t\t\tif (e = b[d], cb.test(e)) {\n\t\t\t\tif (delete b[d], f = f || \"toggle\" === e, e === (p ? \"hide\" : \"show\")) {\n\t\t\t\t\tif (\"show\" !== e || !q || void 0 === q[d]) continue;p = !0;\n\t\t\t\t}n[d] = q && q[d] || r.style(a, d);\n\t\t\t}\n\t\t}if (i = !r.isEmptyObject(b), i || !r.isEmptyObject(n)) {\n\t\t\tl && 1 === a.nodeType && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = q && q.display, null == j && (j = W.get(a, \"display\")), k = r.css(a, \"display\"), \"none\" === k && (j ? k = j : (ia([a], !0), j = a.style.display || j, k = r.css(a, \"display\"), ia([a]))), (\"inline\" === k || \"inline-block\" === k && null != j) && \"none\" === r.css(a, \"float\") && (i || (m.done(function () {\n\t\t\t\to.display = j;\n\t\t\t}), null == j && (k = o.display, j = \"none\" === k ? \"\" : k)), o.display = \"inline-block\")), c.overflow && (o.overflow = \"hidden\", m.always(function () {\n\t\t\t\to.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];\n\t\t\t})), i = !1;for (d in n) {\n\t\t\t\ti || (q ? \"hidden\" in q && (p = q.hidden) : q = W.access(a, \"fxshow\", { display: j }), f && (q.hidden = !p), p && ia([a], !0), m.done(function () {\n\t\t\t\t\tp || ia([a]), W.remove(a, \"fxshow\");for (d in n) {\n\t\t\t\t\t\tr.style(a, d, n[d]);\n\t\t\t\t\t}\n\t\t\t\t})), i = hb(p ? q[d] : 0, d, m), d in q || (q[d] = i.start, p && (i.end = i.start, i.start = 0));\n\t\t\t}\n\t\t}\n\t}function jb(a, b) {\n\t\tvar c, d, e, f, g;for (c in a) {\n\t\t\tif (d = r.camelCase(c), e = b[d], f = a[c], Array.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = r.cssHooks[d], g && \"expand\" in g) {\n\t\t\t\tf = g.expand(f), delete a[d];for (c in f) {\n\t\t\t\t\tc in a || (a[c] = f[c], b[c] = e);\n\t\t\t\t}\n\t\t\t} else b[d] = e;\n\t\t}\n\t}function kb(a, b, c) {\n\t\tvar d,\n\t\t    e,\n\t\t    f = 0,\n\t\t    g = kb.prefilters.length,\n\t\t    h = r.Deferred().always(function () {\n\t\t\tdelete i.elem;\n\t\t}),\n\t\t    i = function i() {\n\t\t\tif (e) return !1;for (var b = ab || fb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; g < i; g++) {\n\t\t\t\tj.tweens[g].run(f);\n\t\t\t}return h.notifyWith(a, [j, f, c]), f < 1 && i ? c : (i || h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j]), !1);\n\t\t},\n\t\t    j = h.promise({ elem: a, props: r.extend({}, b), opts: r.extend(!0, { specialEasing: {}, easing: r.easing._default }, c), originalProperties: b, originalOptions: c, startTime: ab || fb(), duration: c.duration, tweens: [], createTween: function createTween(b, c) {\n\t\t\t\tvar d = r.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);return j.tweens.push(d), d;\n\t\t\t}, stop: function stop(b) {\n\t\t\t\tvar c = 0,\n\t\t\t\t    d = b ? j.tweens.length : 0;if (e) return this;for (e = !0; c < d; c++) {\n\t\t\t\t\tj.tweens[c].run(1);\n\t\t\t\t}return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this;\n\t\t\t} }),\n\t\t    k = j.props;for (jb(k, j.opts.specialEasing); f < g; f++) {\n\t\t\tif (d = kb.prefilters[f].call(j, a, k, j.opts)) return r.isFunction(d.stop) && (r._queueHooks(j.elem, j.opts.queue).stop = r.proxy(d.stop, d)), d;\n\t\t}return r.map(k, hb, j), r.isFunction(j.opts.start) && j.opts.start.call(a, j), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always), r.fx.timer(r.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j;\n\t}r.Animation = r.extend(kb, { tweeners: { \"*\": [function (a, b) {\n\t\t\t\tvar c = this.createTween(a, b);return fa(c.elem, a, ba.exec(b), c), c;\n\t\t\t}] }, tweener: function tweener(a, b) {\n\t\t\tr.isFunction(a) ? (b = a, a = [\"*\"]) : a = a.match(L);for (var c, d = 0, e = a.length; d < e; d++) {\n\t\t\t\tc = a[d], kb.tweeners[c] = kb.tweeners[c] || [], kb.tweeners[c].unshift(b);\n\t\t\t}\n\t\t}, prefilters: [ib], prefilter: function prefilter(a, b) {\n\t\t\tb ? kb.prefilters.unshift(a) : kb.prefilters.push(a);\n\t\t} }), r.speed = function (a, b, c) {\n\t\tvar d = a && \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? r.extend({}, a) : { complete: c || !c && b || r.isFunction(a) && a, duration: a, easing: c && b || b && !r.isFunction(b) && b };return r.fx.off ? d.duration = 0 : \"number\" != typeof d.duration && (d.duration in r.fx.speeds ? d.duration = r.fx.speeds[d.duration] : d.duration = r.fx.speeds._default), null != d.queue && d.queue !== !0 || (d.queue = \"fx\"), d.old = d.complete, d.complete = function () {\n\t\t\tr.isFunction(d.old) && d.old.call(this), d.queue && r.dequeue(this, d.queue);\n\t\t}, d;\n\t}, r.fn.extend({ fadeTo: function fadeTo(a, b, c, d) {\n\t\t\treturn this.filter(da).css(\"opacity\", 0).show().end().animate({ opacity: b }, a, c, d);\n\t\t}, animate: function animate(a, b, c, d) {\n\t\t\tvar e = r.isEmptyObject(a),\n\t\t\t    f = r.speed(b, c, d),\n\t\t\t    g = function g() {\n\t\t\t\tvar b = kb(this, r.extend({}, a), f);(e || W.get(this, \"finish\")) && b.stop(!0);\n\t\t\t};return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);\n\t\t}, stop: function stop(a, b, c) {\n\t\t\tvar d = function d(a) {\n\t\t\t\tvar b = a.stop;delete a.stop, b(c);\n\t\t\t};return \"string\" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || \"fx\", []), this.each(function () {\n\t\t\t\tvar b = !0,\n\t\t\t\t    e = null != a && a + \"queueHooks\",\n\t\t\t\t    f = r.timers,\n\t\t\t\t    g = W.get(this);if (e) g[e] && g[e].stop && d(g[e]);else for (e in g) {\n\t\t\t\t\tg[e] && g[e].stop && db.test(e) && d(g[e]);\n\t\t\t\t}for (e = f.length; e--;) {\n\t\t\t\t\tf[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n\t\t\t\t}!b && c || r.dequeue(this, a);\n\t\t\t});\n\t\t}, finish: function finish(a) {\n\t\t\treturn a !== !1 && (a = a || \"fx\"), this.each(function () {\n\t\t\t\tvar b,\n\t\t\t\t    c = W.get(this),\n\t\t\t\t    d = c[a + \"queue\"],\n\t\t\t\t    e = c[a + \"queueHooks\"],\n\t\t\t\t    f = r.timers,\n\t\t\t\t    g = d ? d.length : 0;for (c.finish = !0, r.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) {\n\t\t\t\t\tf[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n\t\t\t\t}for (b = 0; b < g; b++) {\n\t\t\t\t\td[b] && d[b].finish && d[b].finish.call(this);\n\t\t\t\t}delete c.finish;\n\t\t\t});\n\t\t} }), r.each([\"toggle\", \"show\", \"hide\"], function (a, b) {\n\t\tvar c = r.fn[b];r.fn[b] = function (a, d, e) {\n\t\t\treturn null == a || \"boolean\" == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e);\n\t\t};\n\t}), r.each({ slideDown: gb(\"show\"), slideUp: gb(\"hide\"), slideToggle: gb(\"toggle\"), fadeIn: { opacity: \"show\" }, fadeOut: { opacity: \"hide\" }, fadeToggle: { opacity: \"toggle\" } }, function (a, b) {\n\t\tr.fn[a] = function (a, c, d) {\n\t\t\treturn this.animate(b, a, c, d);\n\t\t};\n\t}), r.timers = [], r.fx.tick = function () {\n\t\tvar a,\n\t\t    b = 0,\n\t\t    c = r.timers;for (ab = r.now(); b < c.length; b++) {\n\t\t\ta = c[b], a() || c[b] !== a || c.splice(b--, 1);\n\t\t}c.length || r.fx.stop(), ab = void 0;\n\t}, r.fx.timer = function (a) {\n\t\tr.timers.push(a), r.fx.start();\n\t}, r.fx.interval = 13, r.fx.start = function () {\n\t\tbb || (bb = !0, eb());\n\t}, r.fx.stop = function () {\n\t\tbb = null;\n\t}, r.fx.speeds = { slow: 600, fast: 200, _default: 400 }, r.fn.delay = function (b, c) {\n\t\treturn b = r.fx ? r.fx.speeds[b] || b : b, c = c || \"fx\", this.queue(c, function (c, d) {\n\t\t\tvar e = a.setTimeout(c, b);d.stop = function () {\n\t\t\t\ta.clearTimeout(e);\n\t\t\t};\n\t\t});\n\t}, function () {\n\t\tvar a = d.createElement(\"input\"),\n\t\t    b = d.createElement(\"select\"),\n\t\t    c = b.appendChild(d.createElement(\"option\"));a.type = \"checkbox\", o.checkOn = \"\" !== a.value, o.optSelected = c.selected, a = d.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", o.radioValue = \"t\" === a.value;\n\t}();var lb,\n\t    mb = r.expr.attrHandle;r.fn.extend({ attr: function attr(a, b) {\n\t\t\treturn T(this, r.attr, a, b, arguments.length > 1);\n\t\t}, removeAttr: function removeAttr(a) {\n\t\t\treturn this.each(function () {\n\t\t\t\tr.removeAttr(this, a);\n\t\t\t});\n\t\t} }), r.extend({ attr: function attr(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e,\n\t\t\t    f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return \"undefined\" == typeof a.getAttribute ? r.prop(a, b, c) : (1 === f && r.isXMLDoc(a) || (e = r.attrHooks[b.toLowerCase()] || (r.expr.match.bool.test(b) ? lb : void 0)), void 0 !== c ? null === c ? void r.removeAttr(a, b) : e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + \"\"), c) : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : (d = r.find.attr(a, b), null == d ? void 0 : d));\n\t\t}, attrHooks: { type: { set: function set(a, b) {\n\t\t\t\t\tif (!o.radioValue && \"radio\" === b && B(a, \"input\")) {\n\t\t\t\t\t\tvar c = a.value;return a.setAttribute(\"type\", b), c && (a.value = c), b;\n\t\t\t\t\t}\n\t\t\t\t} } }, removeAttr: function removeAttr(a, b) {\n\t\t\tvar c,\n\t\t\t    d = 0,\n\t\t\t    e = b && b.match(L);if (e && 1 === a.nodeType) while (c = e[d++]) {\n\t\t\t\ta.removeAttribute(c);\n\t\t\t}\n\t\t} }), lb = { set: function set(a, b, c) {\n\t\t\treturn b === !1 ? r.removeAttr(a, c) : a.setAttribute(c, c), c;\n\t\t} }, r.each(r.expr.match.bool.source.match(/\\w+/g), function (a, b) {\n\t\tvar c = mb[b] || r.find.attr;mb[b] = function (a, b, d) {\n\t\t\tvar e,\n\t\t\t    f,\n\t\t\t    g = b.toLowerCase();return d || (f = mb[g], mb[g] = e, e = null != c(a, b, d) ? g : null, mb[g] = f), e;\n\t\t};\n\t});var nb = /^(?:input|select|textarea|button)$/i,\n\t    ob = /^(?:a|area)$/i;r.fn.extend({ prop: function prop(a, b) {\n\t\t\treturn T(this, r.prop, a, b, arguments.length > 1);\n\t\t}, removeProp: function removeProp(a) {\n\t\t\treturn this.each(function () {\n\t\t\t\tdelete this[r.propFix[a] || a];\n\t\t\t});\n\t\t} }), r.extend({ prop: function prop(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e,\n\t\t\t    f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return 1 === f && r.isXMLDoc(a) || (b = r.propFix[b] || b, e = r.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b];\n\t\t}, propHooks: { tabIndex: { get: function get(a) {\n\t\t\t\t\tvar b = r.find.attr(a, \"tabindex\");return b ? parseInt(b, 10) : nb.test(a.nodeName) || ob.test(a.nodeName) && a.href ? 0 : -1;\n\t\t\t\t} } }, propFix: { \"for\": \"htmlFor\", \"class\": \"className\" } }), o.optSelected || (r.propHooks.selected = { get: function get(a) {\n\t\t\tvar b = a.parentNode;return b && b.parentNode && b.parentNode.selectedIndex, null;\n\t\t}, set: function set(a) {\n\t\t\tvar b = a.parentNode;b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex);\n\t\t} }), r.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n\t\tr.propFix[this.toLowerCase()] = this;\n\t});function pb(a) {\n\t\tvar b = a.match(L) || [];return b.join(\" \");\n\t}function qb(a) {\n\t\treturn a.getAttribute && a.getAttribute(\"class\") || \"\";\n\t}r.fn.extend({ addClass: function addClass(a) {\n\t\t\tvar b,\n\t\t\t    c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i = 0;if (r.isFunction(a)) return this.each(function (b) {\n\t\t\t\tr(this).addClass(a.call(this, b, qb(this)));\n\t\t\t});if (\"string\" == typeof a && a) {\n\t\t\t\tb = a.match(L) || [];while (c = this[i++]) {\n\t\t\t\t\tif (e = qb(c), d = 1 === c.nodeType && \" \" + pb(e) + \" \") {\n\t\t\t\t\t\tg = 0;while (f = b[g++]) {\n\t\t\t\t\t\t\td.indexOf(\" \" + f + \" \") < 0 && (d += f + \" \");\n\t\t\t\t\t\t}h = pb(d), e !== h && c.setAttribute(\"class\", h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}return this;\n\t\t}, removeClass: function removeClass(a) {\n\t\t\tvar b,\n\t\t\t    c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i = 0;if (r.isFunction(a)) return this.each(function (b) {\n\t\t\t\tr(this).removeClass(a.call(this, b, qb(this)));\n\t\t\t});if (!arguments.length) return this.attr(\"class\", \"\");if (\"string\" == typeof a && a) {\n\t\t\t\tb = a.match(L) || [];while (c = this[i++]) {\n\t\t\t\t\tif (e = qb(c), d = 1 === c.nodeType && \" \" + pb(e) + \" \") {\n\t\t\t\t\t\tg = 0;while (f = b[g++]) {\n\t\t\t\t\t\t\twhile (d.indexOf(\" \" + f + \" \") > -1) {\n\t\t\t\t\t\t\t\td = d.replace(\" \" + f + \" \", \" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}h = pb(d), e !== h && c.setAttribute(\"class\", h);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}return this;\n\t\t}, toggleClass: function toggleClass(a, b) {\n\t\t\tvar c = typeof a === \"undefined\" ? \"undefined\" : _typeof(a);return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : r.isFunction(a) ? this.each(function (c) {\n\t\t\t\tr(this).toggleClass(a.call(this, c, qb(this), b), b);\n\t\t\t}) : this.each(function () {\n\t\t\t\tvar b, d, e, f;if (\"string\" === c) {\n\t\t\t\t\td = 0, e = r(this), f = a.match(L) || [];while (b = f[d++]) {\n\t\t\t\t\t\te.hasClass(b) ? e.removeClass(b) : e.addClass(b);\n\t\t\t\t\t}\n\t\t\t\t} else void 0 !== a && \"boolean\" !== c || (b = qb(this), b && W.set(this, \"__className__\", b), this.setAttribute && this.setAttribute(\"class\", b || a === !1 ? \"\" : W.get(this, \"__className__\") || \"\"));\n\t\t\t});\n\t\t}, hasClass: function hasClass(a) {\n\t\t\tvar b,\n\t\t\t    c,\n\t\t\t    d = 0;b = \" \" + a + \" \";while (c = this[d++]) {\n\t\t\t\tif (1 === c.nodeType && (\" \" + pb(qb(c)) + \" \").indexOf(b) > -1) return !0;\n\t\t\t}return !1;\n\t\t} });var rb = /\\r/g;r.fn.extend({ val: function val(a) {\n\t\t\tvar b,\n\t\t\t    c,\n\t\t\t    d,\n\t\t\t    e = this[0];{\n\t\t\t\tif (arguments.length) return d = r.isFunction(a), this.each(function (c) {\n\t\t\t\t\tvar e;1 === this.nodeType && (e = d ? a.call(this, c, r(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : Array.isArray(e) && (e = r.map(e, function (a) {\n\t\t\t\t\t\treturn null == a ? \"\" : a + \"\";\n\t\t\t\t\t})), b = r.valHooks[this.type] || r.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e));\n\t\t\t\t});if (e) return b = r.valHooks[e.type] || r.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(rb, \"\") : null == c ? \"\" : c);\n\t\t\t}\n\t\t} }), r.extend({ valHooks: { option: { get: function get(a) {\n\t\t\t\t\tvar b = r.find.attr(a, \"value\");return null != b ? b : pb(r.text(a));\n\t\t\t\t} }, select: { get: function get(a) {\n\t\t\t\t\tvar b,\n\t\t\t\t\t    c,\n\t\t\t\t\t    d,\n\t\t\t\t\t    e = a.options,\n\t\t\t\t\t    f = a.selectedIndex,\n\t\t\t\t\t    g = \"select-one\" === a.type,\n\t\t\t\t\t    h = g ? null : [],\n\t\t\t\t\t    i = g ? f + 1 : e.length;for (d = f < 0 ? i : g ? f : 0; d < i; d++) {\n\t\t\t\t\t\tif (c = e[d], (c.selected || d === f) && !c.disabled && (!c.parentNode.disabled || !B(c.parentNode, \"optgroup\"))) {\n\t\t\t\t\t\t\tif (b = r(c).val(), g) return b;h.push(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t}return h;\n\t\t\t\t}, set: function set(a, b) {\n\t\t\t\t\tvar c,\n\t\t\t\t\t    d,\n\t\t\t\t\t    e = a.options,\n\t\t\t\t\t    f = r.makeArray(b),\n\t\t\t\t\t    g = e.length;while (g--) {\n\t\t\t\t\t\td = e[g], (d.selected = r.inArray(r.valHooks.option.get(d), f) > -1) && (c = !0);\n\t\t\t\t\t}return c || (a.selectedIndex = -1), f;\n\t\t\t\t} } } }), r.each([\"radio\", \"checkbox\"], function () {\n\t\tr.valHooks[this] = { set: function set(a, b) {\n\t\t\t\tif (Array.isArray(b)) return a.checked = r.inArray(r(a).val(), b) > -1;\n\t\t\t} }, o.checkOn || (r.valHooks[this].get = function (a) {\n\t\t\treturn null === a.getAttribute(\"value\") ? \"on\" : a.value;\n\t\t});\n\t});var sb = /^(?:focusinfocus|focusoutblur)$/;r.extend(r.event, { trigger: function trigger(b, c, e, f) {\n\t\t\tvar g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    m,\n\t\t\t    n,\n\t\t\t    o = [e || d],\n\t\t\t    p = l.call(b, \"type\") ? b.type : b,\n\t\t\t    q = l.call(b, \"namespace\") ? b.namespace.split(\".\") : [];if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !sb.test(p + r.event.triggered) && (p.indexOf(\".\") > -1 && (q = p.split(\".\"), p = q.shift(), q.sort()), k = p.indexOf(\":\") < 0 && \"on\" + p, b = b[r.expando] ? b : new r.Event(p, \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b), b.isTrigger = f ? 2 : 3, b.namespace = q.join(\".\"), b.rnamespace = b.namespace ? new RegExp(\"(^|\\\\.)\" + q.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : r.makeArray(c, [b]), n = r.event.special[p] || {}, f || !n.trigger || n.trigger.apply(e, c) !== !1)) {\n\t\t\t\tif (!f && !n.noBubble && !r.isWindow(e)) {\n\t\t\t\t\tfor (j = n.delegateType || p, sb.test(j + p) || (h = h.parentNode); h; h = h.parentNode) {\n\t\t\t\t\t\to.push(h), i = h;\n\t\t\t\t\t}i === (e.ownerDocument || d) && o.push(i.defaultView || i.parentWindow || a);\n\t\t\t\t}g = 0;while ((h = o[g++]) && !b.isPropagationStopped()) {\n\t\t\t\t\tb.type = g > 1 ? j : n.bindType || p, m = (W.get(h, \"events\") || {})[b.type] && W.get(h, \"handle\"), m && m.apply(h, c), m = k && h[k], m && m.apply && U(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());\n\t\t\t\t}return b.type = p, f || b.isDefaultPrevented() || n._default && n._default.apply(o.pop(), c) !== !1 || !U(e) || k && r.isFunction(e[p]) && !r.isWindow(e) && (i = e[k], i && (e[k] = null), r.event.triggered = p, e[p](), r.event.triggered = void 0, i && (e[k] = i)), b.result;\n\t\t\t}\n\t\t}, simulate: function simulate(a, b, c) {\n\t\t\tvar d = r.extend(new r.Event(), c, { type: a, isSimulated: !0 });r.event.trigger(d, null, b);\n\t\t} }), r.fn.extend({ trigger: function trigger(a, b) {\n\t\t\treturn this.each(function () {\n\t\t\t\tr.event.trigger(a, b, this);\n\t\t\t});\n\t\t}, triggerHandler: function triggerHandler(a, b) {\n\t\t\tvar c = this[0];if (c) return r.event.trigger(a, b, c, !0);\n\t\t} }), r.each(\"blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu\".split(\" \"), function (a, b) {\n\t\tr.fn[b] = function (a, c) {\n\t\t\treturn arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);\n\t\t};\n\t}), r.fn.extend({ hover: function hover(a, b) {\n\t\t\treturn this.mouseenter(a).mouseleave(b || a);\n\t\t} }), o.focusin = \"onfocusin\" in a, o.focusin || r.each({ focus: \"focusin\", blur: \"focusout\" }, function (a, b) {\n\t\tvar c = function c(a) {\n\t\t\tr.event.simulate(b, a.target, r.event.fix(a));\n\t\t};r.event.special[b] = { setup: function setup() {\n\t\t\t\tvar d = this.ownerDocument || this,\n\t\t\t\t    e = W.access(d, b);e || d.addEventListener(a, c, !0), W.access(d, b, (e || 0) + 1);\n\t\t\t}, teardown: function teardown() {\n\t\t\t\tvar d = this.ownerDocument || this,\n\t\t\t\t    e = W.access(d, b) - 1;e ? W.access(d, b, e) : (d.removeEventListener(a, c, !0), W.remove(d, b));\n\t\t\t} };\n\t});var tb = a.location,\n\t    ub = r.now(),\n\t    vb = /\\?/;r.parseXML = function (b) {\n\t\tvar c;if (!b || \"string\" != typeof b) return null;try {\n\t\t\tc = new a.DOMParser().parseFromString(b, \"text/xml\");\n\t\t} catch (d) {\n\t\t\tc = void 0;\n\t\t}return c && !c.getElementsByTagName(\"parsererror\").length || r.error(\"Invalid XML: \" + b), c;\n\t};var wb = /\\[\\]$/,\n\t    xb = /\\r?\\n/g,\n\t    yb = /^(?:submit|button|image|reset|file)$/i,\n\t    zb = /^(?:input|select|textarea|keygen)/i;function Ab(a, b, c, d) {\n\t\tvar e;if (Array.isArray(b)) r.each(b, function (b, e) {\n\t\t\tc || wb.test(a) ? d(a, e) : Ab(a + \"[\" + (\"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && null != e ? b : \"\") + \"]\", e, c, d);\n\t\t});else if (c || \"object\" !== r.type(b)) d(a, b);else for (e in b) {\n\t\t\tAb(a + \"[\" + e + \"]\", b[e], c, d);\n\t\t}\n\t}r.param = function (a, b) {\n\t\tvar c,\n\t\t    d = [],\n\t\t    e = function e(a, b) {\n\t\t\tvar c = r.isFunction(b) ? b() : b;d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(null == c ? \"\" : c);\n\t\t};if (Array.isArray(a) || a.jquery && !r.isPlainObject(a)) r.each(a, function () {\n\t\t\te(this.name, this.value);\n\t\t});else for (c in a) {\n\t\t\tAb(c, a[c], b, e);\n\t\t}return d.join(\"&\");\n\t}, r.fn.extend({ serialize: function serialize() {\n\t\t\treturn r.param(this.serializeArray());\n\t\t}, serializeArray: function serializeArray() {\n\t\t\treturn this.map(function () {\n\t\t\t\tvar a = r.prop(this, \"elements\");return a ? r.makeArray(a) : this;\n\t\t\t}).filter(function () {\n\t\t\t\tvar a = this.type;return this.name && !r(this).is(\":disabled\") && zb.test(this.nodeName) && !yb.test(a) && (this.checked || !ja.test(a));\n\t\t\t}).map(function (a, b) {\n\t\t\t\tvar c = r(this).val();return null == c ? null : Array.isArray(c) ? r.map(c, function (a) {\n\t\t\t\t\treturn { name: b.name, value: a.replace(xb, \"\\r\\n\") };\n\t\t\t\t}) : { name: b.name, value: c.replace(xb, \"\\r\\n\") };\n\t\t\t}).get();\n\t\t} });var Bb = /%20/g,\n\t    Cb = /#.*$/,\n\t    Db = /([?&])_=[^&]*/,\n\t    Eb = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n\t    Fb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t    Gb = /^(?:GET|HEAD)$/,\n\t    Hb = /^\\/\\//,\n\t    Ib = {},\n\t    Jb = {},\n\t    Kb = \"*/\".concat(\"*\"),\n\t    Lb = d.createElement(\"a\");Lb.href = tb.href;function Mb(a) {\n\t\treturn function (b, c) {\n\t\t\t\"string\" != typeof b && (c = b, b = \"*\");var d,\n\t\t\t    e = 0,\n\t\t\t    f = b.toLowerCase().match(L) || [];if (r.isFunction(c)) while (d = f[e++]) {\n\t\t\t\t\"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);\n\t\t\t}\n\t\t};\n\t}function Nb(a, b, c, d) {\n\t\tvar e = {},\n\t\t    f = a === Jb;function g(h) {\n\t\t\tvar i;return e[h] = !0, r.each(a[h] || [], function (a, h) {\n\t\t\t\tvar j = h(b, c, d);return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);\n\t\t\t}), i;\n\t\t}return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\");\n\t}function Ob(a, b) {\n\t\tvar c,\n\t\t    d,\n\t\t    e = r.ajaxSettings.flatOptions || {};for (c in b) {\n\t\t\tvoid 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n\t\t}return d && r.extend(!0, a, d), a;\n\t}function Pb(a, b, c) {\n\t\tvar d,\n\t\t    e,\n\t\t    f,\n\t\t    g,\n\t\t    h = a.contents,\n\t\t    i = a.dataTypes;while (\"*\" === i[0]) {\n\t\t\ti.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n\t\t}if (d) for (e in h) {\n\t\t\tif (h[e] && h[e].test(d)) {\n\t\t\t\ti.unshift(e);break;\n\t\t\t}\n\t\t}if (i[0] in c) f = i[0];else {\n\t\t\tfor (e in c) {\n\t\t\t\tif (!i[0] || a.converters[e + \" \" + i[0]]) {\n\t\t\t\t\tf = e;break;\n\t\t\t\t}g || (g = e);\n\t\t\t}f = f || g;\n\t\t}if (f) return f !== i[0] && i.unshift(f), c[f];\n\t}function Qb(a, b, c, d) {\n\t\tvar e,\n\t\t    f,\n\t\t    g,\n\t\t    h,\n\t\t    i,\n\t\t    j = {},\n\t\t    k = a.dataTypes.slice();if (k[1]) for (g in a.converters) {\n\t\t\tj[g.toLowerCase()] = a.converters[g];\n\t\t}f = k.shift();while (f) {\n\t\t\tif (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if (\"*\" === f) f = i;else if (\"*\" !== i && i !== f) {\n\t\t\t\tif (g = j[i + \" \" + f] || j[\"* \" + f], !g) for (e in j) {\n\t\t\t\t\tif (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n\t\t\t\t\t\tg === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));break;\n\t\t\t\t\t}\n\t\t\t\t}if (g !== !0) if (g && a[\"throws\"]) b = g(b);else try {\n\t\t\t\t\tb = g(b);\n\t\t\t\t} catch (l) {\n\t\t\t\t\treturn { state: \"parsererror\", error: g ? l : \"No conversion from \" + i + \" to \" + f };\n\t\t\t\t}\n\t\t\t}\n\t\t}return { state: \"success\", data: b };\n\t}r.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: tb.href, type: \"GET\", isLocal: Fb.test(tb.protocol), global: !0, processData: !0, async: !0, contentType: \"application/x-www-form-urlencoded; charset=UTF-8\", accepts: { \"*\": Kb, text: \"text/plain\", html: \"text/html\", xml: \"application/xml, text/xml\", json: \"application/json, text/javascript\" }, contents: { xml: /\\bxml\\b/, html: /\\bhtml/, json: /\\bjson\\b/ }, responseFields: { xml: \"responseXML\", text: \"responseText\", json: \"responseJSON\" }, converters: { \"* text\": String, \"text html\": !0, \"text json\": JSON.parse, \"text xml\": r.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function ajaxSetup(a, b) {\n\t\t\treturn b ? Ob(Ob(a, r.ajaxSettings), b) : Ob(r.ajaxSettings, a);\n\t\t}, ajaxPrefilter: Mb(Ib), ajaxTransport: Mb(Jb), ajax: function ajax(b, c) {\n\t\t\t\"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (c = b, b = void 0), c = c || {};var e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k,\n\t\t\t    l,\n\t\t\t    m,\n\t\t\t    n,\n\t\t\t    o = r.ajaxSetup({}, c),\n\t\t\t    p = o.context || o,\n\t\t\t    q = o.context && (p.nodeType || p.jquery) ? r(p) : r.event,\n\t\t\t    s = r.Deferred(),\n\t\t\t    t = r.Callbacks(\"once memory\"),\n\t\t\t    u = o.statusCode || {},\n\t\t\t    v = {},\n\t\t\t    w = {},\n\t\t\t    x = \"canceled\",\n\t\t\t    y = { readyState: 0, getResponseHeader: function getResponseHeader(a) {\n\t\t\t\t\tvar b;if (k) {\n\t\t\t\t\t\tif (!h) {\n\t\t\t\t\t\t\th = {};while (b = Eb.exec(g)) {\n\t\t\t\t\t\t\t\th[b[1].toLowerCase()] = b[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}b = h[a.toLowerCase()];\n\t\t\t\t\t}return null == b ? null : b;\n\t\t\t\t}, getAllResponseHeaders: function getAllResponseHeaders() {\n\t\t\t\t\treturn k ? g : null;\n\t\t\t\t}, setRequestHeader: function setRequestHeader(a, b) {\n\t\t\t\t\treturn null == k && (a = w[a.toLowerCase()] = w[a.toLowerCase()] || a, v[a] = b), this;\n\t\t\t\t}, overrideMimeType: function overrideMimeType(a) {\n\t\t\t\t\treturn null == k && (o.mimeType = a), this;\n\t\t\t\t}, statusCode: function statusCode(a) {\n\t\t\t\t\tvar b;if (a) if (k) y.always(a[y.status]);else for (b in a) {\n\t\t\t\t\t\tu[b] = [u[b], a[b]];\n\t\t\t\t\t}return this;\n\t\t\t\t}, abort: function abort(a) {\n\t\t\t\t\tvar b = a || x;return e && e.abort(b), A(0, b), this;\n\t\t\t\t} };if (s.promise(y), o.url = ((b || o.url || tb.href) + \"\").replace(Hb, tb.protocol + \"//\"), o.type = c.method || c.type || o.method || o.type, o.dataTypes = (o.dataType || \"*\").toLowerCase().match(L) || [\"\"], null == o.crossDomain) {\n\t\t\t\tj = d.createElement(\"a\");try {\n\t\t\t\t\tj.href = o.url, j.href = j.href, o.crossDomain = Lb.protocol + \"//\" + Lb.host != j.protocol + \"//\" + j.host;\n\t\t\t\t} catch (z) {\n\t\t\t\t\to.crossDomain = !0;\n\t\t\t\t}\n\t\t\t}if (o.data && o.processData && \"string\" != typeof o.data && (o.data = r.param(o.data, o.traditional)), Nb(Ib, o, c, y), k) return y;l = r.event && o.global, l && 0 === r.active++ && r.event.trigger(\"ajaxStart\"), o.type = o.type.toUpperCase(), o.hasContent = !Gb.test(o.type), f = o.url.replace(Cb, \"\"), o.hasContent ? o.data && o.processData && 0 === (o.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && (o.data = o.data.replace(Bb, \"+\")) : (n = o.url.slice(f.length), o.data && (f += (vb.test(f) ? \"&\" : \"?\") + o.data, delete o.data), o.cache === !1 && (f = f.replace(Db, \"$1\"), n = (vb.test(f) ? \"&\" : \"?\") + \"_=\" + ub++ + n), o.url = f + n), o.ifModified && (r.lastModified[f] && y.setRequestHeader(\"If-Modified-Since\", r.lastModified[f]), r.etag[f] && y.setRequestHeader(\"If-None-Match\", r.etag[f])), (o.data && o.hasContent && o.contentType !== !1 || c.contentType) && y.setRequestHeader(\"Content-Type\", o.contentType), y.setRequestHeader(\"Accept\", o.dataTypes[0] && o.accepts[o.dataTypes[0]] ? o.accepts[o.dataTypes[0]] + (\"*\" !== o.dataTypes[0] ? \", \" + Kb + \"; q=0.01\" : \"\") : o.accepts[\"*\"]);for (m in o.headers) {\n\t\t\t\ty.setRequestHeader(m, o.headers[m]);\n\t\t\t}if (o.beforeSend && (o.beforeSend.call(p, y, o) === !1 || k)) return y.abort();if (x = \"abort\", t.add(o.complete), y.done(o.success), y.fail(o.error), e = Nb(Jb, o, c, y)) {\n\t\t\t\tif (y.readyState = 1, l && q.trigger(\"ajaxSend\", [y, o]), k) return y;o.async && o.timeout > 0 && (i = a.setTimeout(function () {\n\t\t\t\t\ty.abort(\"timeout\");\n\t\t\t\t}, o.timeout));try {\n\t\t\t\t\tk = !1, e.send(v, A);\n\t\t\t\t} catch (z) {\n\t\t\t\t\tif (k) throw z;A(-1, z);\n\t\t\t\t}\n\t\t\t} else A(-1, \"No Transport\");function A(b, c, d, h) {\n\t\t\t\tvar j,\n\t\t\t\t    m,\n\t\t\t\t    n,\n\t\t\t\t    v,\n\t\t\t\t    w,\n\t\t\t\t    x = c;k || (k = !0, i && a.clearTimeout(i), e = void 0, g = h || \"\", y.readyState = b > 0 ? 4 : 0, j = b >= 200 && b < 300 || 304 === b, d && (v = Pb(o, y, d)), v = Qb(o, v, y, j), j ? (o.ifModified && (w = y.getResponseHeader(\"Last-Modified\"), w && (r.lastModified[f] = w), w = y.getResponseHeader(\"etag\"), w && (r.etag[f] = w)), 204 === b || \"HEAD\" === o.type ? x = \"nocontent\" : 304 === b ? x = \"notmodified\" : (x = v.state, m = v.data, n = v.error, j = !n)) : (n = x, !b && x || (x = \"error\", b < 0 && (b = 0))), y.status = b, y.statusText = (c || x) + \"\", j ? s.resolveWith(p, [m, x, y]) : s.rejectWith(p, [y, x, n]), y.statusCode(u), u = void 0, l && q.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [y, o, j ? m : n]), t.fireWith(p, [y, x]), l && (q.trigger(\"ajaxComplete\", [y, o]), --r.active || r.event.trigger(\"ajaxStop\")));\n\t\t\t}return y;\n\t\t}, getJSON: function getJSON(a, b, c) {\n\t\t\treturn r.get(a, b, c, \"json\");\n\t\t}, getScript: function getScript(a, b) {\n\t\t\treturn r.get(a, void 0, b, \"script\");\n\t\t} }), r.each([\"get\", \"post\"], function (a, b) {\n\t\tr[b] = function (a, c, d, e) {\n\t\t\treturn r.isFunction(c) && (e = e || d, d = c, c = void 0), r.ajax(r.extend({ url: a, type: b, dataType: e, data: c, success: d }, r.isPlainObject(a) && a));\n\t\t};\n\t}), r._evalUrl = function (a) {\n\t\treturn r.ajax({ url: a, type: \"GET\", dataType: \"script\", cache: !0, async: !1, global: !1, \"throws\": !0 });\n\t}, r.fn.extend({ wrapAll: function wrapAll(a) {\n\t\t\tvar b;return this[0] && (r.isFunction(a) && (a = a.call(this[0])), b = r(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {\n\t\t\t\tvar a = this;while (a.firstElementChild) {\n\t\t\t\t\ta = a.firstElementChild;\n\t\t\t\t}return a;\n\t\t\t}).append(this)), this;\n\t\t}, wrapInner: function wrapInner(a) {\n\t\t\treturn r.isFunction(a) ? this.each(function (b) {\n\t\t\t\tr(this).wrapInner(a.call(this, b));\n\t\t\t}) : this.each(function () {\n\t\t\t\tvar b = r(this),\n\t\t\t\t    c = b.contents();c.length ? c.wrapAll(a) : b.append(a);\n\t\t\t});\n\t\t}, wrap: function wrap(a) {\n\t\t\tvar b = r.isFunction(a);return this.each(function (c) {\n\t\t\t\tr(this).wrapAll(b ? a.call(this, c) : a);\n\t\t\t});\n\t\t}, unwrap: function unwrap(a) {\n\t\t\treturn this.parent(a).not(\"body\").each(function () {\n\t\t\t\tr(this).replaceWith(this.childNodes);\n\t\t\t}), this;\n\t\t} }), r.expr.pseudos.hidden = function (a) {\n\t\treturn !r.expr.pseudos.visible(a);\n\t}, r.expr.pseudos.visible = function (a) {\n\t\treturn !!(a.offsetWidth || a.offsetHeight || a.getClientRects().length);\n\t}, r.ajaxSettings.xhr = function () {\n\t\ttry {\n\t\t\treturn new a.XMLHttpRequest();\n\t\t} catch (b) {}\n\t};var Rb = { 0: 200, 1223: 204 },\n\t    Sb = r.ajaxSettings.xhr();o.cors = !!Sb && \"withCredentials\" in Sb, o.ajax = Sb = !!Sb, r.ajaxTransport(function (b) {\n\t\tvar _c, d;if (o.cors || Sb && !b.crossDomain) return { send: function send(e, f) {\n\t\t\t\tvar g,\n\t\t\t\t    h = b.xhr();if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (g in b.xhrFields) {\n\t\t\t\t\th[g] = b.xhrFields[g];\n\t\t\t\t}b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e[\"X-Requested-With\"] || (e[\"X-Requested-With\"] = \"XMLHttpRequest\");for (g in e) {\n\t\t\t\t\th.setRequestHeader(g, e[g]);\n\t\t\t\t}_c = function c(a) {\n\t\t\t\t\treturn function () {\n\t\t\t\t\t\t_c && (_c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, \"abort\" === a ? h.abort() : \"error\" === a ? \"number\" != typeof h.status ? f(0, \"error\") : f(h.status, h.statusText) : f(Rb[h.status] || h.status, h.statusText, \"text\" !== (h.responseType || \"text\") || \"string\" != typeof h.responseText ? { binary: h.response } : { text: h.responseText }, h.getAllResponseHeaders()));\n\t\t\t\t\t};\n\t\t\t\t}, h.onload = _c(), d = h.onerror = _c(\"error\"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function () {\n\t\t\t\t\t4 === h.readyState && a.setTimeout(function () {\n\t\t\t\t\t\t_c && d();\n\t\t\t\t\t});\n\t\t\t\t}, _c = _c(\"abort\");try {\n\t\t\t\t\th.send(b.hasContent && b.data || null);\n\t\t\t\t} catch (i) {\n\t\t\t\t\tif (_c) throw i;\n\t\t\t\t}\n\t\t\t}, abort: function abort() {\n\t\t\t\t_c && _c();\n\t\t\t} };\n\t}), r.ajaxPrefilter(function (a) {\n\t\ta.crossDomain && (a.contents.script = !1);\n\t}), r.ajaxSetup({ accepts: { script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\" }, contents: { script: /\\b(?:java|ecma)script\\b/ }, converters: { \"text script\": function textScript(a) {\n\t\t\t\treturn r.globalEval(a), a;\n\t\t\t} } }), r.ajaxPrefilter(\"script\", function (a) {\n\t\tvoid 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\");\n\t}), r.ajaxTransport(\"script\", function (a) {\n\t\tif (a.crossDomain) {\n\t\t\tvar b, _c2;return { send: function send(e, f) {\n\t\t\t\t\tb = r(\"<script>\").prop({ charset: a.scriptCharset, src: a.url }).on(\"load error\", _c2 = function c(a) {\n\t\t\t\t\t\tb.remove(), _c2 = null, a && f(\"error\" === a.type ? 404 : 200, a.type);\n\t\t\t\t\t}), d.head.appendChild(b[0]);\n\t\t\t\t}, abort: function abort() {\n\t\t\t\t\t_c2 && _c2();\n\t\t\t\t} };\n\t\t}\n\t});var Tb = [],\n\t    Ub = /(=)\\?(?=&|$)|\\?\\?/;r.ajaxSetup({ jsonp: \"callback\", jsonpCallback: function jsonpCallback() {\n\t\t\tvar a = Tb.pop() || r.expando + \"_\" + ub++;return this[a] = !0, a;\n\t\t} }), r.ajaxPrefilter(\"json jsonp\", function (b, c, d) {\n\t\tvar e,\n\t\t    f,\n\t\t    g,\n\t\t    h = b.jsonp !== !1 && (Ub.test(b.url) ? \"url\" : \"string\" == typeof b.data && 0 === (b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Ub.test(b.data) && \"data\");if (h || \"jsonp\" === b.dataTypes[0]) return e = b.jsonpCallback = r.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Ub, \"$1\" + e) : b.jsonp !== !1 && (b.url += (vb.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function () {\n\t\t\treturn g || r.error(e + \" was not called\"), g[0];\n\t\t}, b.dataTypes[0] = \"json\", f = a[e], a[e] = function () {\n\t\t\tg = arguments;\n\t\t}, d.always(function () {\n\t\t\tvoid 0 === f ? r(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Tb.push(e)), g && r.isFunction(f) && f(g[0]), g = f = void 0;\n\t\t}), \"script\";\n\t}), o.createHTMLDocument = function () {\n\t\tvar a = d.implementation.createHTMLDocument(\"\").body;return a.innerHTML = \"<form></form><form></form>\", 2 === a.childNodes.length;\n\t}(), r.parseHTML = function (a, b, c) {\n\t\tif (\"string\" != typeof a) return [];\"boolean\" == typeof b && (c = b, b = !1);var e, f, g;return b || (o.createHTMLDocument ? (b = d.implementation.createHTMLDocument(\"\"), e = b.createElement(\"base\"), e.href = d.location.href, b.head.appendChild(e)) : b = d), f = C.exec(a), g = !c && [], f ? [b.createElement(f[1])] : (f = qa([a], b, g), g && g.length && r(g).remove(), r.merge([], f.childNodes));\n\t}, r.fn.load = function (a, b, c) {\n\t\tvar d,\n\t\t    e,\n\t\t    f,\n\t\t    g = this,\n\t\t    h = a.indexOf(\" \");return h > -1 && (d = pb(a.slice(h)), a = a.slice(0, h)), r.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (e = \"POST\"), g.length > 0 && r.ajax({ url: a, type: e || \"GET\", dataType: \"html\", data: b }).done(function (a) {\n\t\t\tf = arguments, g.html(d ? r(\"<div>\").append(r.parseHTML(a)).find(d) : a);\n\t\t}).always(c && function (a, b) {\n\t\t\tg.each(function () {\n\t\t\t\tc.apply(this, f || [a.responseText, b, a]);\n\t\t\t});\n\t\t}), this;\n\t}, r.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (a, b) {\n\t\tr.fn[b] = function (a) {\n\t\t\treturn this.on(b, a);\n\t\t};\n\t}), r.expr.pseudos.animated = function (a) {\n\t\treturn r.grep(r.timers, function (b) {\n\t\t\treturn a === b.elem;\n\t\t}).length;\n\t}, r.offset = { setOffset: function setOffset(a, b, c) {\n\t\t\tvar d,\n\t\t\t    e,\n\t\t\t    f,\n\t\t\t    g,\n\t\t\t    h,\n\t\t\t    i,\n\t\t\t    j,\n\t\t\t    k = r.css(a, \"position\"),\n\t\t\t    l = r(a),\n\t\t\t    m = {};\"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = r.css(a, \"top\"), i = r.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), r.isFunction(b) && (b = b.call(a, c, r.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m);\n\t\t} }, r.fn.extend({ offset: function offset(a) {\n\t\t\tif (arguments.length) return void 0 === a ? this : this.each(function (b) {\n\t\t\t\tr.offset.setOffset(this, a, b);\n\t\t\t});var b,\n\t\t\t    c,\n\t\t\t    d,\n\t\t\t    e,\n\t\t\t    f = this[0];if (f) return f.getClientRects().length ? (d = f.getBoundingClientRect(), b = f.ownerDocument, c = b.documentElement, e = b.defaultView, { top: d.top + e.pageYOffset - c.clientTop, left: d.left + e.pageXOffset - c.clientLeft }) : { top: 0, left: 0 };\n\t\t}, position: function position() {\n\t\t\tif (this[0]) {\n\t\t\t\tvar a,\n\t\t\t\t    b,\n\t\t\t\t    c = this[0],\n\t\t\t\t    d = { top: 0, left: 0 };return \"fixed\" === r.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), B(a[0], \"html\") || (d = a.offset()), d = { top: d.top + r.css(a[0], \"borderTopWidth\", !0), left: d.left + r.css(a[0], \"borderLeftWidth\", !0) }), { top: b.top - d.top - r.css(c, \"marginTop\", !0), left: b.left - d.left - r.css(c, \"marginLeft\", !0) };\n\t\t\t}\n\t\t}, offsetParent: function offsetParent() {\n\t\t\treturn this.map(function () {\n\t\t\t\tvar a = this.offsetParent;while (a && \"static\" === r.css(a, \"position\")) {\n\t\t\t\t\ta = a.offsetParent;\n\t\t\t\t}return a || ra;\n\t\t\t});\n\t\t} }), r.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (a, b) {\n\t\tvar c = \"pageYOffset\" === b;r.fn[a] = function (d) {\n\t\t\treturn T(this, function (a, d, e) {\n\t\t\t\tvar f;return r.isWindow(a) ? f = a : 9 === a.nodeType && (f = a.defaultView), void 0 === e ? f ? f[b] : a[d] : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e);\n\t\t\t}, a, d, arguments.length);\n\t\t};\n\t}), r.each([\"top\", \"left\"], function (a, b) {\n\t\tr.cssHooks[b] = Pa(o.pixelPosition, function (a, c) {\n\t\t\tif (c) return c = Oa(a, b), Ma.test(c) ? r(a).position()[b] + \"px\" : c;\n\t\t});\n\t}), r.each({ Height: \"height\", Width: \"width\" }, function (a, b) {\n\t\tr.each({ padding: \"inner\" + a, content: b, \"\": \"outer\" + a }, function (c, d) {\n\t\t\tr.fn[d] = function (e, f) {\n\t\t\t\tvar g = arguments.length && (c || \"boolean\" != typeof e),\n\t\t\t\t    h = c || (e === !0 || f === !0 ? \"margin\" : \"border\");return T(this, function (b, c, e) {\n\t\t\t\t\tvar f;return r.isWindow(b) ? 0 === d.indexOf(\"outer\") ? b[\"inner\" + a] : b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (f = b.documentElement, Math.max(b.body[\"scroll\" + a], f[\"scroll\" + a], b.body[\"offset\" + a], f[\"offset\" + a], f[\"client\" + a])) : void 0 === e ? r.css(b, c, h) : r.style(b, c, e, h);\n\t\t\t\t}, b, g ? e : void 0, g);\n\t\t\t};\n\t\t});\n\t}), r.fn.extend({ bind: function bind(a, b, c) {\n\t\t\treturn this.on(a, null, b, c);\n\t\t}, unbind: function unbind(a, b) {\n\t\t\treturn this.off(a, null, b);\n\t\t}, delegate: function delegate(a, b, c, d) {\n\t\t\treturn this.on(b, a, c, d);\n\t\t}, undelegate: function undelegate(a, b, c) {\n\t\t\treturn 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c);\n\t\t} }), r.holdReady = function (a) {\n\t\ta ? r.readyWait++ : r.ready(!0);\n\t}, r.isArray = Array.isArray, r.parseJSON = JSON.parse, r.nodeName = B, \"function\" == \"function\" && __webpack_require__(/*! !webpack amd options */ 4) && !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n\t\treturn r;\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));var Vb = a.jQuery,\n\t    Wb = a.$;return r.noConflict = function (b) {\n\t\treturn a.$ === r && (a.$ = Wb), b && a.jQuery === r && (a.jQuery = Vb), r;\n\t}, b || (a.jQuery = a.$ = r), r;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/module.js */ 3)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9wdWJsaWMvc2NyaXB0cy9saWIvanF1ZXJ5LmpzPzk3MmEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIGpRdWVyeSB2My4yLjEgfCAoYykgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXG4hZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjtcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlLmV4cG9ydHM/bW9kdWxlLmV4cG9ydHM9YS5kb2N1bWVudD9iKGEsITApOmZ1bmN0aW9uKGEpe2lmKCFhLmRvY3VtZW50KXRocm93IG5ldyBFcnJvcihcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIik7cmV0dXJuIGIoYSl9OmIoYSl9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/d2luZG93OnRoaXMsZnVuY3Rpb24oYSxiKXtcInVzZSBzdHJpY3RcIjt2YXIgYz1bXSxkPWEuZG9jdW1lbnQsZT1PYmplY3QuZ2V0UHJvdG90eXBlT2YsZj1jLnNsaWNlLGc9Yy5jb25jYXQsaD1jLnB1c2gsaT1jLmluZGV4T2Ysaj17fSxrPWoudG9TdHJpbmcsbD1qLmhhc093blByb3BlcnR5LG09bC50b1N0cmluZyxuPW0uY2FsbChPYmplY3QpLG89e307ZnVuY3Rpb24gcChhLGIpe2I9Ynx8ZDt2YXIgYz1iLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7Yy50ZXh0PWEsYi5oZWFkLmFwcGVuZENoaWxkKGMpLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYyl9dmFyIHE9XCIzLjIuMVwiLHI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gbmV3IHIuZm4uaW5pdChhLGIpfSxzPS9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZyx0PS9eLW1zLS8sdT0vLShbYS16XSkvZyx2PWZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudG9VcHBlckNhc2UoKX07ci5mbj1yLnByb3RvdHlwZT17anF1ZXJ5OnEsY29uc3RydWN0b3I6cixsZW5ndGg6MCx0b0FycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIGYuY2FsbCh0aGlzKX0sZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP2YuY2FsbCh0aGlzKTphPDA/dGhpc1thK3RoaXMubGVuZ3RoXTp0aGlzW2FdfSxwdXNoU3RhY2s6ZnVuY3Rpb24oYSl7dmFyIGI9ci5tZXJnZSh0aGlzLmNvbnN0cnVjdG9yKCksYSk7cmV0dXJuIGIucHJldk9iamVjdD10aGlzLGJ9LGVhY2g6ZnVuY3Rpb24oYSl7cmV0dXJuIHIuZWFjaCh0aGlzLGEpfSxtYXA6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHIubWFwKHRoaXMsZnVuY3Rpb24oYixjKXtyZXR1cm4gYS5jYWxsKGIsYyxiKX0pKX0sc2xpY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZi5hcHBseSh0aGlzLGFyZ3VtZW50cykpfSxmaXJzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVxKDApfSxsYXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXEoLTEpfSxlcTpmdW5jdGlvbihhKXt2YXIgYj10aGlzLmxlbmd0aCxjPSthKyhhPDA/YjowKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soYz49MCYmYzxiP1t0aGlzW2NdXTpbXSl9LGVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByZXZPYmplY3R8fHRoaXMuY29uc3RydWN0b3IoKX0scHVzaDpoLHNvcnQ6Yy5zb3J0LHNwbGljZTpjLnNwbGljZX0sci5leHRlbmQ9ci5mbi5leHRlbmQ9ZnVuY3Rpb24oKXt2YXIgYSxiLGMsZCxlLGYsZz1hcmd1bWVudHNbMF18fHt9LGg9MSxpPWFyZ3VtZW50cy5sZW5ndGgsaj0hMTtmb3IoXCJib29sZWFuXCI9PXR5cGVvZiBnJiYoaj1nLGc9YXJndW1lbnRzW2hdfHx7fSxoKyspLFwib2JqZWN0XCI9PXR5cGVvZiBnfHxyLmlzRnVuY3Rpb24oZyl8fChnPXt9KSxoPT09aSYmKGc9dGhpcyxoLS0pO2g8aTtoKyspaWYobnVsbCE9KGE9YXJndW1lbnRzW2hdKSlmb3IoYiBpbiBhKWM9Z1tiXSxkPWFbYl0sZyE9PWQmJihqJiZkJiYoci5pc1BsYWluT2JqZWN0KGQpfHwoZT1BcnJheS5pc0FycmF5KGQpKSk/KGU/KGU9ITEsZj1jJiZBcnJheS5pc0FycmF5KGMpP2M6W10pOmY9YyYmci5pc1BsYWluT2JqZWN0KGMpP2M6e30sZ1tiXT1yLmV4dGVuZChqLGYsZCkpOnZvaWQgMCE9PWQmJihnW2JdPWQpKTtyZXR1cm4gZ30sci5leHRlbmQoe2V4cGFuZG86XCJqUXVlcnlcIisocStNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXEQvZyxcIlwiKSxpc1JlYWR5OiEwLGVycm9yOmZ1bmN0aW9uKGEpe3Rocm93IG5ldyBFcnJvcihhKX0sbm9vcDpmdW5jdGlvbigpe30saXNGdW5jdGlvbjpmdW5jdGlvbihhKXtyZXR1cm5cImZ1bmN0aW9uXCI9PT1yLnR5cGUoYSl9LGlzV2luZG93OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT1hJiZhPT09YS53aW5kb3d9LGlzTnVtZXJpYzpmdW5jdGlvbihhKXt2YXIgYj1yLnR5cGUoYSk7cmV0dXJuKFwibnVtYmVyXCI9PT1ifHxcInN0cmluZ1wiPT09YikmJiFpc05hTihhLXBhcnNlRmxvYXQoYSkpfSxpc1BsYWluT2JqZWN0OmZ1bmN0aW9uKGEpe3ZhciBiLGM7cmV0dXJuISghYXx8XCJbb2JqZWN0IE9iamVjdF1cIiE9PWsuY2FsbChhKSkmJighKGI9ZShhKSl8fChjPWwuY2FsbChiLFwiY29uc3RydWN0b3JcIikmJmIuY29uc3RydWN0b3IsXCJmdW5jdGlvblwiPT10eXBlb2YgYyYmbS5jYWxsKGMpPT09bikpfSxpc0VtcHR5T2JqZWN0OmZ1bmN0aW9uKGEpe3ZhciBiO2ZvcihiIGluIGEpcmV0dXJuITE7cmV0dXJuITB9LHR5cGU6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/YStcIlwiOlwib2JqZWN0XCI9PXR5cGVvZiBhfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBhP2pbay5jYWxsKGEpXXx8XCJvYmplY3RcIjp0eXBlb2YgYX0sZ2xvYmFsRXZhbDpmdW5jdGlvbihhKXtwKGEpfSxjYW1lbENhc2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVwbGFjZSh0LFwibXMtXCIpLnJlcGxhY2UodSx2KX0sZWFjaDpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9MDtpZih3KGEpKXtmb3IoYz1hLmxlbmd0aDtkPGM7ZCsrKWlmKGIuY2FsbChhW2RdLGQsYVtkXSk9PT0hMSlicmVha31lbHNlIGZvcihkIGluIGEpaWYoYi5jYWxsKGFbZF0sZCxhW2RdKT09PSExKWJyZWFrO3JldHVybiBhfSx0cmltOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hP1wiXCI6KGErXCJcIikucmVwbGFjZShzLFwiXCIpfSxtYWtlQXJyYXk6ZnVuY3Rpb24oYSxiKXt2YXIgYz1ifHxbXTtyZXR1cm4gbnVsbCE9YSYmKHcoT2JqZWN0KGEpKT9yLm1lcmdlKGMsXCJzdHJpbmdcIj09dHlwZW9mIGE/W2FdOmEpOmguY2FsbChjLGEpKSxjfSxpbkFycmF5OmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gbnVsbD09Yj8tMTppLmNhbGwoYixhLGMpfSxtZXJnZTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0rYi5sZW5ndGgsZD0wLGU9YS5sZW5ndGg7ZDxjO2QrKylhW2UrK109YltkXTtyZXR1cm4gYS5sZW5ndGg9ZSxhfSxncmVwOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQsZT1bXSxmPTAsZz1hLmxlbmd0aCxoPSFjO2Y8ZztmKyspZD0hYihhW2ZdLGYpLGQhPT1oJiZlLnB1c2goYVtmXSk7cmV0dXJuIGV9LG1hcDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPTAsaD1bXTtpZih3KGEpKWZvcihkPWEubGVuZ3RoO2Y8ZDtmKyspZT1iKGFbZl0sZixjKSxudWxsIT1lJiZoLnB1c2goZSk7ZWxzZSBmb3IoZiBpbiBhKWU9YihhW2ZdLGYsYyksbnVsbCE9ZSYmaC5wdXNoKGUpO3JldHVybiBnLmFwcGx5KFtdLGgpfSxndWlkOjEscHJveHk6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGU7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGImJihjPWFbYl0sYj1hLGE9Yyksci5pc0Z1bmN0aW9uKGEpKXJldHVybiBkPWYuY2FsbChhcmd1bWVudHMsMiksZT1mdW5jdGlvbigpe3JldHVybiBhLmFwcGx5KGJ8fHRoaXMsZC5jb25jYXQoZi5jYWxsKGFyZ3VtZW50cykpKX0sZS5ndWlkPWEuZ3VpZD1hLmd1aWR8fHIuZ3VpZCsrLGV9LG5vdzpEYXRlLm5vdyxzdXBwb3J0Om99KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJihyLmZuW1N5bWJvbC5pdGVyYXRvcl09Y1tTeW1ib2wuaXRlcmF0b3JdKSxyLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhLGIpe2pbXCJbb2JqZWN0IFwiK2IrXCJdXCJdPWIudG9Mb3dlckNhc2UoKX0pO2Z1bmN0aW9uIHcoYSl7dmFyIGI9ISFhJiZcImxlbmd0aFwiaW4gYSYmYS5sZW5ndGgsYz1yLnR5cGUoYSk7cmV0dXJuXCJmdW5jdGlvblwiIT09YyYmIXIuaXNXaW5kb3coYSkmJihcImFycmF5XCI9PT1jfHwwPT09Ynx8XCJudW1iZXJcIj09dHlwZW9mIGImJmI+MCYmYi0xIGluIGEpfXZhciB4PWZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlLGYsZyxoLGksaixrLGwsbSxuLG8scCxxLHIscyx0LHU9XCJzaXp6bGVcIisxKm5ldyBEYXRlLHY9YS5kb2N1bWVudCx3PTAseD0wLHk9aGEoKSx6PWhhKCksQT1oYSgpLEI9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYT09PWImJihsPSEwKSwwfSxDPXt9Lmhhc093blByb3BlcnR5LEQ9W10sRT1ELnBvcCxGPUQucHVzaCxHPUQucHVzaCxIPUQuc2xpY2UsST1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGg7YzxkO2MrKylpZihhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX0sSj1cImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsSz1cIltcXFxceDIwXFxcXHRcXFxcclxcXFxuXFxcXGZdXCIsTD1cIig/OlxcXFxcXFxcLnxbXFxcXHctXXxbXlxcMC1cXFxceGEwXSkrXCIsTT1cIlxcXFxbXCIrSytcIiooXCIrTCtcIikoPzpcIitLK1wiKihbKl4kfCF+XT89KVwiK0srXCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIitMK1wiKSl8KVwiK0srXCIqXFxcXF1cIixOPVwiOihcIitMK1wiKSg/OlxcXFwoKCgnKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIitNK1wiKSopfC4qKVxcXFwpfClcIixPPW5ldyBSZWdFeHAoSytcIitcIixcImdcIiksUD1uZXcgUmVnRXhwKFwiXlwiK0srXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiK0srXCIrJFwiLFwiZ1wiKSxRPW5ldyBSZWdFeHAoXCJeXCIrSytcIiosXCIrSytcIipcIiksUj1uZXcgUmVnRXhwKFwiXlwiK0srXCIqKFs+K35dfFwiK0srXCIpXCIrSytcIipcIiksUz1uZXcgUmVnRXhwKFwiPVwiK0srXCIqKFteXFxcXF0nXFxcIl0qPylcIitLK1wiKlxcXFxdXCIsXCJnXCIpLFQ9bmV3IFJlZ0V4cChOKSxVPW5ldyBSZWdFeHAoXCJeXCIrTCtcIiRcIiksVj17SUQ6bmV3IFJlZ0V4cChcIl4jKFwiK0wrXCIpXCIpLENMQVNTOm5ldyBSZWdFeHAoXCJeXFxcXC4oXCIrTCtcIilcIiksVEFHOm5ldyBSZWdFeHAoXCJeKFwiK0wrXCJ8WypdKVwiKSxBVFRSOm5ldyBSZWdFeHAoXCJeXCIrTSksUFNFVURPOm5ldyBSZWdFeHAoXCJeXCIrTiksQ0hJTEQ6bmV3IFJlZ0V4cChcIl46KG9ubHl8Zmlyc3R8bGFzdHxudGh8bnRoLWxhc3QpLShjaGlsZHxvZi10eXBlKSg/OlxcXFwoXCIrSytcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiK0srXCIqKD86KFsrLV18KVwiK0srXCIqKFxcXFxkKyl8KSlcIitLK1wiKlxcXFwpfClcIixcImlcIiksYm9vbDpuZXcgUmVnRXhwKFwiXig/OlwiK0orXCIpJFwiLFwiaVwiKSxuZWVkc0NvbnRleHQ6bmV3IFJlZ0V4cChcIl5cIitLK1wiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIitLK1wiKigoPzotXFxcXGQpP1xcXFxkKilcIitLK1wiKlxcXFwpfCkoPz1bXi1dfCQpXCIsXCJpXCIpfSxXPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksWD0vXmhcXGQkL2ksWT0vXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFo9L14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sJD0vWyt+XS8sXz1uZXcgUmVnRXhwKFwiXFxcXFxcXFwoW1xcXFxkYS1mXXsxLDZ9XCIrSytcIj98KFwiK0srXCIpfC4pXCIsXCJpZ1wiKSxhYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9XCIweFwiK2ItNjU1MzY7cmV0dXJuIGQhPT1kfHxjP2I6ZDwwP1N0cmluZy5mcm9tQ2hhckNvZGUoZCs2NTUzNik6U3RyaW5nLmZyb21DaGFyQ29kZShkPj4xMHw1NTI5NiwxMDIzJmR8NTYzMjApfSxiYT0vKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxjYT1mdW5jdGlvbihhLGIpe3JldHVybiBiP1wiXFwwXCI9PT1hP1wiXFx1ZmZmZFwiOmEuc2xpY2UoMCwtMSkrXCJcXFxcXCIrYS5jaGFyQ29kZUF0KGEubGVuZ3RoLTEpLnRvU3RyaW5nKDE2KStcIiBcIjpcIlxcXFxcIithfSxkYT1mdW5jdGlvbigpe20oKX0sZWE9dGEoZnVuY3Rpb24oYSl7cmV0dXJuIGEuZGlzYWJsZWQ9PT0hMCYmKFwiZm9ybVwiaW4gYXx8XCJsYWJlbFwiaW4gYSl9LHtkaXI6XCJwYXJlbnROb2RlXCIsbmV4dDpcImxlZ2VuZFwifSk7dHJ5e0cuYXBwbHkoRD1ILmNhbGwodi5jaGlsZE5vZGVzKSx2LmNoaWxkTm9kZXMpLERbdi5jaGlsZE5vZGVzLmxlbmd0aF0ubm9kZVR5cGV9Y2F0Y2goZmEpe0c9e2FwcGx5OkQubGVuZ3RoP2Z1bmN0aW9uKGEsYil7Ri5hcHBseShhLEguY2FsbChiKSl9OmZ1bmN0aW9uKGEsYil7dmFyIGM9YS5sZW5ndGgsZD0wO3doaWxlKGFbYysrXT1iW2QrK10pO2EubGVuZ3RoPWMtMX19fWZ1bmN0aW9uIGdhKGEsYixkLGUpe3ZhciBmLGgsaixrLGwsbyxyLHM9YiYmYi5vd25lckRvY3VtZW50LHc9Yj9iLm5vZGVUeXBlOjk7aWYoZD1kfHxbXSxcInN0cmluZ1wiIT10eXBlb2YgYXx8IWF8fDEhPT13JiY5IT09dyYmMTEhPT13KXJldHVybiBkO2lmKCFlJiYoKGI/Yi5vd25lckRvY3VtZW50fHxiOnYpIT09biYmbShiKSxiPWJ8fG4scCkpe2lmKDExIT09dyYmKGw9Wi5leGVjKGEpKSlpZihmPWxbMV0pe2lmKDk9PT13KXtpZighKGo9Yi5nZXRFbGVtZW50QnlJZChmKSkpcmV0dXJuIGQ7aWYoai5pZD09PWYpcmV0dXJuIGQucHVzaChqKSxkfWVsc2UgaWYocyYmKGo9cy5nZXRFbGVtZW50QnlJZChmKSkmJnQoYixqKSYmai5pZD09PWYpcmV0dXJuIGQucHVzaChqKSxkfWVsc2V7aWYobFsyXSlyZXR1cm4gRy5hcHBseShkLGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSkpLGQ7aWYoKGY9bFszXSkmJmMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSYmYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKXJldHVybiBHLmFwcGx5KGQsYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGYpKSxkfWlmKGMucXNhJiYhQVthK1wiIFwiXSYmKCFxfHwhcS50ZXN0KGEpKSl7aWYoMSE9PXcpcz1iLHI9YTtlbHNlIGlmKFwib2JqZWN0XCIhPT1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpeyhrPWIuZ2V0QXR0cmlidXRlKFwiaWRcIikpP2s9ay5yZXBsYWNlKGJhLGNhKTpiLnNldEF0dHJpYnV0ZShcImlkXCIsaz11KSxvPWcoYSksaD1vLmxlbmd0aDt3aGlsZShoLS0pb1toXT1cIiNcIitrK1wiIFwiK3NhKG9baF0pO3I9by5qb2luKFwiLFwiKSxzPSQudGVzdChhKSYmcWEoYi5wYXJlbnROb2RlKXx8Yn1pZihyKXRyeXtyZXR1cm4gRy5hcHBseShkLHMucXVlcnlTZWxlY3RvckFsbChyKSksZH1jYXRjaCh4KXt9ZmluYWxseXtrPT09dSYmYi5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKX19fXJldHVybiBpKGEucmVwbGFjZShQLFwiJDFcIiksYixkLGUpfWZ1bmN0aW9uIGhhKCl7dmFyIGE9W107ZnVuY3Rpb24gYihjLGUpe3JldHVybiBhLnB1c2goYytcIiBcIik+ZC5jYWNoZUxlbmd0aCYmZGVsZXRlIGJbYS5zaGlmdCgpXSxiW2MrXCIgXCJdPWV9cmV0dXJuIGJ9ZnVuY3Rpb24gaWEoYSl7cmV0dXJuIGFbdV09ITAsYX1mdW5jdGlvbiBqYShhKXt2YXIgYj1uLmNyZWF0ZUVsZW1lbnQoXCJmaWVsZHNldFwiKTt0cnl7cmV0dXJuISFhKGIpfWNhdGNoKGMpe3JldHVybiExfWZpbmFsbHl7Yi5wYXJlbnROb2RlJiZiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYiksYj1udWxsfX1mdW5jdGlvbiBrYShhLGIpe3ZhciBjPWEuc3BsaXQoXCJ8XCIpLGU9Yy5sZW5ndGg7d2hpbGUoZS0tKWQuYXR0ckhhbmRsZVtjW2VdXT1ifWZ1bmN0aW9uIGxhKGEsYil7dmFyIGM9YiYmYSxkPWMmJjE9PT1hLm5vZGVUeXBlJiYxPT09Yi5ub2RlVHlwZSYmYS5zb3VyY2VJbmRleC1iLnNvdXJjZUluZGV4O2lmKGQpcmV0dXJuIGQ7aWYoYyl3aGlsZShjPWMubmV4dFNpYmxpbmcpaWYoYz09PWIpcmV0dXJuLTE7cmV0dXJuIGE/MTotMX1mdW5jdGlvbiBtYShhKXtyZXR1cm4gZnVuY3Rpb24oYil7dmFyIGM9Yi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PWMmJmIudHlwZT09PWF9fWZ1bmN0aW9uIG5hKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz1iLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuKFwiaW5wdXRcIj09PWN8fFwiYnV0dG9uXCI9PT1jKSYmYi50eXBlPT09YX19ZnVuY3Rpb24gb2EoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVyblwiZm9ybVwiaW4gYj9iLnBhcmVudE5vZGUmJmIuZGlzYWJsZWQ9PT0hMT9cImxhYmVsXCJpbiBiP1wibGFiZWxcImluIGIucGFyZW50Tm9kZT9iLnBhcmVudE5vZGUuZGlzYWJsZWQ9PT1hOmIuZGlzYWJsZWQ9PT1hOmIuaXNEaXNhYmxlZD09PWF8fGIuaXNEaXNhYmxlZCE9PSFhJiZlYShiKT09PWE6Yi5kaXNhYmxlZD09PWE6XCJsYWJlbFwiaW4gYiYmYi5kaXNhYmxlZD09PWF9fWZ1bmN0aW9uIHBhKGEpe3JldHVybiBpYShmdW5jdGlvbihiKXtyZXR1cm4gYj0rYixpYShmdW5jdGlvbihjLGQpe3ZhciBlLGY9YShbXSxjLmxlbmd0aCxiKSxnPWYubGVuZ3RoO3doaWxlKGctLSljW2U9ZltnXV0mJihjW2VdPSEoZFtlXT1jW2VdKSl9KX0pfWZ1bmN0aW9uIHFhKGEpe3JldHVybiBhJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5nZXRFbGVtZW50c0J5VGFnTmFtZSYmYX1jPWdhLnN1cHBvcnQ9e30sZj1nYS5pc1hNTD1mdW5jdGlvbihhKXt2YXIgYj1hJiYoYS5vd25lckRvY3VtZW50fHxhKS5kb2N1bWVudEVsZW1lbnQ7cmV0dXJuISFiJiZcIkhUTUxcIiE9PWIubm9kZU5hbWV9LG09Z2Euc2V0RG9jdW1lbnQ9ZnVuY3Rpb24oYSl7dmFyIGIsZSxnPWE/YS5vd25lckRvY3VtZW50fHxhOnY7cmV0dXJuIGchPT1uJiY5PT09Zy5ub2RlVHlwZSYmZy5kb2N1bWVudEVsZW1lbnQ/KG49ZyxvPW4uZG9jdW1lbnRFbGVtZW50LHA9IWYobiksdiE9PW4mJihlPW4uZGVmYXVsdFZpZXcpJiZlLnRvcCE9PWUmJihlLmFkZEV2ZW50TGlzdGVuZXI/ZS5hZGRFdmVudExpc3RlbmVyKFwidW5sb2FkXCIsZGEsITEpOmUuYXR0YWNoRXZlbnQmJmUuYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLGRhKSksYy5hdHRyaWJ1dGVzPWphKGZ1bmN0aW9uKGEpe3JldHVybiBhLmNsYXNzTmFtZT1cImlcIiwhYS5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIil9KSxjLmdldEVsZW1lbnRzQnlUYWdOYW1lPWphKGZ1bmN0aW9uKGEpe3JldHVybiBhLmFwcGVuZENoaWxkKG4uY3JlYXRlQ29tbWVudChcIlwiKSksIWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aH0pLGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZT1ZLnRlc3Qobi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSxjLmdldEJ5SWQ9amEoZnVuY3Rpb24oYSl7cmV0dXJuIG8uYXBwZW5kQ2hpbGQoYSkuaWQ9dSwhbi5nZXRFbGVtZW50c0J5TmFtZXx8IW4uZ2V0RWxlbWVudHNCeU5hbWUodSkubGVuZ3RofSksYy5nZXRCeUlkPyhkLmZpbHRlci5JRD1mdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoXyxhYSk7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiBhLmdldEF0dHJpYnV0ZShcImlkXCIpPT09Yn19LGQuZmluZC5JRD1mdW5jdGlvbihhLGIpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBiLmdldEVsZW1lbnRCeUlkJiZwKXt2YXIgYz1iLmdldEVsZW1lbnRCeUlkKGEpO3JldHVybiBjP1tjXTpbXX19KTooZC5maWx0ZXIuSUQ9ZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKF8sYWEpO3JldHVybiBmdW5jdGlvbihhKXt2YXIgYz1cInVuZGVmaW5lZFwiIT10eXBlb2YgYS5nZXRBdHRyaWJ1dGVOb2RlJiZhLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtyZXR1cm4gYyYmYy52YWx1ZT09PWJ9fSxkLmZpbmQuSUQ9ZnVuY3Rpb24oYSxiKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgYi5nZXRFbGVtZW50QnlJZCYmcCl7dmFyIGMsZCxlLGY9Yi5nZXRFbGVtZW50QnlJZChhKTtpZihmKXtpZihjPWYuZ2V0QXR0cmlidXRlTm9kZShcImlkXCIpLGMmJmMudmFsdWU9PT1hKXJldHVybltmXTtlPWIuZ2V0RWxlbWVudHNCeU5hbWUoYSksZD0wO3doaWxlKGY9ZVtkKytdKWlmKGM9Zi5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIiksYyYmYy52YWx1ZT09PWEpcmV0dXJuW2ZdfXJldHVybltdfX0pLGQuZmluZC5UQUc9Yy5nZXRFbGVtZW50c0J5VGFnTmFtZT9mdW5jdGlvbihhLGIpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBiLmdldEVsZW1lbnRzQnlUYWdOYW1lP2IuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk6Yy5xc2E/Yi5xdWVyeVNlbGVjdG9yQWxsKGEpOnZvaWQgMH06ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPVtdLGU9MCxmPWIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk7aWYoXCIqXCI9PT1hKXt3aGlsZShjPWZbZSsrXSkxPT09Yy5ub2RlVHlwZSYmZC5wdXNoKGMpO3JldHVybiBkfXJldHVybiBmfSxkLmZpbmQuQ0xBU1M9Yy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lJiZmdW5jdGlvbihhLGIpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUmJnApcmV0dXJuIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShhKX0scj1bXSxxPVtdLChjLnFzYT1ZLnRlc3Qobi5xdWVyeVNlbGVjdG9yQWxsKSkmJihqYShmdW5jdGlvbihhKXtvLmFwcGVuZENoaWxkKGEpLmlubmVySFRNTD1cIjxhIGlkPSdcIit1K1wiJz48L2E+PHNlbGVjdCBpZD0nXCIrdStcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz48b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiLGEucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2FwdHVyZV49JyddXCIpLmxlbmd0aCYmcS5wdXNoKFwiWypeJF09XCIrSytcIiooPzonJ3xcXFwiXFxcIilcIiksYS5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGh8fHEucHVzaChcIlxcXFxbXCIrSytcIiooPzp2YWx1ZXxcIitKK1wiKVwiKSxhLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbaWR+PVwiK3UrXCItXVwiKS5sZW5ndGh8fHEucHVzaChcIn49XCIpLGEucXVlcnlTZWxlY3RvckFsbChcIjpjaGVja2VkXCIpLmxlbmd0aHx8cS5wdXNoKFwiOmNoZWNrZWRcIiksYS5xdWVyeVNlbGVjdG9yQWxsKFwiYSNcIit1K1wiKypcIikubGVuZ3RofHxxLnB1c2goXCIuIy4rWyt+XVwiKX0pLGphKGZ1bmN0aW9uKGEpe2EuaW5uZXJIVE1MPVwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT48c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7dmFyIGI9bi5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7Yi5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJoaWRkZW5cIiksYS5hcHBlbmRDaGlsZChiKS5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsXCJEXCIpLGEucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCYmcS5wdXNoKFwibmFtZVwiK0srXCIqWypeJHwhfl0/PVwiKSwyIT09YS5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoJiZxLnB1c2goXCI6ZW5hYmxlZFwiLFwiOmRpc2FibGVkXCIpLG8uYXBwZW5kQ2hpbGQoYSkuZGlzYWJsZWQ9ITAsMiE9PWEucXVlcnlTZWxlY3RvckFsbChcIjpkaXNhYmxlZFwiKS5sZW5ndGgmJnEucHVzaChcIjplbmFibGVkXCIsXCI6ZGlzYWJsZWRcIiksYS5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKSxxLnB1c2goXCIsLio6XCIpfSkpLChjLm1hdGNoZXNTZWxlY3Rvcj1ZLnRlc3Qocz1vLm1hdGNoZXN8fG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yfHxvLm1vek1hdGNoZXNTZWxlY3Rvcnx8by5vTWF0Y2hlc1NlbGVjdG9yfHxvLm1zTWF0Y2hlc1NlbGVjdG9yKSkmJmphKGZ1bmN0aW9uKGEpe2MuZGlzY29ubmVjdGVkTWF0Y2g9cy5jYWxsKGEsXCIqXCIpLHMuY2FsbChhLFwiW3MhPScnXTp4XCIpLHIucHVzaChcIiE9XCIsTil9KSxxPXEubGVuZ3RoJiZuZXcgUmVnRXhwKHEuam9pbihcInxcIikpLHI9ci5sZW5ndGgmJm5ldyBSZWdFeHAoci5qb2luKFwifFwiKSksYj1ZLnRlc3Qoby5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiksdD1ifHxZLnRlc3Qoby5jb250YWlucyk/ZnVuY3Rpb24oYSxiKXt2YXIgYz05PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLGQ9YiYmYi5wYXJlbnROb2RlO3JldHVybiBhPT09ZHx8ISghZHx8MSE9PWQubm9kZVR5cGV8fCEoYy5jb250YWlucz9jLmNvbnRhaW5zKGQpOmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24mJjE2JmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZCkpKX06ZnVuY3Rpb24oYSxiKXtpZihiKXdoaWxlKGI9Yi5wYXJlbnROb2RlKWlmKGI9PT1hKXJldHVybiEwO3JldHVybiExfSxCPWI/ZnVuY3Rpb24oYSxiKXtpZihhPT09YilyZXR1cm4gbD0hMCwwO3ZhciBkPSFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uLSFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO3JldHVybiBkP2Q6KGQ9KGEub3duZXJEb2N1bWVudHx8YSk9PT0oYi5vd25lckRvY3VtZW50fHxiKT9hLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpOjEsMSZkfHwhYy5zb3J0RGV0YWNoZWQmJmIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSk9PT1kP2E9PT1ufHxhLm93bmVyRG9jdW1lbnQ9PT12JiZ0KHYsYSk/LTE6Yj09PW58fGIub3duZXJEb2N1bWVudD09PXYmJnQodixiKT8xOms/SShrLGEpLUkoayxiKTowOjQmZD8tMToxKX06ZnVuY3Rpb24oYSxiKXtpZihhPT09YilyZXR1cm4gbD0hMCwwO3ZhciBjLGQ9MCxlPWEucGFyZW50Tm9kZSxmPWIucGFyZW50Tm9kZSxnPVthXSxoPVtiXTtpZighZXx8IWYpcmV0dXJuIGE9PT1uPy0xOmI9PT1uPzE6ZT8tMTpmPzE6az9JKGssYSktSShrLGIpOjA7aWYoZT09PWYpcmV0dXJuIGxhKGEsYik7Yz1hO3doaWxlKGM9Yy5wYXJlbnROb2RlKWcudW5zaGlmdChjKTtjPWI7d2hpbGUoYz1jLnBhcmVudE5vZGUpaC51bnNoaWZ0KGMpO3doaWxlKGdbZF09PT1oW2RdKWQrKztyZXR1cm4gZD9sYShnW2RdLGhbZF0pOmdbZF09PT12Py0xOmhbZF09PT12PzE6MH0sbik6bn0sZ2EubWF0Y2hlcz1mdW5jdGlvbihhLGIpe3JldHVybiBnYShhLG51bGwsbnVsbCxiKX0sZ2EubWF0Y2hlc1NlbGVjdG9yPWZ1bmN0aW9uKGEsYil7aWYoKGEub3duZXJEb2N1bWVudHx8YSkhPT1uJiZtKGEpLGI9Yi5yZXBsYWNlKFMsXCI9JyQxJ11cIiksYy5tYXRjaGVzU2VsZWN0b3ImJnAmJiFBW2IrXCIgXCJdJiYoIXJ8fCFyLnRlc3QoYikpJiYoIXF8fCFxLnRlc3QoYikpKXRyeXt2YXIgZD1zLmNhbGwoYSxiKTtpZihkfHxjLmRpc2Nvbm5lY3RlZE1hdGNofHxhLmRvY3VtZW50JiYxMSE9PWEuZG9jdW1lbnQubm9kZVR5cGUpcmV0dXJuIGR9Y2F0Y2goZSl7fXJldHVybiBnYShiLG4sbnVsbCxbYV0pLmxlbmd0aD4wfSxnYS5jb250YWlucz1mdW5jdGlvbihhLGIpe3JldHVybihhLm93bmVyRG9jdW1lbnR8fGEpIT09biYmbShhKSx0KGEsYil9LGdhLmF0dHI9ZnVuY3Rpb24oYSxiKXsoYS5vd25lckRvY3VtZW50fHxhKSE9PW4mJm0oYSk7dmFyIGU9ZC5hdHRySGFuZGxlW2IudG9Mb3dlckNhc2UoKV0sZj1lJiZDLmNhbGwoZC5hdHRySGFuZGxlLGIudG9Mb3dlckNhc2UoKSk/ZShhLGIsIXApOnZvaWQgMDtyZXR1cm4gdm9pZCAwIT09Zj9mOmMuYXR0cmlidXRlc3x8IXA/YS5nZXRBdHRyaWJ1dGUoYik6KGY9YS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSYmZi5zcGVjaWZpZWQ/Zi52YWx1ZTpudWxsfSxnYS5lc2NhcGU9ZnVuY3Rpb24oYSl7cmV0dXJuKGErXCJcIikucmVwbGFjZShiYSxjYSl9LGdhLmVycm9yPWZ1bmN0aW9uKGEpe3Rocm93IG5ldyBFcnJvcihcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiK2EpfSxnYS51bmlxdWVTb3J0PWZ1bmN0aW9uKGEpe3ZhciBiLGQ9W10sZT0wLGY9MDtpZihsPSFjLmRldGVjdER1cGxpY2F0ZXMsaz0hYy5zb3J0U3RhYmxlJiZhLnNsaWNlKDApLGEuc29ydChCKSxsKXt3aGlsZShiPWFbZisrXSliPT09YVtmXSYmKGU9ZC5wdXNoKGYpKTt3aGlsZShlLS0pYS5zcGxpY2UoZFtlXSwxKX1yZXR1cm4gaz1udWxsLGF9LGU9Z2EuZ2V0VGV4dD1mdW5jdGlvbihhKXt2YXIgYixjPVwiXCIsZD0wLGY9YS5ub2RlVHlwZTtpZihmKXtpZigxPT09Znx8OT09PWZ8fDExPT09Zil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGEudGV4dENvbnRlbnQpcmV0dXJuIGEudGV4dENvbnRlbnQ7Zm9yKGE9YS5maXJzdENoaWxkO2E7YT1hLm5leHRTaWJsaW5nKWMrPWUoYSl9ZWxzZSBpZigzPT09Znx8ND09PWYpcmV0dXJuIGEubm9kZVZhbHVlfWVsc2Ugd2hpbGUoYj1hW2QrK10pYys9ZShiKTtyZXR1cm4gY30sZD1nYS5zZWxlY3RvcnM9e2NhY2hlTGVuZ3RoOjUwLGNyZWF0ZVBzZXVkbzppYSxtYXRjaDpWLGF0dHJIYW5kbGU6e30sZmluZDp7fSxyZWxhdGl2ZTp7XCI+XCI6e2RpcjpcInBhcmVudE5vZGVcIixmaXJzdDohMH0sXCIgXCI6e2RpcjpcInBhcmVudE5vZGVcIn0sXCIrXCI6e2RpcjpcInByZXZpb3VzU2libGluZ1wiLGZpcnN0OiEwfSxcIn5cIjp7ZGlyOlwicHJldmlvdXNTaWJsaW5nXCJ9fSxwcmVGaWx0ZXI6e0FUVFI6ZnVuY3Rpb24oYSl7cmV0dXJuIGFbMV09YVsxXS5yZXBsYWNlKF8sYWEpLGFbM109KGFbM118fGFbNF18fGFbNV18fFwiXCIpLnJlcGxhY2UoXyxhYSksXCJ+PVwiPT09YVsyXSYmKGFbM109XCIgXCIrYVszXStcIiBcIiksYS5zbGljZSgwLDQpfSxDSElMRDpmdW5jdGlvbihhKXtyZXR1cm4gYVsxXT1hWzFdLnRvTG93ZXJDYXNlKCksXCJudGhcIj09PWFbMV0uc2xpY2UoMCwzKT8oYVszXXx8Z2EuZXJyb3IoYVswXSksYVs0XT0rKGFbNF0/YVs1XSsoYVs2XXx8MSk6MiooXCJldmVuXCI9PT1hWzNdfHxcIm9kZFwiPT09YVszXSkpLGFbNV09KyhhWzddK2FbOF18fFwib2RkXCI9PT1hWzNdKSk6YVszXSYmZ2EuZXJyb3IoYVswXSksYX0sUFNFVURPOmZ1bmN0aW9uKGEpe3ZhciBiLGM9IWFbNl0mJmFbMl07cmV0dXJuIFYuQ0hJTEQudGVzdChhWzBdKT9udWxsOihhWzNdP2FbMl09YVs0XXx8YVs1XXx8XCJcIjpjJiZULnRlc3QoYykmJihiPWcoYywhMCkpJiYoYj1jLmluZGV4T2YoXCIpXCIsYy5sZW5ndGgtYiktYy5sZW5ndGgpJiYoYVswXT1hWzBdLnNsaWNlKDAsYiksYVsyXT1jLnNsaWNlKDAsYikpLGEuc2xpY2UoMCwzKSl9fSxmaWx0ZXI6e1RBRzpmdW5jdGlvbihhKXt2YXIgYj1hLnJlcGxhY2UoXyxhYSkudG9Mb3dlckNhc2UoKTtyZXR1cm5cIipcIj09PWE/ZnVuY3Rpb24oKXtyZXR1cm4hMH06ZnVuY3Rpb24oYSl7cmV0dXJuIGEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKT09PWJ9fSxDTEFTUzpmdW5jdGlvbihhKXt2YXIgYj15W2ErXCIgXCJdO3JldHVybiBifHwoYj1uZXcgUmVnRXhwKFwiKF58XCIrSytcIilcIithK1wiKFwiK0srXCJ8JClcIikpJiZ5KGEsZnVuY3Rpb24oYSl7cmV0dXJuIGIudGVzdChcInN0cmluZ1wiPT10eXBlb2YgYS5jbGFzc05hbWUmJmEuY2xhc3NOYW1lfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5nZXRBdHRyaWJ1dGUmJmEuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIpfSl9LEFUVFI6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBmdW5jdGlvbihkKXt2YXIgZT1nYS5hdHRyKGQsYSk7cmV0dXJuIG51bGw9PWU/XCIhPVwiPT09YjohYnx8KGUrPVwiXCIsXCI9XCI9PT1iP2U9PT1jOlwiIT1cIj09PWI/ZSE9PWM6XCJePVwiPT09Yj9jJiYwPT09ZS5pbmRleE9mKGMpOlwiKj1cIj09PWI/YyYmZS5pbmRleE9mKGMpPi0xOlwiJD1cIj09PWI/YyYmZS5zbGljZSgtYy5sZW5ndGgpPT09YzpcIn49XCI9PT1iPyhcIiBcIitlLnJlcGxhY2UoTyxcIiBcIikrXCIgXCIpLmluZGV4T2YoYyk+LTE6XCJ8PVwiPT09YiYmKGU9PT1jfHxlLnNsaWNlKDAsYy5sZW5ndGgrMSk9PT1jK1wiLVwiKSl9fSxDSElMRDpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPVwibnRoXCIhPT1hLnNsaWNlKDAsMyksZz1cImxhc3RcIiE9PWEuc2xpY2UoLTQpLGg9XCJvZi10eXBlXCI9PT1iO3JldHVybiAxPT09ZCYmMD09PWU/ZnVuY3Rpb24oYSl7cmV0dXJuISFhLnBhcmVudE5vZGV9OmZ1bmN0aW9uKGIsYyxpKXt2YXIgaixrLGwsbSxuLG8scD1mIT09Zz9cIm5leHRTaWJsaW5nXCI6XCJwcmV2aW91c1NpYmxpbmdcIixxPWIucGFyZW50Tm9kZSxyPWgmJmIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxzPSFpJiYhaCx0PSExO2lmKHEpe2lmKGYpe3doaWxlKHApe209Yjt3aGlsZShtPW1bcF0paWYoaD9tLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1yOjE9PT1tLm5vZGVUeXBlKXJldHVybiExO289cD1cIm9ubHlcIj09PWEmJiFvJiZcIm5leHRTaWJsaW5nXCJ9cmV0dXJuITB9aWYobz1bZz9xLmZpcnN0Q2hpbGQ6cS5sYXN0Q2hpbGRdLGcmJnMpe209cSxsPW1bdV18fChtW3VdPXt9KSxrPWxbbS51bmlxdWVJRF18fChsW20udW5pcXVlSURdPXt9KSxqPWtbYV18fFtdLG49alswXT09PXcmJmpbMV0sdD1uJiZqWzJdLG09biYmcS5jaGlsZE5vZGVzW25dO3doaWxlKG09KytuJiZtJiZtW3BdfHwodD1uPTApfHxvLnBvcCgpKWlmKDE9PT1tLm5vZGVUeXBlJiYrK3QmJm09PT1iKXtrW2FdPVt3LG4sdF07YnJlYWt9fWVsc2UgaWYocyYmKG09YixsPW1bdV18fChtW3VdPXt9KSxrPWxbbS51bmlxdWVJRF18fChsW20udW5pcXVlSURdPXt9KSxqPWtbYV18fFtdLG49alswXT09PXcmJmpbMV0sdD1uKSx0PT09ITEpd2hpbGUobT0rK24mJm0mJm1bcF18fCh0PW49MCl8fG8ucG9wKCkpaWYoKGg/bS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPT09cjoxPT09bS5ub2RlVHlwZSkmJisrdCYmKHMmJihsPW1bdV18fChtW3VdPXt9KSxrPWxbbS51bmlxdWVJRF18fChsW20udW5pcXVlSURdPXt9KSxrW2FdPVt3LHRdKSxtPT09YikpYnJlYWs7cmV0dXJuIHQtPWUsdD09PWR8fHQlZD09PTAmJnQvZD49MH19fSxQU0VVRE86ZnVuY3Rpb24oYSxiKXt2YXIgYyxlPWQucHNldWRvc1thXXx8ZC5zZXRGaWx0ZXJzW2EudG9Mb3dlckNhc2UoKV18fGdhLmVycm9yKFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIithKTtyZXR1cm4gZVt1XT9lKGIpOmUubGVuZ3RoPjE/KGM9W2EsYSxcIlwiLGJdLGQuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eShhLnRvTG93ZXJDYXNlKCkpP2lhKGZ1bmN0aW9uKGEsYyl7dmFyIGQsZj1lKGEsYiksZz1mLmxlbmd0aDt3aGlsZShnLS0pZD1JKGEsZltnXSksYVtkXT0hKGNbZF09ZltnXSl9KTpmdW5jdGlvbihhKXtyZXR1cm4gZShhLDAsYyl9KTplfX0scHNldWRvczp7bm90OmlhKGZ1bmN0aW9uKGEpe3ZhciBiPVtdLGM9W10sZD1oKGEucmVwbGFjZShQLFwiJDFcIikpO3JldHVybiBkW3VdP2lhKGZ1bmN0aW9uKGEsYixjLGUpe3ZhciBmLGc9ZChhLG51bGwsZSxbXSksaD1hLmxlbmd0aDt3aGlsZShoLS0pKGY9Z1toXSkmJihhW2hdPSEoYltoXT1mKSl9KTpmdW5jdGlvbihhLGUsZil7cmV0dXJuIGJbMF09YSxkKGIsbnVsbCxmLGMpLGJbMF09bnVsbCwhYy5wb3AoKX19KSxoYXM6aWEoZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybiBnYShhLGIpLmxlbmd0aD4wfX0pLGNvbnRhaW5zOmlhKGZ1bmN0aW9uKGEpe3JldHVybiBhPWEucmVwbGFjZShfLGFhKSxmdW5jdGlvbihiKXtyZXR1cm4oYi50ZXh0Q29udGVudHx8Yi5pbm5lclRleHR8fGUoYikpLmluZGV4T2YoYSk+LTF9fSksbGFuZzppYShmdW5jdGlvbihhKXtyZXR1cm4gVS50ZXN0KGF8fFwiXCIpfHxnYS5lcnJvcihcInVuc3VwcG9ydGVkIGxhbmc6IFwiK2EpLGE9YS5yZXBsYWNlKF8sYWEpLnRvTG93ZXJDYXNlKCksZnVuY3Rpb24oYil7dmFyIGM7ZG8gaWYoYz1wP2IubGFuZzpiLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpfHxiLmdldEF0dHJpYnV0ZShcImxhbmdcIikpcmV0dXJuIGM9Yy50b0xvd2VyQ2FzZSgpLGM9PT1hfHwwPT09Yy5pbmRleE9mKGErXCItXCIpO3doaWxlKChiPWIucGFyZW50Tm9kZSkmJjE9PT1iLm5vZGVUeXBlKTtyZXR1cm4hMX19KSx0YXJnZXQ6ZnVuY3Rpb24oYil7dmFyIGM9YS5sb2NhdGlvbiYmYS5sb2NhdGlvbi5oYXNoO3JldHVybiBjJiZjLnNsaWNlKDEpPT09Yi5pZH0scm9vdDpmdW5jdGlvbihhKXtyZXR1cm4gYT09PW99LGZvY3VzOmZ1bmN0aW9uKGEpe3JldHVybiBhPT09bi5hY3RpdmVFbGVtZW50JiYoIW4uaGFzRm9jdXN8fG4uaGFzRm9jdXMoKSkmJiEhKGEudHlwZXx8YS5ocmVmfHx+YS50YWJJbmRleCl9LGVuYWJsZWQ6b2EoITEpLGRpc2FibGVkOm9hKCEwKSxjaGVja2VkOmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT1iJiYhIWEuY2hlY2tlZHx8XCJvcHRpb25cIj09PWImJiEhYS5zZWxlY3RlZH0sc2VsZWN0ZWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucGFyZW50Tm9kZSYmYS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsYS5zZWxlY3RlZD09PSEwfSxlbXB0eTpmdW5jdGlvbihhKXtmb3IoYT1hLmZpcnN0Q2hpbGQ7YTthPWEubmV4dFNpYmxpbmcpaWYoYS5ub2RlVHlwZTw2KXJldHVybiExO3JldHVybiEwfSxwYXJlbnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIWQucHNldWRvcy5lbXB0eShhKX0saGVhZGVyOmZ1bmN0aW9uKGEpe3JldHVybiBYLnRlc3QoYS5ub2RlTmFtZSl9LGlucHV0OmZ1bmN0aW9uKGEpe3JldHVybiBXLnRlc3QoYS5ub2RlTmFtZSl9LGJ1dHRvbjpmdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09YiYmXCJidXR0b25cIj09PWEudHlwZXx8XCJidXR0b25cIj09PWJ9LHRleHQ6ZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuXCJpbnB1dFwiPT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpJiZcInRleHRcIj09PWEudHlwZSYmKG51bGw9PShiPWEuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSl8fFwidGV4dFwiPT09Yi50b0xvd2VyQ2FzZSgpKX0sZmlyc3Q6cGEoZnVuY3Rpb24oKXtyZXR1cm5bMF19KSxsYXN0OnBhKGZ1bmN0aW9uKGEsYil7cmV0dXJuW2ItMV19KSxlcTpwYShmdW5jdGlvbihhLGIsYyl7cmV0dXJuW2M8MD9jK2I6Y119KSxldmVuOnBhKGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxiO2MrPTIpYS5wdXNoKGMpO3JldHVybiBhfSksb2RkOnBhKGZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTE7YzxiO2MrPTIpYS5wdXNoKGMpO3JldHVybiBhfSksbHQ6cGEoZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD1jPDA/YytiOmM7LS1kPj0wOylhLnB1c2goZCk7cmV0dXJuIGF9KSxndDpwYShmdW5jdGlvbihhLGIsYyl7Zm9yKHZhciBkPWM8MD9jK2I6YzsrK2Q8YjspYS5wdXNoKGQpO3JldHVybiBhfSl9fSxkLnBzZXVkb3MubnRoPWQucHNldWRvcy5lcTtmb3IoYiBpbntyYWRpbzohMCxjaGVja2JveDohMCxmaWxlOiEwLHBhc3N3b3JkOiEwLGltYWdlOiEwfSlkLnBzZXVkb3NbYl09bWEoYik7Zm9yKGIgaW57c3VibWl0OiEwLHJlc2V0OiEwfSlkLnBzZXVkb3NbYl09bmEoYik7ZnVuY3Rpb24gcmEoKXt9cmEucHJvdG90eXBlPWQuZmlsdGVycz1kLnBzZXVkb3MsZC5zZXRGaWx0ZXJzPW5ldyByYSxnPWdhLnRva2VuaXplPWZ1bmN0aW9uKGEsYil7dmFyIGMsZSxmLGcsaCxpLGosaz16W2ErXCIgXCJdO2lmKGspcmV0dXJuIGI/MDprLnNsaWNlKDApO2g9YSxpPVtdLGo9ZC5wcmVGaWx0ZXI7d2hpbGUoaCl7YyYmIShlPVEuZXhlYyhoKSl8fChlJiYoaD1oLnNsaWNlKGVbMF0ubGVuZ3RoKXx8aCksaS5wdXNoKGY9W10pKSxjPSExLChlPVIuZXhlYyhoKSkmJihjPWUuc2hpZnQoKSxmLnB1c2goe3ZhbHVlOmMsdHlwZTplWzBdLnJlcGxhY2UoUCxcIiBcIil9KSxoPWguc2xpY2UoYy5sZW5ndGgpKTtmb3IoZyBpbiBkLmZpbHRlcikhKGU9VltnXS5leGVjKGgpKXx8altnXSYmIShlPWpbZ10oZSkpfHwoYz1lLnNoaWZ0KCksZi5wdXNoKHt2YWx1ZTpjLHR5cGU6ZyxtYXRjaGVzOmV9KSxoPWguc2xpY2UoYy5sZW5ndGgpKTtpZighYylicmVha31yZXR1cm4gYj9oLmxlbmd0aDpoP2dhLmVycm9yKGEpOnooYSxpKS5zbGljZSgwKX07ZnVuY3Rpb24gc2EoYSl7Zm9yKHZhciBiPTAsYz1hLmxlbmd0aCxkPVwiXCI7YjxjO2IrKylkKz1hW2JdLnZhbHVlO3JldHVybiBkfWZ1bmN0aW9uIHRhKGEsYixjKXt2YXIgZD1iLmRpcixlPWIubmV4dCxmPWV8fGQsZz1jJiZcInBhcmVudE5vZGVcIj09PWYsaD14Kys7cmV0dXJuIGIuZmlyc3Q/ZnVuY3Rpb24oYixjLGUpe3doaWxlKGI9YltkXSlpZigxPT09Yi5ub2RlVHlwZXx8ZylyZXR1cm4gYShiLGMsZSk7cmV0dXJuITF9OmZ1bmN0aW9uKGIsYyxpKXt2YXIgaixrLGwsbT1bdyxoXTtpZihpKXt3aGlsZShiPWJbZF0paWYoKDE9PT1iLm5vZGVUeXBlfHxnKSYmYShiLGMsaSkpcmV0dXJuITB9ZWxzZSB3aGlsZShiPWJbZF0paWYoMT09PWIubm9kZVR5cGV8fGcpaWYobD1iW3VdfHwoYlt1XT17fSksaz1sW2IudW5pcXVlSURdfHwobFtiLnVuaXF1ZUlEXT17fSksZSYmZT09PWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKSliPWJbZF18fGI7ZWxzZXtpZigoaj1rW2ZdKSYmalswXT09PXcmJmpbMV09PT1oKXJldHVybiBtWzJdPWpbMl07aWYoa1tmXT1tLG1bMl09YShiLGMsaSkpcmV0dXJuITB9cmV0dXJuITF9fWZ1bmN0aW9uIHVhKGEpe3JldHVybiBhLmxlbmd0aD4xP2Z1bmN0aW9uKGIsYyxkKXt2YXIgZT1hLmxlbmd0aDt3aGlsZShlLS0paWYoIWFbZV0oYixjLGQpKXJldHVybiExO3JldHVybiEwfTphWzBdfWZ1bmN0aW9uIHZhKGEsYixjKXtmb3IodmFyIGQ9MCxlPWIubGVuZ3RoO2Q8ZTtkKyspZ2EoYSxiW2RdLGMpO3JldHVybiBjfWZ1bmN0aW9uIHdhKGEsYixjLGQsZSl7Zm9yKHZhciBmLGc9W10saD0wLGk9YS5sZW5ndGgsaj1udWxsIT1iO2g8aTtoKyspKGY9YVtoXSkmJihjJiYhYyhmLGQsZSl8fChnLnB1c2goZiksaiYmYi5wdXNoKGgpKSk7cmV0dXJuIGd9ZnVuY3Rpb24geGEoYSxiLGMsZCxlLGYpe3JldHVybiBkJiYhZFt1XSYmKGQ9eGEoZCkpLGUmJiFlW3VdJiYoZT14YShlLGYpKSxpYShmdW5jdGlvbihmLGcsaCxpKXt2YXIgaixrLGwsbT1bXSxuPVtdLG89Zy5sZW5ndGgscD1mfHx2YShifHxcIipcIixoLm5vZGVUeXBlP1toXTpoLFtdKSxxPSFhfHwhZiYmYj9wOndhKHAsbSxhLGgsaSkscj1jP2V8fChmP2E6b3x8ZCk/W106ZzpxO2lmKGMmJmMocSxyLGgsaSksZCl7aj13YShyLG4pLGQoaixbXSxoLGkpLGs9ai5sZW5ndGg7d2hpbGUoay0tKShsPWpba10pJiYocltuW2tdXT0hKHFbbltrXV09bCkpfWlmKGYpe2lmKGV8fGEpe2lmKGUpe2o9W10saz1yLmxlbmd0aDt3aGlsZShrLS0pKGw9cltrXSkmJmoucHVzaChxW2tdPWwpO2UobnVsbCxyPVtdLGosaSl9az1yLmxlbmd0aDt3aGlsZShrLS0pKGw9cltrXSkmJihqPWU/SShmLGwpOm1ba10pPi0xJiYoZltqXT0hKGdbal09bCkpfX1lbHNlIHI9d2Eocj09PWc/ci5zcGxpY2UobyxyLmxlbmd0aCk6ciksZT9lKG51bGwsZyxyLGkpOkcuYXBwbHkoZyxyKX0pfWZ1bmN0aW9uIHlhKGEpe2Zvcih2YXIgYixjLGUsZj1hLmxlbmd0aCxnPWQucmVsYXRpdmVbYVswXS50eXBlXSxoPWd8fGQucmVsYXRpdmVbXCIgXCJdLGk9Zz8xOjAsaz10YShmdW5jdGlvbihhKXtyZXR1cm4gYT09PWJ9LGgsITApLGw9dGEoZnVuY3Rpb24oYSl7cmV0dXJuIEkoYixhKT4tMX0saCwhMCksbT1bZnVuY3Rpb24oYSxjLGQpe3ZhciBlPSFnJiYoZHx8YyE9PWopfHwoKGI9Yykubm9kZVR5cGU/ayhhLGMsZCk6bChhLGMsZCkpO3JldHVybiBiPW51bGwsZX1dO2k8ZjtpKyspaWYoYz1kLnJlbGF0aXZlW2FbaV0udHlwZV0pbT1bdGEodWEobSksYyldO2Vsc2V7aWYoYz1kLmZpbHRlclthW2ldLnR5cGVdLmFwcGx5KG51bGwsYVtpXS5tYXRjaGVzKSxjW3VdKXtmb3IoZT0rK2k7ZTxmO2UrKylpZihkLnJlbGF0aXZlW2FbZV0udHlwZV0pYnJlYWs7cmV0dXJuIHhhKGk+MSYmdWEobSksaT4xJiZzYShhLnNsaWNlKDAsaS0xKS5jb25jYXQoe3ZhbHVlOlwiIFwiPT09YVtpLTJdLnR5cGU/XCIqXCI6XCJcIn0pKS5yZXBsYWNlKFAsXCIkMVwiKSxjLGk8ZSYmeWEoYS5zbGljZShpLGUpKSxlPGYmJnlhKGE9YS5zbGljZShlKSksZTxmJiZzYShhKSl9bS5wdXNoKGMpfXJldHVybiB1YShtKX1mdW5jdGlvbiB6YShhLGIpe3ZhciBjPWIubGVuZ3RoPjAsZT1hLmxlbmd0aD4wLGY9ZnVuY3Rpb24oZixnLGgsaSxrKXt2YXIgbCxvLHEscj0wLHM9XCIwXCIsdD1mJiZbXSx1PVtdLHY9aix4PWZ8fGUmJmQuZmluZC5UQUcoXCIqXCIsaykseT13Kz1udWxsPT12PzE6TWF0aC5yYW5kb20oKXx8LjEsej14Lmxlbmd0aDtmb3IoayYmKGo9Zz09PW58fGd8fGspO3MhPT16JiZudWxsIT0obD14W3NdKTtzKyspe2lmKGUmJmwpe289MCxnfHxsLm93bmVyRG9jdW1lbnQ9PT1ufHwobShsKSxoPSFwKTt3aGlsZShxPWFbbysrXSlpZihxKGwsZ3x8bixoKSl7aS5wdXNoKGwpO2JyZWFrfWsmJih3PXkpfWMmJigobD0hcSYmbCkmJnItLSxmJiZ0LnB1c2gobCkpfWlmKHIrPXMsYyYmcyE9PXIpe289MDt3aGlsZShxPWJbbysrXSlxKHQsdSxnLGgpO2lmKGYpe2lmKHI+MCl3aGlsZShzLS0pdFtzXXx8dVtzXXx8KHVbc109RS5jYWxsKGkpKTt1PXdhKHUpfUcuYXBwbHkoaSx1KSxrJiYhZiYmdS5sZW5ndGg+MCYmcitiLmxlbmd0aD4xJiZnYS51bmlxdWVTb3J0KGkpfXJldHVybiBrJiYodz15LGo9diksdH07cmV0dXJuIGM/aWEoZik6Zn1yZXR1cm4gaD1nYS5jb21waWxlPWZ1bmN0aW9uKGEsYil7dmFyIGMsZD1bXSxlPVtdLGY9QVthK1wiIFwiXTtpZighZil7Ynx8KGI9ZyhhKSksYz1iLmxlbmd0aDt3aGlsZShjLS0pZj15YShiW2NdKSxmW3VdP2QucHVzaChmKTplLnB1c2goZik7Zj1BKGEsemEoZSxkKSksZi5zZWxlY3Rvcj1hfXJldHVybiBmfSxpPWdhLnNlbGVjdD1mdW5jdGlvbihhLGIsYyxlKXt2YXIgZixpLGosayxsLG09XCJmdW5jdGlvblwiPT10eXBlb2YgYSYmYSxuPSFlJiZnKGE9bS5zZWxlY3Rvcnx8YSk7aWYoYz1jfHxbXSwxPT09bi5sZW5ndGgpe2lmKGk9blswXT1uWzBdLnNsaWNlKDApLGkubGVuZ3RoPjImJlwiSURcIj09PShqPWlbMF0pLnR5cGUmJjk9PT1iLm5vZGVUeXBlJiZwJiZkLnJlbGF0aXZlW2lbMV0udHlwZV0pe2lmKGI9KGQuZmluZC5JRChqLm1hdGNoZXNbMF0ucmVwbGFjZShfLGFhKSxiKXx8W10pWzBdLCFiKXJldHVybiBjO20mJihiPWIucGFyZW50Tm9kZSksYT1hLnNsaWNlKGkuc2hpZnQoKS52YWx1ZS5sZW5ndGgpfWY9Vi5uZWVkc0NvbnRleHQudGVzdChhKT8wOmkubGVuZ3RoO3doaWxlKGYtLSl7aWYoaj1pW2ZdLGQucmVsYXRpdmVbaz1qLnR5cGVdKWJyZWFrO2lmKChsPWQuZmluZFtrXSkmJihlPWwoai5tYXRjaGVzWzBdLnJlcGxhY2UoXyxhYSksJC50ZXN0KGlbMF0udHlwZSkmJnFhKGIucGFyZW50Tm9kZSl8fGIpKSl7aWYoaS5zcGxpY2UoZiwxKSxhPWUubGVuZ3RoJiZzYShpKSwhYSlyZXR1cm4gRy5hcHBseShjLGUpLGM7YnJlYWt9fX1yZXR1cm4obXx8aChhLG4pKShlLGIsIXAsYywhYnx8JC50ZXN0KGEpJiZxYShiLnBhcmVudE5vZGUpfHxiKSxjfSxjLnNvcnRTdGFibGU9dS5zcGxpdChcIlwiKS5zb3J0KEIpLmpvaW4oXCJcIik9PT11LGMuZGV0ZWN0RHVwbGljYXRlcz0hIWwsbSgpLGMuc29ydERldGFjaGVkPWphKGZ1bmN0aW9uKGEpe3JldHVybiAxJmEuY29tcGFyZURvY3VtZW50UG9zaXRpb24obi5jcmVhdGVFbGVtZW50KFwiZmllbGRzZXRcIikpfSksamEoZnVuY3Rpb24oYSl7cmV0dXJuIGEuaW5uZXJIVE1MPVwiPGEgaHJlZj0nIyc+PC9hPlwiLFwiI1wiPT09YS5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIil9KXx8a2EoXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsZnVuY3Rpb24oYSxiLGMpe2lmKCFjKXJldHVybiBhLmdldEF0dHJpYnV0ZShiLFwidHlwZVwiPT09Yi50b0xvd2VyQ2FzZSgpPzE6Mil9KSxjLmF0dHJpYnV0ZXMmJmphKGZ1bmN0aW9uKGEpe3JldHVybiBhLmlubmVySFRNTD1cIjxpbnB1dC8+XCIsYS5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIiksXCJcIj09PWEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKX0pfHxrYShcInZhbHVlXCIsZnVuY3Rpb24oYSxiLGMpe2lmKCFjJiZcImlucHV0XCI9PT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpcmV0dXJuIGEuZGVmYXVsdFZhbHVlfSksamEoZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWEuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIil9KXx8a2EoSixmdW5jdGlvbihhLGIsYyl7dmFyIGQ7aWYoIWMpcmV0dXJuIGFbYl09PT0hMD9iLnRvTG93ZXJDYXNlKCk6KGQ9YS5nZXRBdHRyaWJ1dGVOb2RlKGIpKSYmZC5zcGVjaWZpZWQ/ZC52YWx1ZTpudWxsfSksZ2F9KGEpO3IuZmluZD14LHIuZXhwcj14LnNlbGVjdG9ycyxyLmV4cHJbXCI6XCJdPXIuZXhwci5wc2V1ZG9zLHIudW5pcXVlU29ydD1yLnVuaXF1ZT14LnVuaXF1ZVNvcnQsci50ZXh0PXguZ2V0VGV4dCxyLmlzWE1MRG9jPXguaXNYTUwsci5jb250YWlucz14LmNvbnRhaW5zLHIuZXNjYXBlU2VsZWN0b3I9eC5lc2NhcGU7dmFyIHk9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVtdLGU9dm9pZCAwIT09Yzt3aGlsZSgoYT1hW2JdKSYmOSE9PWEubm9kZVR5cGUpaWYoMT09PWEubm9kZVR5cGUpe2lmKGUmJnIoYSkuaXMoYykpYnJlYWs7ZC5wdXNoKGEpfXJldHVybiBkfSx6PWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdO2E7YT1hLm5leHRTaWJsaW5nKTE9PT1hLm5vZGVUeXBlJiZhIT09YiYmYy5wdXNoKGEpO3JldHVybiBjfSxBPXIuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7ZnVuY3Rpb24gQihhLGIpe3JldHVybiBhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1iLnRvTG93ZXJDYXNlKCl9dmFyIEM9L148KFthLXpdW15cXC9cXDA+OlxceDIwXFx0XFxyXFxuXFxmXSopW1xceDIwXFx0XFxyXFxuXFxmXSpcXC8/Pig/OjxcXC9cXDE+fCkkL2ksRD0vXi5bXjojXFxbXFwuLF0qJC87ZnVuY3Rpb24gRShhLGIsYyl7cmV0dXJuIHIuaXNGdW5jdGlvbihiKT9yLmdyZXAoYSxmdW5jdGlvbihhLGQpe3JldHVybiEhYi5jYWxsKGEsZCxhKSE9PWN9KTpiLm5vZGVUeXBlP3IuZ3JlcChhLGZ1bmN0aW9uKGEpe3JldHVybiBhPT09YiE9PWN9KTpcInN0cmluZ1wiIT10eXBlb2YgYj9yLmdyZXAoYSxmdW5jdGlvbihhKXtyZXR1cm4gaS5jYWxsKGIsYSk+LTEhPT1jfSk6RC50ZXN0KGIpP3IuZmlsdGVyKGIsYSxjKTooYj1yLmZpbHRlcihiLGEpLHIuZ3JlcChhLGZ1bmN0aW9uKGEpe3JldHVybiBpLmNhbGwoYixhKT4tMSE9PWMmJjE9PT1hLm5vZGVUeXBlfSkpfXIuZmlsdGVyPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1iWzBdO3JldHVybiBjJiYoYT1cIjpub3QoXCIrYStcIilcIiksMT09PWIubGVuZ3RoJiYxPT09ZC5ub2RlVHlwZT9yLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGQsYSk/W2RdOltdOnIuZmluZC5tYXRjaGVzKGEsci5ncmVwKGIsZnVuY3Rpb24oYSl7cmV0dXJuIDE9PT1hLm5vZGVUeXBlfSkpfSxyLmZuLmV4dGVuZCh7ZmluZDpmdW5jdGlvbihhKXt2YXIgYixjLGQ9dGhpcy5sZW5ndGgsZT10aGlzO2lmKFwic3RyaW5nXCIhPXR5cGVvZiBhKXJldHVybiB0aGlzLnB1c2hTdGFjayhyKGEpLmZpbHRlcihmdW5jdGlvbigpe2ZvcihiPTA7YjxkO2IrKylpZihyLmNvbnRhaW5zKGVbYl0sdGhpcykpcmV0dXJuITB9KSk7Zm9yKGM9dGhpcy5wdXNoU3RhY2soW10pLGI9MDtiPGQ7YisrKXIuZmluZChhLGVbYl0sYyk7cmV0dXJuIGQ+MT9yLnVuaXF1ZVNvcnQoYyk6Y30sZmlsdGVyOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnB1c2hTdGFjayhFKHRoaXMsYXx8W10sITEpKX0sbm90OmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnB1c2hTdGFjayhFKHRoaXMsYXx8W10sITApKX0saXM6ZnVuY3Rpb24oYSl7cmV0dXJuISFFKHRoaXMsXCJzdHJpbmdcIj09dHlwZW9mIGEmJkEudGVzdChhKT9yKGEpOmF8fFtdLCExKS5sZW5ndGh9fSk7dmFyIEYsRz0vXig/OlxccyooPFtcXHdcXFddKz4pW14+XSp8IyhbXFx3LV0rKSkkLyxIPXIuZm4uaW5pdD1mdW5jdGlvbihhLGIsYyl7dmFyIGUsZjtpZighYSlyZXR1cm4gdGhpcztpZihjPWN8fEYsXCJzdHJpbmdcIj09dHlwZW9mIGEpe2lmKGU9XCI8XCI9PT1hWzBdJiZcIj5cIj09PWFbYS5sZW5ndGgtMV0mJmEubGVuZ3RoPj0zP1tudWxsLGEsbnVsbF06Ry5leGVjKGEpLCFlfHwhZVsxXSYmYilyZXR1cm4hYnx8Yi5qcXVlcnk/KGJ8fGMpLmZpbmQoYSk6dGhpcy5jb25zdHJ1Y3RvcihiKS5maW5kKGEpO2lmKGVbMV0pe2lmKGI9YiBpbnN0YW5jZW9mIHI/YlswXTpiLHIubWVyZ2UodGhpcyxyLnBhcnNlSFRNTChlWzFdLGImJmIubm9kZVR5cGU/Yi5vd25lckRvY3VtZW50fHxiOmQsITApKSxDLnRlc3QoZVsxXSkmJnIuaXNQbGFpbk9iamVjdChiKSlmb3IoZSBpbiBiKXIuaXNGdW5jdGlvbih0aGlzW2VdKT90aGlzW2VdKGJbZV0pOnRoaXMuYXR0cihlLGJbZV0pO3JldHVybiB0aGlzfXJldHVybiBmPWQuZ2V0RWxlbWVudEJ5SWQoZVsyXSksZiYmKHRoaXNbMF09Zix0aGlzLmxlbmd0aD0xKSx0aGlzfXJldHVybiBhLm5vZGVUeXBlPyh0aGlzWzBdPWEsdGhpcy5sZW5ndGg9MSx0aGlzKTpyLmlzRnVuY3Rpb24oYSk/dm9pZCAwIT09Yy5yZWFkeT9jLnJlYWR5KGEpOmEocik6ci5tYWtlQXJyYXkoYSx0aGlzKX07SC5wcm90b3R5cGU9ci5mbixGPXIoZCk7dmFyIEk9L14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sSj17Y2hpbGRyZW46ITAsY29udGVudHM6ITAsbmV4dDohMCxwcmV2OiEwfTtyLmZuLmV4dGVuZCh7aGFzOmZ1bmN0aW9uKGEpe3ZhciBiPXIoYSx0aGlzKSxjPWIubGVuZ3RoO3JldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpe2Zvcih2YXIgYT0wO2E8YzthKyspaWYoci5jb250YWlucyh0aGlzLGJbYV0pKXJldHVybiEwfSl9LGNsb3Nlc3Q6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPTAsZT10aGlzLmxlbmd0aCxmPVtdLGc9XCJzdHJpbmdcIiE9dHlwZW9mIGEmJnIoYSk7aWYoIUEudGVzdChhKSlmb3IoO2Q8ZTtkKyspZm9yKGM9dGhpc1tkXTtjJiZjIT09YjtjPWMucGFyZW50Tm9kZSlpZihjLm5vZGVUeXBlPDExJiYoZz9nLmluZGV4KGMpPi0xOjE9PT1jLm5vZGVUeXBlJiZyLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGMsYSkpKXtmLnB1c2goYyk7YnJlYWt9cmV0dXJuIHRoaXMucHVzaFN0YWNrKGYubGVuZ3RoPjE/ci51bmlxdWVTb3J0KGYpOmYpfSxpbmRleDpmdW5jdGlvbihhKXtyZXR1cm4gYT9cInN0cmluZ1wiPT10eXBlb2YgYT9pLmNhbGwocihhKSx0aGlzWzBdKTppLmNhbGwodGhpcyxhLmpxdWVyeT9hWzBdOmEpOnRoaXNbMF0mJnRoaXNbMF0ucGFyZW50Tm9kZT90aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aDotMX0sYWRkOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMucHVzaFN0YWNrKHIudW5pcXVlU29ydChyLm1lcmdlKHRoaXMuZ2V0KCkscihhLGIpKSkpfSxhZGRCYWNrOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmFkZChudWxsPT1hP3RoaXMucHJldk9iamVjdDp0aGlzLnByZXZPYmplY3QuZmlsdGVyKGEpKX19KTtmdW5jdGlvbiBLKGEsYil7d2hpbGUoKGE9YVtiXSkmJjEhPT1hLm5vZGVUeXBlKTtyZXR1cm4gYX1yLmVhY2goe3BhcmVudDpmdW5jdGlvbihhKXt2YXIgYj1hLnBhcmVudE5vZGU7cmV0dXJuIGImJjExIT09Yi5ub2RlVHlwZT9iOm51bGx9LHBhcmVudHM6ZnVuY3Rpb24oYSl7cmV0dXJuIHkoYSxcInBhcmVudE5vZGVcIil9LHBhcmVudHNVbnRpbDpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIHkoYSxcInBhcmVudE5vZGVcIixjKX0sbmV4dDpmdW5jdGlvbihhKXtyZXR1cm4gSyhhLFwibmV4dFNpYmxpbmdcIil9LHByZXY6ZnVuY3Rpb24oYSl7cmV0dXJuIEsoYSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dEFsbDpmdW5jdGlvbihhKXtyZXR1cm4geShhLFwibmV4dFNpYmxpbmdcIil9LHByZXZBbGw6ZnVuY3Rpb24oYSl7cmV0dXJuIHkoYSxcInByZXZpb3VzU2libGluZ1wiKX0sbmV4dFVudGlsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4geShhLFwibmV4dFNpYmxpbmdcIixjKX0scHJldlVudGlsOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4geShhLFwicHJldmlvdXNTaWJsaW5nXCIsYyl9LHNpYmxpbmdzOmZ1bmN0aW9uKGEpe3JldHVybiB6KChhLnBhcmVudE5vZGV8fHt9KS5maXJzdENoaWxkLGEpfSxjaGlsZHJlbjpmdW5jdGlvbihhKXtyZXR1cm4geihhLmZpcnN0Q2hpbGQpfSxjb250ZW50czpmdW5jdGlvbihhKXtyZXR1cm4gQihhLFwiaWZyYW1lXCIpP2EuY29udGVudERvY3VtZW50OihCKGEsXCJ0ZW1wbGF0ZVwiKSYmKGE9YS5jb250ZW50fHxhKSxyLm1lcmdlKFtdLGEuY2hpbGROb2RlcykpfX0sZnVuY3Rpb24oYSxiKXtyLmZuW2FdPWZ1bmN0aW9uKGMsZCl7dmFyIGU9ci5tYXAodGhpcyxiLGMpO3JldHVyblwiVW50aWxcIiE9PWEuc2xpY2UoLTUpJiYoZD1jKSxkJiZcInN0cmluZ1wiPT10eXBlb2YgZCYmKGU9ci5maWx0ZXIoZCxlKSksdGhpcy5sZW5ndGg+MSYmKEpbYV18fHIudW5pcXVlU29ydChlKSxJLnRlc3QoYSkmJmUucmV2ZXJzZSgpKSx0aGlzLnB1c2hTdGFjayhlKX19KTt2YXIgTD0vW15cXHgyMFxcdFxcclxcblxcZl0rL2c7ZnVuY3Rpb24gTShhKXt2YXIgYj17fTtyZXR1cm4gci5lYWNoKGEubWF0Y2goTCl8fFtdLGZ1bmN0aW9uKGEsYyl7YltjXT0hMH0pLGJ9ci5DYWxsYmFja3M9ZnVuY3Rpb24oYSl7YT1cInN0cmluZ1wiPT10eXBlb2YgYT9NKGEpOnIuZXh0ZW5kKHt9LGEpO3ZhciBiLGMsZCxlLGY9W10sZz1bXSxoPS0xLGk9ZnVuY3Rpb24oKXtmb3IoZT1lfHxhLm9uY2UsZD1iPSEwO2cubGVuZ3RoO2g9LTEpe2M9Zy5zaGlmdCgpO3doaWxlKCsraDxmLmxlbmd0aClmW2hdLmFwcGx5KGNbMF0sY1sxXSk9PT0hMSYmYS5zdG9wT25GYWxzZSYmKGg9Zi5sZW5ndGgsYz0hMSl9YS5tZW1vcnl8fChjPSExKSxiPSExLGUmJihmPWM/W106XCJcIil9LGo9e2FkZDpmdW5jdGlvbigpe3JldHVybiBmJiYoYyYmIWImJihoPWYubGVuZ3RoLTEsZy5wdXNoKGMpKSxmdW5jdGlvbiBkKGIpe3IuZWFjaChiLGZ1bmN0aW9uKGIsYyl7ci5pc0Z1bmN0aW9uKGMpP2EudW5pcXVlJiZqLmhhcyhjKXx8Zi5wdXNoKGMpOmMmJmMubGVuZ3RoJiZcInN0cmluZ1wiIT09ci50eXBlKGMpJiZkKGMpfSl9KGFyZ3VtZW50cyksYyYmIWImJmkoKSksdGhpc30scmVtb3ZlOmZ1bmN0aW9uKCl7cmV0dXJuIHIuZWFjaChhcmd1bWVudHMsZnVuY3Rpb24oYSxiKXt2YXIgYzt3aGlsZSgoYz1yLmluQXJyYXkoYixmLGMpKT4tMSlmLnNwbGljZShjLDEpLGM8PWgmJmgtLX0pLHRoaXN9LGhhczpmdW5jdGlvbihhKXtyZXR1cm4gYT9yLmluQXJyYXkoYSxmKT4tMTpmLmxlbmd0aD4wfSxlbXB0eTpmdW5jdGlvbigpe3JldHVybiBmJiYoZj1bXSksdGhpc30sZGlzYWJsZTpmdW5jdGlvbigpe3JldHVybiBlPWc9W10sZj1jPVwiXCIsdGhpc30sZGlzYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hZn0sbG9jazpmdW5jdGlvbigpe3JldHVybiBlPWc9W10sY3x8Ynx8KGY9Yz1cIlwiKSx0aGlzfSxsb2NrZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hIWV9LGZpcmVXaXRoOmZ1bmN0aW9uKGEsYyl7cmV0dXJuIGV8fChjPWN8fFtdLGM9W2EsYy5zbGljZT9jLnNsaWNlKCk6Y10sZy5wdXNoKGMpLGJ8fGkoKSksdGhpc30sZmlyZTpmdW5jdGlvbigpe3JldHVybiBqLmZpcmVXaXRoKHRoaXMsYXJndW1lbnRzKSx0aGlzfSxmaXJlZDpmdW5jdGlvbigpe3JldHVybiEhZH19O3JldHVybiBqfTtmdW5jdGlvbiBOKGEpe3JldHVybiBhfWZ1bmN0aW9uIE8oYSl7dGhyb3cgYX1mdW5jdGlvbiBQKGEsYixjLGQpe3ZhciBlO3RyeXthJiZyLmlzRnVuY3Rpb24oZT1hLnByb21pc2UpP2UuY2FsbChhKS5kb25lKGIpLmZhaWwoYyk6YSYmci5pc0Z1bmN0aW9uKGU9YS50aGVuKT9lLmNhbGwoYSxiLGMpOmIuYXBwbHkodm9pZCAwLFthXS5zbGljZShkKSl9Y2F0Y2goYSl7Yy5hcHBseSh2b2lkIDAsW2FdKX19ci5leHRlbmQoe0RlZmVycmVkOmZ1bmN0aW9uKGIpe3ZhciBjPVtbXCJub3RpZnlcIixcInByb2dyZXNzXCIsci5DYWxsYmFja3MoXCJtZW1vcnlcIiksci5DYWxsYmFja3MoXCJtZW1vcnlcIiksMl0sW1wicmVzb2x2ZVwiLFwiZG9uZVwiLHIuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksci5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSwwLFwicmVzb2x2ZWRcIl0sW1wicmVqZWN0XCIsXCJmYWlsXCIsci5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxyLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLDEsXCJyZWplY3RlZFwiXV0sZD1cInBlbmRpbmdcIixlPXtzdGF0ZTpmdW5jdGlvbigpe3JldHVybiBkfSxhbHdheXM6ZnVuY3Rpb24oKXtyZXR1cm4gZi5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpLHRoaXN9LFwiY2F0Y2hcIjpmdW5jdGlvbihhKXtyZXR1cm4gZS50aGVuKG51bGwsYSl9LHBpcGU6ZnVuY3Rpb24oKXt2YXIgYT1hcmd1bWVudHM7cmV0dXJuIHIuRGVmZXJyZWQoZnVuY3Rpb24oYil7ci5lYWNoKGMsZnVuY3Rpb24oYyxkKXt2YXIgZT1yLmlzRnVuY3Rpb24oYVtkWzRdXSkmJmFbZFs0XV07ZltkWzFdXShmdW5jdGlvbigpe3ZhciBhPWUmJmUuYXBwbHkodGhpcyxhcmd1bWVudHMpO2EmJnIuaXNGdW5jdGlvbihhLnByb21pc2UpP2EucHJvbWlzZSgpLnByb2dyZXNzKGIubm90aWZ5KS5kb25lKGIucmVzb2x2ZSkuZmFpbChiLnJlamVjdCk6YltkWzBdK1wiV2l0aFwiXSh0aGlzLGU/W2FdOmFyZ3VtZW50cyl9KX0pLGE9bnVsbH0pLnByb21pc2UoKX0sdGhlbjpmdW5jdGlvbihiLGQsZSl7dmFyIGY9MDtmdW5jdGlvbiBnKGIsYyxkLGUpe3JldHVybiBmdW5jdGlvbigpe3ZhciBoPXRoaXMsaT1hcmd1bWVudHMsaj1mdW5jdGlvbigpe3ZhciBhLGo7aWYoIShiPGYpKXtpZihhPWQuYXBwbHkoaCxpKSxhPT09Yy5wcm9taXNlKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiKTtqPWEmJihcIm9iamVjdFwiPT10eXBlb2YgYXx8XCJmdW5jdGlvblwiPT10eXBlb2YgYSkmJmEudGhlbixyLmlzRnVuY3Rpb24oaik/ZT9qLmNhbGwoYSxnKGYsYyxOLGUpLGcoZixjLE8sZSkpOihmKyssai5jYWxsKGEsZyhmLGMsTixlKSxnKGYsYyxPLGUpLGcoZixjLE4sYy5ub3RpZnlXaXRoKSkpOihkIT09TiYmKGg9dm9pZCAwLGk9W2FdKSwoZXx8Yy5yZXNvbHZlV2l0aCkoaCxpKSl9fSxrPWU/ajpmdW5jdGlvbigpe3RyeXtqKCl9Y2F0Y2goYSl7ci5EZWZlcnJlZC5leGNlcHRpb25Ib29rJiZyLkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soYSxrLnN0YWNrVHJhY2UpLGIrMT49ZiYmKGQhPT1PJiYoaD12b2lkIDAsaT1bYV0pLGMucmVqZWN0V2l0aChoLGkpKX19O2I/aygpOihyLkRlZmVycmVkLmdldFN0YWNrSG9vayYmKGsuc3RhY2tUcmFjZT1yLkRlZmVycmVkLmdldFN0YWNrSG9vaygpKSxhLnNldFRpbWVvdXQoaykpfX1yZXR1cm4gci5EZWZlcnJlZChmdW5jdGlvbihhKXtjWzBdWzNdLmFkZChnKDAsYSxyLmlzRnVuY3Rpb24oZSk/ZTpOLGEubm90aWZ5V2l0aCkpLGNbMV1bM10uYWRkKGcoMCxhLHIuaXNGdW5jdGlvbihiKT9iOk4pKSxjWzJdWzNdLmFkZChnKDAsYSxyLmlzRnVuY3Rpb24oZCk/ZDpPKSl9KS5wcm9taXNlKCl9LHByb21pc2U6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPWE/ci5leHRlbmQoYSxlKTplfX0sZj17fTtyZXR1cm4gci5lYWNoKGMsZnVuY3Rpb24oYSxiKXt2YXIgZz1iWzJdLGg9Yls1XTtlW2JbMV1dPWcuYWRkLGgmJmcuYWRkKGZ1bmN0aW9uKCl7ZD1ofSxjWzMtYV1bMl0uZGlzYWJsZSxjWzBdWzJdLmxvY2spLGcuYWRkKGJbM10uZmlyZSksZltiWzBdXT1mdW5jdGlvbigpe3JldHVybiBmW2JbMF0rXCJXaXRoXCJdKHRoaXM9PT1mP3ZvaWQgMDp0aGlzLGFyZ3VtZW50cyksdGhpc30sZltiWzBdK1wiV2l0aFwiXT1nLmZpcmVXaXRofSksZS5wcm9taXNlKGYpLGImJmIuY2FsbChmLGYpLGZ9LHdoZW46ZnVuY3Rpb24oYSl7dmFyIGI9YXJndW1lbnRzLmxlbmd0aCxjPWIsZD1BcnJheShjKSxlPWYuY2FsbChhcmd1bWVudHMpLGc9ci5EZWZlcnJlZCgpLGg9ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKGMpe2RbYV09dGhpcyxlW2FdPWFyZ3VtZW50cy5sZW5ndGg+MT9mLmNhbGwoYXJndW1lbnRzKTpjLC0tYnx8Zy5yZXNvbHZlV2l0aChkLGUpfX07aWYoYjw9MSYmKFAoYSxnLmRvbmUoaChjKSkucmVzb2x2ZSxnLnJlamVjdCwhYiksXCJwZW5kaW5nXCI9PT1nLnN0YXRlKCl8fHIuaXNGdW5jdGlvbihlW2NdJiZlW2NdLnRoZW4pKSlyZXR1cm4gZy50aGVuKCk7d2hpbGUoYy0tKVAoZVtjXSxoKGMpLGcucmVqZWN0KTtyZXR1cm4gZy5wcm9taXNlKCl9fSk7dmFyIFE9L14oRXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJKUVycm9yJC87ci5EZWZlcnJlZC5leGNlcHRpb25Ib29rPWZ1bmN0aW9uKGIsYyl7YS5jb25zb2xlJiZhLmNvbnNvbGUud2FybiYmYiYmUS50ZXN0KGIubmFtZSkmJmEuY29uc29sZS53YXJuKFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIrYi5tZXNzYWdlLGIuc3RhY2ssYyl9LHIucmVhZHlFeGNlcHRpb249ZnVuY3Rpb24oYil7YS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgYn0pfTt2YXIgUj1yLkRlZmVycmVkKCk7ci5mbi5yZWFkeT1mdW5jdGlvbihhKXtyZXR1cm4gUi50aGVuKGEpW1wiY2F0Y2hcIl0oZnVuY3Rpb24oYSl7ci5yZWFkeUV4Y2VwdGlvbihhKX0pLHRoaXN9LHIuZXh0ZW5kKHtpc1JlYWR5OiExLHJlYWR5V2FpdDoxLHJlYWR5OmZ1bmN0aW9uKGEpeyhhPT09ITA/LS1yLnJlYWR5V2FpdDpyLmlzUmVhZHkpfHwoci5pc1JlYWR5PSEwLGEhPT0hMCYmLS1yLnJlYWR5V2FpdD4wfHxSLnJlc29sdmVXaXRoKGQsW3JdKSl9fSksci5yZWFkeS50aGVuPVIudGhlbjtmdW5jdGlvbiBTKCl7ZC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLFMpLFxuXHRhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsUyksci5yZWFkeSgpfVwiY29tcGxldGVcIj09PWQucmVhZHlTdGF0ZXx8XCJsb2FkaW5nXCIhPT1kLnJlYWR5U3RhdGUmJiFkLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbD9hLnNldFRpbWVvdXQoci5yZWFkeSk6KGQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixTKSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsUykpO3ZhciBUPWZ1bmN0aW9uKGEsYixjLGQsZSxmLGcpe3ZhciBoPTAsaT1hLmxlbmd0aCxqPW51bGw9PWM7aWYoXCJvYmplY3RcIj09PXIudHlwZShjKSl7ZT0hMDtmb3IoaCBpbiBjKVQoYSxiLGgsY1toXSwhMCxmLGcpfWVsc2UgaWYodm9pZCAwIT09ZCYmKGU9ITAsci5pc0Z1bmN0aW9uKGQpfHwoZz0hMCksaiYmKGc/KGIuY2FsbChhLGQpLGI9bnVsbCk6KGo9YixiPWZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gai5jYWxsKHIoYSksYyl9KSksYikpZm9yKDtoPGk7aCsrKWIoYVtoXSxjLGc/ZDpkLmNhbGwoYVtoXSxoLGIoYVtoXSxjKSkpO3JldHVybiBlP2E6aj9iLmNhbGwoYSk6aT9iKGFbMF0sYyk6Zn0sVT1mdW5jdGlvbihhKXtyZXR1cm4gMT09PWEubm9kZVR5cGV8fDk9PT1hLm5vZGVUeXBlfHwhK2Eubm9kZVR5cGV9O2Z1bmN0aW9uIFYoKXt0aGlzLmV4cGFuZG89ci5leHBhbmRvK1YudWlkKyt9Vi51aWQ9MSxWLnByb3RvdHlwZT17Y2FjaGU6ZnVuY3Rpb24oYSl7dmFyIGI9YVt0aGlzLmV4cGFuZG9dO3JldHVybiBifHwoYj17fSxVKGEpJiYoYS5ub2RlVHlwZT9hW3RoaXMuZXhwYW5kb109YjpPYmplY3QuZGVmaW5lUHJvcGVydHkoYSx0aGlzLmV4cGFuZG8se3ZhbHVlOmIsY29uZmlndXJhYmxlOiEwfSkpKSxifSxzZXQ6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGU9dGhpcy5jYWNoZShhKTtpZihcInN0cmluZ1wiPT10eXBlb2YgYillW3IuY2FtZWxDYXNlKGIpXT1jO2Vsc2UgZm9yKGQgaW4gYillW3IuY2FtZWxDYXNlKGQpXT1iW2RdO3JldHVybiBlfSxnZXQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdm9pZCAwPT09Yj90aGlzLmNhY2hlKGEpOmFbdGhpcy5leHBhbmRvXSYmYVt0aGlzLmV4cGFuZG9dW3IuY2FtZWxDYXNlKGIpXX0sYWNjZXNzOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gdm9pZCAwPT09Ynx8YiYmXCJzdHJpbmdcIj09dHlwZW9mIGImJnZvaWQgMD09PWM/dGhpcy5nZXQoYSxiKToodGhpcy5zZXQoYSxiLGMpLHZvaWQgMCE9PWM/YzpiKX0scmVtb3ZlOmZ1bmN0aW9uKGEsYil7dmFyIGMsZD1hW3RoaXMuZXhwYW5kb107aWYodm9pZCAwIT09ZCl7aWYodm9pZCAwIT09Yil7QXJyYXkuaXNBcnJheShiKT9iPWIubWFwKHIuY2FtZWxDYXNlKTooYj1yLmNhbWVsQ2FzZShiKSxiPWIgaW4gZD9bYl06Yi5tYXRjaChMKXx8W10pLGM9Yi5sZW5ndGg7d2hpbGUoYy0tKWRlbGV0ZSBkW2JbY11dfSh2b2lkIDA9PT1ifHxyLmlzRW1wdHlPYmplY3QoZCkpJiYoYS5ub2RlVHlwZT9hW3RoaXMuZXhwYW5kb109dm9pZCAwOmRlbGV0ZSBhW3RoaXMuZXhwYW5kb10pfX0saGFzRGF0YTpmdW5jdGlvbihhKXt2YXIgYj1hW3RoaXMuZXhwYW5kb107cmV0dXJuIHZvaWQgMCE9PWImJiFyLmlzRW1wdHlPYmplY3QoYil9fTt2YXIgVz1uZXcgVixYPW5ldyBWLFk9L14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFo9L1tBLVpdL2c7ZnVuY3Rpb24gJChhKXtyZXR1cm5cInRydWVcIj09PWF8fFwiZmFsc2VcIiE9PWEmJihcIm51bGxcIj09PWE/bnVsbDphPT09K2ErXCJcIj8rYTpZLnRlc3QoYSk/SlNPTi5wYXJzZShhKTphKX1mdW5jdGlvbiBfKGEsYixjKXt2YXIgZDtpZih2b2lkIDA9PT1jJiYxPT09YS5ub2RlVHlwZSlpZihkPVwiZGF0YS1cIitiLnJlcGxhY2UoWixcIi0kJlwiKS50b0xvd2VyQ2FzZSgpLGM9YS5nZXRBdHRyaWJ1dGUoZCksXCJzdHJpbmdcIj09dHlwZW9mIGMpe3RyeXtjPSQoYyl9Y2F0Y2goZSl7fVguc2V0KGEsYixjKX1lbHNlIGM9dm9pZCAwO3JldHVybiBjfXIuZXh0ZW5kKHtoYXNEYXRhOmZ1bmN0aW9uKGEpe3JldHVybiBYLmhhc0RhdGEoYSl8fFcuaGFzRGF0YShhKX0sZGF0YTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIFguYWNjZXNzKGEsYixjKX0scmVtb3ZlRGF0YTpmdW5jdGlvbihhLGIpe1gucmVtb3ZlKGEsYil9LF9kYXRhOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gVy5hY2Nlc3MoYSxiLGMpfSxfcmVtb3ZlRGF0YTpmdW5jdGlvbihhLGIpe1cucmVtb3ZlKGEsYil9fSksci5mbi5leHRlbmQoe2RhdGE6ZnVuY3Rpb24oYSxiKXt2YXIgYyxkLGUsZj10aGlzWzBdLGc9ZiYmZi5hdHRyaWJ1dGVzO2lmKHZvaWQgMD09PWEpe2lmKHRoaXMubGVuZ3RoJiYoZT1YLmdldChmKSwxPT09Zi5ub2RlVHlwZSYmIVcuZ2V0KGYsXCJoYXNEYXRhQXR0cnNcIikpKXtjPWcubGVuZ3RoO3doaWxlKGMtLSlnW2NdJiYoZD1nW2NdLm5hbWUsMD09PWQuaW5kZXhPZihcImRhdGEtXCIpJiYoZD1yLmNhbWVsQ2FzZShkLnNsaWNlKDUpKSxfKGYsZCxlW2RdKSkpO1cuc2V0KGYsXCJoYXNEYXRhQXR0cnNcIiwhMCl9cmV0dXJuIGV9cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGE/dGhpcy5lYWNoKGZ1bmN0aW9uKCl7WC5zZXQodGhpcyxhKX0pOlQodGhpcyxmdW5jdGlvbihiKXt2YXIgYztpZihmJiZ2b2lkIDA9PT1iKXtpZihjPVguZ2V0KGYsYSksdm9pZCAwIT09YylyZXR1cm4gYztpZihjPV8oZixhKSx2b2lkIDAhPT1jKXJldHVybiBjfWVsc2UgdGhpcy5lYWNoKGZ1bmN0aW9uKCl7WC5zZXQodGhpcyxhLGIpfSl9LG51bGwsYixhcmd1bWVudHMubGVuZ3RoPjEsbnVsbCwhMCl9LHJlbW92ZURhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1gucmVtb3ZlKHRoaXMsYSl9KX19KSxyLmV4dGVuZCh7cXVldWU6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkO2lmKGEpcmV0dXJuIGI9KGJ8fFwiZnhcIikrXCJxdWV1ZVwiLGQ9Vy5nZXQoYSxiKSxjJiYoIWR8fEFycmF5LmlzQXJyYXkoYyk/ZD1XLmFjY2VzcyhhLGIsci5tYWtlQXJyYXkoYykpOmQucHVzaChjKSksZHx8W119LGRlcXVldWU6ZnVuY3Rpb24oYSxiKXtiPWJ8fFwiZnhcIjt2YXIgYz1yLnF1ZXVlKGEsYiksZD1jLmxlbmd0aCxlPWMuc2hpZnQoKSxmPXIuX3F1ZXVlSG9va3MoYSxiKSxnPWZ1bmN0aW9uKCl7ci5kZXF1ZXVlKGEsYil9O1wiaW5wcm9ncmVzc1wiPT09ZSYmKGU9Yy5zaGlmdCgpLGQtLSksZSYmKFwiZnhcIj09PWImJmMudW5zaGlmdChcImlucHJvZ3Jlc3NcIiksZGVsZXRlIGYuc3RvcCxlLmNhbGwoYSxnLGYpKSwhZCYmZiYmZi5lbXB0eS5maXJlKCl9LF9xdWV1ZUhvb2tzOmZ1bmN0aW9uKGEsYil7dmFyIGM9YitcInF1ZXVlSG9va3NcIjtyZXR1cm4gVy5nZXQoYSxjKXx8Vy5hY2Nlc3MoYSxjLHtlbXB0eTpyLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLmFkZChmdW5jdGlvbigpe1cucmVtb3ZlKGEsW2IrXCJxdWV1ZVwiLGNdKX0pfSl9fSksci5mbi5leHRlbmQoe3F1ZXVlOmZ1bmN0aW9uKGEsYil7dmFyIGM9MjtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgYSYmKGI9YSxhPVwiZnhcIixjLS0pLGFyZ3VtZW50cy5sZW5ndGg8Yz9yLnF1ZXVlKHRoaXNbMF0sYSk6dm9pZCAwPT09Yj90aGlzOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBjPXIucXVldWUodGhpcyxhLGIpO3IuX3F1ZXVlSG9va3ModGhpcyxhKSxcImZ4XCI9PT1hJiZcImlucHJvZ3Jlc3NcIiE9PWNbMF0mJnIuZGVxdWV1ZSh0aGlzLGEpfSl9LGRlcXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3IuZGVxdWV1ZSh0aGlzLGEpfSl9LGNsZWFyUXVldWU6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMucXVldWUoYXx8XCJmeFwiLFtdKX0scHJvbWlzZTpmdW5jdGlvbihhLGIpe3ZhciBjLGQ9MSxlPXIuRGVmZXJyZWQoKSxmPXRoaXMsZz10aGlzLmxlbmd0aCxoPWZ1bmN0aW9uKCl7LS1kfHxlLnJlc29sdmVXaXRoKGYsW2ZdKX07XCJzdHJpbmdcIiE9dHlwZW9mIGEmJihiPWEsYT12b2lkIDApLGE9YXx8XCJmeFwiO3doaWxlKGctLSljPVcuZ2V0KGZbZ10sYStcInF1ZXVlSG9va3NcIiksYyYmYy5lbXB0eSYmKGQrKyxjLmVtcHR5LmFkZChoKSk7cmV0dXJuIGgoKSxlLnByb21pc2UoYil9fSk7dmFyIGFhPS9bKy1dPyg/OlxcZCpcXC58KVxcZCsoPzpbZUVdWystXT9cXGQrfCkvLnNvdXJjZSxiYT1uZXcgUmVnRXhwKFwiXig/OihbKy1dKT18KShcIithYStcIikoW2EteiVdKikkXCIsXCJpXCIpLGNhPVtcIlRvcFwiLFwiUmlnaHRcIixcIkJvdHRvbVwiLFwiTGVmdFwiXSxkYT1mdW5jdGlvbihhLGIpe3JldHVybiBhPWJ8fGEsXCJub25lXCI9PT1hLnN0eWxlLmRpc3BsYXl8fFwiXCI9PT1hLnN0eWxlLmRpc3BsYXkmJnIuY29udGFpbnMoYS5vd25lckRvY3VtZW50LGEpJiZcIm5vbmVcIj09PXIuY3NzKGEsXCJkaXNwbGF5XCIpfSxlYT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZSxmLGc9e307Zm9yKGYgaW4gYilnW2ZdPWEuc3R5bGVbZl0sYS5zdHlsZVtmXT1iW2ZdO2U9Yy5hcHBseShhLGR8fFtdKTtmb3IoZiBpbiBiKWEuc3R5bGVbZl09Z1tmXTtyZXR1cm4gZX07ZnVuY3Rpb24gZmEoYSxiLGMsZCl7dmFyIGUsZj0xLGc9MjAsaD1kP2Z1bmN0aW9uKCl7cmV0dXJuIGQuY3VyKCl9OmZ1bmN0aW9uKCl7cmV0dXJuIHIuY3NzKGEsYixcIlwiKX0saT1oKCksaj1jJiZjWzNdfHwoci5jc3NOdW1iZXJbYl0/XCJcIjpcInB4XCIpLGs9KHIuY3NzTnVtYmVyW2JdfHxcInB4XCIhPT1qJiYraSkmJmJhLmV4ZWMoci5jc3MoYSxiKSk7aWYoayYma1szXSE9PWope2o9anx8a1szXSxjPWN8fFtdLGs9K2l8fDE7ZG8gZj1mfHxcIi41XCIsay89ZixyLnN0eWxlKGEsYixrK2opO3doaWxlKGYhPT0oZj1oKCkvaSkmJjEhPT1mJiYtLWcpfXJldHVybiBjJiYoaz0ra3x8K2l8fDAsZT1jWzFdP2srKGNbMV0rMSkqY1syXTorY1syXSxkJiYoZC51bml0PWosZC5zdGFydD1rLGQuZW5kPWUpKSxlfXZhciBnYT17fTtmdW5jdGlvbiBoYShhKXt2YXIgYixjPWEub3duZXJEb2N1bWVudCxkPWEubm9kZU5hbWUsZT1nYVtkXTtyZXR1cm4gZT9lOihiPWMuYm9keS5hcHBlbmRDaGlsZChjLmNyZWF0ZUVsZW1lbnQoZCkpLGU9ci5jc3MoYixcImRpc3BsYXlcIiksYi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpLFwibm9uZVwiPT09ZSYmKGU9XCJibG9ja1wiKSxnYVtkXT1lLGUpfWZ1bmN0aW9uIGlhKGEsYil7Zm9yKHZhciBjLGQsZT1bXSxmPTAsZz1hLmxlbmd0aDtmPGc7ZisrKWQ9YVtmXSxkLnN0eWxlJiYoYz1kLnN0eWxlLmRpc3BsYXksYj8oXCJub25lXCI9PT1jJiYoZVtmXT1XLmdldChkLFwiZGlzcGxheVwiKXx8bnVsbCxlW2ZdfHwoZC5zdHlsZS5kaXNwbGF5PVwiXCIpKSxcIlwiPT09ZC5zdHlsZS5kaXNwbGF5JiZkYShkKSYmKGVbZl09aGEoZCkpKTpcIm5vbmVcIiE9PWMmJihlW2ZdPVwibm9uZVwiLFcuc2V0KGQsXCJkaXNwbGF5XCIsYykpKTtmb3IoZj0wO2Y8ZztmKyspbnVsbCE9ZVtmXSYmKGFbZl0uc3R5bGUuZGlzcGxheT1lW2ZdKTtyZXR1cm4gYX1yLmZuLmV4dGVuZCh7c2hvdzpmdW5jdGlvbigpe3JldHVybiBpYSh0aGlzLCEwKX0saGlkZTpmdW5jdGlvbigpe3JldHVybiBpYSh0aGlzKX0sdG9nZ2xlOmZ1bmN0aW9uKGEpe3JldHVyblwiYm9vbGVhblwiPT10eXBlb2YgYT9hP3RoaXMuc2hvdygpOnRoaXMuaGlkZSgpOnRoaXMuZWFjaChmdW5jdGlvbigpe2RhKHRoaXMpP3IodGhpcykuc2hvdygpOnIodGhpcykuaGlkZSgpfSl9fSk7dmFyIGphPS9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLGthPS88KFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKykvaSxsYT0vXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pLG1hPXtvcHRpb246WzEsXCI8c2VsZWN0IG11bHRpcGxlPSdtdWx0aXBsZSc+XCIsXCI8L3NlbGVjdD5cIl0sdGhlYWQ6WzEsXCI8dGFibGU+XCIsXCI8L3RhYmxlPlwiXSxjb2w6WzIsXCI8dGFibGU+PGNvbGdyb3VwPlwiLFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSx0cjpbMixcIjx0YWJsZT48dGJvZHk+XCIsXCI8L3Rib2R5PjwvdGFibGU+XCJdLHRkOlszLFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIl0sX2RlZmF1bHQ6WzAsXCJcIixcIlwiXX07bWEub3B0Z3JvdXA9bWEub3B0aW9uLG1hLnRib2R5PW1hLnRmb290PW1hLmNvbGdyb3VwPW1hLmNhcHRpb249bWEudGhlYWQsbWEudGg9bWEudGQ7ZnVuY3Rpb24gbmEoYSxiKXt2YXIgYztyZXR1cm4gYz1cInVuZGVmaW5lZFwiIT10eXBlb2YgYS5nZXRFbGVtZW50c0J5VGFnTmFtZT9hLmdldEVsZW1lbnRzQnlUYWdOYW1lKGJ8fFwiKlwiKTpcInVuZGVmaW5lZFwiIT10eXBlb2YgYS5xdWVyeVNlbGVjdG9yQWxsP2EucXVlcnlTZWxlY3RvckFsbChifHxcIipcIik6W10sdm9pZCAwPT09Ynx8YiYmQihhLGIpP3IubWVyZ2UoW2FdLGMpOmN9ZnVuY3Rpb24gb2EoYSxiKXtmb3IodmFyIGM9MCxkPWEubGVuZ3RoO2M8ZDtjKyspVy5zZXQoYVtjXSxcImdsb2JhbEV2YWxcIiwhYnx8Vy5nZXQoYltjXSxcImdsb2JhbEV2YWxcIikpfXZhciBwYT0vPHwmIz9cXHcrOy87ZnVuY3Rpb24gcWEoYSxiLGMsZCxlKXtmb3IodmFyIGYsZyxoLGksaixrLGw9Yi5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksbT1bXSxuPTAsbz1hLmxlbmd0aDtuPG87bisrKWlmKGY9YVtuXSxmfHwwPT09ZilpZihcIm9iamVjdFwiPT09ci50eXBlKGYpKXIubWVyZ2UobSxmLm5vZGVUeXBlP1tmXTpmKTtlbHNlIGlmKHBhLnRlc3QoZikpe2c9Z3x8bC5hcHBlbmRDaGlsZChiLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLGg9KGthLmV4ZWMoZil8fFtcIlwiLFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpLGk9bWFbaF18fG1hLl9kZWZhdWx0LGcuaW5uZXJIVE1MPWlbMV0rci5odG1sUHJlZmlsdGVyKGYpK2lbMl0saz1pWzBdO3doaWxlKGstLSlnPWcubGFzdENoaWxkO3IubWVyZ2UobSxnLmNoaWxkTm9kZXMpLGc9bC5maXJzdENoaWxkLGcudGV4dENvbnRlbnQ9XCJcIn1lbHNlIG0ucHVzaChiLmNyZWF0ZVRleHROb2RlKGYpKTtsLnRleHRDb250ZW50PVwiXCIsbj0wO3doaWxlKGY9bVtuKytdKWlmKGQmJnIuaW5BcnJheShmLGQpPi0xKWUmJmUucHVzaChmKTtlbHNlIGlmKGo9ci5jb250YWlucyhmLm93bmVyRG9jdW1lbnQsZiksZz1uYShsLmFwcGVuZENoaWxkKGYpLFwic2NyaXB0XCIpLGomJm9hKGcpLGMpe2s9MDt3aGlsZShmPWdbaysrXSlsYS50ZXN0KGYudHlwZXx8XCJcIikmJmMucHVzaChmKX1yZXR1cm4gbH0hZnVuY3Rpb24oKXt2YXIgYT1kLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxiPWEuYXBwZW5kQ2hpbGQoZC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKSxjPWQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO2Muc2V0QXR0cmlidXRlKFwidHlwZVwiLFwicmFkaW9cIiksYy5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsXCJjaGVja2VkXCIpLGMuc2V0QXR0cmlidXRlKFwibmFtZVwiLFwidFwiKSxiLmFwcGVuZENoaWxkKGMpLG8uY2hlY2tDbG9uZT1iLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCxiLmlubmVySFRNTD1cIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIixvLm5vQ2xvbmVDaGVja2VkPSEhYi5jbG9uZU5vZGUoITApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWV9KCk7dmFyIHJhPWQuZG9jdW1lbnRFbGVtZW50LHNhPS9ea2V5Lyx0YT0vXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sdWE9L14oW14uXSopKD86XFwuKC4rKXwpLztmdW5jdGlvbiB2YSgpe3JldHVybiEwfWZ1bmN0aW9uIHdhKCl7cmV0dXJuITF9ZnVuY3Rpb24geGEoKXt0cnl7cmV0dXJuIGQuYWN0aXZlRWxlbWVudH1jYXRjaChhKXt9fWZ1bmN0aW9uIHlhKGEsYixjLGQsZSxmKXt2YXIgZyxoO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBiKXtcInN0cmluZ1wiIT10eXBlb2YgYyYmKGQ9ZHx8YyxjPXZvaWQgMCk7Zm9yKGggaW4gYil5YShhLGgsYyxkLGJbaF0sZik7cmV0dXJuIGF9aWYobnVsbD09ZCYmbnVsbD09ZT8oZT1jLGQ9Yz12b2lkIDApOm51bGw9PWUmJihcInN0cmluZ1wiPT10eXBlb2YgYz8oZT1kLGQ9dm9pZCAwKTooZT1kLGQ9YyxjPXZvaWQgMCkpLGU9PT0hMSllPXdhO2Vsc2UgaWYoIWUpcmV0dXJuIGE7cmV0dXJuIDE9PT1mJiYoZz1lLGU9ZnVuY3Rpb24oYSl7cmV0dXJuIHIoKS5vZmYoYSksZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGUuZ3VpZD1nLmd1aWR8fChnLmd1aWQ9ci5ndWlkKyspKSxhLmVhY2goZnVuY3Rpb24oKXtyLmV2ZW50LmFkZCh0aGlzLGIsZSxkLGMpfSl9ci5ldmVudD17Z2xvYmFsOnt9LGFkZDpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmLGcsaCxpLGosayxsLG0sbixvLHAscT1XLmdldChhKTtpZihxKXtjLmhhbmRsZXImJihmPWMsYz1mLmhhbmRsZXIsZT1mLnNlbGVjdG9yKSxlJiZyLmZpbmQubWF0Y2hlc1NlbGVjdG9yKHJhLGUpLGMuZ3VpZHx8KGMuZ3VpZD1yLmd1aWQrKyksKGk9cS5ldmVudHMpfHwoaT1xLmV2ZW50cz17fSksKGc9cS5oYW5kbGUpfHwoZz1xLmhhbmRsZT1mdW5jdGlvbihiKXtyZXR1cm5cInVuZGVmaW5lZFwiIT10eXBlb2YgciYmci5ldmVudC50cmlnZ2VyZWQhPT1iLnR5cGU/ci5ldmVudC5kaXNwYXRjaC5hcHBseShhLGFyZ3VtZW50cyk6dm9pZCAwfSksYj0oYnx8XCJcIikubWF0Y2goTCl8fFtcIlwiXSxqPWIubGVuZ3RoO3doaWxlKGotLSloPXVhLmV4ZWMoYltqXSl8fFtdLG49cD1oWzFdLG89KGhbMl18fFwiXCIpLnNwbGl0KFwiLlwiKS5zb3J0KCksbiYmKGw9ci5ldmVudC5zcGVjaWFsW25dfHx7fSxuPShlP2wuZGVsZWdhdGVUeXBlOmwuYmluZFR5cGUpfHxuLGw9ci5ldmVudC5zcGVjaWFsW25dfHx7fSxrPXIuZXh0ZW5kKHt0eXBlOm4sb3JpZ1R5cGU6cCxkYXRhOmQsaGFuZGxlcjpjLGd1aWQ6Yy5ndWlkLHNlbGVjdG9yOmUsbmVlZHNDb250ZXh0OmUmJnIuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdChlKSxuYW1lc3BhY2U6by5qb2luKFwiLlwiKX0sZiksKG09aVtuXSl8fChtPWlbbl09W10sbS5kZWxlZ2F0ZUNvdW50PTAsbC5zZXR1cCYmbC5zZXR1cC5jYWxsKGEsZCxvLGcpIT09ITF8fGEuYWRkRXZlbnRMaXN0ZW5lciYmYS5hZGRFdmVudExpc3RlbmVyKG4sZykpLGwuYWRkJiYobC5hZGQuY2FsbChhLGspLGsuaGFuZGxlci5ndWlkfHwoay5oYW5kbGVyLmd1aWQ9Yy5ndWlkKSksZT9tLnNwbGljZShtLmRlbGVnYXRlQ291bnQrKywwLGspOm0ucHVzaChrKSxyLmV2ZW50Lmdsb2JhbFtuXT0hMCl9fSxyZW1vdmU6ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZixnLGgsaSxqLGssbCxtLG4sbyxwLHE9Vy5oYXNEYXRhKGEpJiZXLmdldChhKTtpZihxJiYoaT1xLmV2ZW50cykpe2I9KGJ8fFwiXCIpLm1hdGNoKEwpfHxbXCJcIl0saj1iLmxlbmd0aDt3aGlsZShqLS0paWYoaD11YS5leGVjKGJbal0pfHxbXSxuPXA9aFsxXSxvPShoWzJdfHxcIlwiKS5zcGxpdChcIi5cIikuc29ydCgpLG4pe2w9ci5ldmVudC5zcGVjaWFsW25dfHx7fSxuPShkP2wuZGVsZWdhdGVUeXBlOmwuYmluZFR5cGUpfHxuLG09aVtuXXx8W10saD1oWzJdJiZuZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIrby5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikrXCIoXFxcXC58JClcIiksZz1mPW0ubGVuZ3RoO3doaWxlKGYtLSlrPW1bZl0sIWUmJnAhPT1rLm9yaWdUeXBlfHxjJiZjLmd1aWQhPT1rLmd1aWR8fGgmJiFoLnRlc3Qoay5uYW1lc3BhY2UpfHxkJiZkIT09ay5zZWxlY3RvciYmKFwiKipcIiE9PWR8fCFrLnNlbGVjdG9yKXx8KG0uc3BsaWNlKGYsMSksay5zZWxlY3RvciYmbS5kZWxlZ2F0ZUNvdW50LS0sbC5yZW1vdmUmJmwucmVtb3ZlLmNhbGwoYSxrKSk7ZyYmIW0ubGVuZ3RoJiYobC50ZWFyZG93biYmbC50ZWFyZG93bi5jYWxsKGEsbyxxLmhhbmRsZSkhPT0hMXx8ci5yZW1vdmVFdmVudChhLG4scS5oYW5kbGUpLGRlbGV0ZSBpW25dKX1lbHNlIGZvcihuIGluIGkpci5ldmVudC5yZW1vdmUoYSxuK2Jbal0sYyxkLCEwKTtyLmlzRW1wdHlPYmplY3QoaSkmJlcucmVtb3ZlKGEsXCJoYW5kbGUgZXZlbnRzXCIpfX0sZGlzcGF0Y2g6ZnVuY3Rpb24oYSl7dmFyIGI9ci5ldmVudC5maXgoYSksYyxkLGUsZixnLGgsaT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksaj0oVy5nZXQodGhpcyxcImV2ZW50c1wiKXx8e30pW2IudHlwZV18fFtdLGs9ci5ldmVudC5zcGVjaWFsW2IudHlwZV18fHt9O2ZvcihpWzBdPWIsYz0xO2M8YXJndW1lbnRzLmxlbmd0aDtjKyspaVtjXT1hcmd1bWVudHNbY107aWYoYi5kZWxlZ2F0ZVRhcmdldD10aGlzLCFrLnByZURpc3BhdGNofHxrLnByZURpc3BhdGNoLmNhbGwodGhpcyxiKSE9PSExKXtoPXIuZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLGIsaiksYz0wO3doaWxlKChmPWhbYysrXSkmJiFiLmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpe2IuY3VycmVudFRhcmdldD1mLmVsZW0sZD0wO3doaWxlKChnPWYuaGFuZGxlcnNbZCsrXSkmJiFiLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpYi5ybmFtZXNwYWNlJiYhYi5ybmFtZXNwYWNlLnRlc3QoZy5uYW1lc3BhY2UpfHwoYi5oYW5kbGVPYmo9ZyxiLmRhdGE9Zy5kYXRhLGU9KChyLmV2ZW50LnNwZWNpYWxbZy5vcmlnVHlwZV18fHt9KS5oYW5kbGV8fGcuaGFuZGxlcikuYXBwbHkoZi5lbGVtLGkpLHZvaWQgMCE9PWUmJihiLnJlc3VsdD1lKT09PSExJiYoYi5wcmV2ZW50RGVmYXVsdCgpLGIuc3RvcFByb3BhZ2F0aW9uKCkpKX1yZXR1cm4gay5wb3N0RGlzcGF0Y2gmJmsucG9zdERpc3BhdGNoLmNhbGwodGhpcyxiKSxiLnJlc3VsdH19LGhhbmRsZXJzOmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlLGYsZyxoPVtdLGk9Yi5kZWxlZ2F0ZUNvdW50LGo9YS50YXJnZXQ7aWYoaSYmai5ub2RlVHlwZSYmIShcImNsaWNrXCI9PT1hLnR5cGUmJmEuYnV0dG9uPj0xKSlmb3IoO2ohPT10aGlzO2o9ai5wYXJlbnROb2RlfHx0aGlzKWlmKDE9PT1qLm5vZGVUeXBlJiYoXCJjbGlja1wiIT09YS50eXBlfHxqLmRpc2FibGVkIT09ITApKXtmb3IoZj1bXSxnPXt9LGM9MDtjPGk7YysrKWQ9YltjXSxlPWQuc2VsZWN0b3IrXCIgXCIsdm9pZCAwPT09Z1tlXSYmKGdbZV09ZC5uZWVkc0NvbnRleHQ/cihlLHRoaXMpLmluZGV4KGopPi0xOnIuZmluZChlLHRoaXMsbnVsbCxbal0pLmxlbmd0aCksZ1tlXSYmZi5wdXNoKGQpO2YubGVuZ3RoJiZoLnB1c2goe2VsZW06aixoYW5kbGVyczpmfSl9cmV0dXJuIGo9dGhpcyxpPGIubGVuZ3RoJiZoLnB1c2goe2VsZW06aixoYW5kbGVyczpiLnNsaWNlKGkpfSksaH0sYWRkUHJvcDpmdW5jdGlvbihhLGIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLkV2ZW50LnByb3RvdHlwZSxhLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ci5pc0Z1bmN0aW9uKGIpP2Z1bmN0aW9uKCl7aWYodGhpcy5vcmlnaW5hbEV2ZW50KXJldHVybiBiKHRoaXMub3JpZ2luYWxFdmVudCl9OmZ1bmN0aW9uKCl7aWYodGhpcy5vcmlnaW5hbEV2ZW50KXJldHVybiB0aGlzLm9yaWdpbmFsRXZlbnRbYV19LHNldDpmdW5jdGlvbihiKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxhLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpifSl9fSl9LGZpeDpmdW5jdGlvbihhKXtyZXR1cm4gYVtyLmV4cGFuZG9dP2E6bmV3IHIuRXZlbnQoYSl9LHNwZWNpYWw6e2xvYWQ6e25vQnViYmxlOiEwfSxmb2N1czp7dHJpZ2dlcjpmdW5jdGlvbigpe2lmKHRoaXMhPT14YSgpJiZ0aGlzLmZvY3VzKXJldHVybiB0aGlzLmZvY3VzKCksITF9LGRlbGVnYXRlVHlwZTpcImZvY3VzaW5cIn0sYmx1cjp7dHJpZ2dlcjpmdW5jdGlvbigpe2lmKHRoaXM9PT14YSgpJiZ0aGlzLmJsdXIpcmV0dXJuIHRoaXMuYmx1cigpLCExfSxkZWxlZ2F0ZVR5cGU6XCJmb2N1c291dFwifSxjbGljazp7dHJpZ2dlcjpmdW5jdGlvbigpe2lmKFwiY2hlY2tib3hcIj09PXRoaXMudHlwZSYmdGhpcy5jbGljayYmQih0aGlzLFwiaW5wdXRcIikpcmV0dXJuIHRoaXMuY2xpY2soKSwhMX0sX2RlZmF1bHQ6ZnVuY3Rpb24oYSl7cmV0dXJuIEIoYS50YXJnZXQsXCJhXCIpfX0sYmVmb3JldW5sb2FkOntwb3N0RGlzcGF0Y2g6ZnVuY3Rpb24oYSl7dm9pZCAwIT09YS5yZXN1bHQmJmEub3JpZ2luYWxFdmVudCYmKGEub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZT1hLnJlc3VsdCl9fX19LHIucmVtb3ZlRXZlbnQ9ZnVuY3Rpb24oYSxiLGMpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lciYmYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsYyl9LHIuRXZlbnQ9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIHIuRXZlbnQ/KGEmJmEudHlwZT8odGhpcy5vcmlnaW5hbEV2ZW50PWEsdGhpcy50eXBlPWEudHlwZSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1hLmRlZmF1bHRQcmV2ZW50ZWR8fHZvaWQgMD09PWEuZGVmYXVsdFByZXZlbnRlZCYmYS5yZXR1cm5WYWx1ZT09PSExP3ZhOndhLHRoaXMudGFyZ2V0PWEudGFyZ2V0JiYzPT09YS50YXJnZXQubm9kZVR5cGU/YS50YXJnZXQucGFyZW50Tm9kZTphLnRhcmdldCx0aGlzLmN1cnJlbnRUYXJnZXQ9YS5jdXJyZW50VGFyZ2V0LHRoaXMucmVsYXRlZFRhcmdldD1hLnJlbGF0ZWRUYXJnZXQpOnRoaXMudHlwZT1hLGImJnIuZXh0ZW5kKHRoaXMsYiksdGhpcy50aW1lU3RhbXA9YSYmYS50aW1lU3RhbXB8fHIubm93KCksdm9pZCh0aGlzW3IuZXhwYW5kb109ITApKTpuZXcgci5FdmVudChhLGIpfSxyLkV2ZW50LnByb3RvdHlwZT17Y29uc3RydWN0b3I6ci5FdmVudCxpc0RlZmF1bHRQcmV2ZW50ZWQ6d2EsaXNQcm9wYWdhdGlvblN0b3BwZWQ6d2EsaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6d2EsaXNTaW11bGF0ZWQ6ITEscHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9dmEsYSYmIXRoaXMuaXNTaW11bGF0ZWQmJmEucHJldmVudERlZmF1bHQoKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9dmEsYSYmIXRoaXMuaXNTaW11bGF0ZWQmJmEuc3RvcFByb3BhZ2F0aW9uKCl9LHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkPXZhLGEmJiF0aGlzLmlzU2ltdWxhdGVkJiZhLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLHRoaXMuc3RvcFByb3BhZ2F0aW9uKCl9fSxyLmVhY2goe2FsdEtleTohMCxidWJibGVzOiEwLGNhbmNlbGFibGU6ITAsY2hhbmdlZFRvdWNoZXM6ITAsY3RybEtleTohMCxkZXRhaWw6ITAsZXZlbnRQaGFzZTohMCxtZXRhS2V5OiEwLHBhZ2VYOiEwLHBhZ2VZOiEwLHNoaWZ0S2V5OiEwLHZpZXc6ITAsXCJjaGFyXCI6ITAsY2hhckNvZGU6ITAsa2V5OiEwLGtleUNvZGU6ITAsYnV0dG9uOiEwLGJ1dHRvbnM6ITAsY2xpZW50WDohMCxjbGllbnRZOiEwLG9mZnNldFg6ITAsb2Zmc2V0WTohMCxwb2ludGVySWQ6ITAscG9pbnRlclR5cGU6ITAsc2NyZWVuWDohMCxzY3JlZW5ZOiEwLHRhcmdldFRvdWNoZXM6ITAsdG9FbGVtZW50OiEwLHRvdWNoZXM6ITAsd2hpY2g6ZnVuY3Rpb24oYSl7dmFyIGI9YS5idXR0b247cmV0dXJuIG51bGw9PWEud2hpY2gmJnNhLnRlc3QoYS50eXBlKT9udWxsIT1hLmNoYXJDb2RlP2EuY2hhckNvZGU6YS5rZXlDb2RlOiFhLndoaWNoJiZ2b2lkIDAhPT1iJiZ0YS50ZXN0KGEudHlwZSk/MSZiPzE6MiZiPzM6NCZiPzI6MDphLndoaWNofX0sci5ldmVudC5hZGRQcm9wKSxyLmVhY2goe21vdXNlZW50ZXI6XCJtb3VzZW92ZXJcIixtb3VzZWxlYXZlOlwibW91c2VvdXRcIixwb2ludGVyZW50ZXI6XCJwb2ludGVyb3ZlclwiLHBvaW50ZXJsZWF2ZTpcInBvaW50ZXJvdXRcIn0sZnVuY3Rpb24oYSxiKXtyLmV2ZW50LnNwZWNpYWxbYV09e2RlbGVnYXRlVHlwZTpiLGJpbmRUeXBlOmIsaGFuZGxlOmZ1bmN0aW9uKGEpe3ZhciBjLGQ9dGhpcyxlPWEucmVsYXRlZFRhcmdldCxmPWEuaGFuZGxlT2JqO3JldHVybiBlJiYoZT09PWR8fHIuY29udGFpbnMoZCxlKSl8fChhLnR5cGU9Zi5vcmlnVHlwZSxjPWYuaGFuZGxlci5hcHBseSh0aGlzLGFyZ3VtZW50cyksYS50eXBlPWIpLGN9fX0pLHIuZm4uZXh0ZW5kKHtvbjpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4geWEodGhpcyxhLGIsYyxkKX0sb25lOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB5YSh0aGlzLGEsYixjLGQsMSl9LG9mZjpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZTtpZihhJiZhLnByZXZlbnREZWZhdWx0JiZhLmhhbmRsZU9iailyZXR1cm4gZD1hLmhhbmRsZU9iaixyKGEuZGVsZWdhdGVUYXJnZXQpLm9mZihkLm5hbWVzcGFjZT9kLm9yaWdUeXBlK1wiLlwiK2QubmFtZXNwYWNlOmQub3JpZ1R5cGUsZC5zZWxlY3RvcixkLmhhbmRsZXIpLHRoaXM7aWYoXCJvYmplY3RcIj09dHlwZW9mIGEpe2ZvcihlIGluIGEpdGhpcy5vZmYoZSxiLGFbZV0pO3JldHVybiB0aGlzfXJldHVybiBiIT09ITEmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGJ8fChjPWIsYj12b2lkIDApLGM9PT0hMSYmKGM9d2EpLHRoaXMuZWFjaChmdW5jdGlvbigpe3IuZXZlbnQucmVtb3ZlKHRoaXMsYSxjLGIpfSl9fSk7dmFyIHphPS88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFthLXpdW15cXC9cXDA+XFx4MjBcXHRcXHJcXG5cXGZdKilbXj5dKilcXC8+L2dpLEFhPS88c2NyaXB0fDxzdHlsZXw8bGluay9pLEJhPS9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksQ2E9L150cnVlXFwvKC4qKS8sRGE9L15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO2Z1bmN0aW9uIEVhKGEsYil7cmV0dXJuIEIoYSxcInRhYmxlXCIpJiZCKDExIT09Yi5ub2RlVHlwZT9iOmIuZmlyc3RDaGlsZCxcInRyXCIpP3IoXCI+dGJvZHlcIixhKVswXXx8YTphfWZ1bmN0aW9uIEZhKGEpe3JldHVybiBhLnR5cGU9KG51bGwhPT1hLmdldEF0dHJpYnV0ZShcInR5cGVcIikpK1wiL1wiK2EudHlwZSxhfWZ1bmN0aW9uIEdhKGEpe3ZhciBiPUNhLmV4ZWMoYS50eXBlKTtyZXR1cm4gYj9hLnR5cGU9YlsxXTphLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIiksYX1mdW5jdGlvbiBIYShhLGIpe3ZhciBjLGQsZSxmLGcsaCxpLGo7aWYoMT09PWIubm9kZVR5cGUpe2lmKFcuaGFzRGF0YShhKSYmKGY9Vy5hY2Nlc3MoYSksZz1XLnNldChiLGYpLGo9Zi5ldmVudHMpKXtkZWxldGUgZy5oYW5kbGUsZy5ldmVudHM9e307Zm9yKGUgaW4gailmb3IoYz0wLGQ9altlXS5sZW5ndGg7YzxkO2MrKylyLmV2ZW50LmFkZChiLGUsaltlXVtjXSl9WC5oYXNEYXRhKGEpJiYoaD1YLmFjY2VzcyhhKSxpPXIuZXh0ZW5kKHt9LGgpLFguc2V0KGIsaSkpfX1mdW5jdGlvbiBJYShhLGIpe3ZhciBjPWIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcImlucHV0XCI9PT1jJiZqYS50ZXN0KGEudHlwZSk/Yi5jaGVja2VkPWEuY2hlY2tlZDpcImlucHV0XCIhPT1jJiZcInRleHRhcmVhXCIhPT1jfHwoYi5kZWZhdWx0VmFsdWU9YS5kZWZhdWx0VmFsdWUpfWZ1bmN0aW9uIEphKGEsYixjLGQpe2I9Zy5hcHBseShbXSxiKTt2YXIgZSxmLGgsaSxqLGssbD0wLG09YS5sZW5ndGgsbj1tLTEscT1iWzBdLHM9ci5pc0Z1bmN0aW9uKHEpO2lmKHN8fG0+MSYmXCJzdHJpbmdcIj09dHlwZW9mIHEmJiFvLmNoZWNrQ2xvbmUmJkJhLnRlc3QocSkpcmV0dXJuIGEuZWFjaChmdW5jdGlvbihlKXt2YXIgZj1hLmVxKGUpO3MmJihiWzBdPXEuY2FsbCh0aGlzLGUsZi5odG1sKCkpKSxKYShmLGIsYyxkKX0pO2lmKG0mJihlPXFhKGIsYVswXS5vd25lckRvY3VtZW50LCExLGEsZCksZj1lLmZpcnN0Q2hpbGQsMT09PWUuY2hpbGROb2Rlcy5sZW5ndGgmJihlPWYpLGZ8fGQpKXtmb3IoaD1yLm1hcChuYShlLFwic2NyaXB0XCIpLEZhKSxpPWgubGVuZ3RoO2w8bTtsKyspaj1lLGwhPT1uJiYoaj1yLmNsb25lKGosITAsITApLGkmJnIubWVyZ2UoaCxuYShqLFwic2NyaXB0XCIpKSksYy5jYWxsKGFbbF0saixsKTtpZihpKWZvcihrPWhbaC5sZW5ndGgtMV0ub3duZXJEb2N1bWVudCxyLm1hcChoLEdhKSxsPTA7bDxpO2wrKylqPWhbbF0sbGEudGVzdChqLnR5cGV8fFwiXCIpJiYhVy5hY2Nlc3MoaixcImdsb2JhbEV2YWxcIikmJnIuY29udGFpbnMoayxqKSYmKGouc3JjP3IuX2V2YWxVcmwmJnIuX2V2YWxVcmwoai5zcmMpOnAoai50ZXh0Q29udGVudC5yZXBsYWNlKERhLFwiXCIpLGspKX1yZXR1cm4gYX1mdW5jdGlvbiBLYShhLGIsYyl7Zm9yKHZhciBkLGU9Yj9yLmZpbHRlcihiLGEpOmEsZj0wO251bGwhPShkPWVbZl0pO2YrKyljfHwxIT09ZC5ub2RlVHlwZXx8ci5jbGVhbkRhdGEobmEoZCkpLGQucGFyZW50Tm9kZSYmKGMmJnIuY29udGFpbnMoZC5vd25lckRvY3VtZW50LGQpJiZvYShuYShkLFwic2NyaXB0XCIpKSxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCkpO3JldHVybiBhfXIuZXh0ZW5kKHtodG1sUHJlZmlsdGVyOmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlcGxhY2UoemEsXCI8JDE+PC8kMj5cIil9LGNsb25lOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGYsZyxoPWEuY2xvbmVOb2RlKCEwKSxpPXIuY29udGFpbnMoYS5vd25lckRvY3VtZW50LGEpO2lmKCEoby5ub0Nsb25lQ2hlY2tlZHx8MSE9PWEubm9kZVR5cGUmJjExIT09YS5ub2RlVHlwZXx8ci5pc1hNTERvYyhhKSkpZm9yKGc9bmEoaCksZj1uYShhKSxkPTAsZT1mLmxlbmd0aDtkPGU7ZCsrKUlhKGZbZF0sZ1tkXSk7aWYoYilpZihjKWZvcihmPWZ8fG5hKGEpLGc9Z3x8bmEoaCksZD0wLGU9Zi5sZW5ndGg7ZDxlO2QrKylIYShmW2RdLGdbZF0pO2Vsc2UgSGEoYSxoKTtyZXR1cm4gZz1uYShoLFwic2NyaXB0XCIpLGcubGVuZ3RoPjAmJm9hKGcsIWkmJm5hKGEsXCJzY3JpcHRcIikpLGh9LGNsZWFuRGF0YTpmdW5jdGlvbihhKXtmb3IodmFyIGIsYyxkLGU9ci5ldmVudC5zcGVjaWFsLGY9MDt2b2lkIDAhPT0oYz1hW2ZdKTtmKyspaWYoVShjKSl7aWYoYj1jW1cuZXhwYW5kb10pe2lmKGIuZXZlbnRzKWZvcihkIGluIGIuZXZlbnRzKWVbZF0/ci5ldmVudC5yZW1vdmUoYyxkKTpyLnJlbW92ZUV2ZW50KGMsZCxiLmhhbmRsZSk7Y1tXLmV4cGFuZG9dPXZvaWQgMH1jW1guZXhwYW5kb10mJihjW1guZXhwYW5kb109dm9pZCAwKX19fSksci5mbi5leHRlbmQoe2RldGFjaDpmdW5jdGlvbihhKXtyZXR1cm4gS2EodGhpcyxhLCEwKX0scmVtb3ZlOmZ1bmN0aW9uKGEpe3JldHVybiBLYSh0aGlzLGEpfSx0ZXh0OmZ1bmN0aW9uKGEpe3JldHVybiBUKHRoaXMsZnVuY3Rpb24oYSl7cmV0dXJuIHZvaWQgMD09PWE/ci50ZXh0KHRoaXMpOnRoaXMuZW1wdHkoKS5lYWNoKGZ1bmN0aW9uKCl7MSE9PXRoaXMubm9kZVR5cGUmJjExIT09dGhpcy5ub2RlVHlwZSYmOSE9PXRoaXMubm9kZVR5cGV8fCh0aGlzLnRleHRDb250ZW50PWEpfSl9LG51bGwsYSxhcmd1bWVudHMubGVuZ3RoKX0sYXBwZW5kOmZ1bmN0aW9uKCl7cmV0dXJuIEphKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGEpe2lmKDE9PT10aGlzLm5vZGVUeXBlfHwxMT09PXRoaXMubm9kZVR5cGV8fDk9PT10aGlzLm5vZGVUeXBlKXt2YXIgYj1FYSh0aGlzLGEpO2IuYXBwZW5kQ2hpbGQoYSl9fSl9LHByZXBlbmQ6ZnVuY3Rpb24oKXtyZXR1cm4gSmEodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oYSl7aWYoMT09PXRoaXMubm9kZVR5cGV8fDExPT09dGhpcy5ub2RlVHlwZXx8OT09PXRoaXMubm9kZVR5cGUpe3ZhciBiPUVhKHRoaXMsYSk7Yi5pbnNlcnRCZWZvcmUoYSxiLmZpcnN0Q2hpbGQpfX0pfSxiZWZvcmU6ZnVuY3Rpb24oKXtyZXR1cm4gSmEodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oYSl7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsdGhpcyl9KX0sYWZ0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gSmEodGhpcyxhcmd1bWVudHMsZnVuY3Rpb24oYSl7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGEsdGhpcy5uZXh0U2libGluZyl9KX0sZW1wdHk6ZnVuY3Rpb24oKXtmb3IodmFyIGEsYj0wO251bGwhPShhPXRoaXNbYl0pO2IrKykxPT09YS5ub2RlVHlwZSYmKHIuY2xlYW5EYXRhKG5hKGEsITEpKSxhLnRleHRDb250ZW50PVwiXCIpO3JldHVybiB0aGlzfSxjbG9uZTpmdW5jdGlvbihhLGIpe3JldHVybiBhPW51bGwhPWEmJmEsYj1udWxsPT1iP2E6Yix0aGlzLm1hcChmdW5jdGlvbigpe3JldHVybiByLmNsb25lKHRoaXMsYSxiKX0pfSxodG1sOmZ1bmN0aW9uKGEpe3JldHVybiBUKHRoaXMsZnVuY3Rpb24oYSl7dmFyIGI9dGhpc1swXXx8e30sYz0wLGQ9dGhpcy5sZW5ndGg7aWYodm9pZCAwPT09YSYmMT09PWIubm9kZVR5cGUpcmV0dXJuIGIuaW5uZXJIVE1MO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhJiYhQWEudGVzdChhKSYmIW1hWyhrYS5leGVjKGEpfHxbXCJcIixcIlwiXSlbMV0udG9Mb3dlckNhc2UoKV0pe2E9ci5odG1sUHJlZmlsdGVyKGEpO3RyeXtmb3IoO2M8ZDtjKyspYj10aGlzW2NdfHx7fSwxPT09Yi5ub2RlVHlwZSYmKHIuY2xlYW5EYXRhKG5hKGIsITEpKSxiLmlubmVySFRNTD1hKTtiPTB9Y2F0Y2goZSl7fX1iJiZ0aGlzLmVtcHR5KCkuYXBwZW5kKGEpfSxudWxsLGEsYXJndW1lbnRzLmxlbmd0aCl9LHJlcGxhY2VXaXRoOmZ1bmN0aW9uKCl7dmFyIGE9W107cmV0dXJuIEphKHRoaXMsYXJndW1lbnRzLGZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMucGFyZW50Tm9kZTtyLmluQXJyYXkodGhpcyxhKTwwJiYoci5jbGVhbkRhdGEobmEodGhpcykpLGMmJmMucmVwbGFjZUNoaWxkKGIsdGhpcykpfSxhKX19KSxyLmVhY2goe2FwcGVuZFRvOlwiYXBwZW5kXCIscHJlcGVuZFRvOlwicHJlcGVuZFwiLGluc2VydEJlZm9yZTpcImJlZm9yZVwiLGluc2VydEFmdGVyOlwiYWZ0ZXJcIixyZXBsYWNlQWxsOlwicmVwbGFjZVdpdGhcIn0sZnVuY3Rpb24oYSxiKXtyLmZuW2FdPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYyxkPVtdLGU9cihhKSxmPWUubGVuZ3RoLTEsZz0wO2c8PWY7ZysrKWM9Zz09PWY/dGhpczp0aGlzLmNsb25lKCEwKSxyKGVbZ10pW2JdKGMpLGguYXBwbHkoZCxjLmdldCgpKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soZCl9fSk7dmFyIExhPS9ebWFyZ2luLyxNYT1uZXcgUmVnRXhwKFwiXihcIithYStcIikoPyFweClbYS16JV0rJFwiLFwiaVwiKSxOYT1mdW5jdGlvbihiKXt2YXIgYz1iLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7cmV0dXJuIGMmJmMub3BlbmVyfHwoYz1hKSxjLmdldENvbXB1dGVkU3R5bGUoYil9OyFmdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXtpZihpKXtpLnN0eWxlLmNzc1RleHQ9XCJib3gtc2l6aW5nOmJvcmRlci1ib3g7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jazttYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O3RvcDoxJTt3aWR0aDo1MCVcIixpLmlubmVySFRNTD1cIlwiLHJhLmFwcGVuZENoaWxkKGgpO3ZhciBiPWEuZ2V0Q29tcHV0ZWRTdHlsZShpKTtjPVwiMSVcIiE9PWIudG9wLGc9XCIycHhcIj09PWIubWFyZ2luTGVmdCxlPVwiNHB4XCI9PT1iLndpZHRoLGkuc3R5bGUubWFyZ2luUmlnaHQ9XCI1MCVcIixmPVwiNHB4XCI9PT1iLm1hcmdpblJpZ2h0LHJhLnJlbW92ZUNoaWxkKGgpLGk9bnVsbH19dmFyIGMsZSxmLGcsaD1kLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksaT1kLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7aS5zdHlsZSYmKGkuc3R5bGUuYmFja2dyb3VuZENsaXA9XCJjb250ZW50LWJveFwiLGkuY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcD1cIlwiLG8uY2xlYXJDbG9uZVN0eWxlPVwiY29udGVudC1ib3hcIj09PWkuc3R5bGUuYmFja2dyb3VuZENsaXAsaC5zdHlsZS5jc3NUZXh0PVwiYm9yZGVyOjA7d2lkdGg6OHB4O2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDtwYWRkaW5nOjA7bWFyZ2luLXRvcDoxcHg7cG9zaXRpb246YWJzb2x1dGVcIixoLmFwcGVuZENoaWxkKGkpLHIuZXh0ZW5kKG8se3BpeGVsUG9zaXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gYigpLGN9LGJveFNpemluZ1JlbGlhYmxlOmZ1bmN0aW9uKCl7cmV0dXJuIGIoKSxlfSxwaXhlbE1hcmdpblJpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIGIoKSxmfSxyZWxpYWJsZU1hcmdpbkxlZnQ6ZnVuY3Rpb24oKXtyZXR1cm4gYigpLGd9fSkpfSgpO2Z1bmN0aW9uIE9hKGEsYixjKXt2YXIgZCxlLGYsZyxoPWEuc3R5bGU7cmV0dXJuIGM9Y3x8TmEoYSksYyYmKGc9Yy5nZXRQcm9wZXJ0eVZhbHVlKGIpfHxjW2JdLFwiXCIhPT1nfHxyLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCxhKXx8KGc9ci5zdHlsZShhLGIpKSwhby5waXhlbE1hcmdpblJpZ2h0KCkmJk1hLnRlc3QoZykmJkxhLnRlc3QoYikmJihkPWgud2lkdGgsZT1oLm1pbldpZHRoLGY9aC5tYXhXaWR0aCxoLm1pbldpZHRoPWgubWF4V2lkdGg9aC53aWR0aD1nLGc9Yy53aWR0aCxoLndpZHRoPWQsaC5taW5XaWR0aD1lLGgubWF4V2lkdGg9ZikpLHZvaWQgMCE9PWc/ZytcIlwiOmd9ZnVuY3Rpb24gUGEoYSxiKXtyZXR1cm57Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGEoKT92b2lkIGRlbGV0ZSB0aGlzLmdldDoodGhpcy5nZXQ9YikuYXBwbHkodGhpcyxhcmd1bWVudHMpfX19dmFyIFFhPS9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxSYT0vXi0tLyxTYT17cG9zaXRpb246XCJhYnNvbHV0ZVwiLHZpc2liaWxpdHk6XCJoaWRkZW5cIixkaXNwbGF5OlwiYmxvY2tcIn0sVGE9e2xldHRlclNwYWNpbmc6XCIwXCIsZm9udFdlaWdodDpcIjQwMFwifSxVYT1bXCJXZWJraXRcIixcIk1velwiLFwibXNcIl0sVmE9ZC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlO2Z1bmN0aW9uIFdhKGEpe2lmKGEgaW4gVmEpcmV0dXJuIGE7dmFyIGI9YVswXS50b1VwcGVyQ2FzZSgpK2Euc2xpY2UoMSksYz1VYS5sZW5ndGg7d2hpbGUoYy0tKWlmKGE9VWFbY10rYixhIGluIFZhKXJldHVybiBhfWZ1bmN0aW9uIFhhKGEpe3ZhciBiPXIuY3NzUHJvcHNbYV07cmV0dXJuIGJ8fChiPXIuY3NzUHJvcHNbYV09V2EoYSl8fGEpLGJ9ZnVuY3Rpb24gWWEoYSxiLGMpe3ZhciBkPWJhLmV4ZWMoYik7cmV0dXJuIGQ/TWF0aC5tYXgoMCxkWzJdLShjfHwwKSkrKGRbM118fFwicHhcIik6Yn1mdW5jdGlvbiBaYShhLGIsYyxkLGUpe3ZhciBmLGc9MDtmb3IoZj1jPT09KGQ/XCJib3JkZXJcIjpcImNvbnRlbnRcIik/NDpcIndpZHRoXCI9PT1iPzE6MDtmPDQ7Zis9MilcIm1hcmdpblwiPT09YyYmKGcrPXIuY3NzKGEsYytjYVtmXSwhMCxlKSksZD8oXCJjb250ZW50XCI9PT1jJiYoZy09ci5jc3MoYSxcInBhZGRpbmdcIitjYVtmXSwhMCxlKSksXCJtYXJnaW5cIiE9PWMmJihnLT1yLmNzcyhhLFwiYm9yZGVyXCIrY2FbZl0rXCJXaWR0aFwiLCEwLGUpKSk6KGcrPXIuY3NzKGEsXCJwYWRkaW5nXCIrY2FbZl0sITAsZSksXCJwYWRkaW5nXCIhPT1jJiYoZys9ci5jc3MoYSxcImJvcmRlclwiK2NhW2ZdK1wiV2lkdGhcIiwhMCxlKSkpO3JldHVybiBnfWZ1bmN0aW9uICRhKGEsYixjKXt2YXIgZCxlPU5hKGEpLGY9T2EoYSxiLGUpLGc9XCJib3JkZXItYm94XCI9PT1yLmNzcyhhLFwiYm94U2l6aW5nXCIsITEsZSk7cmV0dXJuIE1hLnRlc3QoZik/ZjooZD1nJiYoby5ib3hTaXppbmdSZWxpYWJsZSgpfHxmPT09YS5zdHlsZVtiXSksXCJhdXRvXCI9PT1mJiYoZj1hW1wib2Zmc2V0XCIrYlswXS50b1VwcGVyQ2FzZSgpK2Iuc2xpY2UoMSldKSxmPXBhcnNlRmxvYXQoZil8fDAsZitaYShhLGIsY3x8KGc/XCJib3JkZXJcIjpcImNvbnRlbnRcIiksZCxlKStcInB4XCIpfXIuZXh0ZW5kKHtjc3NIb29rczp7b3BhY2l0eTp7Z2V0OmZ1bmN0aW9uKGEsYil7aWYoYil7dmFyIGM9T2EoYSxcIm9wYWNpdHlcIik7cmV0dXJuXCJcIj09PWM/XCIxXCI6Y319fX0sY3NzTnVtYmVyOnthbmltYXRpb25JdGVyYXRpb25Db3VudDohMCxjb2x1bW5Db3VudDohMCxmaWxsT3BhY2l0eTohMCxmbGV4R3JvdzohMCxmbGV4U2hyaW5rOiEwLGZvbnRXZWlnaHQ6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsd2lkb3dzOiEwLHpJbmRleDohMCx6b29tOiEwfSxjc3NQcm9wczp7XCJmbG9hdFwiOlwiY3NzRmxvYXRcIn0sc3R5bGU6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoYSYmMyE9PWEubm9kZVR5cGUmJjghPT1hLm5vZGVUeXBlJiZhLnN0eWxlKXt2YXIgZSxmLGcsaD1yLmNhbWVsQ2FzZShiKSxpPVJhLnRlc3QoYiksaj1hLnN0eWxlO3JldHVybiBpfHwoYj1YYShoKSksZz1yLmNzc0hvb2tzW2JdfHxyLmNzc0hvb2tzW2hdLHZvaWQgMD09PWM/ZyYmXCJnZXRcImluIGcmJnZvaWQgMCE9PShlPWcuZ2V0KGEsITEsZCkpP2U6altiXTooZj10eXBlb2YgYyxcInN0cmluZ1wiPT09ZiYmKGU9YmEuZXhlYyhjKSkmJmVbMV0mJihjPWZhKGEsYixlKSxmPVwibnVtYmVyXCIpLG51bGwhPWMmJmM9PT1jJiYoXCJudW1iZXJcIj09PWYmJihjKz1lJiZlWzNdfHwoci5jc3NOdW1iZXJbaF0/XCJcIjpcInB4XCIpKSxvLmNsZWFyQ2xvbmVTdHlsZXx8XCJcIiE9PWN8fDAhPT1iLmluZGV4T2YoXCJiYWNrZ3JvdW5kXCIpfHwoaltiXT1cImluaGVyaXRcIiksZyYmXCJzZXRcImluIGcmJnZvaWQgMD09PShjPWcuc2V0KGEsYyxkKSl8fChpP2ouc2V0UHJvcGVydHkoYixjKTpqW2JdPWMpKSx2b2lkIDApfX0sY3NzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlLGYsZyxoPXIuY2FtZWxDYXNlKGIpLGk9UmEudGVzdChiKTtyZXR1cm4gaXx8KGI9WGEoaCkpLGc9ci5jc3NIb29rc1tiXXx8ci5jc3NIb29rc1toXSxnJiZcImdldFwiaW4gZyYmKGU9Zy5nZXQoYSwhMCxjKSksdm9pZCAwPT09ZSYmKGU9T2EoYSxiLGQpKSxcIm5vcm1hbFwiPT09ZSYmYiBpbiBUYSYmKGU9VGFbYl0pLFwiXCI9PT1jfHxjPyhmPXBhcnNlRmxvYXQoZSksYz09PSEwfHxpc0Zpbml0ZShmKT9mfHwwOmUpOmV9fSksci5lYWNoKFtcImhlaWdodFwiLFwid2lkdGhcIl0sZnVuY3Rpb24oYSxiKXtyLmNzc0hvb2tzW2JdPXtnZXQ6ZnVuY3Rpb24oYSxjLGQpe2lmKGMpcmV0dXJuIVFhLnRlc3Qoci5jc3MoYSxcImRpc3BsYXlcIikpfHxhLmdldENsaWVudFJlY3RzKCkubGVuZ3RoJiZhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoPyRhKGEsYixkKTplYShhLFNhLGZ1bmN0aW9uKCl7cmV0dXJuICRhKGEsYixkKX0pfSxzZXQ6ZnVuY3Rpb24oYSxjLGQpe3ZhciBlLGY9ZCYmTmEoYSksZz1kJiZaYShhLGIsZCxcImJvcmRlci1ib3hcIj09PXIuY3NzKGEsXCJib3hTaXppbmdcIiwhMSxmKSxmKTtyZXR1cm4gZyYmKGU9YmEuZXhlYyhjKSkmJlwicHhcIiE9PShlWzNdfHxcInB4XCIpJiYoYS5zdHlsZVtiXT1jLGM9ci5jc3MoYSxiKSksWWEoYSxjLGcpfX19KSxyLmNzc0hvb2tzLm1hcmdpbkxlZnQ9UGEoby5yZWxpYWJsZU1hcmdpbkxlZnQsZnVuY3Rpb24oYSxiKXtpZihiKXJldHVybihwYXJzZUZsb2F0KE9hKGEsXCJtYXJnaW5MZWZ0XCIpKXx8YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0LWVhKGEse21hcmdpbkxlZnQ6MH0sZnVuY3Rpb24oKXtyZXR1cm4gYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0fSkpK1wicHhcIn0pLHIuZWFjaCh7bWFyZ2luOlwiXCIscGFkZGluZzpcIlwiLGJvcmRlcjpcIldpZHRoXCJ9LGZ1bmN0aW9uKGEsYil7ci5jc3NIb29rc1thK2JdPXtleHBhbmQ6ZnVuY3Rpb24oYyl7Zm9yKHZhciBkPTAsZT17fSxmPVwic3RyaW5nXCI9PXR5cGVvZiBjP2Muc3BsaXQoXCIgXCIpOltjXTtkPDQ7ZCsrKWVbYStjYVtkXStiXT1mW2RdfHxmW2QtMl18fGZbMF07cmV0dXJuIGV9fSxMYS50ZXN0KGEpfHwoci5jc3NIb29rc1thK2JdLnNldD1ZYSl9KSxyLmZuLmV4dGVuZCh7Y3NzOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFQodGhpcyxmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmPXt9LGc9MDtpZihBcnJheS5pc0FycmF5KGIpKXtmb3IoZD1OYShhKSxlPWIubGVuZ3RoO2c8ZTtnKyspZltiW2ddXT1yLmNzcyhhLGJbZ10sITEsZCk7cmV0dXJuIGZ9cmV0dXJuIHZvaWQgMCE9PWM/ci5zdHlsZShhLGIsYyk6ci5jc3MoYSxiKX0sYSxiLGFyZ3VtZW50cy5sZW5ndGg+MSl9fSk7ZnVuY3Rpb24gX2EoYSxiLGMsZCxlKXtyZXR1cm4gbmV3IF9hLnByb3RvdHlwZS5pbml0KGEsYixjLGQsZSl9ci5Ud2Vlbj1fYSxfYS5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOl9hLGluaXQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3RoaXMuZWxlbT1hLHRoaXMucHJvcD1jLHRoaXMuZWFzaW5nPWV8fHIuZWFzaW5nLl9kZWZhdWx0LHRoaXMub3B0aW9ucz1iLHRoaXMuc3RhcnQ9dGhpcy5ub3c9dGhpcy5jdXIoKSx0aGlzLmVuZD1kLHRoaXMudW5pdD1mfHwoci5jc3NOdW1iZXJbY10/XCJcIjpcInB4XCIpfSxjdXI6ZnVuY3Rpb24oKXt2YXIgYT1fYS5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gYSYmYS5nZXQ/YS5nZXQodGhpcyk6X2EucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKX0scnVuOmZ1bmN0aW9uKGEpe3ZhciBiLGM9X2EucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbj90aGlzLnBvcz1iPXIuZWFzaW5nW3RoaXMuZWFzaW5nXShhLHRoaXMub3B0aW9ucy5kdXJhdGlvbiphLDAsMSx0aGlzLm9wdGlvbnMuZHVyYXRpb24pOnRoaXMucG9zPWI9YSx0aGlzLm5vdz0odGhpcy5lbmQtdGhpcy5zdGFydCkqYit0aGlzLnN0YXJ0LHRoaXMub3B0aW9ucy5zdGVwJiZ0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSx0aGlzLm5vdyx0aGlzKSxjJiZjLnNldD9jLnNldCh0aGlzKTpfYS5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLHRoaXN9fSxfYS5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGU9X2EucHJvdG90eXBlLF9hLnByb3BIb29rcz17X2RlZmF1bHQ6e2dldDpmdW5jdGlvbihhKXt2YXIgYjtyZXR1cm4gMSE9PWEuZWxlbS5ub2RlVHlwZXx8bnVsbCE9YS5lbGVtW2EucHJvcF0mJm51bGw9PWEuZWxlbS5zdHlsZVthLnByb3BdP2EuZWxlbVthLnByb3BdOihiPXIuY3NzKGEuZWxlbSxhLnByb3AsXCJcIiksYiYmXCJhdXRvXCIhPT1iP2I6MCl9LHNldDpmdW5jdGlvbihhKXtyLmZ4LnN0ZXBbYS5wcm9wXT9yLmZ4LnN0ZXBbYS5wcm9wXShhKToxIT09YS5lbGVtLm5vZGVUeXBlfHxudWxsPT1hLmVsZW0uc3R5bGVbci5jc3NQcm9wc1thLnByb3BdXSYmIXIuY3NzSG9va3NbYS5wcm9wXT9hLmVsZW1bYS5wcm9wXT1hLm5vdzpyLnN0eWxlKGEuZWxlbSxhLnByb3AsYS5ub3crYS51bml0KX19fSxfYS5wcm9wSG9va3Muc2Nyb2xsVG9wPV9hLnByb3BIb29rcy5zY3JvbGxMZWZ0PXtzZXQ6ZnVuY3Rpb24oYSl7YS5lbGVtLm5vZGVUeXBlJiZhLmVsZW0ucGFyZW50Tm9kZSYmKGEuZWxlbVthLnByb3BdPWEubm93KX19LHIuZWFzaW5nPXtsaW5lYXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGF9LHN3aW5nOmZ1bmN0aW9uKGEpe3JldHVybi41LU1hdGguY29zKGEqTWF0aC5QSSkvMn0sX2RlZmF1bHQ6XCJzd2luZ1wifSxyLmZ4PV9hLnByb3RvdHlwZS5pbml0LHIuZnguc3RlcD17fTt2YXIgYWIsYmIsY2I9L14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLGRiPS9xdWV1ZUhvb2tzJC87ZnVuY3Rpb24gZWIoKXtiYiYmKGQuaGlkZGVuPT09ITEmJmEucmVxdWVzdEFuaW1hdGlvbkZyYW1lP2EucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGViKTphLnNldFRpbWVvdXQoZWIsci5meC5pbnRlcnZhbCksci5meC50aWNrKCkpfWZ1bmN0aW9uIGZiKCl7cmV0dXJuIGEuc2V0VGltZW91dChmdW5jdGlvbigpe2FiPXZvaWQgMH0pLGFiPXIubm93KCl9ZnVuY3Rpb24gZ2IoYSxiKXt2YXIgYyxkPTAsZT17aGVpZ2h0OmF9O2ZvcihiPWI/MTowO2Q8NDtkKz0yLWIpYz1jYVtkXSxlW1wibWFyZ2luXCIrY109ZVtcInBhZGRpbmdcIitjXT1hO3JldHVybiBiJiYoZS5vcGFjaXR5PWUud2lkdGg9YSksZX1mdW5jdGlvbiBoYihhLGIsYyl7Zm9yKHZhciBkLGU9KGtiLnR3ZWVuZXJzW2JdfHxbXSkuY29uY2F0KGtiLnR3ZWVuZXJzW1wiKlwiXSksZj0wLGc9ZS5sZW5ndGg7ZjxnO2YrKylpZihkPWVbZl0uY2FsbChjLGIsYSkpcmV0dXJuIGR9ZnVuY3Rpb24gaWIoYSxiLGMpe3ZhciBkLGUsZixnLGgsaSxqLGssbD1cIndpZHRoXCJpbiBifHxcImhlaWdodFwiaW4gYixtPXRoaXMsbj17fSxvPWEuc3R5bGUscD1hLm5vZGVUeXBlJiZkYShhKSxxPVcuZ2V0KGEsXCJmeHNob3dcIik7Yy5xdWV1ZXx8KGc9ci5fcXVldWVIb29rcyhhLFwiZnhcIiksbnVsbD09Zy51bnF1ZXVlZCYmKGcudW5xdWV1ZWQ9MCxoPWcuZW1wdHkuZmlyZSxnLmVtcHR5LmZpcmU9ZnVuY3Rpb24oKXtnLnVucXVldWVkfHxoKCl9KSxnLnVucXVldWVkKyssbS5hbHdheXMoZnVuY3Rpb24oKXttLmFsd2F5cyhmdW5jdGlvbigpe2cudW5xdWV1ZWQtLSxyLnF1ZXVlKGEsXCJmeFwiKS5sZW5ndGh8fGcuZW1wdHkuZmlyZSgpfSl9KSk7Zm9yKGQgaW4gYilpZihlPWJbZF0sY2IudGVzdChlKSl7aWYoZGVsZXRlIGJbZF0sZj1mfHxcInRvZ2dsZVwiPT09ZSxlPT09KHA/XCJoaWRlXCI6XCJzaG93XCIpKXtpZihcInNob3dcIiE9PWV8fCFxfHx2b2lkIDA9PT1xW2RdKWNvbnRpbnVlO3A9ITB9bltkXT1xJiZxW2RdfHxyLnN0eWxlKGEsZCl9aWYoaT0hci5pc0VtcHR5T2JqZWN0KGIpLGl8fCFyLmlzRW1wdHlPYmplY3Qobikpe2wmJjE9PT1hLm5vZGVUeXBlJiYoYy5vdmVyZmxvdz1bby5vdmVyZmxvdyxvLm92ZXJmbG93WCxvLm92ZXJmbG93WV0saj1xJiZxLmRpc3BsYXksbnVsbD09aiYmKGo9Vy5nZXQoYSxcImRpc3BsYXlcIikpLGs9ci5jc3MoYSxcImRpc3BsYXlcIiksXCJub25lXCI9PT1rJiYoaj9rPWo6KGlhKFthXSwhMCksaj1hLnN0eWxlLmRpc3BsYXl8fGosaz1yLmNzcyhhLFwiZGlzcGxheVwiKSxpYShbYV0pKSksKFwiaW5saW5lXCI9PT1rfHxcImlubGluZS1ibG9ja1wiPT09ayYmbnVsbCE9aikmJlwibm9uZVwiPT09ci5jc3MoYSxcImZsb2F0XCIpJiYoaXx8KG0uZG9uZShmdW5jdGlvbigpe28uZGlzcGxheT1qfSksbnVsbD09aiYmKGs9by5kaXNwbGF5LGo9XCJub25lXCI9PT1rP1wiXCI6aykpLG8uZGlzcGxheT1cImlubGluZS1ibG9ja1wiKSksYy5vdmVyZmxvdyYmKG8ub3ZlcmZsb3c9XCJoaWRkZW5cIixtLmFsd2F5cyhmdW5jdGlvbigpe28ub3ZlcmZsb3c9Yy5vdmVyZmxvd1swXSxvLm92ZXJmbG93WD1jLm92ZXJmbG93WzFdLG8ub3ZlcmZsb3dZPWMub3ZlcmZsb3dbMl19KSksaT0hMTtmb3IoZCBpbiBuKWl8fChxP1wiaGlkZGVuXCJpbiBxJiYocD1xLmhpZGRlbik6cT1XLmFjY2VzcyhhLFwiZnhzaG93XCIse2Rpc3BsYXk6an0pLGYmJihxLmhpZGRlbj0hcCkscCYmaWEoW2FdLCEwKSxtLmRvbmUoZnVuY3Rpb24oKXtwfHxpYShbYV0pLFcucmVtb3ZlKGEsXCJmeHNob3dcIik7Zm9yKGQgaW4gbilyLnN0eWxlKGEsZCxuW2RdKX0pKSxpPWhiKHA/cVtkXTowLGQsbSksZCBpbiBxfHwocVtkXT1pLnN0YXJ0LHAmJihpLmVuZD1pLnN0YXJ0LGkuc3RhcnQ9MCkpfX1mdW5jdGlvbiBqYihhLGIpe3ZhciBjLGQsZSxmLGc7Zm9yKGMgaW4gYSlpZihkPXIuY2FtZWxDYXNlKGMpLGU9YltkXSxmPWFbY10sQXJyYXkuaXNBcnJheShmKSYmKGU9ZlsxXSxmPWFbY109ZlswXSksYyE9PWQmJihhW2RdPWYsZGVsZXRlIGFbY10pLGc9ci5jc3NIb29rc1tkXSxnJiZcImV4cGFuZFwiaW4gZyl7Zj1nLmV4cGFuZChmKSxkZWxldGUgYVtkXTtmb3IoYyBpbiBmKWMgaW4gYXx8KGFbY109ZltjXSxiW2NdPWUpfWVsc2UgYltkXT1lfWZ1bmN0aW9uIGtiKGEsYixjKXt2YXIgZCxlLGY9MCxnPWtiLnByZWZpbHRlcnMubGVuZ3RoLGg9ci5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbigpe2RlbGV0ZSBpLmVsZW19KSxpPWZ1bmN0aW9uKCl7aWYoZSlyZXR1cm4hMTtmb3IodmFyIGI9YWJ8fGZiKCksYz1NYXRoLm1heCgwLGouc3RhcnRUaW1lK2ouZHVyYXRpb24tYiksZD1jL2ouZHVyYXRpb258fDAsZj0xLWQsZz0wLGk9ai50d2VlbnMubGVuZ3RoO2c8aTtnKyspai50d2VlbnNbZ10ucnVuKGYpO3JldHVybiBoLm5vdGlmeVdpdGgoYSxbaixmLGNdKSxmPDEmJmk/YzooaXx8aC5ub3RpZnlXaXRoKGEsW2osMSwwXSksaC5yZXNvbHZlV2l0aChhLFtqXSksITEpfSxqPWgucHJvbWlzZSh7ZWxlbTphLHByb3BzOnIuZXh0ZW5kKHt9LGIpLG9wdHM6ci5leHRlbmQoITAse3NwZWNpYWxFYXNpbmc6e30sZWFzaW5nOnIuZWFzaW5nLl9kZWZhdWx0fSxjKSxvcmlnaW5hbFByb3BlcnRpZXM6YixvcmlnaW5hbE9wdGlvbnM6YyxzdGFydFRpbWU6YWJ8fGZiKCksZHVyYXRpb246Yy5kdXJhdGlvbix0d2VlbnM6W10sY3JlYXRlVHdlZW46ZnVuY3Rpb24oYixjKXt2YXIgZD1yLlR3ZWVuKGEsai5vcHRzLGIsYyxqLm9wdHMuc3BlY2lhbEVhc2luZ1tiXXx8ai5vcHRzLmVhc2luZyk7cmV0dXJuIGoudHdlZW5zLnB1c2goZCksZH0sc3RvcDpmdW5jdGlvbihiKXt2YXIgYz0wLGQ9Yj9qLnR3ZWVucy5sZW5ndGg6MDtpZihlKXJldHVybiB0aGlzO2ZvcihlPSEwO2M8ZDtjKyspai50d2VlbnNbY10ucnVuKDEpO3JldHVybiBiPyhoLm5vdGlmeVdpdGgoYSxbaiwxLDBdKSxoLnJlc29sdmVXaXRoKGEsW2osYl0pKTpoLnJlamVjdFdpdGgoYSxbaixiXSksdGhpc319KSxrPWoucHJvcHM7Zm9yKGpiKGssai5vcHRzLnNwZWNpYWxFYXNpbmcpO2Y8ZztmKyspaWYoZD1rYi5wcmVmaWx0ZXJzW2ZdLmNhbGwoaixhLGssai5vcHRzKSlyZXR1cm4gci5pc0Z1bmN0aW9uKGQuc3RvcCkmJihyLl9xdWV1ZUhvb2tzKGouZWxlbSxqLm9wdHMucXVldWUpLnN0b3A9ci5wcm94eShkLnN0b3AsZCkpLGQ7cmV0dXJuIHIubWFwKGssaGIsaiksci5pc0Z1bmN0aW9uKGoub3B0cy5zdGFydCkmJmoub3B0cy5zdGFydC5jYWxsKGEsaiksai5wcm9ncmVzcyhqLm9wdHMucHJvZ3Jlc3MpLmRvbmUoai5vcHRzLmRvbmUsai5vcHRzLmNvbXBsZXRlKS5mYWlsKGoub3B0cy5mYWlsKS5hbHdheXMoai5vcHRzLmFsd2F5cyksci5meC50aW1lcihyLmV4dGVuZChpLHtlbGVtOmEsYW5pbTpqLHF1ZXVlOmoub3B0cy5xdWV1ZX0pKSxqfXIuQW5pbWF0aW9uPXIuZXh0ZW5kKGtiLHt0d2VlbmVyczp7XCIqXCI6W2Z1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jcmVhdGVUd2VlbihhLGIpO3JldHVybiBmYShjLmVsZW0sYSxiYS5leGVjKGIpLGMpLGN9XX0sdHdlZW5lcjpmdW5jdGlvbihhLGIpe3IuaXNGdW5jdGlvbihhKT8oYj1hLGE9W1wiKlwiXSk6YT1hLm1hdGNoKEwpO2Zvcih2YXIgYyxkPTAsZT1hLmxlbmd0aDtkPGU7ZCsrKWM9YVtkXSxrYi50d2VlbmVyc1tjXT1rYi50d2VlbmVyc1tjXXx8W10sa2IudHdlZW5lcnNbY10udW5zaGlmdChiKX0scHJlZmlsdGVyczpbaWJdLHByZWZpbHRlcjpmdW5jdGlvbihhLGIpe2I/a2IucHJlZmlsdGVycy51bnNoaWZ0KGEpOmtiLnByZWZpbHRlcnMucHVzaChhKX19KSxyLnNwZWVkPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1hJiZcIm9iamVjdFwiPT10eXBlb2YgYT9yLmV4dGVuZCh7fSxhKTp7Y29tcGxldGU6Y3x8IWMmJmJ8fHIuaXNGdW5jdGlvbihhKSYmYSxkdXJhdGlvbjphLGVhc2luZzpjJiZifHxiJiYhci5pc0Z1bmN0aW9uKGIpJiZifTtyZXR1cm4gci5meC5vZmY/ZC5kdXJhdGlvbj0wOlwibnVtYmVyXCIhPXR5cGVvZiBkLmR1cmF0aW9uJiYoZC5kdXJhdGlvbiBpbiByLmZ4LnNwZWVkcz9kLmR1cmF0aW9uPXIuZnguc3BlZWRzW2QuZHVyYXRpb25dOmQuZHVyYXRpb249ci5meC5zcGVlZHMuX2RlZmF1bHQpLG51bGwhPWQucXVldWUmJmQucXVldWUhPT0hMHx8KGQucXVldWU9XCJmeFwiKSxkLm9sZD1kLmNvbXBsZXRlLGQuY29tcGxldGU9ZnVuY3Rpb24oKXtyLmlzRnVuY3Rpb24oZC5vbGQpJiZkLm9sZC5jYWxsKHRoaXMpLGQucXVldWUmJnIuZGVxdWV1ZSh0aGlzLGQucXVldWUpfSxkfSxyLmZuLmV4dGVuZCh7ZmFkZVRvOmZ1bmN0aW9uKGEsYixjLGQpe3JldHVybiB0aGlzLmZpbHRlcihkYSkuY3NzKFwib3BhY2l0eVwiLDApLnNob3coKS5lbmQoKS5hbmltYXRlKHtvcGFjaXR5OmJ9LGEsYyxkKX0sYW5pbWF0ZTpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1yLmlzRW1wdHlPYmplY3QoYSksZj1yLnNwZWVkKGIsYyxkKSxnPWZ1bmN0aW9uKCl7dmFyIGI9a2IodGhpcyxyLmV4dGVuZCh7fSxhKSxmKTsoZXx8Vy5nZXQodGhpcyxcImZpbmlzaFwiKSkmJmIuc3RvcCghMCl9O3JldHVybiBnLmZpbmlzaD1nLGV8fGYucXVldWU9PT0hMT90aGlzLmVhY2goZyk6dGhpcy5xdWV1ZShmLnF1ZXVlLGcpfSxzdG9wOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1mdW5jdGlvbihhKXt2YXIgYj1hLnN0b3A7ZGVsZXRlIGEuc3RvcCxiKGMpfTtyZXR1cm5cInN0cmluZ1wiIT10eXBlb2YgYSYmKGM9YixiPWEsYT12b2lkIDApLGImJmEhPT0hMSYmdGhpcy5xdWV1ZShhfHxcImZ4XCIsW10pLHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiPSEwLGU9bnVsbCE9YSYmYStcInF1ZXVlSG9va3NcIixmPXIudGltZXJzLGc9Vy5nZXQodGhpcyk7aWYoZSlnW2VdJiZnW2VdLnN0b3AmJmQoZ1tlXSk7ZWxzZSBmb3IoZSBpbiBnKWdbZV0mJmdbZV0uc3RvcCYmZGIudGVzdChlKSYmZChnW2VdKTtmb3IoZT1mLmxlbmd0aDtlLS07KWZbZV0uZWxlbSE9PXRoaXN8fG51bGwhPWEmJmZbZV0ucXVldWUhPT1hfHwoZltlXS5hbmltLnN0b3AoYyksYj0hMSxmLnNwbGljZShlLDEpKTshYiYmY3x8ci5kZXF1ZXVlKHRoaXMsYSl9KX0sZmluaXNoOmZ1bmN0aW9uKGEpe3JldHVybiBhIT09ITEmJihhPWF8fFwiZnhcIiksdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGIsYz1XLmdldCh0aGlzKSxkPWNbYStcInF1ZXVlXCJdLGU9Y1thK1wicXVldWVIb29rc1wiXSxmPXIudGltZXJzLGc9ZD9kLmxlbmd0aDowO2ZvcihjLmZpbmlzaD0hMCxyLnF1ZXVlKHRoaXMsYSxbXSksZSYmZS5zdG9wJiZlLnN0b3AuY2FsbCh0aGlzLCEwKSxiPWYubGVuZ3RoO2ItLTspZltiXS5lbGVtPT09dGhpcyYmZltiXS5xdWV1ZT09PWEmJihmW2JdLmFuaW0uc3RvcCghMCksZi5zcGxpY2UoYiwxKSk7Zm9yKGI9MDtiPGc7YisrKWRbYl0mJmRbYl0uZmluaXNoJiZkW2JdLmZpbmlzaC5jYWxsKHRoaXMpO2RlbGV0ZSBjLmZpbmlzaH0pfX0pLHIuZWFjaChbXCJ0b2dnbGVcIixcInNob3dcIixcImhpZGVcIl0sZnVuY3Rpb24oYSxiKXt2YXIgYz1yLmZuW2JdO3IuZm5bYl09ZnVuY3Rpb24oYSxkLGUpe3JldHVybiBudWxsPT1hfHxcImJvb2xlYW5cIj09dHlwZW9mIGE/Yy5hcHBseSh0aGlzLGFyZ3VtZW50cyk6dGhpcy5hbmltYXRlKGdiKGIsITApLGEsZCxlKX19KSxyLmVhY2goe3NsaWRlRG93bjpnYihcInNob3dcIiksc2xpZGVVcDpnYihcImhpZGVcIiksc2xpZGVUb2dnbGU6Z2IoXCJ0b2dnbGVcIiksZmFkZUluOntvcGFjaXR5Olwic2hvd1wifSxmYWRlT3V0OntvcGFjaXR5OlwiaGlkZVwifSxmYWRlVG9nZ2xlOntvcGFjaXR5OlwidG9nZ2xlXCJ9fSxmdW5jdGlvbihhLGIpe3IuZm5bYV09ZnVuY3Rpb24oYSxjLGQpe3JldHVybiB0aGlzLmFuaW1hdGUoYixhLGMsZCl9fSksci50aW1lcnM9W10sci5meC50aWNrPWZ1bmN0aW9uKCl7dmFyIGEsYj0wLGM9ci50aW1lcnM7Zm9yKGFiPXIubm93KCk7YjxjLmxlbmd0aDtiKyspYT1jW2JdLGEoKXx8Y1tiXSE9PWF8fGMuc3BsaWNlKGItLSwxKTtjLmxlbmd0aHx8ci5meC5zdG9wKCksYWI9dm9pZCAwfSxyLmZ4LnRpbWVyPWZ1bmN0aW9uKGEpe3IudGltZXJzLnB1c2goYSksci5meC5zdGFydCgpfSxyLmZ4LmludGVydmFsPTEzLHIuZnguc3RhcnQ9ZnVuY3Rpb24oKXtiYnx8KGJiPSEwLGViKCkpfSxyLmZ4LnN0b3A9ZnVuY3Rpb24oKXtiYj1udWxsfSxyLmZ4LnNwZWVkcz17c2xvdzo2MDAsZmFzdDoyMDAsX2RlZmF1bHQ6NDAwfSxyLmZuLmRlbGF5PWZ1bmN0aW9uKGIsYyl7cmV0dXJuIGI9ci5meD9yLmZ4LnNwZWVkc1tiXXx8YjpiLGM9Y3x8XCJmeFwiLHRoaXMucXVldWUoYyxmdW5jdGlvbihjLGQpe3ZhciBlPWEuc2V0VGltZW91dChjLGIpO2Quc3RvcD1mdW5jdGlvbigpe2EuY2xlYXJUaW1lb3V0KGUpfX0pfSxmdW5jdGlvbigpe3ZhciBhPWQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLGI9ZC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpLGM9Yi5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIikpO2EudHlwZT1cImNoZWNrYm94XCIsby5jaGVja09uPVwiXCIhPT1hLnZhbHVlLG8ub3B0U2VsZWN0ZWQ9Yy5zZWxlY3RlZCxhPWQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLGEudmFsdWU9XCJ0XCIsYS50eXBlPVwicmFkaW9cIixvLnJhZGlvVmFsdWU9XCJ0XCI9PT1hLnZhbHVlfSgpO3ZhciBsYixtYj1yLmV4cHIuYXR0ckhhbmRsZTtyLmZuLmV4dGVuZCh7YXR0cjpmdW5jdGlvbihhLGIpe3JldHVybiBUKHRoaXMsci5hdHRyLGEsYixhcmd1bWVudHMubGVuZ3RoPjEpfSxyZW1vdmVBdHRyOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtyLnJlbW92ZUF0dHIodGhpcyxhKX0pfX0pLHIuZXh0ZW5kKHthdHRyOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9YS5ub2RlVHlwZTtpZigzIT09ZiYmOCE9PWYmJjIhPT1mKXJldHVyblwidW5kZWZpbmVkXCI9PXR5cGVvZiBhLmdldEF0dHJpYnV0ZT9yLnByb3AoYSxiLGMpOigxPT09ZiYmci5pc1hNTERvYyhhKXx8KGU9ci5hdHRySG9va3NbYi50b0xvd2VyQ2FzZSgpXXx8KHIuZXhwci5tYXRjaC5ib29sLnRlc3QoYik/bGI6dm9pZCAwKSksdm9pZCAwIT09Yz9udWxsPT09Yz92b2lkIHIucmVtb3ZlQXR0cihhLGIpOmUmJlwic2V0XCJpbiBlJiZ2b2lkIDAhPT0oZD1lLnNldChhLGMsYikpP2Q6KGEuc2V0QXR0cmlidXRlKGIsYytcIlwiKSxjKTplJiZcImdldFwiaW4gZSYmbnVsbCE9PShkPWUuZ2V0KGEsYikpP2Q6KGQ9ci5maW5kLmF0dHIoYSxiKSxcblx0bnVsbD09ZD92b2lkIDA6ZCkpfSxhdHRySG9va3M6e3R5cGU6e3NldDpmdW5jdGlvbihhLGIpe2lmKCFvLnJhZGlvVmFsdWUmJlwicmFkaW9cIj09PWImJkIoYSxcImlucHV0XCIpKXt2YXIgYz1hLnZhbHVlO3JldHVybiBhLnNldEF0dHJpYnV0ZShcInR5cGVcIixiKSxjJiYoYS52YWx1ZT1jKSxifX19fSxyZW1vdmVBdHRyOmZ1bmN0aW9uKGEsYil7dmFyIGMsZD0wLGU9YiYmYi5tYXRjaChMKTtpZihlJiYxPT09YS5ub2RlVHlwZSl3aGlsZShjPWVbZCsrXSlhLnJlbW92ZUF0dHJpYnV0ZShjKX19KSxsYj17c2V0OmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYj09PSExP3IucmVtb3ZlQXR0cihhLGMpOmEuc2V0QXR0cmlidXRlKGMsYyksY319LHIuZWFjaChyLmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcdysvZyksZnVuY3Rpb24oYSxiKXt2YXIgYz1tYltiXXx8ci5maW5kLmF0dHI7bWJbYl09ZnVuY3Rpb24oYSxiLGQpe3ZhciBlLGYsZz1iLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGR8fChmPW1iW2ddLG1iW2ddPWUsZT1udWxsIT1jKGEsYixkKT9nOm51bGwsbWJbZ109ZiksZX19KTt2YXIgbmI9L14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxvYj0vXig/OmF8YXJlYSkkL2k7ci5mbi5leHRlbmQoe3Byb3A6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gVCh0aGlzLHIucHJvcCxhLGIsYXJndW1lbnRzLmxlbmd0aD4xKX0scmVtb3ZlUHJvcDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7ZGVsZXRlIHRoaXNbci5wcm9wRml4W2FdfHxhXX0pfX0pLHIuZXh0ZW5kKHtwcm9wOmZ1bmN0aW9uKGEsYixjKXt2YXIgZCxlLGY9YS5ub2RlVHlwZTtpZigzIT09ZiYmOCE9PWYmJjIhPT1mKXJldHVybiAxPT09ZiYmci5pc1hNTERvYyhhKXx8KGI9ci5wcm9wRml4W2JdfHxiLGU9ci5wcm9wSG9va3NbYl0pLHZvaWQgMCE9PWM/ZSYmXCJzZXRcImluIGUmJnZvaWQgMCE9PShkPWUuc2V0KGEsYyxiKSk/ZDphW2JdPWM6ZSYmXCJnZXRcImluIGUmJm51bGwhPT0oZD1lLmdldChhLGIpKT9kOmFbYl19LHByb3BIb29rczp7dGFiSW5kZXg6e2dldDpmdW5jdGlvbihhKXt2YXIgYj1yLmZpbmQuYXR0cihhLFwidGFiaW5kZXhcIik7cmV0dXJuIGI/cGFyc2VJbnQoYiwxMCk6bmIudGVzdChhLm5vZGVOYW1lKXx8b2IudGVzdChhLm5vZGVOYW1lKSYmYS5ocmVmPzA6LTF9fX0scHJvcEZpeDp7XCJmb3JcIjpcImh0bWxGb3JcIixcImNsYXNzXCI6XCJjbGFzc05hbWVcIn19KSxvLm9wdFNlbGVjdGVkfHwoci5wcm9wSG9va3Muc2VsZWN0ZWQ9e2dldDpmdW5jdGlvbihhKXt2YXIgYj1hLnBhcmVudE5vZGU7cmV0dXJuIGImJmIucGFyZW50Tm9kZSYmYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgsbnVsbH0sc2V0OmZ1bmN0aW9uKGEpe3ZhciBiPWEucGFyZW50Tm9kZTtiJiYoYi5zZWxlY3RlZEluZGV4LGIucGFyZW50Tm9kZSYmYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpfX0pLHIuZWFjaChbXCJ0YWJJbmRleFwiLFwicmVhZE9ubHlcIixcIm1heExlbmd0aFwiLFwiY2VsbFNwYWNpbmdcIixcImNlbGxQYWRkaW5nXCIsXCJyb3dTcGFuXCIsXCJjb2xTcGFuXCIsXCJ1c2VNYXBcIixcImZyYW1lQm9yZGVyXCIsXCJjb250ZW50RWRpdGFibGVcIl0sZnVuY3Rpb24oKXtyLnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXT10aGlzfSk7ZnVuY3Rpb24gcGIoYSl7dmFyIGI9YS5tYXRjaChMKXx8W107cmV0dXJuIGIuam9pbihcIiBcIil9ZnVuY3Rpb24gcWIoYSl7cmV0dXJuIGEuZ2V0QXR0cmlidXRlJiZhLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwifXIuZm4uZXh0ZW5kKHthZGRDbGFzczpmdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGcsaCxpPTA7aWYoci5pc0Z1bmN0aW9uKGEpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYil7cih0aGlzKS5hZGRDbGFzcyhhLmNhbGwodGhpcyxiLHFiKHRoaXMpKSl9KTtpZihcInN0cmluZ1wiPT10eXBlb2YgYSYmYSl7Yj1hLm1hdGNoKEwpfHxbXTt3aGlsZShjPXRoaXNbaSsrXSlpZihlPXFiKGMpLGQ9MT09PWMubm9kZVR5cGUmJlwiIFwiK3BiKGUpK1wiIFwiKXtnPTA7d2hpbGUoZj1iW2crK10pZC5pbmRleE9mKFwiIFwiK2YrXCIgXCIpPDAmJihkKz1mK1wiIFwiKTtoPXBiKGQpLGUhPT1oJiZjLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsaCl9fXJldHVybiB0aGlzfSxyZW1vdmVDbGFzczpmdW5jdGlvbihhKXt2YXIgYixjLGQsZSxmLGcsaCxpPTA7aWYoci5pc0Z1bmN0aW9uKGEpKXJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oYil7cih0aGlzKS5yZW1vdmVDbGFzcyhhLmNhbGwodGhpcyxiLHFiKHRoaXMpKSl9KTtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5hdHRyKFwiY2xhc3NcIixcIlwiKTtpZihcInN0cmluZ1wiPT10eXBlb2YgYSYmYSl7Yj1hLm1hdGNoKEwpfHxbXTt3aGlsZShjPXRoaXNbaSsrXSlpZihlPXFiKGMpLGQ9MT09PWMubm9kZVR5cGUmJlwiIFwiK3BiKGUpK1wiIFwiKXtnPTA7d2hpbGUoZj1iW2crK10pd2hpbGUoZC5pbmRleE9mKFwiIFwiK2YrXCIgXCIpPi0xKWQ9ZC5yZXBsYWNlKFwiIFwiK2YrXCIgXCIsXCIgXCIpO2g9cGIoZCksZSE9PWgmJmMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixoKX19cmV0dXJuIHRoaXN9LHRvZ2dsZUNsYXNzOmZ1bmN0aW9uKGEsYil7dmFyIGM9dHlwZW9mIGE7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiBiJiZcInN0cmluZ1wiPT09Yz9iP3RoaXMuYWRkQ2xhc3MoYSk6dGhpcy5yZW1vdmVDbGFzcyhhKTpyLmlzRnVuY3Rpb24oYSk/dGhpcy5lYWNoKGZ1bmN0aW9uKGMpe3IodGhpcykudG9nZ2xlQ2xhc3MoYS5jYWxsKHRoaXMsYyxxYih0aGlzKSxiKSxiKX0pOnRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBiLGQsZSxmO2lmKFwic3RyaW5nXCI9PT1jKXtkPTAsZT1yKHRoaXMpLGY9YS5tYXRjaChMKXx8W107d2hpbGUoYj1mW2QrK10pZS5oYXNDbGFzcyhiKT9lLnJlbW92ZUNsYXNzKGIpOmUuYWRkQ2xhc3MoYil9ZWxzZSB2b2lkIDAhPT1hJiZcImJvb2xlYW5cIiE9PWN8fChiPXFiKHRoaXMpLGImJlcuc2V0KHRoaXMsXCJfX2NsYXNzTmFtZV9fXCIsYiksdGhpcy5zZXRBdHRyaWJ1dGUmJnRoaXMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixifHxhPT09ITE/XCJcIjpXLmdldCh0aGlzLFwiX19jbGFzc05hbWVfX1wiKXx8XCJcIikpfSl9LGhhc0NsYXNzOmZ1bmN0aW9uKGEpe3ZhciBiLGMsZD0wO2I9XCIgXCIrYStcIiBcIjt3aGlsZShjPXRoaXNbZCsrXSlpZigxPT09Yy5ub2RlVHlwZSYmKFwiIFwiK3BiKHFiKGMpKStcIiBcIikuaW5kZXhPZihiKT4tMSlyZXR1cm4hMDtyZXR1cm4hMX19KTt2YXIgcmI9L1xcci9nO3IuZm4uZXh0ZW5kKHt2YWw6ZnVuY3Rpb24oYSl7dmFyIGIsYyxkLGU9dGhpc1swXTt7aWYoYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gZD1yLmlzRnVuY3Rpb24oYSksdGhpcy5lYWNoKGZ1bmN0aW9uKGMpe3ZhciBlOzE9PT10aGlzLm5vZGVUeXBlJiYoZT1kP2EuY2FsbCh0aGlzLGMscih0aGlzKS52YWwoKSk6YSxudWxsPT1lP2U9XCJcIjpcIm51bWJlclwiPT10eXBlb2YgZT9lKz1cIlwiOkFycmF5LmlzQXJyYXkoZSkmJihlPXIubWFwKGUsZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/XCJcIjphK1wiXCJ9KSksYj1yLnZhbEhvb2tzW3RoaXMudHlwZV18fHIudmFsSG9va3NbdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSxiJiZcInNldFwiaW4gYiYmdm9pZCAwIT09Yi5zZXQodGhpcyxlLFwidmFsdWVcIil8fCh0aGlzLnZhbHVlPWUpKX0pO2lmKGUpcmV0dXJuIGI9ci52YWxIb29rc1tlLnR5cGVdfHxyLnZhbEhvb2tzW2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sYiYmXCJnZXRcImluIGImJnZvaWQgMCE9PShjPWIuZ2V0KGUsXCJ2YWx1ZVwiKSk/YzooYz1lLnZhbHVlLFwic3RyaW5nXCI9PXR5cGVvZiBjP2MucmVwbGFjZShyYixcIlwiKTpudWxsPT1jP1wiXCI6Yyl9fX0pLHIuZXh0ZW5kKHt2YWxIb29rczp7b3B0aW9uOntnZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9ci5maW5kLmF0dHIoYSxcInZhbHVlXCIpO3JldHVybiBudWxsIT1iP2I6cGIoci50ZXh0KGEpKX19LHNlbGVjdDp7Z2V0OmZ1bmN0aW9uKGEpe3ZhciBiLGMsZCxlPWEub3B0aW9ucyxmPWEuc2VsZWN0ZWRJbmRleCxnPVwic2VsZWN0LW9uZVwiPT09YS50eXBlLGg9Zz9udWxsOltdLGk9Zz9mKzE6ZS5sZW5ndGg7Zm9yKGQ9ZjwwP2k6Zz9mOjA7ZDxpO2QrKylpZihjPWVbZF0sKGMuc2VsZWN0ZWR8fGQ9PT1mKSYmIWMuZGlzYWJsZWQmJighYy5wYXJlbnROb2RlLmRpc2FibGVkfHwhQihjLnBhcmVudE5vZGUsXCJvcHRncm91cFwiKSkpe2lmKGI9cihjKS52YWwoKSxnKXJldHVybiBiO2gucHVzaChiKX1yZXR1cm4gaH0sc2V0OmZ1bmN0aW9uKGEsYil7dmFyIGMsZCxlPWEub3B0aW9ucyxmPXIubWFrZUFycmF5KGIpLGc9ZS5sZW5ndGg7d2hpbGUoZy0tKWQ9ZVtnXSwoZC5zZWxlY3RlZD1yLmluQXJyYXkoci52YWxIb29rcy5vcHRpb24uZ2V0KGQpLGYpPi0xKSYmKGM9ITApO3JldHVybiBjfHwoYS5zZWxlY3RlZEluZGV4PS0xKSxmfX19fSksci5lYWNoKFtcInJhZGlvXCIsXCJjaGVja2JveFwiXSxmdW5jdGlvbigpe3IudmFsSG9va3NbdGhpc109e3NldDpmdW5jdGlvbihhLGIpe2lmKEFycmF5LmlzQXJyYXkoYikpcmV0dXJuIGEuY2hlY2tlZD1yLmluQXJyYXkocihhKS52YWwoKSxiKT4tMX19LG8uY2hlY2tPbnx8KHIudmFsSG9va3NbdGhpc10uZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT09YS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKT9cIm9uXCI6YS52YWx1ZX0pfSk7dmFyIHNiPS9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztyLmV4dGVuZChyLmV2ZW50LHt0cmlnZ2VyOmZ1bmN0aW9uKGIsYyxlLGYpe3ZhciBnLGgsaSxqLGssbSxuLG89W2V8fGRdLHA9bC5jYWxsKGIsXCJ0eXBlXCIpP2IudHlwZTpiLHE9bC5jYWxsKGIsXCJuYW1lc3BhY2VcIik/Yi5uYW1lc3BhY2Uuc3BsaXQoXCIuXCIpOltdO2lmKGg9aT1lPWV8fGQsMyE9PWUubm9kZVR5cGUmJjghPT1lLm5vZGVUeXBlJiYhc2IudGVzdChwK3IuZXZlbnQudHJpZ2dlcmVkKSYmKHAuaW5kZXhPZihcIi5cIik+LTEmJihxPXAuc3BsaXQoXCIuXCIpLHA9cS5zaGlmdCgpLHEuc29ydCgpKSxrPXAuaW5kZXhPZihcIjpcIik8MCYmXCJvblwiK3AsYj1iW3IuZXhwYW5kb10/YjpuZXcgci5FdmVudChwLFwib2JqZWN0XCI9PXR5cGVvZiBiJiZiKSxiLmlzVHJpZ2dlcj1mPzI6MyxiLm5hbWVzcGFjZT1xLmpvaW4oXCIuXCIpLGIucm5hbWVzcGFjZT1iLm5hbWVzcGFjZT9uZXcgUmVnRXhwKFwiKF58XFxcXC4pXCIrcS5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikrXCIoXFxcXC58JClcIik6bnVsbCxiLnJlc3VsdD12b2lkIDAsYi50YXJnZXR8fChiLnRhcmdldD1lKSxjPW51bGw9PWM/W2JdOnIubWFrZUFycmF5KGMsW2JdKSxuPXIuZXZlbnQuc3BlY2lhbFtwXXx8e30sZnx8IW4udHJpZ2dlcnx8bi50cmlnZ2VyLmFwcGx5KGUsYykhPT0hMSkpe2lmKCFmJiYhbi5ub0J1YmJsZSYmIXIuaXNXaW5kb3coZSkpe2ZvcihqPW4uZGVsZWdhdGVUeXBlfHxwLHNiLnRlc3QoaitwKXx8KGg9aC5wYXJlbnROb2RlKTtoO2g9aC5wYXJlbnROb2RlKW8ucHVzaChoKSxpPWg7aT09PShlLm93bmVyRG9jdW1lbnR8fGQpJiZvLnB1c2goaS5kZWZhdWx0Vmlld3x8aS5wYXJlbnRXaW5kb3d8fGEpfWc9MDt3aGlsZSgoaD1vW2crK10pJiYhYi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKWIudHlwZT1nPjE/ajpuLmJpbmRUeXBlfHxwLG09KFcuZ2V0KGgsXCJldmVudHNcIil8fHt9KVtiLnR5cGVdJiZXLmdldChoLFwiaGFuZGxlXCIpLG0mJm0uYXBwbHkoaCxjKSxtPWsmJmhba10sbSYmbS5hcHBseSYmVShoKSYmKGIucmVzdWx0PW0uYXBwbHkoaCxjKSxiLnJlc3VsdD09PSExJiZiLnByZXZlbnREZWZhdWx0KCkpO3JldHVybiBiLnR5cGU9cCxmfHxiLmlzRGVmYXVsdFByZXZlbnRlZCgpfHxuLl9kZWZhdWx0JiZuLl9kZWZhdWx0LmFwcGx5KG8ucG9wKCksYykhPT0hMXx8IVUoZSl8fGsmJnIuaXNGdW5jdGlvbihlW3BdKSYmIXIuaXNXaW5kb3coZSkmJihpPWVba10saSYmKGVba109bnVsbCksci5ldmVudC50cmlnZ2VyZWQ9cCxlW3BdKCksci5ldmVudC50cmlnZ2VyZWQ9dm9pZCAwLGkmJihlW2tdPWkpKSxiLnJlc3VsdH19LHNpbXVsYXRlOmZ1bmN0aW9uKGEsYixjKXt2YXIgZD1yLmV4dGVuZChuZXcgci5FdmVudCxjLHt0eXBlOmEsaXNTaW11bGF0ZWQ6ITB9KTtyLmV2ZW50LnRyaWdnZXIoZCxudWxsLGIpfX0pLHIuZm4uZXh0ZW5kKHt0cmlnZ2VyOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3IuZXZlbnQudHJpZ2dlcihhLGIsdGhpcyl9KX0sdHJpZ2dlckhhbmRsZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzWzBdO2lmKGMpcmV0dXJuIHIuZXZlbnQudHJpZ2dlcihhLGIsYywhMCl9fSksci5lYWNoKFwiYmx1ciBmb2N1cyBmb2N1c2luIGZvY3Vzb3V0IHJlc2l6ZSBzY3JvbGwgY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiLnNwbGl0KFwiIFwiKSxmdW5jdGlvbihhLGIpe3IuZm5bYl09ZnVuY3Rpb24oYSxjKXtyZXR1cm4gYXJndW1lbnRzLmxlbmd0aD4wP3RoaXMub24oYixudWxsLGEsYyk6dGhpcy50cmlnZ2VyKGIpfX0pLHIuZm4uZXh0ZW5kKHtob3ZlcjpmdW5jdGlvbihhLGIpe3JldHVybiB0aGlzLm1vdXNlZW50ZXIoYSkubW91c2VsZWF2ZShifHxhKX19KSxvLmZvY3VzaW49XCJvbmZvY3VzaW5cImluIGEsby5mb2N1c2lufHxyLmVhY2goe2ZvY3VzOlwiZm9jdXNpblwiLGJsdXI6XCJmb2N1c291dFwifSxmdW5jdGlvbihhLGIpe3ZhciBjPWZ1bmN0aW9uKGEpe3IuZXZlbnQuc2ltdWxhdGUoYixhLnRhcmdldCxyLmV2ZW50LmZpeChhKSl9O3IuZXZlbnQuc3BlY2lhbFtiXT17c2V0dXA6ZnVuY3Rpb24oKXt2YXIgZD10aGlzLm93bmVyRG9jdW1lbnR8fHRoaXMsZT1XLmFjY2VzcyhkLGIpO2V8fGQuYWRkRXZlbnRMaXN0ZW5lcihhLGMsITApLFcuYWNjZXNzKGQsYiwoZXx8MCkrMSl9LHRlYXJkb3duOmZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5vd25lckRvY3VtZW50fHx0aGlzLGU9Vy5hY2Nlc3MoZCxiKS0xO2U/Vy5hY2Nlc3MoZCxiLGUpOihkLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxjLCEwKSxXLnJlbW92ZShkLGIpKX19fSk7dmFyIHRiPWEubG9jYXRpb24sdWI9ci5ub3coKSx2Yj0vXFw/LztyLnBhcnNlWE1MPWZ1bmN0aW9uKGIpe3ZhciBjO2lmKCFifHxcInN0cmluZ1wiIT10eXBlb2YgYilyZXR1cm4gbnVsbDt0cnl7Yz0obmV3IGEuRE9NUGFyc2VyKS5wYXJzZUZyb21TdHJpbmcoYixcInRleHQveG1sXCIpfWNhdGNoKGQpe2M9dm9pZCAwfXJldHVybiBjJiYhYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcInBhcnNlcmVycm9yXCIpLmxlbmd0aHx8ci5lcnJvcihcIkludmFsaWQgWE1MOiBcIitiKSxjfTt2YXIgd2I9L1xcW1xcXSQvLHhiPS9cXHI/XFxuL2cseWI9L14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLHpiPS9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtmdW5jdGlvbiBBYihhLGIsYyxkKXt2YXIgZTtpZihBcnJheS5pc0FycmF5KGIpKXIuZWFjaChiLGZ1bmN0aW9uKGIsZSl7Y3x8d2IudGVzdChhKT9kKGEsZSk6QWIoYStcIltcIisoXCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPWU/YjpcIlwiKStcIl1cIixlLGMsZCl9KTtlbHNlIGlmKGN8fFwib2JqZWN0XCIhPT1yLnR5cGUoYikpZChhLGIpO2Vsc2UgZm9yKGUgaW4gYilBYihhK1wiW1wiK2UrXCJdXCIsYltlXSxjLGQpfXIucGFyYW09ZnVuY3Rpb24oYSxiKXt2YXIgYyxkPVtdLGU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1yLmlzRnVuY3Rpb24oYik/YigpOmI7ZFtkLmxlbmd0aF09ZW5jb2RlVVJJQ29tcG9uZW50KGEpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChudWxsPT1jP1wiXCI6Yyl9O2lmKEFycmF5LmlzQXJyYXkoYSl8fGEuanF1ZXJ5JiYhci5pc1BsYWluT2JqZWN0KGEpKXIuZWFjaChhLGZ1bmN0aW9uKCl7ZSh0aGlzLm5hbWUsdGhpcy52YWx1ZSl9KTtlbHNlIGZvcihjIGluIGEpQWIoYyxhW2NdLGIsZSk7cmV0dXJuIGQuam9pbihcIiZcIil9LHIuZm4uZXh0ZW5kKHtzZXJpYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gci5wYXJhbSh0aGlzLnNlcmlhbGl6ZUFycmF5KCkpfSxzZXJpYWxpemVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPXIucHJvcCh0aGlzLFwiZWxlbWVudHNcIik7cmV0dXJuIGE/ci5tYWtlQXJyYXkoYSk6dGhpc30pLmZpbHRlcihmdW5jdGlvbigpe3ZhciBhPXRoaXMudHlwZTtyZXR1cm4gdGhpcy5uYW1lJiYhcih0aGlzKS5pcyhcIjpkaXNhYmxlZFwiKSYmemIudGVzdCh0aGlzLm5vZGVOYW1lKSYmIXliLnRlc3QoYSkmJih0aGlzLmNoZWNrZWR8fCFqYS50ZXN0KGEpKX0pLm1hcChmdW5jdGlvbihhLGIpe3ZhciBjPXIodGhpcykudmFsKCk7cmV0dXJuIG51bGw9PWM/bnVsbDpBcnJheS5pc0FycmF5KGMpP3IubWFwKGMsZnVuY3Rpb24oYSl7cmV0dXJue25hbWU6Yi5uYW1lLHZhbHVlOmEucmVwbGFjZSh4YixcIlxcclxcblwiKX19KTp7bmFtZTpiLm5hbWUsdmFsdWU6Yy5yZXBsYWNlKHhiLFwiXFxyXFxuXCIpfX0pLmdldCgpfX0pO3ZhciBCYj0vJTIwL2csQ2I9LyMuKiQvLERiPS8oWz8mXSlfPVteJl0qLyxFYj0vXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL2dtLEZiPS9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLEdiPS9eKD86R0VUfEhFQUQpJC8sSGI9L15cXC9cXC8vLEliPXt9LEpiPXt9LEtiPVwiKi9cIi5jb25jYXQoXCIqXCIpLExiPWQuY3JlYXRlRWxlbWVudChcImFcIik7TGIuaHJlZj10Yi5ocmVmO2Z1bmN0aW9uIE1iKGEpe3JldHVybiBmdW5jdGlvbihiLGMpe1wic3RyaW5nXCIhPXR5cGVvZiBiJiYoYz1iLGI9XCIqXCIpO3ZhciBkLGU9MCxmPWIudG9Mb3dlckNhc2UoKS5tYXRjaChMKXx8W107aWYoci5pc0Z1bmN0aW9uKGMpKXdoaWxlKGQ9ZltlKytdKVwiK1wiPT09ZFswXT8oZD1kLnNsaWNlKDEpfHxcIipcIiwoYVtkXT1hW2RdfHxbXSkudW5zaGlmdChjKSk6KGFbZF09YVtkXXx8W10pLnB1c2goYyl9fWZ1bmN0aW9uIE5iKGEsYixjLGQpe3ZhciBlPXt9LGY9YT09PUpiO2Z1bmN0aW9uIGcoaCl7dmFyIGk7cmV0dXJuIGVbaF09ITAsci5lYWNoKGFbaF18fFtdLGZ1bmN0aW9uKGEsaCl7dmFyIGo9aChiLGMsZCk7cmV0dXJuXCJzdHJpbmdcIiE9dHlwZW9mIGp8fGZ8fGVbal0/Zj8hKGk9aik6dm9pZCAwOihiLmRhdGFUeXBlcy51bnNoaWZ0KGopLGcoaiksITEpfSksaX1yZXR1cm4gZyhiLmRhdGFUeXBlc1swXSl8fCFlW1wiKlwiXSYmZyhcIipcIil9ZnVuY3Rpb24gT2IoYSxiKXt2YXIgYyxkLGU9ci5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnN8fHt9O2ZvcihjIGluIGIpdm9pZCAwIT09YltjXSYmKChlW2NdP2E6ZHx8KGQ9e30pKVtjXT1iW2NdKTtyZXR1cm4gZCYmci5leHRlbmQoITAsYSxkKSxhfWZ1bmN0aW9uIFBiKGEsYixjKXt2YXIgZCxlLGYsZyxoPWEuY29udGVudHMsaT1hLmRhdGFUeXBlczt3aGlsZShcIipcIj09PWlbMF0paS5zaGlmdCgpLHZvaWQgMD09PWQmJihkPWEubWltZVR5cGV8fGIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikpO2lmKGQpZm9yKGUgaW4gaClpZihoW2VdJiZoW2VdLnRlc3QoZCkpe2kudW5zaGlmdChlKTticmVha31pZihpWzBdaW4gYylmPWlbMF07ZWxzZXtmb3IoZSBpbiBjKXtpZighaVswXXx8YS5jb252ZXJ0ZXJzW2UrXCIgXCIraVswXV0pe2Y9ZTticmVha31nfHwoZz1lKX1mPWZ8fGd9aWYoZilyZXR1cm4gZiE9PWlbMF0mJmkudW5zaGlmdChmKSxjW2ZdfWZ1bmN0aW9uIFFiKGEsYixjLGQpe3ZhciBlLGYsZyxoLGksaj17fSxrPWEuZGF0YVR5cGVzLnNsaWNlKCk7aWYoa1sxXSlmb3IoZyBpbiBhLmNvbnZlcnRlcnMpaltnLnRvTG93ZXJDYXNlKCldPWEuY29udmVydGVyc1tnXTtmPWsuc2hpZnQoKTt3aGlsZShmKWlmKGEucmVzcG9uc2VGaWVsZHNbZl0mJihjW2EucmVzcG9uc2VGaWVsZHNbZl1dPWIpLCFpJiZkJiZhLmRhdGFGaWx0ZXImJihiPWEuZGF0YUZpbHRlcihiLGEuZGF0YVR5cGUpKSxpPWYsZj1rLnNoaWZ0KCkpaWYoXCIqXCI9PT1mKWY9aTtlbHNlIGlmKFwiKlwiIT09aSYmaSE9PWYpe2lmKGc9altpK1wiIFwiK2ZdfHxqW1wiKiBcIitmXSwhZylmb3IoZSBpbiBqKWlmKGg9ZS5zcGxpdChcIiBcIiksaFsxXT09PWYmJihnPWpbaStcIiBcIitoWzBdXXx8altcIiogXCIraFswXV0pKXtnPT09ITA/Zz1qW2VdOmpbZV0hPT0hMCYmKGY9aFswXSxrLnVuc2hpZnQoaFsxXSkpO2JyZWFrfWlmKGchPT0hMClpZihnJiZhW1widGhyb3dzXCJdKWI9ZyhiKTtlbHNlIHRyeXtiPWcoYil9Y2F0Y2gobCl7cmV0dXJue3N0YXRlOlwicGFyc2VyZXJyb3JcIixlcnJvcjpnP2w6XCJObyBjb252ZXJzaW9uIGZyb20gXCIraStcIiB0byBcIitmfX19cmV0dXJue3N0YXRlOlwic3VjY2Vzc1wiLGRhdGE6Yn19ci5leHRlbmQoe2FjdGl2ZTowLGxhc3RNb2RpZmllZDp7fSxldGFnOnt9LGFqYXhTZXR0aW5nczp7dXJsOnRiLmhyZWYsdHlwZTpcIkdFVFwiLGlzTG9jYWw6RmIudGVzdCh0Yi5wcm90b2NvbCksZ2xvYmFsOiEwLHByb2Nlc3NEYXRhOiEwLGFzeW5jOiEwLGNvbnRlbnRUeXBlOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04XCIsYWNjZXB0czp7XCIqXCI6S2IsdGV4dDpcInRleHQvcGxhaW5cIixodG1sOlwidGV4dC9odG1sXCIseG1sOlwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLGpzb246XCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIn0sY29udGVudHM6e3htbDovXFxieG1sXFxiLyxodG1sOi9cXGJodG1sLyxqc29uOi9cXGJqc29uXFxiL30scmVzcG9uc2VGaWVsZHM6e3htbDpcInJlc3BvbnNlWE1MXCIsdGV4dDpcInJlc3BvbnNlVGV4dFwiLGpzb246XCJyZXNwb25zZUpTT05cIn0sY29udmVydGVyczp7XCIqIHRleHRcIjpTdHJpbmcsXCJ0ZXh0IGh0bWxcIjohMCxcInRleHQganNvblwiOkpTT04ucGFyc2UsXCJ0ZXh0IHhtbFwiOnIucGFyc2VYTUx9LGZsYXRPcHRpb25zOnt1cmw6ITAsY29udGV4dDohMH19LGFqYXhTZXR1cDpmdW5jdGlvbihhLGIpe3JldHVybiBiP09iKE9iKGEsci5hamF4U2V0dGluZ3MpLGIpOk9iKHIuYWpheFNldHRpbmdzLGEpfSxhamF4UHJlZmlsdGVyOk1iKEliKSxhamF4VHJhbnNwb3J0Ok1iKEpiKSxhamF4OmZ1bmN0aW9uKGIsYyl7XCJvYmplY3RcIj09dHlwZW9mIGImJihjPWIsYj12b2lkIDApLGM9Y3x8e307dmFyIGUsZixnLGgsaSxqLGssbCxtLG4sbz1yLmFqYXhTZXR1cCh7fSxjKSxwPW8uY29udGV4dHx8byxxPW8uY29udGV4dCYmKHAubm9kZVR5cGV8fHAuanF1ZXJ5KT9yKHApOnIuZXZlbnQscz1yLkRlZmVycmVkKCksdD1yLkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLHU9by5zdGF0dXNDb2RlfHx7fSx2PXt9LHc9e30seD1cImNhbmNlbGVkXCIseT17cmVhZHlTdGF0ZTowLGdldFJlc3BvbnNlSGVhZGVyOmZ1bmN0aW9uKGEpe3ZhciBiO2lmKGspe2lmKCFoKXtoPXt9O3doaWxlKGI9RWIuZXhlYyhnKSloW2JbMV0udG9Mb3dlckNhc2UoKV09YlsyXX1iPWhbYS50b0xvd2VyQ2FzZSgpXX1yZXR1cm4gbnVsbD09Yj9udWxsOmJ9LGdldEFsbFJlc3BvbnNlSGVhZGVyczpmdW5jdGlvbigpe3JldHVybiBrP2c6bnVsbH0sc2V0UmVxdWVzdEhlYWRlcjpmdW5jdGlvbihhLGIpe3JldHVybiBudWxsPT1rJiYoYT13W2EudG9Mb3dlckNhc2UoKV09d1thLnRvTG93ZXJDYXNlKCldfHxhLHZbYV09YiksdGhpc30sb3ZlcnJpZGVNaW1lVHlwZTpmdW5jdGlvbihhKXtyZXR1cm4gbnVsbD09ayYmKG8ubWltZVR5cGU9YSksdGhpc30sc3RhdHVzQ29kZTpmdW5jdGlvbihhKXt2YXIgYjtpZihhKWlmKGspeS5hbHdheXMoYVt5LnN0YXR1c10pO2Vsc2UgZm9yKGIgaW4gYSl1W2JdPVt1W2JdLGFbYl1dO3JldHVybiB0aGlzfSxhYm9ydDpmdW5jdGlvbihhKXt2YXIgYj1hfHx4O3JldHVybiBlJiZlLmFib3J0KGIpLEEoMCxiKSx0aGlzfX07aWYocy5wcm9taXNlKHkpLG8udXJsPSgoYnx8by51cmx8fHRiLmhyZWYpK1wiXCIpLnJlcGxhY2UoSGIsdGIucHJvdG9jb2wrXCIvL1wiKSxvLnR5cGU9Yy5tZXRob2R8fGMudHlwZXx8by5tZXRob2R8fG8udHlwZSxvLmRhdGFUeXBlcz0oby5kYXRhVHlwZXx8XCIqXCIpLnRvTG93ZXJDYXNlKCkubWF0Y2goTCl8fFtcIlwiXSxudWxsPT1vLmNyb3NzRG9tYWluKXtqPWQuY3JlYXRlRWxlbWVudChcImFcIik7dHJ5e2ouaHJlZj1vLnVybCxqLmhyZWY9ai5ocmVmLG8uY3Jvc3NEb21haW49TGIucHJvdG9jb2wrXCIvL1wiK0xiLmhvc3QhPWoucHJvdG9jb2wrXCIvL1wiK2ouaG9zdH1jYXRjaCh6KXtvLmNyb3NzRG9tYWluPSEwfX1pZihvLmRhdGEmJm8ucHJvY2Vzc0RhdGEmJlwic3RyaW5nXCIhPXR5cGVvZiBvLmRhdGEmJihvLmRhdGE9ci5wYXJhbShvLmRhdGEsby50cmFkaXRpb25hbCkpLE5iKEliLG8sYyx5KSxrKXJldHVybiB5O2w9ci5ldmVudCYmby5nbG9iYWwsbCYmMD09PXIuYWN0aXZlKysmJnIuZXZlbnQudHJpZ2dlcihcImFqYXhTdGFydFwiKSxvLnR5cGU9by50eXBlLnRvVXBwZXJDYXNlKCksby5oYXNDb250ZW50PSFHYi50ZXN0KG8udHlwZSksZj1vLnVybC5yZXBsYWNlKENiLFwiXCIpLG8uaGFzQ29udGVudD9vLmRhdGEmJm8ucHJvY2Vzc0RhdGEmJjA9PT0oby5jb250ZW50VHlwZXx8XCJcIikuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSYmKG8uZGF0YT1vLmRhdGEucmVwbGFjZShCYixcIitcIikpOihuPW8udXJsLnNsaWNlKGYubGVuZ3RoKSxvLmRhdGEmJihmKz0odmIudGVzdChmKT9cIiZcIjpcIj9cIikrby5kYXRhLGRlbGV0ZSBvLmRhdGEpLG8uY2FjaGU9PT0hMSYmKGY9Zi5yZXBsYWNlKERiLFwiJDFcIiksbj0odmIudGVzdChmKT9cIiZcIjpcIj9cIikrXCJfPVwiK3ViKysgK24pLG8udXJsPWYrbiksby5pZk1vZGlmaWVkJiYoci5sYXN0TW9kaWZpZWRbZl0mJnkuc2V0UmVxdWVzdEhlYWRlcihcIklmLU1vZGlmaWVkLVNpbmNlXCIsci5sYXN0TW9kaWZpZWRbZl0pLHIuZXRhZ1tmXSYmeS5zZXRSZXF1ZXN0SGVhZGVyKFwiSWYtTm9uZS1NYXRjaFwiLHIuZXRhZ1tmXSkpLChvLmRhdGEmJm8uaGFzQ29udGVudCYmby5jb250ZW50VHlwZSE9PSExfHxjLmNvbnRlbnRUeXBlKSYmeS5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsby5jb250ZW50VHlwZSkseS5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0XCIsby5kYXRhVHlwZXNbMF0mJm8uYWNjZXB0c1tvLmRhdGFUeXBlc1swXV0/by5hY2NlcHRzW28uZGF0YVR5cGVzWzBdXSsoXCIqXCIhPT1vLmRhdGFUeXBlc1swXT9cIiwgXCIrS2IrXCI7IHE9MC4wMVwiOlwiXCIpOm8uYWNjZXB0c1tcIipcIl0pO2ZvcihtIGluIG8uaGVhZGVycyl5LnNldFJlcXVlc3RIZWFkZXIobSxvLmhlYWRlcnNbbV0pO2lmKG8uYmVmb3JlU2VuZCYmKG8uYmVmb3JlU2VuZC5jYWxsKHAseSxvKT09PSExfHxrKSlyZXR1cm4geS5hYm9ydCgpO2lmKHg9XCJhYm9ydFwiLHQuYWRkKG8uY29tcGxldGUpLHkuZG9uZShvLnN1Y2Nlc3MpLHkuZmFpbChvLmVycm9yKSxlPU5iKEpiLG8sYyx5KSl7aWYoeS5yZWFkeVN0YXRlPTEsbCYmcS50cmlnZ2VyKFwiYWpheFNlbmRcIixbeSxvXSksaylyZXR1cm4geTtvLmFzeW5jJiZvLnRpbWVvdXQ+MCYmKGk9YS5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7eS5hYm9ydChcInRpbWVvdXRcIil9LG8udGltZW91dCkpO3RyeXtrPSExLGUuc2VuZCh2LEEpfWNhdGNoKHope2lmKGspdGhyb3cgejtBKC0xLHopfX1lbHNlIEEoLTEsXCJObyBUcmFuc3BvcnRcIik7ZnVuY3Rpb24gQShiLGMsZCxoKXt2YXIgaixtLG4sdix3LHg9YztrfHwoaz0hMCxpJiZhLmNsZWFyVGltZW91dChpKSxlPXZvaWQgMCxnPWh8fFwiXCIseS5yZWFkeVN0YXRlPWI+MD80OjAsaj1iPj0yMDAmJmI8MzAwfHwzMDQ9PT1iLGQmJih2PVBiKG8seSxkKSksdj1RYihvLHYseSxqKSxqPyhvLmlmTW9kaWZpZWQmJih3PXkuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpLHcmJihyLmxhc3RNb2RpZmllZFtmXT13KSx3PXkuZ2V0UmVzcG9uc2VIZWFkZXIoXCJldGFnXCIpLHcmJihyLmV0YWdbZl09dykpLDIwND09PWJ8fFwiSEVBRFwiPT09by50eXBlP3g9XCJub2NvbnRlbnRcIjozMDQ9PT1iP3g9XCJub3Rtb2RpZmllZFwiOih4PXYuc3RhdGUsbT12LmRhdGEsbj12LmVycm9yLGo9IW4pKToobj14LCFiJiZ4fHwoeD1cImVycm9yXCIsYjwwJiYoYj0wKSkpLHkuc3RhdHVzPWIseS5zdGF0dXNUZXh0PShjfHx4KStcIlwiLGo/cy5yZXNvbHZlV2l0aChwLFttLHgseV0pOnMucmVqZWN0V2l0aChwLFt5LHgsbl0pLHkuc3RhdHVzQ29kZSh1KSx1PXZvaWQgMCxsJiZxLnRyaWdnZXIoaj9cImFqYXhTdWNjZXNzXCI6XCJhamF4RXJyb3JcIixbeSxvLGo/bTpuXSksdC5maXJlV2l0aChwLFt5LHhdKSxsJiYocS50cmlnZ2VyKFwiYWpheENvbXBsZXRlXCIsW3ksb10pLC0tci5hY3RpdmV8fHIuZXZlbnQudHJpZ2dlcihcImFqYXhTdG9wXCIpKSl9cmV0dXJuIHl9LGdldEpTT046ZnVuY3Rpb24oYSxiLGMpe3JldHVybiByLmdldChhLGIsYyxcImpzb25cIil9LGdldFNjcmlwdDpmdW5jdGlvbihhLGIpe3JldHVybiByLmdldChhLHZvaWQgMCxiLFwic2NyaXB0XCIpfX0pLHIuZWFjaChbXCJnZXRcIixcInBvc3RcIl0sZnVuY3Rpb24oYSxiKXtyW2JdPWZ1bmN0aW9uKGEsYyxkLGUpe3JldHVybiByLmlzRnVuY3Rpb24oYykmJihlPWV8fGQsZD1jLGM9dm9pZCAwKSxyLmFqYXgoci5leHRlbmQoe3VybDphLHR5cGU6YixkYXRhVHlwZTplLGRhdGE6YyxzdWNjZXNzOmR9LHIuaXNQbGFpbk9iamVjdChhKSYmYSkpfX0pLHIuX2V2YWxVcmw9ZnVuY3Rpb24oYSl7cmV0dXJuIHIuYWpheCh7dXJsOmEsdHlwZTpcIkdFVFwiLGRhdGFUeXBlOlwic2NyaXB0XCIsY2FjaGU6ITAsYXN5bmM6ITEsZ2xvYmFsOiExLFwidGhyb3dzXCI6ITB9KX0sci5mbi5leHRlbmQoe3dyYXBBbGw6ZnVuY3Rpb24oYSl7dmFyIGI7cmV0dXJuIHRoaXNbMF0mJihyLmlzRnVuY3Rpb24oYSkmJihhPWEuY2FsbCh0aGlzWzBdKSksYj1yKGEsdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCksdGhpc1swXS5wYXJlbnROb2RlJiZiLmluc2VydEJlZm9yZSh0aGlzWzBdKSxiLm1hcChmdW5jdGlvbigpe3ZhciBhPXRoaXM7d2hpbGUoYS5maXJzdEVsZW1lbnRDaGlsZClhPWEuZmlyc3RFbGVtZW50Q2hpbGQ7cmV0dXJuIGF9KS5hcHBlbmQodGhpcykpLHRoaXN9LHdyYXBJbm5lcjpmdW5jdGlvbihhKXtyZXR1cm4gci5pc0Z1bmN0aW9uKGEpP3RoaXMuZWFjaChmdW5jdGlvbihiKXtyKHRoaXMpLndyYXBJbm5lcihhLmNhbGwodGhpcyxiKSl9KTp0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1yKHRoaXMpLGM9Yi5jb250ZW50cygpO2MubGVuZ3RoP2Mud3JhcEFsbChhKTpiLmFwcGVuZChhKX0pfSx3cmFwOmZ1bmN0aW9uKGEpe3ZhciBiPXIuaXNGdW5jdGlvbihhKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGMpe3IodGhpcykud3JhcEFsbChiP2EuY2FsbCh0aGlzLGMpOmEpfSl9LHVud3JhcDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5wYXJlbnQoYSkubm90KFwiYm9keVwiKS5lYWNoKGZ1bmN0aW9uKCl7cih0aGlzKS5yZXBsYWNlV2l0aCh0aGlzLmNoaWxkTm9kZXMpfSksdGhpc319KSxyLmV4cHIucHNldWRvcy5oaWRkZW49ZnVuY3Rpb24oYSl7cmV0dXJuIXIuZXhwci5wc2V1ZG9zLnZpc2libGUoYSl9LHIuZXhwci5wc2V1ZG9zLnZpc2libGU9ZnVuY3Rpb24oYSl7cmV0dXJuISEoYS5vZmZzZXRXaWR0aHx8YS5vZmZzZXRIZWlnaHR8fGEuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGgpfSxyLmFqYXhTZXR0aW5ncy54aHI9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIG5ldyBhLlhNTEh0dHBSZXF1ZXN0fWNhdGNoKGIpe319O3ZhciBSYj17MDoyMDAsMTIyMzoyMDR9LFNiPXIuYWpheFNldHRpbmdzLnhocigpO28uY29ycz0hIVNiJiZcIndpdGhDcmVkZW50aWFsc1wiaW4gU2Isby5hamF4PVNiPSEhU2Isci5hamF4VHJhbnNwb3J0KGZ1bmN0aW9uKGIpe3ZhciBjLGQ7aWYoby5jb3JzfHxTYiYmIWIuY3Jvc3NEb21haW4pcmV0dXJue3NlbmQ6ZnVuY3Rpb24oZSxmKXt2YXIgZyxoPWIueGhyKCk7aWYoaC5vcGVuKGIudHlwZSxiLnVybCxiLmFzeW5jLGIudXNlcm5hbWUsYi5wYXNzd29yZCksYi54aHJGaWVsZHMpZm9yKGcgaW4gYi54aHJGaWVsZHMpaFtnXT1iLnhockZpZWxkc1tnXTtiLm1pbWVUeXBlJiZoLm92ZXJyaWRlTWltZVR5cGUmJmgub3ZlcnJpZGVNaW1lVHlwZShiLm1pbWVUeXBlKSxiLmNyb3NzRG9tYWlufHxlW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXXx8KGVbXCJYLVJlcXVlc3RlZC1XaXRoXCJdPVwiWE1MSHR0cFJlcXVlc3RcIik7Zm9yKGcgaW4gZSloLnNldFJlcXVlc3RIZWFkZXIoZyxlW2ddKTtjPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbigpe2MmJihjPWQ9aC5vbmxvYWQ9aC5vbmVycm9yPWgub25hYm9ydD1oLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLFwiYWJvcnRcIj09PWE/aC5hYm9ydCgpOlwiZXJyb3JcIj09PWE/XCJudW1iZXJcIiE9dHlwZW9mIGguc3RhdHVzP2YoMCxcImVycm9yXCIpOmYoaC5zdGF0dXMsaC5zdGF0dXNUZXh0KTpmKFJiW2guc3RhdHVzXXx8aC5zdGF0dXMsaC5zdGF0dXNUZXh0LFwidGV4dFwiIT09KGgucmVzcG9uc2VUeXBlfHxcInRleHRcIil8fFwic3RyaW5nXCIhPXR5cGVvZiBoLnJlc3BvbnNlVGV4dD97YmluYXJ5OmgucmVzcG9uc2V9Ont0ZXh0OmgucmVzcG9uc2VUZXh0fSxoLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSl9fSxoLm9ubG9hZD1jKCksZD1oLm9uZXJyb3I9YyhcImVycm9yXCIpLHZvaWQgMCE9PWgub25hYm9ydD9oLm9uYWJvcnQ9ZDpoLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpezQ9PT1oLnJlYWR5U3RhdGUmJmEuc2V0VGltZW91dChmdW5jdGlvbigpe2MmJmQoKX0pfSxjPWMoXCJhYm9ydFwiKTt0cnl7aC5zZW5kKGIuaGFzQ29udGVudCYmYi5kYXRhfHxudWxsKX1jYXRjaChpKXtpZihjKXRocm93IGl9fSxhYm9ydDpmdW5jdGlvbigpe2MmJmMoKX19fSksci5hamF4UHJlZmlsdGVyKGZ1bmN0aW9uKGEpe2EuY3Jvc3NEb21haW4mJihhLmNvbnRlbnRzLnNjcmlwdD0hMSl9KSxyLmFqYXhTZXR1cCh7YWNjZXB0czp7c2NyaXB0OlwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIn0sY29udGVudHM6e3NjcmlwdDovXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi99LGNvbnZlcnRlcnM6e1widGV4dCBzY3JpcHRcIjpmdW5jdGlvbihhKXtyZXR1cm4gci5nbG9iYWxFdmFsKGEpLGF9fX0pLHIuYWpheFByZWZpbHRlcihcInNjcmlwdFwiLGZ1bmN0aW9uKGEpe3ZvaWQgMD09PWEuY2FjaGUmJihhLmNhY2hlPSExKSxhLmNyb3NzRG9tYWluJiYoYS50eXBlPVwiR0VUXCIpfSksci5hamF4VHJhbnNwb3J0KFwic2NyaXB0XCIsZnVuY3Rpb24oYSl7aWYoYS5jcm9zc0RvbWFpbil7dmFyIGIsYztyZXR1cm57c2VuZDpmdW5jdGlvbihlLGYpe2I9cihcIjxzY3JpcHQ+XCIpLnByb3Aoe2NoYXJzZXQ6YS5zY3JpcHRDaGFyc2V0LHNyYzphLnVybH0pLm9uKFwibG9hZCBlcnJvclwiLGM9ZnVuY3Rpb24oYSl7Yi5yZW1vdmUoKSxjPW51bGwsYSYmZihcImVycm9yXCI9PT1hLnR5cGU/NDA0OjIwMCxhLnR5cGUpfSksZC5oZWFkLmFwcGVuZENoaWxkKGJbMF0pfSxhYm9ydDpmdW5jdGlvbigpe2MmJmMoKX19fX0pO3ZhciBUYj1bXSxVYj0vKD0pXFw/KD89JnwkKXxcXD9cXD8vO3IuYWpheFNldHVwKHtqc29ucDpcImNhbGxiYWNrXCIsanNvbnBDYWxsYmFjazpmdW5jdGlvbigpe3ZhciBhPVRiLnBvcCgpfHxyLmV4cGFuZG8rXCJfXCIrdWIrKztyZXR1cm4gdGhpc1thXT0hMCxhfX0pLHIuYWpheFByZWZpbHRlcihcImpzb24ganNvbnBcIixmdW5jdGlvbihiLGMsZCl7dmFyIGUsZixnLGg9Yi5qc29ucCE9PSExJiYoVWIudGVzdChiLnVybCk/XCJ1cmxcIjpcInN0cmluZ1wiPT10eXBlb2YgYi5kYXRhJiYwPT09KGIuY29udGVudFR5cGV8fFwiXCIpLmluZGV4T2YoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIikmJlViLnRlc3QoYi5kYXRhKSYmXCJkYXRhXCIpO2lmKGh8fFwianNvbnBcIj09PWIuZGF0YVR5cGVzWzBdKXJldHVybiBlPWIuanNvbnBDYWxsYmFjaz1yLmlzRnVuY3Rpb24oYi5qc29ucENhbGxiYWNrKT9iLmpzb25wQ2FsbGJhY2soKTpiLmpzb25wQ2FsbGJhY2ssaD9iW2hdPWJbaF0ucmVwbGFjZShVYixcIiQxXCIrZSk6Yi5qc29ucCE9PSExJiYoYi51cmwrPSh2Yi50ZXN0KGIudXJsKT9cIiZcIjpcIj9cIikrYi5qc29ucCtcIj1cIitlKSxiLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXT1mdW5jdGlvbigpe3JldHVybiBnfHxyLmVycm9yKGUrXCIgd2FzIG5vdCBjYWxsZWRcIiksZ1swXX0sYi5kYXRhVHlwZXNbMF09XCJqc29uXCIsZj1hW2VdLGFbZV09ZnVuY3Rpb24oKXtnPWFyZ3VtZW50c30sZC5hbHdheXMoZnVuY3Rpb24oKXt2b2lkIDA9PT1mP3IoYSkucmVtb3ZlUHJvcChlKTphW2VdPWYsYltlXSYmKGIuanNvbnBDYWxsYmFjaz1jLmpzb25wQ2FsbGJhY2ssVGIucHVzaChlKSksZyYmci5pc0Z1bmN0aW9uKGYpJiZmKGdbMF0pLGc9Zj12b2lkIDB9KSxcInNjcmlwdFwifSksby5jcmVhdGVIVE1MRG9jdW1lbnQ9ZnVuY3Rpb24oKXt2YXIgYT1kLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKS5ib2R5O3JldHVybiBhLmlubmVySFRNTD1cIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCIsMj09PWEuY2hpbGROb2Rlcy5sZW5ndGh9KCksci5wYXJzZUhUTUw9ZnVuY3Rpb24oYSxiLGMpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBhKXJldHVybltdO1wiYm9vbGVhblwiPT10eXBlb2YgYiYmKGM9YixiPSExKTt2YXIgZSxmLGc7cmV0dXJuIGJ8fChvLmNyZWF0ZUhUTUxEb2N1bWVudD8oYj1kLmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcIlwiKSxlPWIuY3JlYXRlRWxlbWVudChcImJhc2VcIiksZS5ocmVmPWQubG9jYXRpb24uaHJlZixiLmhlYWQuYXBwZW5kQ2hpbGQoZSkpOmI9ZCksZj1DLmV4ZWMoYSksZz0hYyYmW10sZj9bYi5jcmVhdGVFbGVtZW50KGZbMV0pXTooZj1xYShbYV0sYixnKSxnJiZnLmxlbmd0aCYmcihnKS5yZW1vdmUoKSxyLm1lcmdlKFtdLGYuY2hpbGROb2RlcykpfSxyLmZuLmxvYWQ9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkLGUsZixnPXRoaXMsaD1hLmluZGV4T2YoXCIgXCIpO3JldHVybiBoPi0xJiYoZD1wYihhLnNsaWNlKGgpKSxhPWEuc2xpY2UoMCxoKSksci5pc0Z1bmN0aW9uKGIpPyhjPWIsYj12b2lkIDApOmImJlwib2JqZWN0XCI9PXR5cGVvZiBiJiYoZT1cIlBPU1RcIiksZy5sZW5ndGg+MCYmci5hamF4KHt1cmw6YSx0eXBlOmV8fFwiR0VUXCIsZGF0YVR5cGU6XCJodG1sXCIsZGF0YTpifSkuZG9uZShmdW5jdGlvbihhKXtmPWFyZ3VtZW50cyxnLmh0bWwoZD9yKFwiPGRpdj5cIikuYXBwZW5kKHIucGFyc2VIVE1MKGEpKS5maW5kKGQpOmEpfSkuYWx3YXlzKGMmJmZ1bmN0aW9uKGEsYil7Zy5lYWNoKGZ1bmN0aW9uKCl7Yy5hcHBseSh0aGlzLGZ8fFthLnJlc3BvbnNlVGV4dCxiLGFdKX0pfSksdGhpc30sci5lYWNoKFtcImFqYXhTdGFydFwiLFwiYWpheFN0b3BcIixcImFqYXhDb21wbGV0ZVwiLFwiYWpheEVycm9yXCIsXCJhamF4U3VjY2Vzc1wiLFwiYWpheFNlbmRcIl0sZnVuY3Rpb24oYSxiKXtyLmZuW2JdPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLm9uKGIsYSl9fSksci5leHByLnBzZXVkb3MuYW5pbWF0ZWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIHIuZ3JlcChyLnRpbWVycyxmdW5jdGlvbihiKXtyZXR1cm4gYT09PWIuZWxlbX0pLmxlbmd0aH0sci5vZmZzZXQ9e3NldE9mZnNldDpmdW5jdGlvbihhLGIsYyl7dmFyIGQsZSxmLGcsaCxpLGosaz1yLmNzcyhhLFwicG9zaXRpb25cIiksbD1yKGEpLG09e307XCJzdGF0aWNcIj09PWsmJihhLnN0eWxlLnBvc2l0aW9uPVwicmVsYXRpdmVcIiksaD1sLm9mZnNldCgpLGY9ci5jc3MoYSxcInRvcFwiKSxpPXIuY3NzKGEsXCJsZWZ0XCIpLGo9KFwiYWJzb2x1dGVcIj09PWt8fFwiZml4ZWRcIj09PWspJiYoZitpKS5pbmRleE9mKFwiYXV0b1wiKT4tMSxqPyhkPWwucG9zaXRpb24oKSxnPWQudG9wLGU9ZC5sZWZ0KTooZz1wYXJzZUZsb2F0KGYpfHwwLGU9cGFyc2VGbG9hdChpKXx8MCksci5pc0Z1bmN0aW9uKGIpJiYoYj1iLmNhbGwoYSxjLHIuZXh0ZW5kKHt9LGgpKSksbnVsbCE9Yi50b3AmJihtLnRvcD1iLnRvcC1oLnRvcCtnKSxudWxsIT1iLmxlZnQmJihtLmxlZnQ9Yi5sZWZ0LWgubGVmdCtlKSxcInVzaW5nXCJpbiBiP2IudXNpbmcuY2FsbChhLG0pOmwuY3NzKG0pfX0sci5mbi5leHRlbmQoe29mZnNldDpmdW5jdGlvbihhKXtpZihhcmd1bWVudHMubGVuZ3RoKXJldHVybiB2b2lkIDA9PT1hP3RoaXM6dGhpcy5lYWNoKGZ1bmN0aW9uKGIpe3Iub2Zmc2V0LnNldE9mZnNldCh0aGlzLGEsYil9KTt2YXIgYixjLGQsZSxmPXRoaXNbMF07aWYoZilyZXR1cm4gZi5nZXRDbGllbnRSZWN0cygpLmxlbmd0aD8oZD1mLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGI9Zi5vd25lckRvY3VtZW50LGM9Yi5kb2N1bWVudEVsZW1lbnQsZT1iLmRlZmF1bHRWaWV3LHt0b3A6ZC50b3ArZS5wYWdlWU9mZnNldC1jLmNsaWVudFRvcCxsZWZ0OmQubGVmdCtlLnBhZ2VYT2Zmc2V0LWMuY2xpZW50TGVmdH0pOnt0b3A6MCxsZWZ0OjB9fSxwb3NpdGlvbjpmdW5jdGlvbigpe2lmKHRoaXNbMF0pe3ZhciBhLGIsYz10aGlzWzBdLGQ9e3RvcDowLGxlZnQ6MH07cmV0dXJuXCJmaXhlZFwiPT09ci5jc3MoYyxcInBvc2l0aW9uXCIpP2I9Yy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTooYT10aGlzLm9mZnNldFBhcmVudCgpLGI9dGhpcy5vZmZzZXQoKSxCKGFbMF0sXCJodG1sXCIpfHwoZD1hLm9mZnNldCgpKSxkPXt0b3A6ZC50b3Arci5jc3MoYVswXSxcImJvcmRlclRvcFdpZHRoXCIsITApLGxlZnQ6ZC5sZWZ0K3IuY3NzKGFbMF0sXCJib3JkZXJMZWZ0V2lkdGhcIiwhMCl9KSx7dG9wOmIudG9wLWQudG9wLXIuY3NzKGMsXCJtYXJnaW5Ub3BcIiwhMCksbGVmdDpiLmxlZnQtZC5sZWZ0LXIuY3NzKGMsXCJtYXJnaW5MZWZ0XCIsITApfX19LG9mZnNldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe3ZhciBhPXRoaXMub2Zmc2V0UGFyZW50O3doaWxlKGEmJlwic3RhdGljXCI9PT1yLmNzcyhhLFwicG9zaXRpb25cIikpYT1hLm9mZnNldFBhcmVudDtyZXR1cm4gYXx8cmF9KX19KSxyLmVhY2goe3Njcm9sbExlZnQ6XCJwYWdlWE9mZnNldFwiLHNjcm9sbFRvcDpcInBhZ2VZT2Zmc2V0XCJ9LGZ1bmN0aW9uKGEsYil7dmFyIGM9XCJwYWdlWU9mZnNldFwiPT09YjtyLmZuW2FdPWZ1bmN0aW9uKGQpe3JldHVybiBUKHRoaXMsZnVuY3Rpb24oYSxkLGUpe3ZhciBmO3JldHVybiByLmlzV2luZG93KGEpP2Y9YTo5PT09YS5ub2RlVHlwZSYmKGY9YS5kZWZhdWx0Vmlldyksdm9pZCAwPT09ZT9mP2ZbYl06YVtkXTp2b2lkKGY/Zi5zY3JvbGxUbyhjP2YucGFnZVhPZmZzZXQ6ZSxjP2U6Zi5wYWdlWU9mZnNldCk6YVtkXT1lKX0sYSxkLGFyZ3VtZW50cy5sZW5ndGgpfX0pLHIuZWFjaChbXCJ0b3BcIixcImxlZnRcIl0sZnVuY3Rpb24oYSxiKXtyLmNzc0hvb2tzW2JdPVBhKG8ucGl4ZWxQb3NpdGlvbixmdW5jdGlvbihhLGMpe2lmKGMpcmV0dXJuIGM9T2EoYSxiKSxNYS50ZXN0KGMpP3IoYSkucG9zaXRpb24oKVtiXStcInB4XCI6Y30pfSksci5lYWNoKHtIZWlnaHQ6XCJoZWlnaHRcIixXaWR0aDpcIndpZHRoXCJ9LGZ1bmN0aW9uKGEsYil7ci5lYWNoKHtwYWRkaW5nOlwiaW5uZXJcIithLGNvbnRlbnQ6YixcIlwiOlwib3V0ZXJcIithfSxmdW5jdGlvbihjLGQpe3IuZm5bZF09ZnVuY3Rpb24oZSxmKXt2YXIgZz1hcmd1bWVudHMubGVuZ3RoJiYoY3x8XCJib29sZWFuXCIhPXR5cGVvZiBlKSxoPWN8fChlPT09ITB8fGY9PT0hMD9cIm1hcmdpblwiOlwiYm9yZGVyXCIpO3JldHVybiBUKHRoaXMsZnVuY3Rpb24oYixjLGUpe3ZhciBmO3JldHVybiByLmlzV2luZG93KGIpPzA9PT1kLmluZGV4T2YoXCJvdXRlclwiKT9iW1wiaW5uZXJcIithXTpiLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtcImNsaWVudFwiK2FdOjk9PT1iLm5vZGVUeXBlPyhmPWIuZG9jdW1lbnRFbGVtZW50LE1hdGgubWF4KGIuYm9keVtcInNjcm9sbFwiK2FdLGZbXCJzY3JvbGxcIithXSxiLmJvZHlbXCJvZmZzZXRcIithXSxmW1wib2Zmc2V0XCIrYV0sZltcImNsaWVudFwiK2FdKSk6dm9pZCAwPT09ZT9yLmNzcyhiLGMsaCk6ci5zdHlsZShiLGMsZSxoKX0sYixnP2U6dm9pZCAwLGcpfX0pfSksci5mbi5leHRlbmQoe2JpbmQ6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiB0aGlzLm9uKGEsbnVsbCxiLGMpfSx1bmJpbmQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy5vZmYoYSxudWxsLGIpfSxkZWxlZ2F0ZTpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gdGhpcy5vbihiLGEsYyxkKX0sdW5kZWxlZ2F0ZTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIDE9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMub2ZmKGEsXCIqKlwiKTp0aGlzLm9mZihiLGF8fFwiKipcIixjKX19KSxyLmhvbGRSZWFkeT1mdW5jdGlvbihhKXthP3IucmVhZHlXYWl0Kys6ci5yZWFkeSghMCl9LHIuaXNBcnJheT1BcnJheS5pc0FycmF5LHIucGFyc2VKU09OPUpTT04ucGFyc2Usci5ub2RlTmFtZT1CLFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZCYmZGVmaW5lKFwianF1ZXJ5XCIsW10sZnVuY3Rpb24oKXtyZXR1cm4gcn0pO3ZhciBWYj1hLmpRdWVyeSxXYj1hLiQ7cmV0dXJuIHIubm9Db25mbGljdD1mdW5jdGlvbihiKXtyZXR1cm4gYS4kPT09ciYmKGEuJD1XYiksYiYmYS5qUXVlcnk9PT1yJiYoYS5qUXVlcnk9VmIpLHJ9LGJ8fChhLmpRdWVyeT1hLiQ9cikscn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwdWJsaWMvc2NyaXB0cy9saWIvanF1ZXJ5LmpzIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),

/***/ 1:
/*!*****************************************!*\
  !*** ./public/scripts/widget/lizard.js ***!
  \*****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar $ = __webpack_require__(/*! ../lib/jquery */ 0);\n\nvar Lizard = {\n\n\tprompt: function prompt(obj, determine, cancel) {\n\n\t\tvar tips = obj.tips;\n\n\t\tvar btn = obj.btn;\n\n\t\tvar tpl = '\\\n\t\t\t  <div class=\"layui-poup\"></div>\\\n\t\t\t\t<div class=\"layui-layer\">\\\n\t\t\t\t\t<div class=\"layui-layer-title\"></div>\\\n\t\t\t\t\t<div class=\"layui-layer-content\">' + tips + '</div>\\\n\t\t\t\t\t<span class=\"layui-layer-setwin J_close\"></span>\\\n\t\t\t\t\t<div class=\"layui-layer-btn layui-layer-btn-\">\\\n\t\t\t\t\t\t<a href=\"javascript:;\" class=\"layui-layer-btn0\">' + btn[0] + '</a>\\\n\t\t\t\t\t\t<a href=\"javascript:;\" class=\"layui-layer-btn1 J_close\">' + btn[1] + '</a>\\\n\t\t\t\t\t</div>\\\n\t\t\t</div>';\n\n\t\t$('body').append(tpl);\n\n\t\t$('.layui-layer').css({\n\t\t\t'marginLeft': -$('.layui-layer').width() / 2,\n\t\t\t'marginTop': -$('.layui-layer').height() / 2\n\t\t});\n\n\t\t$('.layui-layer-btn0').click(function () {\n\n\t\t\tdetermine();\n\n\t\t\t$('.layui-poup').remove();\n\n\t\t\t$('.layui-layer').remove();\n\t\t});\n\n\t\t$('.J_close').click(function () {\n\n\t\t\tcancel && cancel();\n\n\t\t\t$('.layui-poup').remove();\n\n\t\t\t$('.layui-layer').remove();\n\t\t});\n\t},\n\tshowToast: function showToast(value) {\n\n\t\tvar tpl = '<div class=\"mask\"></div> <div class=\"mask-ui\"><span>' + value + '</span></div>';\n\n\t\tif ($('.mask').length) {\n\t\t\treturn;\n\t\t}\n\n\t\t$('body').append(tpl);\n\n\t\t$('.mask-ui').css({\n\t\t\t'marginLeft': -$('.mask-ui').width() / 2,\n\t\t\t'marginTop': -$('.mask-ui').height() / 2\n\t\t});\n\n\t\tsetTimeout(function () {\n\n\t\t\t$('.mask-ui').remove();\n\n\t\t\t$('.mask').remove();\n\t\t}, 2000);\n\t},\n\tcheckNumber: function checkNumber(theObj) {\n\t\tvar reg = /^[0-9]+.?[0-9]*$/;\n\t\tif (reg.test(theObj)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\ttips: function tips(obj) {\n\n\t\tvar eleCont = obj.ele;\n\n\t\tvar text = obj.text;\n\n\t\tvar eleHeight = $(eleCont).outerHeight(true);\n\n\t\tvar eleWidth = $(eleCont).outerWidth(true);\n\n\t\tvar tpl = '\\\n\t\t\t\t<div class=\"tips_cont tips_top\">\\\n\t\t\t\t\t<span>' + text + '</span>\\\n\t\t\t\t</div>\\\n\t\t\t';\n\n\t\t$('body').append(tpl);\n\n\t\tvar tipsWidth = $('.tips_cont').outerWidth(true);\n\n\t\tvar top = $(eleCont).offset().top - eleHeight - 25;\n\n\t\tvar left = $(eleCont).offset().left - (tipsWidth - 20) / 2;\n\n\t\t$('.tips_cont').css({ 'top': top, 'left': left });\n\n\t\tsetTimeout(function () {\n\n\t\t\t$('.tips_cont').remove();\n\t\t}, 3000);\n\t},\n\n\tquery: function query() {\n\n\t\tvar strParame = arguments[0];\n\n\t\tvar args = new Object();\n\n\t\tvar query = location.search.substring(1).toLowerCase(); // Get query string\n\n\t\tvar pairs = query.split(\"&\"); // Break at ampersand\n\n\t\tfor (var i = 0; i < pairs.length; i++) {\n\n\t\t\tvar pos = pairs[i].indexOf('='); // Look for \"name=value\"\n\n\t\t\tif (pos == -1) continue; // If not found, skip\n\n\t\t\tvar argname = pairs[i].substring(0, pos); // Extract the name\n\n\t\t\tvar value = pairs[i].substring(pos + 1); // Extract the value\n\n\t\t\tvalue = decodeURIComponent(value); // Decode it, if needed\n\n\t\t\targs[argname] = value; // Store as a property\n\t\t}\n\t\tif (strParame == undefined) {\n\n\t\t\treturn args;\n\t\t} else {\n\n\t\t\treturn args[strParame.toLowerCase()]; // Return the object\n\t\t}\n\t},\n\n\tdiffArray: function diffArray(arr1, arr2) {\n\n\t\tvar arr = arr1.filter(function (item) {\n\n\t\t\treturn arr2.indexOf(item) < 0;\n\t\t});\n\n\t\treturn arr;\n\t},\n\tqueryStringify: function queryStringify(obj) {\n\n\t\tfunction toQueryPair(key, value) {\n\t\t\tif (typeof value == 'undefined') {\n\t\t\t\treturn key;\n\t\t\t}\n\t\t\treturn key + '=' + encodeURIComponent(value === null ? '' : String(value));\n\t\t}\n\t\tvar ret = [];\n\t\tfor (var key in obj) {\n\t\t\tkey = encodeURIComponent(key);\n\t\t\tvar values = obj[key];\n\t\t\tif (values && values.constructor == Array) {\n\t\t\t\t//\n\t\t\t\tvar queryValues = [];\n\n\t\t\t\tfor (var i = 0, len = values.length, value; i < len; i++) {\n\t\t\t\t\tvalue = values[i];\n\t\t\t\t\tqueryValues.push(toQueryPair(key, value));\n\t\t\t\t}\n\t\t\t\tret = ret.concat(queryValues);\n\t\t\t} else {\n\t\t\t\t//\n\t\t\t\tret.push(toQueryPair(key, values));\n\t\t\t}\n\t\t}\n\t\treturn ret.join('&');\n\t},\n\n\tajax: function ajax(obj) {\n\n\t\tvar resData = obj.data;\n\n\t\tvar jwt = Lizard.getCookie('jwt');\n\n\t\tvar org_id = Lizard.getCookie('org_id');\n\n\t\tvar async = obj.async == false ? obj.async : true;\n\n\t\t$.ajax({\n\t\t\ttype: obj.type,\n\t\t\tdataType: 'json',\n\t\t\turl: obj.url,\n\t\t\tasync: async,\n\t\t\tdata: resData,\n\t\t\tbeforeSend: function beforeSend(xhr) {\n\t\t\t\txhr.setRequestHeader(\"Authorization\", 'Bearer ' + jwt);\n\t\t\t\txhr.setRequestHeader('X-Org', org_id);\n\t\t\t},\n\t\t\tsuccess: function success(data) {\n\n\t\t\t\tobj.success(data);\n\t\t\t},\n\t\t\terror: function error(_error) {\n\n\t\t\t\tif (obj.error) {\n\n\t\t\t\t\tobj.error();\n\t\t\t\t} else {\n\n\t\t\t\t\tif (_error) {\n\n\t\t\t\t\t\tvar msg = JSON.parse(_error.responseText);\n\n\t\t\t\t\t\tLizard.showToast(msg.error.message);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t},\n\tgetDateDiff: function getDateDiff(dateTimeStamp) {\n\n\t\tdateTimeStamp = Date.parse(dateTimeStamp.replace(/-/gi, \"/\"));\n\t\tvar minute = 1000 * 60;\n\t\tvar hour = minute * 60;\n\t\tvar day = hour * 24;\n\t\tvar halfamonth = day * 15;\n\t\tvar month = day * 30;\n\t\tvar now = new Date().getTime();\n\t\tvar diffValue = now - dateTimeStamp;\n\t\tif (diffValue < 0) {\n\t\t\treturn;\n\t\t}\n\t\tvar monthC = diffValue / month;\n\t\tvar weekC = diffValue / (7 * day);\n\t\tvar dayC = diffValue / day;\n\t\tvar hourC = diffValue / hour;\n\t\tvar minC = diffValue / minute;\n\n\t\tvar result = \"\";\n\t\tif (monthC >= 1) {\n\t\t\tresult += parseInt(monthC) + \"\";\n\t\t} else if (weekC >= 1) {\n\t\t\tresult += parseInt(weekC) + \"\";\n\t\t} else if (dayC >= 1) {\n\t\t\tresult += parseInt(dayC) + \"\";\n\t\t} else if (hourC >= 1) {\n\t\t\tresult += parseInt(hourC) + \"\";\n\t\t} else if (minC >= 1) {\n\t\t\tresult += parseInt(minC) + \"\";\n\t\t} else result = \"\";\n\t\treturn result;\n\t},\n\tgetPathName: function getPathName() {\n\n\t\tvar strUrl = document.location.toString();\n\n\t\tvar arrObj = strUrl.split('//');\n\n\t\tvar start = arrObj[1].indexOf('/');\n\n\t\treturn arrObj[1].substring(start);\n\t},\n\n\t/**\n  * Date Date String\n  * (M)(d)12(h)24(H)(m)(s)(E)(q)  1-2 \n  * (y) 1-4 (S) 1 ( 1-3 )\n  * eg:\n  * (new Date().getTime(,\"yyyy-MM-dd hh:mm:ss.S\") ==> 2006-07-02 08:09:04.423\n  * (new Date().getTime(,\"yyyy-MM-dd E HH:mm:ss\") ==> 2009-03-10  20:09:04\n  * (new Date().getTime(,\"yyyy-MM-dd EE hh:mm:ss\") ==> 2009-03-10  08:09:04\n  * (new Date().getTime(,\"yyyy-MM-dd EEE hh:mm:ss\") ==> 2009-03-10  08:09:04\n  * (new Date().getTime(,\"yyyy-M-d h:m:s.S\") ==> 2006-7-2 8:9:4.18\n  */\n\tdateFormat: function dateFormat(tiems, fmt) {\n\n\t\tvar date = new Date(tiems);\n\n\t\tvar o = {\n\t\t\t\"M+\": date.getMonth() + 1, //\n\t\t\t\"d+\": date.getDate(), //\n\t\t\t\"h+\": date.getHours() % 12 == 0 ? 12 : date.getHours() % 12, //\n\t\t\t\"H+\": date.getHours(), //\n\t\t\t\"m+\": date.getMinutes(), //\n\t\t\t\"s+\": date.getSeconds(), //\n\t\t\t\"q+\": Math.floor((date.getMonth() + 3) / 3), //\n\t\t\t\"S\": date.getMilliseconds() //\n\t\t};\n\t\tvar week = {\n\t\t\t\"0\": '\\u65E5',\n\t\t\t\"1\": '\\u4E00',\n\t\t\t\"2\": '\\u4E8C',\n\t\t\t\"3\": '\\u4E09',\n\t\t\t\"4\": '\\u56DB',\n\t\t\t\"5\": '\\u4E94',\n\t\t\t\"6\": '\\u516D'\n\t\t};\n\t\tif (/(y+)/.test(fmt)) {\n\t\t\tfmt = fmt.replace(RegExp.$1, (date.getFullYear() + \"\").substr(4 - RegExp.$1.length));\n\t\t}\n\t\tif (/(E+)/.test(fmt)) {\n\t\t\tfmt = fmt.replace(RegExp.$1, (RegExp.$1.length > 1 ? RegExp.$1.length > 2 ? '\\u661F\\u671F' : '\\u5468' : \"\") + week[date.getDay() + \"\"]);\n\t\t}\n\t\tfor (var k in o) {\n\t\t\tif (new RegExp(\"(\" + k + \")\").test(fmt)) {\n\t\t\t\tfmt = fmt.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : (\"00\" + o[k]).substr((\"\" + o[k]).length));\n\t\t\t}\n\t\t}\n\t\treturn fmt;\n\t},\n\t//cookies\n\tsetCookie: function setCookie(name, value, times) {\n\t\tvar exp = new Date();\n\t\texp.setTime(exp.getTime() + times);\n\t\tdocument.cookie = name + \"=\" + escape(value) + \";expires=\" + exp.toGMTString() + \";path=/\";\n\t},\n\t//cookies\n\tgetCookie: function getCookie(name) {\n\t\tvar arr,\n\t\t    reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n\t\tif (arr = document.cookie.match(reg)) {\n\t\t\treturn unescape(arr[2]);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t},\n\n\t//cookies\n\tremoveCookie: function removeCookie(name) {\n\t\tvar exp = new Date();\n\t\texp.setTime(exp.getTime() - 1);\n\t\tvar cval = this.getCookie(name);\n\t\tif (cval !== null) document.cookie = name + \"=\" + cval + \";expires=\" + exp.toGMTString() + \";path=/\";\n\t},\n\n\tclearCookie: function clearCookie() {\n\t\tvar keys = document.cookie.match(/[^ =;]+(?=\\=)/g);\n\t\tif (keys) {\n\t\t\tfor (var i = keys.length; i--;) {\n\t\t\t\tdocument.cookie = keys[i] + '=0;expires=' + new Date().toGMTString() + \";path=/\";\n\t\t\t}\n\t\t}\n\t},\n\tthrottle: function throttle(func, wait, mustRun) {\n\t\tvar timeout,\n\t\t    startTime = new Date();\n\n\t\treturn function () {\n\t\t\tvar context = this,\n\t\t\t    args = arguments,\n\t\t\t    curTime = new Date();\n\n\t\t\tclearTimeout(timeout);\n\t\t\t//  handler\n\t\t\tif (curTime - startTime >= mustRun) {\n\n\t\t\t\tfunc.apply(context, args);\n\n\t\t\t\tstartTime = curTime;\n\n\t\t\t\t// \n\t\t\t} else {\n\n\t\t\t\ttimeout = setTimeout(func, wait);\n\t\t\t}\n\t\t};\n\t}\n};\nwindow.Lizard = Lizard;\nmodule.exports = Lizard;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9wdWJsaWMvc2NyaXB0cy93aWRnZXQvbGl6YXJkLmpzP2Q1NDkiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cblx0dmFyICQgPSByZXF1aXJlKCcuLi9saWIvanF1ZXJ5Jyk7XG5cblx0dmFyIExpemFyZCA9IHtcblxuXHRcdHByb21wdDogZnVuY3Rpb24gKG9iaixkZXRlcm1pbmUsY2FuY2VsKXtcblxuXHRcdFx0dmFyIHRpcHMgPSBvYmoudGlwcztcblxuXHRcdFx0dmFyIGJ0biA9IG9iai5idG47XG5cblx0XHRcdHZhciB0cGwgPSAnXFxcblx0XHRcdCAgPGRpdiBjbGFzcz1cImxheXVpLXBvdXBcIj48L2Rpdj5cXFxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwibGF5dWktbGF5ZXJcIj5cXFxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJsYXl1aS1sYXllci10aXRsZVwiPuaPkOekujwvZGl2PlxcXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImxheXVpLWxheWVyLWNvbnRlbnRcIj4nKyB0aXBzICsnPC9kaXY+XFxcblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImxheXVpLWxheWVyLXNldHdpbiBKX2Nsb3NlXCI+PC9zcGFuPlxcXG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImxheXVpLWxheWVyLWJ0biBsYXl1aS1sYXllci1idG4tXCI+XFxcblx0XHRcdFx0XHRcdDxhIGhyZWY9XCJqYXZhc2NyaXB0OjtcIiBjbGFzcz1cImxheXVpLWxheWVyLWJ0bjBcIj4nKyBidG5bMF0rJzwvYT5cXFxuXHRcdFx0XHRcdFx0PGEgaHJlZj1cImphdmFzY3JpcHQ6O1wiIGNsYXNzPVwibGF5dWktbGF5ZXItYnRuMSBKX2Nsb3NlXCI+JysgYnRuIFsxXSsnPC9hPlxcXG5cdFx0XHRcdFx0PC9kaXY+XFxcblx0XHRcdDwvZGl2Pic7XG5cblx0XHRcdCQoJ2JvZHknKS5hcHBlbmQodHBsKTtcblxuXHRcdFx0JCgnLmxheXVpLWxheWVyJykuY3NzKHtcblx0XHRcdFx0J21hcmdpbkxlZnQnOi1cdCQoJy5sYXl1aS1sYXllcicpLndpZHRoKCkgLyAyLFxuXHRcdFx0XHQnbWFyZ2luVG9wJzotICQoJy5sYXl1aS1sYXllcicpLmhlaWdodCgpIC8gMlxuXHRcdFx0fSlcblxuXHRcdFx0JCgnLmxheXVpLWxheWVyLWJ0bjAnKS5jbGljayhmdW5jdGlvbigpe1xuXG5cdFx0XHRcdGRldGVybWluZSgpO1xuXG5cdFx0XHRcdCQoJy5sYXl1aS1wb3VwJykucmVtb3ZlKCk7XG5cblx0XHRcdFx0JCgnLmxheXVpLWxheWVyJykucmVtb3ZlKCk7XG5cblx0XHRcdH0pXG5cblx0XHRcdCQoJy5KX2Nsb3NlJykuY2xpY2soZnVuY3Rpb24oKXtcblxuXHRcdFx0XHRjYW5jZWwgJiYgY2FuY2VsKCk7XG5cblx0XHRcdFx0JCgnLmxheXVpLXBvdXAnKS5yZW1vdmUoKTtcblxuXHRcdFx0XHQkKCcubGF5dWktbGF5ZXInKS5yZW1vdmUoKTtcblxuXHRcdFx0fSlcblx0XHR9LFxuXHRcdHNob3dUb2FzdDpmdW5jdGlvbih2YWx1ZSl7XG5cblx0XHRcdHZhciB0cGw9JzxkaXYgY2xhc3M9XCJtYXNrXCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJtYXNrLXVpXCI+PHNwYW4+Jyt2YWx1ZSsnPC9zcGFuPjwvZGl2Pic7XG5cblx0XHRcdGlmICgkKCcubWFzaycpLmxlbmd0aCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdCQoJ2JvZHknKS5hcHBlbmQodHBsKTtcblxuXHRcdFx0JCgnLm1hc2stdWknKS5jc3Moe1xuXHRcdFx0XHQnbWFyZ2luTGVmdCc6IC0gJCgnLm1hc2stdWknKS53aWR0aCgpLzIsXG5cdFx0XHRcdCdtYXJnaW5Ub3AnOiAtICQoJy5tYXNrLXVpJykuaGVpZ2h0KCkvMlxuXHRcdFx0fSk7XG5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuXHRcdFx0XHQkKCcubWFzay11aScpLnJlbW92ZSgpO1xuXG5cdFx0XHRcdCQoJy5tYXNrJykucmVtb3ZlKCk7XG5cblx0XHRcdH0sMjAwMClcblx0XHR9LFxuXHRcdGNoZWNrTnVtYmVyOiBmdW5jdGlvbiAodGhlT2JqKSB7XG5cdFx0ICB2YXIgcmVnID0gL15bMC05XSsuP1swLTldKiQvO1xuXHRcdCAgaWYgKHJlZy50ZXN0KHRoZU9iaikpIHtcblx0XHQgICAgcmV0dXJuIHRydWU7XG5cdFx0ICB9XG5cdFx0ICByZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHR0aXBzOmZ1bmN0aW9uKG9iail7XG5cblx0XHRcdHZhciBlbGVDb250ID0gb2JqLmVsZTtcblxuXHRcdFx0dmFyIHRleHQgPSBvYmoudGV4dDtcblxuXHRcdFx0dmFyIGVsZUhlaWdodCA9ICQoZWxlQ29udCkub3V0ZXJIZWlnaHQodHJ1ZSk7XG5cblx0XHRcdHZhciBlbGVXaWR0aCA9ICQoZWxlQ29udCkub3V0ZXJXaWR0aCh0cnVlKTtcblxuXG5cdFx0XHR2YXIgdHBsID0gJ1xcXG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJ0aXBzX2NvbnQgdGlwc190b3BcIj5cXFxuXHRcdFx0XHRcdDxzcGFuPicrdGV4dCsnPC9zcGFuPlxcXG5cdFx0XHRcdDwvZGl2PlxcXG5cdFx0XHQnO1xuXG5cdFx0XHQkKCdib2R5JykuYXBwZW5kKHRwbCk7XG5cblx0XHRcdHZhciB0aXBzV2lkdGggID0gJCgnLnRpcHNfY29udCcpLm91dGVyV2lkdGgodHJ1ZSk7XG5cblx0XHRcdHZhciB0b3AgPSAkKGVsZUNvbnQpLm9mZnNldCgpLnRvcCAtIGVsZUhlaWdodCAtIDI1O1xuXG5cdFx0XHR2YXIgbGVmdCA9ICQoZWxlQ29udCkub2Zmc2V0KCkubGVmdCAtICh0aXBzV2lkdGggLSAyMCkvMjtcblxuXHRcdFx0JCgnLnRpcHNfY29udCcpLmNzcyh7J3RvcCc6dG9wLCdsZWZ0JzpsZWZ0fSk7XG5cblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuXHRcdFx0XHQkKCcudGlwc19jb250JykucmVtb3ZlKCk7XG5cblx0XHRcdH0sMzAwMCk7XG5cblx0XHR9LFxuXG5cdFx0cXVlcnk6IGZ1bmN0aW9uKCl7XG5cblx0XHRcdHZhciBzdHJQYXJhbWUgPSBhcmd1bWVudHNbMF07XG5cblx0XHRcdHZhciBhcmdzID0gbmV3IE9iamVjdCgpO1xuXG5cdFx0XHR2YXIgcXVlcnkgPSBsb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpLnRvTG93ZXJDYXNlKCk7IC8vIEdldCBxdWVyeSBzdHJpbmdcblxuXHRcdFx0dmFyIHBhaXJzID0gcXVlcnkuc3BsaXQoXCImXCIpOyAvLyBCcmVhayBhdCBhbXBlcnNhbmRcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuXG5cdFx0XHRcdHZhciBwb3MgPSBwYWlyc1tpXS5pbmRleE9mKCc9Jyk7IC8vIExvb2sgZm9yIFwibmFtZT12YWx1ZVwiXG5cblx0XHRcdFx0aWYgKHBvcyA9PSAtMSkgY29udGludWU7IC8vIElmIG5vdCBmb3VuZCwgc2tpcFxuXG5cdFx0XHRcdHZhciBhcmduYW1lID0gcGFpcnNbaV0uc3Vic3RyaW5nKDAsIHBvcyk7IC8vIEV4dHJhY3QgdGhlIG5hbWVcblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBwYWlyc1tpXS5zdWJzdHJpbmcocG9zICsgMSk7IC8vIEV4dHJhY3QgdGhlIHZhbHVlXG5cblx0XHRcdFx0dmFsdWU9ZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTsgLy8gRGVjb2RlIGl0LCBpZiBuZWVkZWRcblxuXHRcdFx0XHRhcmdzW2FyZ25hbWVdID0gdmFsdWU7IC8vIFN0b3JlIGFzIGEgcHJvcGVydHlcblx0XHRcdH1cblx0XHRcdGlmIChzdHJQYXJhbWUgPT0gdW5kZWZpbmVkKSB7XG5cblx0XHRcdFx0cmV0dXJuIGFyZ3M7XG5cblx0XHRcdH1lbHNlIHtcblxuXHRcdFx0XHRyZXR1cm4gYXJnc1tzdHJQYXJhbWUudG9Mb3dlckNhc2UoKV07IC8vIFJldHVybiB0aGUgb2JqZWN0XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGRpZmZBcnJheTogZnVuY3Rpb24oYXJyMSxhcnIyKXtcblxuXHRcdFx0dmFyIGFyciAgPSBhcnIxLmZpbHRlcihmdW5jdGlvbihpdGVtKSB7XG5cblx0XHRcdFx0cmV0dXJuIGFycjIuaW5kZXhPZihpdGVtKSA8IDA7XG5cblx0XHRcdH0pXG5cblx0XHRcdHJldHVybiBhcnI7XG5cblx0XHR9LFxuXHRcdHF1ZXJ5U3RyaW5naWZ5OiBmdW5jdGlvbiAob2JqKSB7XG5cblx0XHRcdFx0ZnVuY3Rpb24gdG9RdWVyeVBhaXIoa2V5LCB2YWx1ZSkge1xuXHRcdFx0ICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdCAgICAgICAgcmV0dXJuIGtleTtcblx0XHRcdCAgICB9XG5cdFx0ICAgIFx0cmV0dXJuIGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSA9PT0gbnVsbCA/ICcnOiBTdHJpbmcodmFsdWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcmV0ID0gW107XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRcdFx0ICAgIGtleSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xuXHRcdFx0XHQgICAgdmFyIHZhbHVlcyA9IG9ialtrZXldO1xuXHRcdFx0XHQgICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMuY29uc3RydWN0b3IgPT0gQXJyYXkpIHsgLy/mlbDnu4Rcblx0XHRcdFx0ICAgICAgICB2YXIgcXVlcnlWYWx1ZXMgPSBbXTtcblxuXHRcdFx0XHQgICAgICAgIGZvciAodmFyIGkgPSAwLFxuXHRcdFx0XHQgICAgICAgIGxlbiA9IHZhbHVlcy5sZW5ndGgsXG5cdFx0XHRcdCAgICAgICAgdmFsdWU7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcblx0XHRcdFx0ICAgICAgICAgICAgcXVlcnlWYWx1ZXMucHVzaCh0b1F1ZXJ5UGFpcihrZXksIHZhbHVlKSk7XG5cdFx0XHRcdCAgICAgICAgfVxuXHRcdFx0XHQgICAgICAgIHJldCA9IHJldC5jb25jYXQocXVlcnlWYWx1ZXMpO1xuXG5cdFx0XHRcdCAgICB9IGVsc2UgeyAvL+Wtl+espuS4slxuXHRcdFx0XHQgICAgICAgIHJldC5wdXNoKHRvUXVlcnlQYWlyKGtleSwgdmFsdWVzKSk7XG5cdFx0XHRcdCAgICB9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJldC5qb2luKCcmJyk7XG5cblx0XHR9LFxuXG5cdFx0YWpheDogZnVuY3Rpb24ob2JqKSB7XG5cblx0XHRcdHZhciByZXNEYXRhID0gb2JqLmRhdGE7XG5cblx0XHRcdHZhciBqd3QgPSBMaXphcmQuZ2V0Q29va2llKCdqd3QnKTtcblxuXHRcdFx0dmFyIG9yZ19pZCA9IExpemFyZC5nZXRDb29raWUoJ29yZ19pZCcpO1xuXG5cdFx0XHR2YXIgYXN5bmMgPSBvYmouYXN5bmMgPT0gZmFsc2UgPyBvYmouYXN5bmMgOiB0cnVlO1xuXG5cdFx0XHQkLmFqYXgoe1xuXHRcdFx0XHR0eXBlOm9iai50eXBlLFxuXHRcdFx0XHRkYXRhVHlwZTogJ2pzb24nLFxuXHRcdFx0XHR1cmw6IG9iai51cmwsXG5cdFx0XHRcdGFzeW5jOmFzeW5jLFxuXHRcdFx0XHRkYXRhOnJlc0RhdGEsXG5cdFx0XHRcdGJlZm9yZVNlbmQ6IGZ1bmN0aW9uKHhocikge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQXV0aG9yaXphdGlvblwiLCAnQmVhcmVyICcgKyBqd3QpO1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLU9yZycsb3JnX2lkKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzdWNjZXNzOmZ1bmN0aW9uKGRhdGEpe1xuXG5cdFx0XHRcdFx0b2JqLnN1Y2Nlc3MoZGF0YSk7XG5cblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKGVycm9yKXtcblxuXHRcdFx0XHRcdGlmIChvYmouZXJyb3IpIHtcblxuXHRcdFx0XHRcdFx0b2JqLmVycm9yKCk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblxuXHRcdFx0XHRcdFx0XHR2YXIgbXNnID0gSlNPTi5wYXJzZShlcnJvci5yZXNwb25zZVRleHQpO1xuXG5cdFx0XHRcdFx0XHRcdExpemFyZC5zaG93VG9hc3QobXNnLmVycm9yLm1lc3NhZ2UpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9LFxuXHRcdGdldERhdGVEaWZmOiBmdW5jdGlvbiAoZGF0ZVRpbWVTdGFtcCl7XG5cblx0XHRcdGRhdGVUaW1lU3RhbXAgPSBEYXRlLnBhcnNlKGRhdGVUaW1lU3RhbXAucmVwbGFjZSgvLS9naSxcIi9cIikpO1xuXHRcdFx0dmFyIG1pbnV0ZSA9IDEwMDAgKiA2MDtcblx0XHRcdHZhciBob3VyID0gbWludXRlICogNjA7XG5cdFx0XHR2YXIgZGF5ID0gaG91ciAqIDI0O1xuXHRcdFx0dmFyIGhhbGZhbW9udGggPSBkYXkgKiAxNTtcblx0XHRcdHZhciBtb250aCA9IGRheSAqIDMwO1xuXHRcdFx0dmFyIG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdFx0dmFyIGRpZmZWYWx1ZSA9IG5vdyAtIGRhdGVUaW1lU3RhbXA7XG5cdFx0XHRpZiAoZGlmZlZhbHVlIDwgMCkgeyByZXR1cm47IH1cblx0XHRcdHZhciBtb250aEMgPSBkaWZmVmFsdWUvbW9udGg7XG5cdFx0XHR2YXIgd2Vla0MgPSBkaWZmVmFsdWUvKDcqZGF5KTtcblx0XHRcdHZhciBkYXlDID0gZGlmZlZhbHVlL2RheTtcblx0XHRcdHZhciBob3VyQyA9IGRpZmZWYWx1ZS9ob3VyO1xuXHRcdFx0dmFyIG1pbkMgPSBkaWZmVmFsdWUvbWludXRlO1xuXG5cdFx0XHR2YXIgcmVzdWx0ID0gXCJcIjtcblx0XHRcdGlmKG1vbnRoQyA+PSAxKXtcblx0XHRcdFx0cmVzdWx0ICs9IHBhcnNlSW50KG1vbnRoQykgKyBcIuaciOWJjVwiO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZih3ZWVrQyA+PSAxKXtcblx0XHRcdFx0cmVzdWx0ICs9IHBhcnNlSW50KHdlZWtDKSArIFwi5ZGo5YmNXCI7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKGRheUMgPj0gMSl7XG5cdFx0XHRcdHJlc3VsdCArPSBwYXJzZUludChkYXlDKSArXCLlpKnliY1cIjtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYoaG91ckMgPj0gMSl7XG5cdFx0XHRcdHJlc3VsdCArPSBwYXJzZUludChob3VyQykgK1wi5bCP5pe25YmNXCI7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKG1pbkM+PTEpe1xuXHRcdFx0XHRyZXN1bHQgKz0gcGFyc2VJbnQobWluQykgK1wi5YiG6ZKf5YmNXCI7XG5cdFx0XHR9ZWxzZVxuXHRcdFx0cmVzdWx0ID0gXCLliJrliJpcIjtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblx0XHRnZXRQYXRoTmFtZTpmdW5jdGlvbigpe1xuXG5cdFx0XHR2YXIgc3RyVXJsID0gZG9jdW1lbnQubG9jYXRpb24udG9TdHJpbmcoKTtcblxuXHRcdFx0dmFyIGFyck9iaiA9IHN0clVybC5zcGxpdCgnLy8nKTtcblxuXHRcdFx0dmFyIHN0YXJ0ID0gYXJyT2JqWzFdLmluZGV4T2YoJy8nKTtcblxuXHRcdFx0cmV0dXJuIGFyck9ialsxXS5zdWJzdHJpbmcoc3RhcnQpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiDlr7lEYXRl55qE5omp5bGV77yM5bCGIERhdGUg6L2s5YyW5Li65oyH5a6a5qC85byP55qEU3RyaW5nXG5cdFx0ICog5pyIKE0p44CB5pelKGQp44CBMTLlsI/ml7YoaCnjgIEyNOWwj+aXtihIKeOAgeWIhihtKeOAgeenkihzKeOAgeWRqChFKeOAgeWto+W6pihxKSDlj6/ku6XnlKggMS0yIOS4quWNoOS9jeesplxuXHRcdCAqIOW5tCh5KeWPr+S7peeUqCAxLTQg5Liq5Y2g5L2N56ym77yM5q+r56eSKFMp5Y+q6IO955SoIDEg5Liq5Y2g5L2N56ymKOaYryAxLTMg5L2N55qE5pWw5a2XKVxuXHRcdCAqIGVnOlxuXHRcdCAqIChuZXcgRGF0ZSgpLmdldFRpbWUoLFwieXl5eS1NTS1kZCBoaDptbTpzcy5TXCIpID09PiAyMDA2LTA3LTAyIDA4OjA5OjA0LjQyM1xuXHRcdCAqIChuZXcgRGF0ZSgpLmdldFRpbWUoLFwieXl5eS1NTS1kZCBFIEhIOm1tOnNzXCIpID09PiAyMDA5LTAzLTEwIOS6jCAyMDowOTowNFxuXHRcdCAqIChuZXcgRGF0ZSgpLmdldFRpbWUoLFwieXl5eS1NTS1kZCBFRSBoaDptbTpzc1wiKSA9PT4gMjAwOS0wMy0xMCDlkajkuowgMDg6MDk6MDRcblx0XHQgKiAobmV3IERhdGUoKS5nZXRUaW1lKCxcInl5eXktTU0tZGQgRUVFIGhoOm1tOnNzXCIpID09PiAyMDA5LTAzLTEwIOaYn+acn+S6jCAwODowOTowNFxuXHRcdCAqIChuZXcgRGF0ZSgpLmdldFRpbWUoLFwieXl5eS1NLWQgaDptOnMuU1wiKSA9PT4gMjAwNi03LTIgODo5OjQuMThcblx0XHQgKi9cblx0XHRkYXRlRm9ybWF0OmZ1bmN0aW9uKHRpZW1zLGZtdCl7XG5cblx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUodGllbXMpO1xuXG5cdFx0XHR2YXIgbyA9IHtcblx0XHRcdFx0XCJNK1wiIDogZGF0ZS5nZXRNb250aCgpKzEsIC8v5pyI5Lu9XG5cdFx0XHRcdFwiZCtcIiA6IGRhdGUuZ2V0RGF0ZSgpLCAvL+aXpVxuXHRcdFx0XHRcImgrXCIgOiBkYXRlLmdldEhvdXJzKCklMTIgPT0gMCA/IDEyIDogZGF0ZS5nZXRIb3VycygpJTEyLCAvL+Wwj+aXtlxuXHRcdFx0XHRcIkgrXCIgOiBkYXRlLmdldEhvdXJzKCksIC8v5bCP5pe2XG5cdFx0XHRcdFwibStcIiA6IGRhdGUuZ2V0TWludXRlcygpLCAvL+WIhlxuXHRcdFx0XHRcInMrXCIgOiBkYXRlLmdldFNlY29uZHMoKSwgLy/np5Jcblx0XHRcdFx0XCJxK1wiIDogTWF0aC5mbG9vcigoZGF0ZS5nZXRNb250aCgpKzMpLzMpLCAvL+Wto+W6plxuXHRcdFx0XHRcIlNcIiA6ICBkYXRlLmdldE1pbGxpc2Vjb25kcygpIC8v5q+r56eSXG5cdFx0XHR9O1xuXHRcdFx0dmFyIHdlZWsgPSB7XG5cdFx0XHRcdFwiMFwiIDogXCJcXHU2NWU1XCIsXG5cdFx0XHRcdFwiMVwiIDogXCJcXHU0ZTAwXCIsXG5cdFx0XHRcdFwiMlwiIDogXCJcXHU0ZThjXCIsXG5cdFx0XHRcdFwiM1wiIDogXCJcXHU0ZTA5XCIsXG5cdFx0XHRcdFwiNFwiIDogXCJcXHU1NmRiXCIsXG5cdFx0XHRcdFwiNVwiIDogXCJcXHU0ZTk0XCIsXG5cdFx0XHRcdFwiNlwiIDogXCJcXHU1MTZkXCJcblx0XHRcdH07XG5cdFx0XHRpZigvKHkrKS8udGVzdChmbXQpKXtcblx0XHRcdFx0Zm10PWZtdC5yZXBsYWNlKFJlZ0V4cC4kMSwgKGRhdGUuZ2V0RnVsbFllYXIoKStcIlwiKS5zdWJzdHIoNCAtIFJlZ0V4cC4kMS5sZW5ndGgpKTtcblx0XHRcdH1cblx0XHRcdGlmKC8oRSspLy50ZXN0KGZtdCkpe1xuXHRcdFx0XHRmbXQ9Zm10LnJlcGxhY2UoUmVnRXhwLiQxLCAoKFJlZ0V4cC4kMS5sZW5ndGg+MSkgPyAoUmVnRXhwLiQxLmxlbmd0aD4yID8gXCJcXHU2NjFmXFx1NjcxZlwiIDogXCJcXHU1NDY4XCIpIDogXCJcIikrd2Vla1tkYXRlLmdldERheSgpK1wiXCJdKTtcblx0XHRcdH1cblx0XHRcdGZvcih2YXIgayBpbiBvKXtcblx0XHRcdFx0aWYobmV3IFJlZ0V4cChcIihcIisgayArXCIpXCIpLnRlc3QoZm10KSl7XG5cdFx0XHRcdFx0Zm10ID0gZm10LnJlcGxhY2UoUmVnRXhwLiQxLCAoUmVnRXhwLiQxLmxlbmd0aD09MSkgPyAob1trXSkgOiAoKFwiMDBcIisgb1trXSkuc3Vic3RyKChcIlwiKyBvW2tdKS5sZW5ndGgpKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmbXQ7XG5cdFx0fSxcblx0XHQvL+iuvue9rmNvb2tpZXNcblx0XHRzZXRDb29raWU6ZnVuY3Rpb24gKG5hbWUsdmFsdWUsdGltZXMpIHtcblx0XHRcdHZhciBleHAgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0ZXhwLnNldFRpbWUoZXhwLmdldFRpbWUoKSArdGltZXMpO1xuXHRcdFx0ZG9jdW1lbnQuY29va2llID0gbmFtZSArIFwiPVwiKyBlc2NhcGUgKHZhbHVlKSArIFwiO2V4cGlyZXM9XCIgKyBleHAudG9HTVRTdHJpbmcoKStcIjtwYXRoPS9cIjtcblx0XHR9LFxuXHRcdC8v6K+75Y+WY29va2llc1xuXHRcdGdldENvb2tpZTogZnVuY3Rpb24gKG5hbWUpe1xuXHRcdFx0dmFyIGFycixyZWcgPSBuZXcgUmVnRXhwKFwiKF58IClcIituYW1lK1wiPShbXjtdKikoO3wkKVwiKTtcblx0XHRcdGlmKGFyciA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChyZWcpKXtcblx0XHRcdFx0cmV0dXJuIHVuZXNjYXBlKGFyclsyXSk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvL+WIoOmZpGNvb2tpZXNcblx0XHRyZW1vdmVDb29raWU6ZnVuY3Rpb24gKG5hbWUpe1xuXHRcdFx0dmFyIGV4cCA9IG5ldyBEYXRlKCk7XG5cdFx0XHRleHAuc2V0VGltZShleHAuZ2V0VGltZSgpIC0gMSk7XG5cdFx0XHR2YXIgY3ZhbCA9IHRoaXMuZ2V0Q29va2llKG5hbWUpO1xuICAgICAgaWYoY3ZhbCE9PSBudWxsKSBkb2N1bWVudC5jb29raWU9IG5hbWUgKyBcIj1cIitjdmFsK1wiO2V4cGlyZXM9XCIrZXhwLnRvR01UU3RyaW5nKCkrXCI7cGF0aD0vXCI7XG5cdFx0fSxcblxuXHRcdGNsZWFyQ29va2llOmZ1bmN0aW9uICgpe1xuXHRcdFx0dmFyIGtleXM9ZG9jdW1lbnQuY29va2llLm1hdGNoKC9bXiA9O10rKD89XFw9KS9nKTtcblx0XHRcdGlmIChrZXlzKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSBrZXlzLmxlbmd0aDsgaS0tOylcblx0XHRcdFx0XHRkb2N1bWVudC5jb29raWU9a2V5c1tpXSsnPTA7ZXhwaXJlcz0nICsgbmV3IERhdGUoKS50b0dNVFN0cmluZygpK1wiO3BhdGg9L1wiO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0dGhyb3R0bGU6IGZ1bmN0aW9uIChmdW5jLCB3YWl0LCBtdXN0UnVuKSB7XG5cdFx0XHR2YXIgdGltZW91dCxcblx0XHRcdFx0c3RhcnRUaW1lID0gbmV3IERhdGUoKTtcblxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgY29udGV4dCA9IHRoaXMsXG5cdFx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0XHRjdXJUaW1lID0gbmV3IERhdGUoKTtcblxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0XHRcdC8vIOWmguaenOi+vuWIsOS6huinhOWumueahOinpuWPkeaXtumXtOmXtOmalO+8jOinpuWPkSBoYW5kbGVyXG5cdFx0XHRcdGlmKGN1clRpbWUgLSBzdGFydFRpbWUgPj0gbXVzdFJ1bil7XG5cblx0XHRcdFx0XHRmdW5jLmFwcGx5KGNvbnRleHQsYXJncyk7XG5cblx0XHRcdFx0XHRzdGFydFRpbWUgPSBjdXJUaW1lO1xuXG5cdFx0XHRcdFx0Ly8g5rKh6L6+5Yiw6Kem5Y+R6Ze06ZqU77yM6YeN5paw6K6+5a6a5a6a5pe25ZmoXG5cdFx0XHRcdH1lbHNle1xuXG5cdFx0XHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHR3aW5kb3cuTGl6YXJkID0gTGl6YXJkO1xuXHRtb2R1bGUuZXhwb3J0cyA9IExpemFyZDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwdWJsaWMvc2NyaXB0cy93aWRnZXQvbGl6YXJkLmpzIl0sIm1hcHBpbmdzIjoiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFBQTs7O0FBQUE7QUFBQTs7QUFBQTtBQUNBO0FBV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFBQTs7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUJBO0FBZ0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQTdYQTtBQStYQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),

/***/ 2:
/*!**********************************!*\
  !*** ./public/scripts/common.js ***!
  \**********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar $ = __webpack_require__(/*! ./lib/jquery */ 0);\n\nvar Lizard = __webpack_require__(/*! ./widget/lizard */ 1);\n\nvar common = {\n\n\theaderMenu: function headerMenu() {\n\n\t\t$('.js_narrow').click(function () {\n\n\t\t\t$('.header-logo').toggleClass('header_menu_scale');\n\n\t\t\t$('.aside-menu').toggleClass('header_menu_scale');\n\n\t\t\t$('.header_logo_img').toggle();\n\n\t\t\t$('.js_nav_link').toggle();\n\n\t\t\t$('.header-top').toggleClass('header_menu_toggle');\n\n\t\t\t$('.right-container').toggleClass('header_menu_toggle');\n\t\t});\n\n\t\t$('.container').css('height', $(window).height());\n\n\t\t$('.right-container').css('min-height', $(window).height());\n\n\t\t$('.header_message_list li').click(function () {\n\n\t\t\t$('.header_notice').toggle();\n\t\t});\n\n\t\t//\n\n\t\t$('.js_logout').click(function () {\n\n\t\t\tLizard.clearCookie();\n\n\t\t\tlocation.href = '/user/login';\n\t\t});\n\n\t\t//\n\n\t\t$('.js_user').click(function () {\n\n\t\t\t$('.user_info').toggle();\n\t\t});\n\n\t\tgetMessage();\n\n\t\tfunction getMessage() {\n\n\t\t\tvar userName = $('.authority_name').text();\n\n\t\t\tLizard.ajax({\n\t\t\t\ttype: 'POST',\n\t\t\t\turl: '/user/message',\n\t\t\t\tsuccess: function success(data) {\n\n\t\t\t\t\tvar msgList = data.content;\n\n\t\t\t\t\tif (data && msgList.length) {\n\n\t\t\t\t\t\tvar getDateDiff = Lizard.getDateDiff;\n\n\t\t\t\t\t\tvar html = msgList.map(function (item) {\n\t\t\t\t\t\t\treturn '\\n\\t\\t\\t\\t\\t\\t\\t<dd>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<img src=\"https://imgthisisdashcdn-83chedai-com.alikunlun.com/identicons/135.png\" class=\"notice_img fl\"/>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<div class=\"notice_cont fr\">\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<div class=\"notice_txt\">\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<strong>' + userName + '</strong>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<time>' + getDateDiff(item.created_at) + '</time>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<p>' + item.content + '</p>\\n\\t\\t\\t\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t\\t\\t\\t\\t</dd>';\n\t\t\t\t\t\t}).join('');\n\n\t\t\t\t\t\t$('.notice_list').html(html);\n\n\t\t\t\t\t\t$('.js_msgNume').show();\n\n\t\t\t\t\t\t$('.js_msgNume').text(msgList.length);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t$('.js_msgNume').text('0');\n\n\t\t\t\t\t\t$('.notice_list').html('<dd><p></p></dd>');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\tgetVerify: function getVerify() {\n\t\t//\n\n\t\t$('#captcha-img').click(function () {\n\n\t\t\tcommon.updateVerify();\n\t\t});\n\t},\n\tgetPage: function getPage(page, showPage) {\n\n\t\tvar iPage = 0;\n\n\t\tif (page % showPage == 0) {\n\n\t\t\tiPage = Math.floor(page / showPage - 1) * showPage;\n\t\t} else {\n\n\t\t\tiPage = Math.floor(page / showPage) * showPage;\n\t\t}\n\n\t\treturn iPage;\n\t},\n\tdropMenu: function dropMenu() {\n\n\t\t$('.js_select').click(function (e) {\n\n\t\t\tconsole.log(111);\n\n\t\t\te.stopPropagation();\n\n\t\t\t$(this).toggleClass('active');\n\n\t\t\t$(this).parent('.drop_menu').toggleClass('active');\n\t\t});\n\n\t\t$('.drop_menu_list').on('click', 'li', function (e) {\n\n\t\t\te.stopPropagation();\n\n\t\t\tvar value = $(this).data('value');\n\n\t\t\t$(this).parent().prev('.js_select').text($(this).text()).data('value', value).addClass('active').parents('.drop_menu').removeClass('active');\n\t\t});\n\n\t\t$(document).click(function () {\n\n\t\t\t$('.drop_menu').removeClass('active');\n\t\t});\n\t},\n\n\tclearForm: function clearForm() {\n\n\t\t$('.js_select').data('value', 0).text('');\n\t},\n\n\tupdateVerify: function updateVerify() {\n\t\tLizard.ajax({\n\t\t\ttype: 'POST',\n\t\t\tgateway: 'gatewayExt',\n\t\t\turl: '/user/verify',\n\t\t\tsuccess: function success(data) {\n\n\t\t\t\t$('#captcha-img').attr('src', data.img_url);\n\n\t\t\t\t$('#captcha_key').val(data.key);\n\t\t\t}\n\t\t});\n\t},\n\tdeleteEmptyProperty: function deleteEmptyProperty(object) {\n\n\t\tfor (var attr in object) {\n\n\t\t\tvar value = object[attr];\n\n\t\t\tif (value === '' || value === null || value === undefined) {\n\n\t\t\t\tdelete object[attr];\n\t\t\t}\n\t\t}\n\n\t\treturn object;\n\t}\n};\n\nmodule.exports = common;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9wdWJsaWMvc2NyaXB0cy9jb21tb24uanM/ZGYzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJCA9IHJlcXVpcmUoJy4vbGliL2pxdWVyeScpO1xuXG52YXIgTGl6YXJkID0gcmVxdWlyZSgnLi93aWRnZXQvbGl6YXJkJyk7XG5cbnZhciBjb21tb24gPSB7XG5cblx0aGVhZGVyTWVudTogZnVuY3Rpb24oKXtcblxuXHRcdCQoJy5qc19uYXJyb3cnKS5jbGljayhmdW5jdGlvbigpe1xuXG5cdFx0XHQkKCcuaGVhZGVyLWxvZ28nKS50b2dnbGVDbGFzcygnaGVhZGVyX21lbnVfc2NhbGUnKTtcblxuXHRcdFx0JCgnLmFzaWRlLW1lbnUnKS50b2dnbGVDbGFzcygnaGVhZGVyX21lbnVfc2NhbGUnKTtcblxuXHRcdFx0JCgnLmhlYWRlcl9sb2dvX2ltZycpLnRvZ2dsZSgpO1xuXG5cdFx0XHQkKCcuanNfbmF2X2xpbmsnKS50b2dnbGUoKTtcblxuXHRcdFx0JCgnLmhlYWRlci10b3AnKS50b2dnbGVDbGFzcygnaGVhZGVyX21lbnVfdG9nZ2xlJyk7XG5cblx0XHRcdCQoJy5yaWdodC1jb250YWluZXInKS50b2dnbGVDbGFzcygnaGVhZGVyX21lbnVfdG9nZ2xlJyk7XG5cblx0XHR9KVxuXG5cblx0XHQkKCcuY29udGFpbmVyJykuY3NzKCdoZWlnaHQnLCQod2luZG93KS5oZWlnaHQoKSk7XG5cblx0XHQkKCcucmlnaHQtY29udGFpbmVyJykuY3NzKCdtaW4taGVpZ2h0JywkKHdpbmRvdykuaGVpZ2h0KCkpO1xuXG5cdFx0JCgnLmhlYWRlcl9tZXNzYWdlX2xpc3QgbGknKS5jbGljayhmdW5jdGlvbigpe1xuXG5cdFx0XHQkKCcuaGVhZGVyX25vdGljZScpLnRvZ2dsZSgpO1xuXG5cdFx0fSlcblxuXHRcdC8v6YCA5Ye655m75b2VXG5cblx0XHQkKCcuanNfbG9nb3V0JykuY2xpY2soZnVuY3Rpb24oKXtcblxuXHRcdFx0TGl6YXJkLmNsZWFyQ29va2llKCk7XG5cblx0XHRcdGxvY2F0aW9uLmhyZWYgPSAnL3VzZXIvbG9naW4nO1xuXG5cdFx0fSlcblxuXHRcdC8v55So5oi35L+h5oGvXG5cblx0XHQkKCcuanNfdXNlcicpLmNsaWNrKGZ1bmN0aW9uKCl7XG5cblx0XHRcdCQoJy51c2VyX2luZm8nKS50b2dnbGUoKTtcblxuXHRcdH0pXG5cblx0XHRnZXRNZXNzYWdlKCk7XG5cblx0XHRmdW5jdGlvbiBnZXRNZXNzYWdlKCl7XG5cblx0XHRcdHZhciB1c2VyTmFtZSA9ICQoJy5hdXRob3JpdHlfbmFtZScpLnRleHQoKTtcblxuXHRcdFx0TGl6YXJkLmFqYXgoe1xuXHRcdFx0XHR0eXBlOidQT1NUJyxcblx0XHRcdFx0dXJsOicvdXNlci9tZXNzYWdlJyxcblx0XHRcdFx0c3VjY2VzczpmdW5jdGlvbihkYXRhKXtcblxuXHRcdFx0XHRcdHZhciBtc2dMaXN0ID0gZGF0YS5jb250ZW50O1xuXG5cdFx0XHRcdFx0aWYoZGF0YSAmJiBtc2dMaXN0Lmxlbmd0aCl7XG5cblx0XHRcdFx0XHRcdHZhciBnZXREYXRlRGlmZiA9IExpemFyZC5nZXREYXRlRGlmZjtcblxuXHRcdFx0XHRcdFx0dmFyIGh0bWwgPSBtc2dMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYFxuXHRcdFx0XHRcdFx0XHQ8ZGQ+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8aW1nIHNyYz1cImh0dHBzOi8vaW1ndGhpc2lzZGFzaGNkbi04M2NoZWRhaS1jb20uYWxpa3VubHVuLmNvbS9pZGVudGljb25zLzEzNS5wbmdcIiBjbGFzcz1cIm5vdGljZV9pbWcgZmxcIi8+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwibm90aWNlX2NvbnQgZnJcIj5cblx0XHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9XCJub3RpY2VfdHh0XCI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3Ryb25nPiR7dXNlck5hbWV9PC9zdHJvbmc+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8dGltZT4ke2dldERhdGVEaWZmKGl0ZW0uY3JlYXRlZF9hdCl9PC90aW1lPlxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8cD4ke2l0ZW0uY29udGVudH08L3A+XG5cdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0PC9kZD5gXG5cdFx0XHRcdFx0XHR9KS5qb2luKCcnKTtcblxuXHRcdFx0XHRcdFx0JCgnLm5vdGljZV9saXN0JykuaHRtbChodG1sKTtcblxuXHRcdFx0XHRcdFx0JCgnLmpzX21zZ051bWUnKS5zaG93KCk7XG5cblx0XHRcdFx0XHRcdCQoJy5qc19tc2dOdW1lJykudGV4dChtc2dMaXN0Lmxlbmd0aCk7XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQkKCcuanNfbXNnTnVtZScpLnRleHQoJzAnKTtcblxuXHRcdFx0XHRcdFx0JCgnLm5vdGljZV9saXN0JykuaHRtbCgnPGRkPjxwPuW9k+WJjeaXoOS/oeaBrzwvcD48L2RkPicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHRcdH1cblx0fSxcblx0Z2V0VmVyaWZ5OiBmdW5jdGlvbiAoKSB7IC8v6I635Y+W6aqM6K+B56CBXG5cblx0XHQkKCcjY2FwdGNoYS1pbWcnKS5jbGljayhmdW5jdGlvbigpe1xuXG5cdFx0XHRjb21tb24udXBkYXRlVmVyaWZ5KCk7XG5cblx0XHR9KVxuXHR9LFxuXHRnZXRQYWdlOiBmdW5jdGlvbiAocGFnZSxzaG93UGFnZSkge1xuXG5cdFx0dmFyIGlQYWdlID0gMDtcblxuXHRcdGlmICgocGFnZSAlIHNob3dQYWdlKSA9PSAwKXtcblxuXHRcdFx0aVBhZ2UgPSBNYXRoLmZsb29yKChwYWdlIC8gc2hvd1BhZ2UgLTEpKSAqIHNob3dQYWdlO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aVBhZ2UgPSBNYXRoLmZsb29yKHBhZ2UgLyBzaG93UGFnZSkgKiBzaG93UGFnZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBpUGFnZVxuXG5cdH0sXG5cdGRyb3BNZW51OiBmdW5jdGlvbiAgKCkge1xuXG5cdFx0JCgnLmpzX3NlbGVjdCcpLmNsaWNrKGZ1bmN0aW9uKGUpe1xuXG5cdFx0XHRjb25zb2xlLmxvZygxMTEpXG5cblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblxuXHRcdFx0JCh0aGlzKS50b2dnbGVDbGFzcygnYWN0aXZlJyk7XG5cblx0XHRcdCQodGhpcykucGFyZW50KCcuZHJvcF9tZW51JykudG9nZ2xlQ2xhc3MoJ2FjdGl2ZScpO1xuXG5cdFx0fSlcblxuXHRcdCQoJy5kcm9wX21lbnVfbGlzdCcpLm9uKCdjbGljaycsJ2xpJyxmdW5jdGlvbihlKXtcblxuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdFx0dmFyIHZhbHVlID0gJCh0aGlzKS5kYXRhKCd2YWx1ZScpO1xuXG5cdFx0XHQkKHRoaXMpLnBhcmVudCgpLnByZXYoJy5qc19zZWxlY3QnKS50ZXh0KCQodGhpcykudGV4dCgpKS5kYXRhKCd2YWx1ZScsdmFsdWUpLmFkZENsYXNzKCdhY3RpdmUnKS5wYXJlbnRzKCcuZHJvcF9tZW51JykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXG5cdFx0fSlcblxuXHRcdCQoZG9jdW1lbnQpLmNsaWNrKGZ1bmN0aW9uKCl7XG5cblx0XHRcdCQoJy5kcm9wX21lbnUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cblx0XHR9KVxuXHR9LFxuXG5cdGNsZWFyRm9ybSgpe1xuXG5cdFx0JCgnLmpzX3NlbGVjdCcpLmRhdGEoJ3ZhbHVlJywwKS50ZXh0KCfor7fpgInmi6knKTtcblxuXG5cdH0sXG5cdHVwZGF0ZVZlcmlmeTogZnVuY3Rpb24oKXtcblx0XHRMaXphcmQuYWpheCh7XG5cdFx0XHR0eXBlOiAnUE9TVCcsXG5cdFx0XHRnYXRld2F5OidnYXRld2F5RXh0Jyxcblx0XHRcdHVybDogJy91c2VyL3ZlcmlmeScsXG5cdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSkge1xuXG5cdFx0XHRcdCQoJyNjYXB0Y2hhLWltZycpLmF0dHIoJ3NyYycsZGF0YS5pbWdfdXJsKTtcblxuXHRcdFx0XHQkKCcjY2FwdGNoYV9rZXknKS52YWwoZGF0YS5rZXkpO1xuXG5cdFx0XHR9XG5cdFx0fSlcblx0fSxcblx0ZGVsZXRlRW1wdHlQcm9wZXJ0eShvYmplY3Qpe1xuXG5cdFx0Zm9yICh2YXIgYXR0ciBpbiBvYmplY3QpIHtcblxuXHRcdFx0dmFyIHZhbHVlID0gb2JqZWN0W2F0dHJdO1xuXG5cdFx0XHRpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcblxuXHRcdFx0XHRkZWxldGUgb2JqZWN0W2F0dHJdO1xuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9iamVjdDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbW1vbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwdWJsaWMvc2NyaXB0cy9jb21tb24uanMiXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckNBO0FBd0NBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFWQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQTVMQTtBQUNBO0FBOExBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n");

/***/ }),

/***/ 3:
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/YzNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XHJcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcclxuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xyXG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XHJcblx0XHRpZighbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcclxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcclxuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XHJcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXHJcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xyXG5cdH1cclxuXHRyZXR1cm4gbW9kdWxlO1xyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAod2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIDIzIDI0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n");

/***/ }),

/***/ 4:
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9hbWQtb3B0aW9ucy5qcz81ZjcxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEgMiAzIDQgNSA2IDcgOCA5IDEwIDExIDEyIDEzIDE0IDE1IDE2IDE3IDE4IDE5IDIwIDIxIDIyIDIzIDI0Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n");

/***/ }),

/***/ 40:
/*!***********************************!*\
  !*** ./public/scripts/lib/vue.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * Vue.js v2.3.4\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n\t( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.Vue = factory();\n})(undefined, function () {\n\t'use strict';\n\n\t/*  */\n\n\t// these helpers produces better vm code in JS engines due to their\n\t// explicitness and function inlining\n\n\tfunction isUndef(v) {\n\t\treturn v === undefined || v === null;\n\t}\n\n\tfunction isDef(v) {\n\t\treturn v !== undefined && v !== null;\n\t}\n\n\tfunction isTrue(v) {\n\t\treturn v === true;\n\t}\n\n\tfunction isFalse(v) {\n\t\treturn v === false;\n\t}\n\t/**\n  * Check if value is primitive\n  */\n\tfunction isPrimitive(value) {\n\t\treturn typeof value === 'string' || typeof value === 'number';\n\t}\n\n\t/**\n  * Quick object check - this is primarily used to tell\n  * Objects from primitive values when we know the value\n  * is a JSON-compliant type.\n  */\n\tfunction isObject(obj) {\n\t\treturn obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';\n\t}\n\n\tvar _toString = Object.prototype.toString;\n\n\t/**\n  * Strict object type check. Only returns true\n  * for plain JavaScript objects.\n  */\n\tfunction isPlainObject(obj) {\n\t\treturn _toString.call(obj) === '[object Object]';\n\t}\n\n\tfunction isRegExp(v) {\n\t\treturn _toString.call(v) === '[object RegExp]';\n\t}\n\n\t/**\n  * Convert a value to a string that is actually rendered.\n  */\n\tfunction toString(val) {\n\t\treturn val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);\n\t}\n\n\t/**\n  * Convert a input value to a number for persistence.\n  * If the conversion fails, return original string.\n  */\n\tfunction toNumber(val) {\n\t\tvar n = parseFloat(val);\n\t\treturn isNaN(n) ? val : n;\n\t}\n\n\t/**\n  * Make a map and return a function for checking if a key\n  * is in that map.\n  */\n\tfunction makeMap(str, expectsLowerCase) {\n\t\tvar map = Object.create(null);\n\t\tvar list = str.split(',');\n\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\tmap[list[i]] = true;\n\t\t}\n\t\treturn expectsLowerCase ? function (val) {\n\t\t\treturn map[val.toLowerCase()];\n\t\t} : function (val) {\n\t\t\treturn map[val];\n\t\t};\n\t}\n\n\t/**\n  * Check if a tag is a built-in tag.\n  */\n\tvar isBuiltInTag = makeMap('slot,component', true);\n\n\t/**\n  * Remove an item from an array\n  */\n\tfunction remove(arr, item) {\n\t\tif (arr.length) {\n\t\t\tvar index = arr.indexOf(item);\n\t\t\tif (index > -1) {\n\t\t\t\treturn arr.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Check whether the object has the property.\n  */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tfunction hasOwn(obj, key) {\n\t\treturn hasOwnProperty.call(obj, key);\n\t}\n\n\t/**\n  * Create a cached version of a pure function.\n  */\n\tfunction cached(fn) {\n\t\tvar cache = Object.create(null);\n\t\treturn function cachedFn(str) {\n\t\t\tvar hit = cache[str];\n\t\t\treturn hit || (cache[str] = fn(str));\n\t\t};\n\t}\n\n\t/**\n  * Camelize a hyphen-delimited string.\n  */\n\tvar camelizeRE = /-(\\w)/g;\n\tvar camelize = cached(function (str) {\n\t\treturn str.replace(camelizeRE, function (_, c) {\n\t\t\treturn c ? c.toUpperCase() : '';\n\t\t});\n\t});\n\n\t/**\n  * Capitalize a string.\n  */\n\tvar capitalize = cached(function (str) {\n\t\treturn str.charAt(0).toUpperCase() + str.slice(1);\n\t});\n\n\t/**\n  * Hyphenate a camelCase string.\n  */\n\tvar hyphenateRE = /([^-])([A-Z])/g;\n\tvar hyphenate = cached(function (str) {\n\t\treturn str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\n\t});\n\n\t/**\n  * Simple bind, faster than native\n  */\n\tfunction bind(fn, ctx) {\n\t\tfunction boundFn(a) {\n\t\t\tvar l = arguments.length;\n\t\t\treturn l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n\t\t}\n\t\t// record original fn length\n\t\tboundFn._length = fn.length;\n\t\treturn boundFn;\n\t}\n\n\t/**\n  * Convert an Array-like object to a real Array.\n  */\n\tfunction toArray(list, start) {\n\t\tstart = start || 0;\n\t\tvar i = list.length - start;\n\t\tvar ret = new Array(i);\n\t\twhile (i--) {\n\t\t\tret[i] = list[i + start];\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/**\n  * Mix properties into target object.\n  */\n\tfunction extend(to, _from) {\n\t\tfor (var key in _from) {\n\t\t\tto[key] = _from[key];\n\t\t}\n\t\treturn to;\n\t}\n\n\t/**\n  * Merge an Array of Objects into a single Object.\n  */\n\tfunction toObject(arr) {\n\t\tvar res = {};\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i]) {\n\t\t\t\textend(res, arr[i]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t/**\n  * Perform no operation.\n  */\n\tfunction noop() {}\n\n\t/**\n  * Always return false.\n  */\n\tvar no = function no() {\n\t\treturn false;\n\t};\n\n\t/**\n  * Return same value\n  */\n\tvar identity = function identity(_) {\n\t\treturn _;\n\t};\n\n\t/**\n  * Generate a static keys string from compiler modules.\n  */\n\tfunction genStaticKeys(modules) {\n\t\treturn modules.reduce(function (keys, m) {\n\t\t\treturn keys.concat(m.staticKeys || []);\n\t\t}, []).join(',');\n\t}\n\n\t/**\n  * Check if two values are loosely equal - that is,\n  * if they are plain objects, do they have the same shape?\n  */\n\tfunction looseEqual(a, b) {\n\t\tvar isObjectA = isObject(a);\n\t\tvar isObjectB = isObject(b);\n\t\tif (isObjectA && isObjectB) {\n\t\t\ttry {\n\t\t\t\treturn JSON.stringify(a) === JSON.stringify(b);\n\t\t\t} catch (e) {\n\t\t\t\t// possible circular reference\n\t\t\t\treturn a === b;\n\t\t\t}\n\t\t} else if (!isObjectA && !isObjectB) {\n\t\t\treturn String(a) === String(b);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction looseIndexOf(arr, val) {\n\t\tfor (var i = 0; i < arr.length; i++) {\n\t\t\tif (looseEqual(arr[i], val)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n  * Ensure a function is called only once.\n  */\n\tfunction once(fn) {\n\t\tvar called = false;\n\t\treturn function () {\n\t\t\tif (!called) {\n\t\t\t\tcalled = true;\n\t\t\t\tfn.apply(this, arguments);\n\t\t\t}\n\t\t};\n\t}\n\n\tvar SSR_ATTR = 'data-server-rendered';\n\n\tvar ASSET_TYPES = ['component', 'directive', 'filter'];\n\n\tvar LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated'];\n\n\t/*  */\n\n\tvar config = {\n\t\t/**\n   * Option merge strategies (used in core/util/options)\n   */\n\t\toptionMergeStrategies: Object.create(null),\n\n\t\t/**\n   * Whether to suppress warnings.\n   */\n\t\tsilent: false,\n\n\t\t/**\n   * Show production mode tip message on boot?\n   */\n\t\tproductionTip: \"development\" !== 'production',\n\n\t\t/**\n   * Whether to enable devtools\n   */\n\t\tdevtools: \"development\" !== 'production',\n\n\t\t/**\n   * Whether to record perf\n   */\n\t\tperformance: false,\n\n\t\t/**\n   * Error handler for watcher errors\n   */\n\t\terrorHandler: null,\n\n\t\t/**\n   * Ignore certain custom elements\n   */\n\t\tignoredElements: [],\n\n\t\t/**\n   * Custom user key aliases for v-on\n   */\n\t\tkeyCodes: Object.create(null),\n\n\t\t/**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n\t\tisReservedTag: no,\n\n\t\t/**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n\t\tisReservedAttr: no,\n\n\t\t/**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n\t\tisUnknownElement: no,\n\n\t\t/**\n   * Get the namespace of an element\n   */\n\t\tgetTagNamespace: noop,\n\n\t\t/**\n   * Parse the real tag name for the specific platform.\n   */\n\t\tparsePlatformTagName: identity,\n\n\t\t/**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n\t\tmustUseProp: no,\n\n\t\t/**\n   * Exposed for legacy reasons\n   */\n\t\t_lifecycleHooks: LIFECYCLE_HOOKS\n\t};\n\n\t/*  */\n\n\tvar emptyObject = Object.freeze({});\n\n\t/**\n  * Check if a string starts with $ or _\n  */\n\tfunction isReserved(str) {\n\t\tvar c = (str + '').charCodeAt(0);\n\t\treturn c === 0x24 || c === 0x5F;\n\t}\n\n\t/**\n  * Define a property.\n  */\n\tfunction def(obj, key, val, enumerable) {\n\t\tObject.defineProperty(obj, key, {\n\t\t\tvalue: val,\n\t\t\tenumerable: !!enumerable,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t}\n\n\t/**\n  * Parse simple path.\n  */\n\tvar bailRE = /[^\\w.$]/;\n\tfunction parsePath(path) {\n\t\tif (bailRE.test(path)) {\n\t\t\treturn;\n\t\t}\n\t\tvar segments = path.split('.');\n\t\treturn function (obj) {\n\t\t\tfor (var i = 0; i < segments.length; i++) {\n\t\t\t\tif (!obj) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobj = obj[segments[i]];\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t}\n\n\t/*  */\n\n\tvar warn = noop;\n\tvar tip = noop;\n\tvar formatComponentName = null; // work around flow check\n\n\t{\n\t\tvar hasConsole = typeof console !== 'undefined';\n\t\tvar classifyRE = /(?:^|[-_])(\\w)/g;\n\t\tvar classify = function classify(str) {\n\t\t\treturn str.replace(classifyRE, function (c) {\n\t\t\t\treturn c.toUpperCase();\n\t\t\t}).replace(/[-_]/g, '');\n\t\t};\n\n\t\twarn = function warn(msg, vm) {\n\t\t\tif (hasConsole && !config.silent) {\n\t\t\t\tconsole.error(\"[Vue warn]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n\t\t\t}\n\t\t};\n\n\t\ttip = function tip(msg, vm) {\n\t\t\tif (hasConsole && !config.silent) {\n\t\t\t\tconsole.warn(\"[Vue tip]: \" + msg + (vm ? generateComponentTrace(vm) : ''));\n\t\t\t}\n\t\t};\n\n\t\tformatComponentName = function formatComponentName(vm, includeFile) {\n\t\t\tif (vm.$root === vm) {\n\t\t\t\treturn '<Root>';\n\t\t\t}\n\t\t\tvar name = typeof vm === 'string' ? vm : typeof vm === 'function' && vm.options ? vm.options.name : vm._isVue ? vm.$options.name || vm.$options._componentTag : vm.name;\n\n\t\t\tvar file = vm._isVue && vm.$options.__file;\n\t\t\tif (!name && file) {\n\t\t\t\tvar match = file.match(/([^/\\\\]+)\\.vue$/);\n\t\t\t\tname = match && match[1];\n\t\t\t}\n\n\t\t\treturn (name ? \"<\" + classify(name) + \">\" : \"<Anonymous>\") + (file && includeFile !== false ? \" at \" + file : '');\n\t\t};\n\n\t\tvar repeat = function repeat(str, n) {\n\t\t\tvar res = '';\n\t\t\twhile (n) {\n\t\t\t\tif (n % 2 === 1) {\n\t\t\t\t\tres += str;\n\t\t\t\t}\n\t\t\t\tif (n > 1) {\n\t\t\t\t\tstr += str;\n\t\t\t\t}\n\t\t\t\tn >>= 1;\n\t\t\t}\n\t\t\treturn res;\n\t\t};\n\n\t\tvar generateComponentTrace = function generateComponentTrace(vm) {\n\t\t\tif (vm._isVue && vm.$parent) {\n\t\t\t\tvar tree = [];\n\t\t\t\tvar currentRecursiveSequence = 0;\n\t\t\t\twhile (vm) {\n\t\t\t\t\tif (tree.length > 0) {\n\t\t\t\t\t\tvar last = tree[tree.length - 1];\n\t\t\t\t\t\tif (last.constructor === vm.constructor) {\n\t\t\t\t\t\t\tcurrentRecursiveSequence++;\n\t\t\t\t\t\t\tvm = vm.$parent;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (currentRecursiveSequence > 0) {\n\t\t\t\t\t\t\ttree[tree.length - 1] = [last, currentRecursiveSequence];\n\t\t\t\t\t\t\tcurrentRecursiveSequence = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttree.push(vm);\n\t\t\t\t\tvm = vm.$parent;\n\t\t\t\t}\n\t\t\t\treturn '\\n\\nfound in\\n\\n' + tree.map(function (vm, i) {\n\t\t\t\t\treturn \"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + \"... (\" + vm[1] + \" recursive calls)\" : formatComponentName(vm));\n\t\t\t\t}).join('\\n');\n\t\t\t} else {\n\t\t\t\treturn \"\\n\\n(found in \" + formatComponentName(vm) + \")\";\n\t\t\t}\n\t\t};\n\t}\n\n\t/*  */\n\n\tfunction handleError(err, vm, info) {\n\t\tif (config.errorHandler) {\n\t\t\tconfig.errorHandler.call(null, err, vm, info);\n\t\t} else {\n\t\t\t{\n\t\t\t\twarn(\"Error in \" + info + \": \\\"\" + err.toString() + \"\\\"\", vm);\n\t\t\t}\n\t\t\t/* istanbul ignore else */\n\t\t\tif (inBrowser && typeof console !== 'undefined') {\n\t\t\t\tconsole.error(err);\n\t\t\t} else {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\t/* globals MutationObserver */\n\n\t// can we use __proto__?\n\tvar hasProto = '__proto__' in {};\n\n\t// Browser environment sniffing\n\tvar inBrowser = typeof window !== 'undefined';\n\tvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\n\tvar isIE = UA && /msie|trident/.test(UA);\n\tvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n\tvar isEdge = UA && UA.indexOf('edge/') > 0;\n\tvar isAndroid = UA && UA.indexOf('android') > 0;\n\tvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\tvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n\tvar supportsPassive = false;\n\tif (inBrowser) {\n\t\ttry {\n\t\t\tvar opts = {};\n\t\t\tObject.defineProperty(opts, 'passive', {\n\t\t\t\tget: function get() {\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tsupportsPassive = true;\n\t\t\t\t}\n\t\t\t}); // https://github.com/facebook/flow/issues/285\n\t\t\twindow.addEventListener('test-passive', null, opts);\n\t\t} catch (e) {}\n\t}\n\n\t// this needs to be lazy-evaled because vue may be required before\n\t// vue-server-renderer can set VUE_ENV\n\tvar _isServer;\n\tvar isServerRendering = function isServerRendering() {\n\t\tif (_isServer === undefined) {\n\t\t\t/* istanbul ignore if */\n\t\t\tif (!inBrowser && typeof global !== 'undefined') {\n\t\t\t\t// detect presence of vue-server-renderer and avoid\n\t\t\t\t// Webpack shimming the process\n\t\t\t\t_isServer = global['process'].env.VUE_ENV === 'server';\n\t\t\t} else {\n\t\t\t\t_isServer = false;\n\t\t\t}\n\t\t}\n\t\treturn _isServer;\n\t};\n\n\t// detect devtools\n\tvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n\t/* istanbul ignore next */\n\tfunction isNative(Ctor) {\n\t\treturn typeof Ctor === 'function' && /native code/.test(Ctor.toString());\n\t}\n\n\tvar hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n\t/**\n  * Defer a task to execute it asynchronously.\n  */\n\tvar nextTick = function () {\n\t\tvar callbacks = [];\n\t\tvar pending = false;\n\t\tvar timerFunc;\n\n\t\tfunction nextTickHandler() {\n\t\t\tpending = false;\n\t\t\tvar copies = callbacks.slice(0);\n\t\t\tcallbacks.length = 0;\n\t\t\tfor (var i = 0; i < copies.length; i++) {\n\t\t\t\tcopies[i]();\n\t\t\t}\n\t\t}\n\n\t\t// the nextTick behavior leverages the microtask queue, which can be accessed\n\t\t// via either native Promise.then or MutationObserver.\n\t\t// MutationObserver has wider support, however it is seriously bugged in\n\t\t// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n\t\t// completely stops working after triggering a few times... so, if native\n\t\t// Promise is available, we will use it:\n\t\t/* istanbul ignore if */\n\t\tif (typeof Promise !== 'undefined' && isNative(Promise)) {\n\t\t\tvar p = Promise.resolve();\n\t\t\tvar logError = function logError(err) {\n\t\t\t\tconsole.error(err);\n\t\t\t};\n\t\t\ttimerFunc = function timerFunc() {\n\t\t\t\tp.then(nextTickHandler).catch(logError);\n\t\t\t\t// in problematic UIWebViews, Promise.then doesn't completely break, but\n\t\t\t\t// it can get stuck in a weird state where callbacks are pushed into the\n\t\t\t\t// microtask queue but the queue isn't being flushed, until the browser\n\t\t\t\t// needs to do some other work, e.g. handle a timer. Therefore we can\n\t\t\t\t// \"force\" the microtask queue to be flushed by adding an empty timer.\n\t\t\t\tif (isIOS) {\n\t\t\t\t\tsetTimeout(noop);\n\t\t\t\t}\n\t\t\t};\n\t\t} else if (typeof MutationObserver !== 'undefined' && (isNative(MutationObserver) ||\n\t\t// PhantomJS and iOS 7.x\n\t\tMutationObserver.toString() === '[object MutationObserverConstructor]')) {\n\t\t\t// use MutationObserver where native Promise is not available,\n\t\t\t// e.g. PhantomJS IE11, iOS7, Android 4.4\n\t\t\tvar counter = 1;\n\t\t\tvar observer = new MutationObserver(nextTickHandler);\n\t\t\tvar textNode = document.createTextNode(String(counter));\n\t\t\tobserver.observe(textNode, {\n\t\t\t\tcharacterData: true\n\t\t\t});\n\t\t\ttimerFunc = function timerFunc() {\n\t\t\t\tcounter = (counter + 1) % 2;\n\t\t\t\ttextNode.data = String(counter);\n\t\t\t};\n\t\t} else {\n\t\t\t// fallback to setTimeout\n\t\t\t/* istanbul ignore next */\n\t\t\ttimerFunc = function timerFunc() {\n\t\t\t\tsetTimeout(nextTickHandler, 0);\n\t\t\t};\n\t\t}\n\n\t\treturn function queueNextTick(cb, ctx) {\n\t\t\tvar _resolve;\n\t\t\tcallbacks.push(function () {\n\t\t\t\tif (cb) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcb.call(ctx);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\thandleError(e, ctx, 'nextTick');\n\t\t\t\t\t}\n\t\t\t\t} else if (_resolve) {\n\t\t\t\t\t_resolve(ctx);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!pending) {\n\t\t\t\tpending = true;\n\t\t\t\ttimerFunc();\n\t\t\t}\n\t\t\tif (!cb && typeof Promise !== 'undefined') {\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t_resolve = resolve;\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t}();\n\n\tvar _Set;\n\t/* istanbul ignore if */\n\tif (typeof Set !== 'undefined' && isNative(Set)) {\n\t\t// use native Set when available.\n\t\t_Set = Set;\n\t} else {\n\t\t// a non-standard Set polyfill that only works with primitive keys.\n\t\t_Set = function () {\n\t\t\tfunction Set() {\n\t\t\t\tthis.set = Object.create(null);\n\t\t\t}\n\t\t\tSet.prototype.has = function has(key) {\n\t\t\t\treturn this.set[key] === true;\n\t\t\t};\n\t\t\tSet.prototype.add = function add(key) {\n\t\t\t\tthis.set[key] = true;\n\t\t\t};\n\t\t\tSet.prototype.clear = function clear() {\n\t\t\t\tthis.set = Object.create(null);\n\t\t\t};\n\n\t\t\treturn Set;\n\t\t}();\n\t}\n\n\t/*  */\n\n\tvar uid = 0;\n\n\t/**\n  * A dep is an observable that can have multiple\n  * directives subscribing to it.\n  */\n\tvar Dep = function Dep() {\n\t\tthis.id = uid++;\n\t\tthis.subs = [];\n\t};\n\n\tDep.prototype.addSub = function addSub(sub) {\n\t\tthis.subs.push(sub);\n\t};\n\n\tDep.prototype.removeSub = function removeSub(sub) {\n\t\tremove(this.subs, sub);\n\t};\n\n\tDep.prototype.depend = function depend() {\n\t\tif (Dep.target) {\n\t\t\tDep.target.addDep(this);\n\t\t}\n\t};\n\n\tDep.prototype.notify = function notify() {\n\t\t// stabilize the subscriber list first\n\t\tvar subs = this.subs.slice();\n\t\tfor (var i = 0, l = subs.length; i < l; i++) {\n\t\t\tsubs[i].update();\n\t\t}\n\t};\n\n\t// the current target watcher being evaluated.\n\t// this is globally unique because there could be only one\n\t// watcher being evaluated at any time.\n\tDep.target = null;\n\tvar targetStack = [];\n\n\tfunction pushTarget(_target) {\n\t\tif (Dep.target) {\n\t\t\ttargetStack.push(Dep.target);\n\t\t}\n\t\tDep.target = _target;\n\t}\n\n\tfunction popTarget() {\n\t\tDep.target = targetStack.pop();\n\t}\n\n\t/*\n  * not type checking this file because flow doesn't play well with\n  * dynamically accessing methods on Array prototype\n  */\n\n\tvar arrayProto = Array.prototype;\n\tvar arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n\t\t// cache original method\n\t\tvar original = arrayProto[method];\n\t\tdef(arrayMethods, method, function mutator() {\n\t\t\tvar arguments$1 = arguments;\n\n\t\t\t// avoid leaking arguments:\n\t\t\t// http://jsperf.com/closure-with-arguments\n\t\t\tvar i = arguments.length;\n\t\t\tvar args = new Array(i);\n\t\t\twhile (i--) {\n\t\t\t\targs[i] = arguments$1[i];\n\t\t\t}\n\t\t\tvar result = original.apply(this, args);\n\t\t\tvar ob = this.__ob__;\n\t\t\tvar inserted;\n\t\t\tswitch (method) {\n\t\t\t\tcase 'push':\n\t\t\t\t\tinserted = args;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'unshift':\n\t\t\t\t\tinserted = args;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'splice':\n\t\t\t\t\tinserted = args.slice(2);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (inserted) {\n\t\t\t\tob.observeArray(inserted);\n\t\t\t}\n\t\t\t// notify change\n\t\t\tob.dep.notify();\n\t\t\treturn result;\n\t\t});\n\t});\n\n\t/*  */\n\n\tvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n\t/**\n  * By default, when a reactive property is set, the new value is\n  * also converted to become reactive. However when passing down props,\n  * we don't want to force conversion because the value may be a nested value\n  * under a frozen data structure. Converting it would defeat the optimization.\n  */\n\tvar observerState = {\n\t\tshouldConvert: true,\n\t\tisSettingProps: false\n\t};\n\n\t/**\n  * Observer class that are attached to each observed\n  * object. Once attached, the observer converts target\n  * object's property keys into getter/setters that\n  * collect dependencies and dispatches updates.\n  */\n\tvar Observer = function Observer(value) {\n\t\tthis.value = value;\n\t\tthis.dep = new Dep();\n\t\tthis.vmCount = 0;\n\t\tdef(value, '__ob__', this);\n\t\tif (Array.isArray(value)) {\n\t\t\tvar augment = hasProto ? protoAugment : copyAugment;\n\t\t\taugment(value, arrayMethods, arrayKeys);\n\t\t\tthis.observeArray(value);\n\t\t} else {\n\t\t\tthis.walk(value);\n\t\t}\n\t};\n\n\t/**\n  * Walk through each property and convert them into\n  * getter/setters. This method should only be called when\n  * value type is Object.\n  */\n\tObserver.prototype.walk = function walk(obj) {\n\t\tvar keys = Object.keys(obj);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tdefineReactive$$1(obj, keys[i], obj[keys[i]]);\n\t\t}\n\t};\n\n\t/**\n  * Observe a list of Array items.\n  */\n\tObserver.prototype.observeArray = function observeArray(items) {\n\t\tfor (var i = 0, l = items.length; i < l; i++) {\n\t\t\tobserve(items[i]);\n\t\t}\n\t};\n\n\t// helpers\n\n\t/**\n  * Augment an target Object or Array by intercepting\n  * the prototype chain using __proto__\n  */\n\tfunction protoAugment(target, src) {\n\t\t/* eslint-disable no-proto */\n\t\ttarget.__proto__ = src;\n\t\t/* eslint-enable no-proto */\n\t}\n\n\t/**\n  * Augment an target Object or Array by defining\n  * hidden properties.\n  */\n\t/* istanbul ignore next */\n\tfunction copyAugment(target, src, keys) {\n\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\t\t\tvar key = keys[i];\n\t\t\tdef(target, key, src[key]);\n\t\t}\n\t}\n\n\t/**\n  * Attempt to create an observer instance for a value,\n  * returns the new observer if successfully observed,\n  * or the existing observer if the value already has one.\n  */\n\tfunction observe(value, asRootData) {\n\t\tif (!isObject(value)) {\n\t\t\treturn;\n\t\t}\n\t\tvar ob;\n\t\tif (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n\t\t\tob = value.__ob__;\n\t\t} else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n\t\t\tob = new Observer(value);\n\t\t}\n\t\tif (asRootData && ob) {\n\t\t\tob.vmCount++;\n\t\t}\n\t\treturn ob;\n\t}\n\n\t/**\n  * Define a reactive property on an Object.\n  */\n\tfunction defineReactive$$1(obj, key, val, customSetter) {\n\t\tvar dep = new Dep();\n\n\t\tvar property = Object.getOwnPropertyDescriptor(obj, key);\n\t\tif (property && property.configurable === false) {\n\t\t\treturn;\n\t\t}\n\n\t\t// cater for pre-defined getter/setters\n\t\tvar getter = property && property.get;\n\t\tvar setter = property && property.set;\n\n\t\tvar childOb = observe(val);\n\t\tObject.defineProperty(obj, key, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tget: function reactiveGetter() {\n\t\t\t\tvar value = getter ? getter.call(obj) : val;\n\t\t\t\tif (Dep.target) {\n\t\t\t\t\tdep.depend();\n\t\t\t\t\tif (childOb) {\n\t\t\t\t\t\tchildOb.dep.depend();\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\tdependArray(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tset: function reactiveSetter(newVal) {\n\t\t\t\tvar value = getter ? getter.call(obj) : val;\n\t\t\t\t/* eslint-disable no-self-compare */\n\t\t\t\tif (newVal === value || newVal !== newVal && value !== value) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t/* eslint-enable no-self-compare */\n\t\t\t\tif (\"development\" !== 'production' && customSetter) {\n\t\t\t\t\tcustomSetter();\n\t\t\t\t}\n\t\t\t\tif (setter) {\n\t\t\t\t\tsetter.call(obj, newVal);\n\t\t\t\t} else {\n\t\t\t\t\tval = newVal;\n\t\t\t\t}\n\t\t\t\tchildOb = observe(newVal);\n\t\t\t\tdep.notify();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n  * Set a property on an object. Adds the new property and\n  * triggers change notification if the property doesn't\n  * already exist.\n  */\n\tfunction set(target, key, val) {\n\t\tif (Array.isArray(target) && typeof key === 'number') {\n\t\t\ttarget.length = Math.max(target.length, key);\n\t\t\ttarget.splice(key, 1, val);\n\t\t\treturn val;\n\t\t}\n\t\tif (hasOwn(target, key)) {\n\t\t\ttarget[key] = val;\n\t\t\treturn val;\n\t\t}\n\t\tvar ob = target.__ob__;\n\t\tif (target._isVue || ob && ob.vmCount) {\n\t\t\t\"development\" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');\n\t\t\treturn val;\n\t\t}\n\t\tif (!ob) {\n\t\t\ttarget[key] = val;\n\t\t\treturn val;\n\t\t}\n\t\tdefineReactive$$1(ob.value, key, val);\n\t\tob.dep.notify();\n\t\treturn val;\n\t}\n\n\t/**\n  * Delete a property and trigger change if necessary.\n  */\n\tfunction del(target, key) {\n\t\tif (Array.isArray(target) && typeof key === 'number') {\n\t\t\ttarget.splice(key, 1);\n\t\t\treturn;\n\t\t}\n\t\tvar ob = target.__ob__;\n\t\tif (target._isVue || ob && ob.vmCount) {\n\t\t\t\"development\" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');\n\t\t\treturn;\n\t\t}\n\t\tif (!hasOwn(target, key)) {\n\t\t\treturn;\n\t\t}\n\t\tdelete target[key];\n\t\tif (!ob) {\n\t\t\treturn;\n\t\t}\n\t\tob.dep.notify();\n\t}\n\n\t/**\n  * Collect dependencies on array elements when the array is touched, since\n  * we cannot intercept array element access like property getters.\n  */\n\tfunction dependArray(value) {\n\t\tfor (var e = void 0, i = 0, l = value.length; i < l; i++) {\n\t\t\te = value[i];\n\t\t\te && e.__ob__ && e.__ob__.dep.depend();\n\t\t\tif (Array.isArray(e)) {\n\t\t\t\tdependArray(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\t/**\n  * Option overwriting strategies are functions that handle\n  * how to merge a parent option value and a child option\n  * value into the final value.\n  */\n\tvar strats = config.optionMergeStrategies;\n\n\t/**\n  * Options with restrictions\n  */\n\t{\n\t\tstrats.el = strats.propsData = function (parent, child, vm, key) {\n\t\t\tif (!vm) {\n\t\t\t\twarn(\"option \\\"\" + key + \"\\\" can only be used during instance \" + 'creation with the `new` keyword.');\n\t\t\t}\n\t\t\treturn defaultStrat(parent, child);\n\t\t};\n\t}\n\n\t/**\n  * Helper that recursively merges two data objects together.\n  */\n\tfunction mergeData(to, from) {\n\t\tif (!from) {\n\t\t\treturn to;\n\t\t}\n\t\tvar key, toVal, fromVal;\n\t\tvar keys = Object.keys(from);\n\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\tkey = keys[i];\n\t\t\ttoVal = to[key];\n\t\t\tfromVal = from[key];\n\t\t\tif (!hasOwn(to, key)) {\n\t\t\t\tset(to, key, fromVal);\n\t\t\t} else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n\t\t\t\tmergeData(toVal, fromVal);\n\t\t\t}\n\t\t}\n\t\treturn to;\n\t}\n\n\t/**\n  * Data\n  */\n\tstrats.data = function (parentVal, childVal, vm) {\n\t\tif (!vm) {\n\t\t\t// in a Vue.extend merge, both should be functions\n\t\t\tif (!childVal) {\n\t\t\t\treturn parentVal;\n\t\t\t}\n\t\t\tif (typeof childVal !== 'function') {\n\t\t\t\t\"development\" !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n\t\t\t\treturn parentVal;\n\t\t\t}\n\t\t\tif (!parentVal) {\n\t\t\t\treturn childVal;\n\t\t\t}\n\t\t\t// when parentVal & childVal are both present,\n\t\t\t// we need to return a function that returns the\n\t\t\t// merged result of both functions... no need to\n\t\t\t// check if parentVal is a function here because\n\t\t\t// it has to be a function to pass previous merges.\n\t\t\treturn function mergedDataFn() {\n\t\t\t\treturn mergeData(childVal.call(this), parentVal.call(this));\n\t\t\t};\n\t\t} else if (parentVal || childVal) {\n\t\t\treturn function mergedInstanceDataFn() {\n\t\t\t\t// instance merge\n\t\t\t\tvar instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n\t\t\t\tvar defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n\t\t\t\tif (instanceData) {\n\t\t\t\t\treturn mergeData(instanceData, defaultData);\n\t\t\t\t} else {\n\t\t\t\t\treturn defaultData;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n  * Hooks and props are merged as arrays.\n  */\n\tfunction mergeHook(parentVal, childVal) {\n\t\treturn childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;\n\t}\n\n\tLIFECYCLE_HOOKS.forEach(function (hook) {\n\t\tstrats[hook] = mergeHook;\n\t});\n\n\t/**\n  * Assets\n  *\n  * When a vm is present (instance creation), we need to do\n  * a three-way merge between constructor options, instance\n  * options and parent options.\n  */\n\tfunction mergeAssets(parentVal, childVal) {\n\t\tvar res = Object.create(parentVal || null);\n\t\treturn childVal ? extend(res, childVal) : res;\n\t}\n\n\tASSET_TYPES.forEach(function (type) {\n\t\tstrats[type + 's'] = mergeAssets;\n\t});\n\n\t/**\n  * Watchers.\n  *\n  * Watchers hashes should not overwrite one\n  * another, so we merge them as arrays.\n  */\n\tstrats.watch = function (parentVal, childVal) {\n\t\t/* istanbul ignore if */\n\t\tif (!childVal) {\n\t\t\treturn Object.create(parentVal || null);\n\t\t}\n\t\tif (!parentVal) {\n\t\t\treturn childVal;\n\t\t}\n\t\tvar ret = {};\n\t\textend(ret, parentVal);\n\t\tfor (var key in childVal) {\n\t\t\tvar parent = ret[key];\n\t\t\tvar child = childVal[key];\n\t\t\tif (parent && !Array.isArray(parent)) {\n\t\t\t\tparent = [parent];\n\t\t\t}\n\t\t\tret[key] = parent ? parent.concat(child) : [child];\n\t\t}\n\t\treturn ret;\n\t};\n\n\t/**\n  * Other object hashes.\n  */\n\tstrats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n\t\tif (!childVal) {\n\t\t\treturn Object.create(parentVal || null);\n\t\t}\n\t\tif (!parentVal) {\n\t\t\treturn childVal;\n\t\t}\n\t\tvar ret = Object.create(null);\n\t\textend(ret, parentVal);\n\t\textend(ret, childVal);\n\t\treturn ret;\n\t};\n\n\t/**\n  * Default strategy.\n  */\n\tvar defaultStrat = function defaultStrat(parentVal, childVal) {\n\t\treturn childVal === undefined ? parentVal : childVal;\n\t};\n\n\t/**\n  * Validate component names\n  */\n\tfunction checkComponents(options) {\n\t\tfor (var key in options.components) {\n\t\t\tvar lower = key.toLowerCase();\n\t\t\tif (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n\t\t\t\twarn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Ensure all props option syntax are normalized into the\n  * Object-based format.\n  */\n\tfunction normalizeProps(options) {\n\t\tvar props = options.props;\n\t\tif (!props) {\n\t\t\treturn;\n\t\t}\n\t\tvar res = {};\n\t\tvar i, val, name;\n\t\tif (Array.isArray(props)) {\n\t\t\ti = props.length;\n\t\t\twhile (i--) {\n\t\t\t\tval = props[i];\n\t\t\t\tif (typeof val === 'string') {\n\t\t\t\t\tname = camelize(val);\n\t\t\t\t\tres[name] = { type: null };\n\t\t\t\t} else {\n\t\t\t\t\twarn('props must be strings when using array syntax.');\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isPlainObject(props)) {\n\t\t\tfor (var key in props) {\n\t\t\t\tval = props[key];\n\t\t\t\tname = camelize(key);\n\t\t\t\tres[name] = isPlainObject(val) ? val : { type: val };\n\t\t\t}\n\t\t}\n\t\toptions.props = res;\n\t}\n\n\t/**\n  * Normalize raw function directives into object format.\n  */\n\tfunction normalizeDirectives(options) {\n\t\tvar dirs = options.directives;\n\t\tif (dirs) {\n\t\t\tfor (var key in dirs) {\n\t\t\t\tvar def = dirs[key];\n\t\t\t\tif (typeof def === 'function') {\n\t\t\t\t\tdirs[key] = { bind: def, update: def };\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Merge two option objects into a new one.\n  * Core utility used in both instantiation and inheritance.\n  */\n\tfunction mergeOptions(parent, child, vm) {\n\t\t{\n\t\t\tcheckComponents(child);\n\t\t}\n\n\t\tif (typeof child === 'function') {\n\t\t\tchild = child.options;\n\t\t}\n\n\t\tnormalizeProps(child);\n\t\tnormalizeDirectives(child);\n\t\tvar extendsFrom = child.extends;\n\t\tif (extendsFrom) {\n\t\t\tparent = mergeOptions(parent, extendsFrom, vm);\n\t\t}\n\t\tif (child.mixins) {\n\t\t\tfor (var i = 0, l = child.mixins.length; i < l; i++) {\n\t\t\t\tparent = mergeOptions(parent, child.mixins[i], vm);\n\t\t\t}\n\t\t}\n\t\tvar options = {};\n\t\tvar key;\n\t\tfor (key in parent) {\n\t\t\tmergeField(key);\n\t\t}\n\t\tfor (key in child) {\n\t\t\tif (!hasOwn(parent, key)) {\n\t\t\t\tmergeField(key);\n\t\t\t}\n\t\t}\n\t\tfunction mergeField(key) {\n\t\t\tvar strat = strats[key] || defaultStrat;\n\t\t\toptions[key] = strat(parent[key], child[key], vm, key);\n\t\t}\n\t\treturn options;\n\t}\n\n\t/**\n  * Resolve an asset.\n  * This function is used because child instances need access\n  * to assets defined in its ancestor chain.\n  */\n\tfunction resolveAsset(options, type, id, warnMissing) {\n\t\t/* istanbul ignore if */\n\t\tif (typeof id !== 'string') {\n\t\t\treturn;\n\t\t}\n\t\tvar assets = options[type];\n\t\t// check local registration variations first\n\t\tif (hasOwn(assets, id)) {\n\t\t\treturn assets[id];\n\t\t}\n\t\tvar camelizedId = camelize(id);\n\t\tif (hasOwn(assets, camelizedId)) {\n\t\t\treturn assets[camelizedId];\n\t\t}\n\t\tvar PascalCaseId = capitalize(camelizedId);\n\t\tif (hasOwn(assets, PascalCaseId)) {\n\t\t\treturn assets[PascalCaseId];\n\t\t}\n\t\t// fallback to prototype chain\n\t\tvar res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n\t\tif (\"development\" !== 'production' && warnMissing && !res) {\n\t\t\twarn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n\t\t}\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tfunction validateProp(key, propOptions, propsData, vm) {\n\t\tvar prop = propOptions[key];\n\t\tvar absent = !hasOwn(propsData, key);\n\t\tvar value = propsData[key];\n\t\t// handle boolean props\n\t\tif (isType(Boolean, prop.type)) {\n\t\t\tif (absent && !hasOwn(prop, 'default')) {\n\t\t\t\tvalue = false;\n\t\t\t} else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n\t\t\t\tvalue = true;\n\t\t\t}\n\t\t}\n\t\t// check default value\n\t\tif (value === undefined) {\n\t\t\tvalue = getPropDefaultValue(vm, prop, key);\n\t\t\t// since the default value is a fresh copy,\n\t\t\t// make sure to observe it.\n\t\t\tvar prevShouldConvert = observerState.shouldConvert;\n\t\t\tobserverState.shouldConvert = true;\n\t\t\tobserve(value);\n\t\t\tobserverState.shouldConvert = prevShouldConvert;\n\t\t}\n\t\t{\n\t\t\tassertProp(prop, key, value, vm, absent);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n  * Get the default value of a prop.\n  */\n\tfunction getPropDefaultValue(vm, prop, key) {\n\t\t// no default, return undefined\n\t\tif (!hasOwn(prop, 'default')) {\n\t\t\treturn undefined;\n\t\t}\n\t\tvar def = prop.default;\n\t\t// warn against non-factory defaults for Object & Array\n\t\tif (\"development\" !== 'production' && isObject(def)) {\n\t\t\twarn('Invalid default value for prop \"' + key + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n\t\t}\n\t\t// the raw prop value was also undefined from previous render,\n\t\t// return previous default value to avoid unnecessary watcher trigger\n\t\tif (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {\n\t\t\treturn vm._props[key];\n\t\t}\n\t\t// call factory function for non-Function types\n\t\t// a value is Function if its prototype is function even across different execution context\n\t\treturn typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;\n\t}\n\n\t/**\n  * Assert whether a prop is valid.\n  */\n\tfunction assertProp(prop, name, value, vm, absent) {\n\t\tif (prop.required && absent) {\n\t\t\twarn('Missing required prop: \"' + name + '\"', vm);\n\t\t\treturn;\n\t\t}\n\t\tif (value == null && !prop.required) {\n\t\t\treturn;\n\t\t}\n\t\tvar type = prop.type;\n\t\tvar valid = !type || type === true;\n\t\tvar expectedTypes = [];\n\t\tif (type) {\n\t\t\tif (!Array.isArray(type)) {\n\t\t\t\ttype = [type];\n\t\t\t}\n\t\t\tfor (var i = 0; i < type.length && !valid; i++) {\n\t\t\t\tvar assertedType = assertType(value, type[i]);\n\t\t\t\texpectedTypes.push(assertedType.expectedType || '');\n\t\t\t\tvalid = assertedType.valid;\n\t\t\t}\n\t\t}\n\t\tif (!valid) {\n\t\t\twarn('Invalid prop: type check failed for prop \"' + name + '\".' + ' Expected ' + expectedTypes.map(capitalize).join(', ') + ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.', vm);\n\t\t\treturn;\n\t\t}\n\t\tvar validator = prop.validator;\n\t\tif (validator) {\n\t\t\tif (!validator(value)) {\n\t\t\t\twarn('Invalid prop: custom validator check failed for prop \"' + name + '\".', vm);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n\tfunction assertType(value, type) {\n\t\tvar valid;\n\t\tvar expectedType = getType(type);\n\t\tif (simpleCheckRE.test(expectedType)) {\n\t\t\tvalid = (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === expectedType.toLowerCase();\n\t\t} else if (expectedType === 'Object') {\n\t\t\tvalid = isPlainObject(value);\n\t\t} else if (expectedType === 'Array') {\n\t\t\tvalid = Array.isArray(value);\n\t\t} else {\n\t\t\tvalid = value instanceof type;\n\t\t}\n\t\treturn {\n\t\t\tvalid: valid,\n\t\t\texpectedType: expectedType\n\t\t};\n\t}\n\n\t/**\n  * Use function string name to check built-in types,\n  * because a simple equality check will fail when running\n  * across different vms / iframes.\n  */\n\tfunction getType(fn) {\n\t\tvar match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n\t\treturn match ? match[1] : '';\n\t}\n\n\tfunction isType(type, fn) {\n\t\tif (!Array.isArray(fn)) {\n\t\t\treturn getType(fn) === getType(type);\n\t\t}\n\t\tfor (var i = 0, len = fn.length; i < len; i++) {\n\t\t\tif (getType(fn[i]) === getType(type)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn false;\n\t}\n\n\t/*  */\n\n\tvar mark;\n\tvar measure;\n\n\t{\n\t\tvar perf = inBrowser && window.performance;\n\t\t/* istanbul ignore if */\n\t\tif (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {\n\t\t\tmark = function mark(tag) {\n\t\t\t\treturn perf.mark(tag);\n\t\t\t};\n\t\t\tmeasure = function measure(name, startTag, endTag) {\n\t\t\t\tperf.measure(name, startTag, endTag);\n\t\t\t\tperf.clearMarks(startTag);\n\t\t\t\tperf.clearMarks(endTag);\n\t\t\t\tperf.clearMeasures(name);\n\t\t\t};\n\t\t}\n\t}\n\n\t/* not type checking this file because flow doesn't play well with Proxy */\n\n\tvar initProxy;\n\n\t{\n\t\tvar allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify\n\t\t);\n\n\t\tvar warnNonPresent = function warnNonPresent(target, key) {\n\t\t\twarn(\"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" + \"referenced during render. Make sure to declare reactive data \" + \"properties in the data option.\", target);\n\t\t};\n\n\t\tvar hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);\n\n\t\tif (hasProxy) {\n\t\t\tvar isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n\t\t\tconfig.keyCodes = new Proxy(config.keyCodes, {\n\t\t\t\tset: function set(target, key, value) {\n\t\t\t\t\tif (isBuiltInModifier(key)) {\n\t\t\t\t\t\twarn(\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[key] = value;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tvar hasHandler = {\n\t\t\thas: function has(target, key) {\n\t\t\t\tvar has = key in target;\n\t\t\t\tvar isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n\t\t\t\tif (!has && !isAllowed) {\n\t\t\t\t\twarnNonPresent(target, key);\n\t\t\t\t}\n\t\t\t\treturn has || !isAllowed;\n\t\t\t}\n\t\t};\n\n\t\tvar getHandler = {\n\t\t\tget: function get(target, key) {\n\t\t\t\tif (typeof key === 'string' && !(key in target)) {\n\t\t\t\t\twarnNonPresent(target, key);\n\t\t\t\t}\n\t\t\t\treturn target[key];\n\t\t\t}\n\t\t};\n\n\t\tinitProxy = function initProxy(vm) {\n\t\t\tif (hasProxy) {\n\t\t\t\t// determine which proxy handler to use\n\t\t\t\tvar options = vm.$options;\n\t\t\t\tvar handlers = options.render && options.render._withStripped ? getHandler : hasHandler;\n\t\t\t\tvm._renderProxy = new Proxy(vm, handlers);\n\t\t\t} else {\n\t\t\t\tvm._renderProxy = vm;\n\t\t\t}\n\t\t};\n\t}\n\n\t/*  */\n\n\tvar VNode = function VNode(tag, data, children, text, elm, context, componentOptions) {\n\t\tthis.tag = tag;\n\t\tthis.data = data;\n\t\tthis.children = children;\n\t\tthis.text = text;\n\t\tthis.elm = elm;\n\t\tthis.ns = undefined;\n\t\tthis.context = context;\n\t\tthis.functionalContext = undefined;\n\t\tthis.key = data && data.key;\n\t\tthis.componentOptions = componentOptions;\n\t\tthis.componentInstance = undefined;\n\t\tthis.parent = undefined;\n\t\tthis.raw = false;\n\t\tthis.isStatic = false;\n\t\tthis.isRootInsert = true;\n\t\tthis.isComment = false;\n\t\tthis.isCloned = false;\n\t\tthis.isOnce = false;\n\t};\n\n\tvar prototypeAccessors = { child: {} };\n\n\t// DEPRECATED: alias for componentInstance for backwards compat.\n\t/* istanbul ignore next */\n\tprototypeAccessors.child.get = function () {\n\t\treturn this.componentInstance;\n\t};\n\n\tObject.defineProperties(VNode.prototype, prototypeAccessors);\n\n\tvar createEmptyVNode = function createEmptyVNode() {\n\t\tvar node = new VNode();\n\t\tnode.text = '';\n\t\tnode.isComment = true;\n\t\treturn node;\n\t};\n\n\tfunction createTextVNode(val) {\n\t\treturn new VNode(undefined, undefined, undefined, String(val));\n\t}\n\n\t// optimized shallow clone\n\t// used for static nodes and slot nodes because they may be reused across\n\t// multiple renders, cloning them avoids errors when DOM manipulations rely\n\t// on their elm reference.\n\tfunction cloneVNode(vnode) {\n\t\tvar cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions);\n\t\tcloned.ns = vnode.ns;\n\t\tcloned.isStatic = vnode.isStatic;\n\t\tcloned.key = vnode.key;\n\t\tcloned.isComment = vnode.isComment;\n\t\tcloned.isCloned = true;\n\t\treturn cloned;\n\t}\n\n\tfunction cloneVNodes(vnodes) {\n\t\tvar len = vnodes.length;\n\t\tvar res = new Array(len);\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tres[i] = cloneVNode(vnodes[i]);\n\t\t}\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tvar normalizeEvent = cached(function (name) {\n\t\tvar passive = name.charAt(0) === '&';\n\t\tname = passive ? name.slice(1) : name;\n\t\tvar once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n\t\tname = once$$1 ? name.slice(1) : name;\n\t\tvar capture = name.charAt(0) === '!';\n\t\tname = capture ? name.slice(1) : name;\n\t\treturn {\n\t\t\tname: name,\n\t\t\tonce: once$$1,\n\t\t\tcapture: capture,\n\t\t\tpassive: passive\n\t\t};\n\t});\n\n\tfunction createFnInvoker(fns) {\n\t\tfunction invoker() {\n\t\t\tvar arguments$1 = arguments;\n\n\t\t\tvar fns = invoker.fns;\n\t\t\tif (Array.isArray(fns)) {\n\t\t\t\tfor (var i = 0; i < fns.length; i++) {\n\t\t\t\t\tfns[i].apply(null, arguments$1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// return handler return value for single handlers\n\t\t\t\treturn fns.apply(null, arguments);\n\t\t\t}\n\t\t}\n\t\tinvoker.fns = fns;\n\t\treturn invoker;\n\t}\n\n\tfunction updateListeners(on, oldOn, add, remove$$1, vm) {\n\t\tvar name, cur, old, event;\n\t\tfor (name in on) {\n\t\t\tcur = on[name];\n\t\t\told = oldOn[name];\n\t\t\tevent = normalizeEvent(name);\n\t\t\tif (isUndef(cur)) {\n\t\t\t\t\"development\" !== 'production' && warn(\"Invalid handler for event \\\"\" + event.name + \"\\\": got \" + String(cur), vm);\n\t\t\t} else if (isUndef(old)) {\n\t\t\t\tif (isUndef(cur.fns)) {\n\t\t\t\t\tcur = on[name] = createFnInvoker(cur);\n\t\t\t\t}\n\t\t\t\tadd(event.name, cur, event.once, event.capture, event.passive);\n\t\t\t} else if (cur !== old) {\n\t\t\t\told.fns = cur;\n\t\t\t\ton[name] = old;\n\t\t\t}\n\t\t}\n\t\tfor (name in oldOn) {\n\t\t\tif (isUndef(on[name])) {\n\t\t\t\tevent = normalizeEvent(name);\n\t\t\t\tremove$$1(event.name, oldOn[name], event.capture);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction mergeVNodeHook(def, hookKey, hook) {\n\t\tvar invoker;\n\t\tvar oldHook = def[hookKey];\n\n\t\tfunction wrappedHook() {\n\t\t\thook.apply(this, arguments);\n\t\t\t// important: remove merged hook to ensure it's called only once\n\t\t\t// and prevent memory leak\n\t\t\tremove(invoker.fns, wrappedHook);\n\t\t}\n\n\t\tif (isUndef(oldHook)) {\n\t\t\t// no existing hook\n\t\t\tinvoker = createFnInvoker([wrappedHook]);\n\t\t} else {\n\t\t\t/* istanbul ignore if */\n\t\t\tif (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n\t\t\t\t// already a merged invoker\n\t\t\t\tinvoker = oldHook;\n\t\t\t\tinvoker.fns.push(wrappedHook);\n\t\t\t} else {\n\t\t\t\t// existing plain hook\n\t\t\t\tinvoker = createFnInvoker([oldHook, wrappedHook]);\n\t\t\t}\n\t\t}\n\n\t\tinvoker.merged = true;\n\t\tdef[hookKey] = invoker;\n\t}\n\n\t/*  */\n\n\tfunction extractPropsFromVNodeData(data, Ctor, tag) {\n\t\t// we are only extracting raw values here.\n\t\t// validation and default values are handled in the child\n\t\t// component itself.\n\t\tvar propOptions = Ctor.options.props;\n\t\tif (isUndef(propOptions)) {\n\t\t\treturn;\n\t\t}\n\t\tvar res = {};\n\t\tvar attrs = data.attrs;\n\t\tvar props = data.props;\n\t\tif (isDef(attrs) || isDef(props)) {\n\t\t\tfor (var key in propOptions) {\n\t\t\t\tvar altKey = hyphenate(key);\n\t\t\t\t{\n\t\t\t\t\tvar keyInLowerCase = key.toLowerCase();\n\t\t\t\t\tif (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {\n\t\t\t\t\t\ttip(\"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + formatComponentName(tag || Ctor) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcheckProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction checkProp(res, hash, key, altKey, preserve) {\n\t\tif (isDef(hash)) {\n\t\t\tif (hasOwn(hash, key)) {\n\t\t\t\tres[key] = hash[key];\n\t\t\t\tif (!preserve) {\n\t\t\t\t\tdelete hash[key];\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else if (hasOwn(hash, altKey)) {\n\t\t\t\tres[key] = hash[altKey];\n\t\t\t\tif (!preserve) {\n\t\t\t\t\tdelete hash[altKey];\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*  */\n\n\t// The template compiler attempts to minimize the need for normalization by\n\t// statically analyzing the template at compile time.\n\t//\n\t// For plain HTML markup, normalization can be completely skipped because the\n\t// generated render function is guaranteed to return Array<VNode>. There are\n\t// two cases where extra normalization is needed:\n\n\t// 1. When the children contains components - because a functional component\n\t// may return an Array instead of a single root. In this case, just a simple\n\t// normalization is needed - if any child is an Array, we flatten the whole\n\t// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n\t// because functional components already normalize their own children.\n\tfunction simpleNormalizeChildren(children) {\n\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\tif (Array.isArray(children[i])) {\n\t\t\t\treturn Array.prototype.concat.apply([], children);\n\t\t\t}\n\t\t}\n\t\treturn children;\n\t}\n\n\t// 2. When the children contains constructs that always generated nested Arrays,\n\t// e.g. <template>, <slot>, v-for, or when the children is provided by user\n\t// with hand-written render functions / JSX. In such cases a full normalization\n\t// is needed to cater to all possible types of children values.\n\tfunction normalizeChildren(children) {\n\t\treturn isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;\n\t}\n\n\tfunction isTextNode(node) {\n\t\treturn isDef(node) && isDef(node.text) && isFalse(node.isComment);\n\t}\n\n\tfunction normalizeArrayChildren(children, nestedIndex) {\n\t\tvar res = [];\n\t\tvar i, c, last;\n\t\tfor (i = 0; i < children.length; i++) {\n\t\t\tc = children[i];\n\t\t\tif (isUndef(c) || typeof c === 'boolean') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlast = res[res.length - 1];\n\t\t\t//  nested\n\t\t\tif (Array.isArray(c)) {\n\t\t\t\tres.push.apply(res, normalizeArrayChildren(c, (nestedIndex || '') + \"_\" + i));\n\t\t\t} else if (isPrimitive(c)) {\n\t\t\t\tif (isTextNode(last)) {\n\t\t\t\t\t// merge adjacent text nodes\n\t\t\t\t\t// this is necessary for SSR hydration because text nodes are\n\t\t\t\t\t// essentially merged when rendered to HTML strings\n\t\t\t\t\tlast.text += String(c);\n\t\t\t\t} else if (c !== '') {\n\t\t\t\t\t// convert primitive to vnode\n\t\t\t\t\tres.push(createTextVNode(c));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isTextNode(c) && isTextNode(last)) {\n\t\t\t\t\t// merge adjacent text nodes\n\t\t\t\t\tres[res.length - 1] = createTextVNode(last.text + c.text);\n\t\t\t\t} else {\n\t\t\t\t\t// default key for nested array children (likely generated by v-for)\n\t\t\t\t\tif (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {\n\t\t\t\t\t\tc.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n\t\t\t\t\t}\n\t\t\t\t\tres.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tfunction ensureCtor(comp, base) {\n\t\treturn isObject(comp) ? base.extend(comp) : comp;\n\t}\n\n\tfunction resolveAsyncComponent(factory, baseCtor, context) {\n\t\tif (isTrue(factory.error) && isDef(factory.errorComp)) {\n\t\t\treturn factory.errorComp;\n\t\t}\n\n\t\tif (isDef(factory.resolved)) {\n\t\t\treturn factory.resolved;\n\t\t}\n\n\t\tif (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n\t\t\treturn factory.loadingComp;\n\t\t}\n\n\t\tif (isDef(factory.contexts)) {\n\t\t\t// already pending\n\t\t\tfactory.contexts.push(context);\n\t\t} else {\n\t\t\tvar contexts = factory.contexts = [context];\n\t\t\tvar sync = true;\n\n\t\t\tvar forceRender = function forceRender() {\n\t\t\t\tfor (var i = 0, l = contexts.length; i < l; i++) {\n\t\t\t\t\tcontexts[i].$forceUpdate();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar resolve = once(function (res) {\n\t\t\t\t// cache resolved\n\t\t\t\tfactory.resolved = ensureCtor(res, baseCtor);\n\t\t\t\t// invoke callbacks only if this is not a synchronous resolve\n\t\t\t\t// (async resolves are shimmed as synchronous during SSR)\n\t\t\t\tif (!sync) {\n\t\t\t\t\tforceRender();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar reject = once(function (reason) {\n\t\t\t\t\"development\" !== 'production' && warn(\"Failed to resolve async component: \" + String(factory) + (reason ? \"\\nReason: \" + reason : ''));\n\t\t\t\tif (isDef(factory.errorComp)) {\n\t\t\t\t\tfactory.error = true;\n\t\t\t\t\tforceRender();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar res = factory(resolve, reject);\n\n\t\t\tif (isObject(res)) {\n\t\t\t\tif (typeof res.then === 'function') {\n\t\t\t\t\t// () => Promise\n\t\t\t\t\tif (isUndef(factory.resolved)) {\n\t\t\t\t\t\tres.then(resolve, reject);\n\t\t\t\t\t}\n\t\t\t\t} else if (isDef(res.component) && typeof res.component.then === 'function') {\n\t\t\t\t\tres.component.then(resolve, reject);\n\n\t\t\t\t\tif (isDef(res.error)) {\n\t\t\t\t\t\tfactory.errorComp = ensureCtor(res.error, baseCtor);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isDef(res.loading)) {\n\t\t\t\t\t\tfactory.loadingComp = ensureCtor(res.loading, baseCtor);\n\t\t\t\t\t\tif (res.delay === 0) {\n\t\t\t\t\t\t\tfactory.loading = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\tif (isUndef(factory.resolved) && isUndef(factory.error)) {\n\t\t\t\t\t\t\t\t\tfactory.loading = true;\n\t\t\t\t\t\t\t\t\tforceRender();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, res.delay || 200);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isDef(res.timeout)) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tif (isUndef(factory.resolved)) {\n\t\t\t\t\t\t\t\treject(\"timeout (\" + res.timeout + \"ms)\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, res.timeout);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsync = false;\n\t\t\t// return in case resolved synchronously\n\t\t\treturn factory.loading ? factory.loadingComp : factory.resolved;\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction getFirstComponentChild(children) {\n\t\tif (Array.isArray(children)) {\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\t\tvar c = children[i];\n\t\t\t\tif (isDef(c) && isDef(c.componentOptions)) {\n\t\t\t\t\treturn c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\t/*  */\n\n\tfunction initEvents(vm) {\n\t\tvm._events = Object.create(null);\n\t\tvm._hasHookEvent = false;\n\t\t// init parent attached events\n\t\tvar listeners = vm.$options._parentListeners;\n\t\tif (listeners) {\n\t\t\tupdateComponentListeners(vm, listeners);\n\t\t}\n\t}\n\n\tvar target;\n\n\tfunction add(event, fn, once$$1) {\n\t\tif (once$$1) {\n\t\t\ttarget.$once(event, fn);\n\t\t} else {\n\t\t\ttarget.$on(event, fn);\n\t\t}\n\t}\n\n\tfunction remove$1(event, fn) {\n\t\ttarget.$off(event, fn);\n\t}\n\n\tfunction updateComponentListeners(vm, listeners, oldListeners) {\n\t\ttarget = vm;\n\t\tupdateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n\t}\n\n\tfunction eventsMixin(Vue) {\n\t\tvar hookRE = /^hook:/;\n\t\tVue.prototype.$on = function (event, fn) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar vm = this;\n\t\t\tif (Array.isArray(event)) {\n\t\t\t\tfor (var i = 0, l = event.length; i < l; i++) {\n\t\t\t\t\tthis$1.$on(event[i], fn);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t(vm._events[event] || (vm._events[event] = [])).push(fn);\n\t\t\t\t// optimize hook:event cost by using a boolean flag marked at registration\n\t\t\t\t// instead of a hash lookup\n\t\t\t\tif (hookRE.test(event)) {\n\t\t\t\t\tvm._hasHookEvent = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vm;\n\t\t};\n\n\t\tVue.prototype.$once = function (event, fn) {\n\t\t\tvar vm = this;\n\t\t\tfunction on() {\n\t\t\t\tvm.$off(event, on);\n\t\t\t\tfn.apply(vm, arguments);\n\t\t\t}\n\t\t\ton.fn = fn;\n\t\t\tvm.$on(event, on);\n\t\t\treturn vm;\n\t\t};\n\n\t\tVue.prototype.$off = function (event, fn) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar vm = this;\n\t\t\t// all\n\t\t\tif (!arguments.length) {\n\t\t\t\tvm._events = Object.create(null);\n\t\t\t\treturn vm;\n\t\t\t}\n\t\t\t// array of events\n\t\t\tif (Array.isArray(event)) {\n\t\t\t\tfor (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n\t\t\t\t\tthis$1.$off(event[i$1], fn);\n\t\t\t\t}\n\t\t\t\treturn vm;\n\t\t\t}\n\t\t\t// specific event\n\t\t\tvar cbs = vm._events[event];\n\t\t\tif (!cbs) {\n\t\t\t\treturn vm;\n\t\t\t}\n\t\t\tif (arguments.length === 1) {\n\t\t\t\tvm._events[event] = null;\n\t\t\t\treturn vm;\n\t\t\t}\n\t\t\t// specific handler\n\t\t\tvar cb;\n\t\t\tvar i = cbs.length;\n\t\t\twhile (i--) {\n\t\t\t\tcb = cbs[i];\n\t\t\t\tif (cb === fn || cb.fn === fn) {\n\t\t\t\t\tcbs.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vm;\n\t\t};\n\n\t\tVue.prototype.$emit = function (event) {\n\t\t\tvar vm = this;\n\t\t\t{\n\t\t\t\tvar lowerCaseEvent = event.toLowerCase();\n\t\t\t\tif (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n\t\t\t\t\ttip(\"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" + formatComponentName(vm) + \" but the handler is registered for \\\"\" + event + \"\\\". \" + \"Note that HTML attributes are case-insensitive and you cannot use \" + \"v-on to listen to camelCase events when using in-DOM templates. \" + \"You should probably use \\\"\" + hyphenate(event) + \"\\\" instead of \\\"\" + event + \"\\\".\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar cbs = vm._events[event];\n\t\t\tif (cbs) {\n\t\t\t\tcbs = cbs.length > 1 ? toArray(cbs) : cbs;\n\t\t\t\tvar args = toArray(arguments, 1);\n\t\t\t\tfor (var i = 0, l = cbs.length; i < l; i++) {\n\t\t\t\t\tcbs[i].apply(vm, args);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vm;\n\t\t};\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for resolving raw children VNodes into a slot object.\n  */\n\tfunction resolveSlots(children, context) {\n\t\tvar slots = {};\n\t\tif (!children) {\n\t\t\treturn slots;\n\t\t}\n\t\tvar defaultSlot = [];\n\t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t\t\tvar child = children[i];\n\t\t\t// named slots should only be respected if the vnode was rendered in the\n\t\t\t// same context.\n\t\t\tif ((child.context === context || child.functionalContext === context) && child.data && child.data.slot != null) {\n\t\t\t\tvar name = child.data.slot;\n\t\t\t\tvar slot = slots[name] || (slots[name] = []);\n\t\t\t\tif (child.tag === 'template') {\n\t\t\t\t\tslot.push.apply(slot, child.children);\n\t\t\t\t} else {\n\t\t\t\t\tslot.push(child);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdefaultSlot.push(child);\n\t\t\t}\n\t\t}\n\t\t// ignore whitespace\n\t\tif (!defaultSlot.every(isWhitespace)) {\n\t\t\tslots.default = defaultSlot;\n\t\t}\n\t\treturn slots;\n\t}\n\n\tfunction isWhitespace(node) {\n\t\treturn node.isComment || node.text === ' ';\n\t}\n\n\tfunction resolveScopedSlots(fns, // see flow/vnode\n\tres) {\n\t\tres = res || {};\n\t\tfor (var i = 0; i < fns.length; i++) {\n\t\t\tif (Array.isArray(fns[i])) {\n\t\t\t\tresolveScopedSlots(fns[i], res);\n\t\t\t} else {\n\t\t\t\tres[fns[i].key] = fns[i].fn;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tvar activeInstance = null;\n\n\tfunction initLifecycle(vm) {\n\t\tvar options = vm.$options;\n\n\t\t// locate first non-abstract parent\n\t\tvar parent = options.parent;\n\t\tif (parent && !options.abstract) {\n\t\t\twhile (parent.$options.abstract && parent.$parent) {\n\t\t\t\tparent = parent.$parent;\n\t\t\t}\n\t\t\tparent.$children.push(vm);\n\t\t}\n\n\t\tvm.$parent = parent;\n\t\tvm.$root = parent ? parent.$root : vm;\n\n\t\tvm.$children = [];\n\t\tvm.$refs = {};\n\n\t\tvm._watcher = null;\n\t\tvm._inactive = null;\n\t\tvm._directInactive = false;\n\t\tvm._isMounted = false;\n\t\tvm._isDestroyed = false;\n\t\tvm._isBeingDestroyed = false;\n\t}\n\n\tfunction lifecycleMixin(Vue) {\n\t\tVue.prototype._update = function (vnode, hydrating) {\n\t\t\tvar vm = this;\n\t\t\tif (vm._isMounted) {\n\t\t\t\tcallHook(vm, 'beforeUpdate');\n\t\t\t}\n\t\t\tvar prevEl = vm.$el;\n\t\t\tvar prevVnode = vm._vnode;\n\t\t\tvar prevActiveInstance = activeInstance;\n\t\t\tactiveInstance = vm;\n\t\t\tvm._vnode = vnode;\n\t\t\t// Vue.prototype.__patch__ is injected in entry points\n\t\t\t// based on the rendering backend used.\n\t\t\tif (!prevVnode) {\n\t\t\t\t// initial render\n\t\t\t\tvm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */\n\t\t\t\t, vm.$options._parentElm, vm.$options._refElm);\n\t\t\t} else {\n\t\t\t\t// updates\n\t\t\t\tvm.$el = vm.__patch__(prevVnode, vnode);\n\t\t\t}\n\t\t\tactiveInstance = prevActiveInstance;\n\t\t\t// update __vue__ reference\n\t\t\tif (prevEl) {\n\t\t\t\tprevEl.__vue__ = null;\n\t\t\t}\n\t\t\tif (vm.$el) {\n\t\t\t\tvm.$el.__vue__ = vm;\n\t\t\t}\n\t\t\t// if parent is an HOC, update its $el as well\n\t\t\tif (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n\t\t\t\tvm.$parent.$el = vm.$el;\n\t\t\t}\n\t\t\t// updated hook is called by the scheduler to ensure that children are\n\t\t\t// updated in a parent's updated hook.\n\t\t};\n\n\t\tVue.prototype.$forceUpdate = function () {\n\t\t\tvar vm = this;\n\t\t\tif (vm._watcher) {\n\t\t\t\tvm._watcher.update();\n\t\t\t}\n\t\t};\n\n\t\tVue.prototype.$destroy = function () {\n\t\t\tvar vm = this;\n\t\t\tif (vm._isBeingDestroyed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcallHook(vm, 'beforeDestroy');\n\t\t\tvm._isBeingDestroyed = true;\n\t\t\t// remove self from parent\n\t\t\tvar parent = vm.$parent;\n\t\t\tif (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n\t\t\t\tremove(parent.$children, vm);\n\t\t\t}\n\t\t\t// teardown watchers\n\t\t\tif (vm._watcher) {\n\t\t\t\tvm._watcher.teardown();\n\t\t\t}\n\t\t\tvar i = vm._watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tvm._watchers[i].teardown();\n\t\t\t}\n\t\t\t// remove reference from data ob\n\t\t\t// frozen object may not have observer.\n\t\t\tif (vm._data.__ob__) {\n\t\t\t\tvm._data.__ob__.vmCount--;\n\t\t\t}\n\t\t\t// call the last hook...\n\t\t\tvm._isDestroyed = true;\n\t\t\t// invoke destroy hooks on current rendered tree\n\t\t\tvm.__patch__(vm._vnode, null);\n\t\t\t// fire destroyed hook\n\t\t\tcallHook(vm, 'destroyed');\n\t\t\t// turn off all instance listeners.\n\t\t\tvm.$off();\n\t\t\t// remove __vue__ reference\n\t\t\tif (vm.$el) {\n\t\t\t\tvm.$el.__vue__ = null;\n\t\t\t}\n\t\t\t// remove reference to DOM nodes (prevents leak)\n\t\t\tvm.$options._parentElm = vm.$options._refElm = null;\n\t\t};\n\t}\n\n\tfunction mountComponent(vm, el, hydrating) {\n\t\tvm.$el = el;\n\t\tif (!vm.$options.render) {\n\t\t\tvm.$options.render = createEmptyVNode;\n\t\t\t{\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {\n\t\t\t\t\twarn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);\n\t\t\t\t} else {\n\t\t\t\t\twarn('Failed to mount component: template or render function not defined.', vm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcallHook(vm, 'beforeMount');\n\n\t\tvar updateComponent;\n\t\t/* istanbul ignore if */\n\t\tif (\"development\" !== 'production' && config.performance && mark) {\n\t\t\tupdateComponent = function updateComponent() {\n\t\t\t\tvar name = vm._name;\n\t\t\t\tvar id = vm._uid;\n\t\t\t\tvar startTag = \"vue-perf-start:\" + id;\n\t\t\t\tvar endTag = \"vue-perf-end:\" + id;\n\n\t\t\t\tmark(startTag);\n\t\t\t\tvar vnode = vm._render();\n\t\t\t\tmark(endTag);\n\t\t\t\tmeasure(name + \" render\", startTag, endTag);\n\n\t\t\t\tmark(startTag);\n\t\t\t\tvm._update(vnode, hydrating);\n\t\t\t\tmark(endTag);\n\t\t\t\tmeasure(name + \" patch\", startTag, endTag);\n\t\t\t};\n\t\t} else {\n\t\t\tupdateComponent = function updateComponent() {\n\t\t\t\tvm._update(vm._render(), hydrating);\n\t\t\t};\n\t\t}\n\n\t\tvm._watcher = new Watcher(vm, updateComponent, noop);\n\t\thydrating = false;\n\n\t\t// manually mounted instance, call mounted on self\n\t\t// mounted is called for render-created child components in its inserted hook\n\t\tif (vm.$vnode == null) {\n\t\t\tvm._isMounted = true;\n\t\t\tcallHook(vm, 'mounted');\n\t\t}\n\t\treturn vm;\n\t}\n\n\tfunction updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {\n\t\t// determine whether component has slot children\n\t\t// we need to do this before overwriting $options._renderChildren\n\t\tvar hasChildren = !!(renderChildren || // has new static slots\n\t\tvm.$options._renderChildren || // has old static slots\n\t\tparentVnode.data.scopedSlots || // has new scoped slots\n\t\tvm.$scopedSlots !== emptyObject // has old scoped slots\n\t\t);\n\n\t\tvm.$options._parentVnode = parentVnode;\n\t\tvm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\t\tif (vm._vnode) {\n\t\t\t// update child tree's parent\n\t\t\tvm._vnode.parent = parentVnode;\n\t\t}\n\t\tvm.$options._renderChildren = renderChildren;\n\n\t\t// update props\n\t\tif (propsData && vm.$options.props) {\n\t\t\tobserverState.shouldConvert = false;\n\t\t\t{\n\t\t\t\tobserverState.isSettingProps = true;\n\t\t\t}\n\t\t\tvar props = vm._props;\n\t\t\tvar propKeys = vm.$options._propKeys || [];\n\t\t\tfor (var i = 0; i < propKeys.length; i++) {\n\t\t\t\tvar key = propKeys[i];\n\t\t\t\tprops[key] = validateProp(key, vm.$options.props, propsData, vm);\n\t\t\t}\n\t\t\tobserverState.shouldConvert = true;\n\t\t\t{\n\t\t\t\tobserverState.isSettingProps = false;\n\t\t\t}\n\t\t\t// keep a copy of raw propsData\n\t\t\tvm.$options.propsData = propsData;\n\t\t}\n\t\t// update listeners\n\t\tif (listeners) {\n\t\t\tvar oldListeners = vm.$options._parentListeners;\n\t\t\tvm.$options._parentListeners = listeners;\n\t\t\tupdateComponentListeners(vm, listeners, oldListeners);\n\t\t}\n\t\t// resolve slots + force update if has children\n\t\tif (hasChildren) {\n\t\t\tvm.$slots = resolveSlots(renderChildren, parentVnode.context);\n\t\t\tvm.$forceUpdate();\n\t\t}\n\t}\n\n\tfunction isInInactiveTree(vm) {\n\t\twhile (vm && (vm = vm.$parent)) {\n\t\t\tif (vm._inactive) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction activateChildComponent(vm, direct) {\n\t\tif (direct) {\n\t\t\tvm._directInactive = false;\n\t\t\tif (isInInactiveTree(vm)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if (vm._directInactive) {\n\t\t\treturn;\n\t\t}\n\t\tif (vm._inactive || vm._inactive === null) {\n\t\t\tvm._inactive = false;\n\t\t\tfor (var i = 0; i < vm.$children.length; i++) {\n\t\t\t\tactivateChildComponent(vm.$children[i]);\n\t\t\t}\n\t\t\tcallHook(vm, 'activated');\n\t\t}\n\t}\n\n\tfunction deactivateChildComponent(vm, direct) {\n\t\tif (direct) {\n\t\t\tvm._directInactive = true;\n\t\t\tif (isInInactiveTree(vm)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (!vm._inactive) {\n\t\t\tvm._inactive = true;\n\t\t\tfor (var i = 0; i < vm.$children.length; i++) {\n\t\t\t\tdeactivateChildComponent(vm.$children[i]);\n\t\t\t}\n\t\t\tcallHook(vm, 'deactivated');\n\t\t}\n\t}\n\n\tfunction callHook(vm, hook) {\n\t\tvar handlers = vm.$options[hook];\n\t\tif (handlers) {\n\t\t\tfor (var i = 0, j = handlers.length; i < j; i++) {\n\t\t\t\ttry {\n\t\t\t\t\thandlers[i].call(vm);\n\t\t\t\t} catch (e) {\n\t\t\t\t\thandleError(e, vm, hook + \" hook\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (vm._hasHookEvent) {\n\t\t\tvm.$emit('hook:' + hook);\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar MAX_UPDATE_COUNT = 100;\n\n\tvar queue = [];\n\tvar activatedChildren = [];\n\tvar has = {};\n\tvar circular = {};\n\tvar waiting = false;\n\tvar flushing = false;\n\tvar index = 0;\n\n\t/**\n  * Reset the scheduler's state.\n  */\n\tfunction resetSchedulerState() {\n\t\tindex = queue.length = activatedChildren.length = 0;\n\t\thas = {};\n\t\t{\n\t\t\tcircular = {};\n\t\t}\n\t\twaiting = flushing = false;\n\t}\n\n\t/**\n  * Flush both queues and run the watchers.\n  */\n\tfunction flushSchedulerQueue() {\n\t\tflushing = true;\n\t\tvar watcher, id;\n\n\t\t// Sort queue before flush.\n\t\t// This ensures that:\n\t\t// 1. Components are updated from parent to child. (because parent is always\n\t\t//    created before the child)\n\t\t// 2. A component's user watchers are run before its render watcher (because\n\t\t//    user watchers are created before the render watcher)\n\t\t// 3. If a component is destroyed during a parent component's watcher run,\n\t\t//    its watchers can be skipped.\n\t\tqueue.sort(function (a, b) {\n\t\t\treturn a.id - b.id;\n\t\t});\n\n\t\t// do not cache length because more watchers might be pushed\n\t\t// as we run existing watchers\n\t\tfor (index = 0; index < queue.length; index++) {\n\t\t\twatcher = queue[index];\n\t\t\tid = watcher.id;\n\t\t\thas[id] = null;\n\t\t\twatcher.run();\n\t\t\t// in dev build, check and stop circular updates.\n\t\t\tif (\"development\" !== 'production' && has[id] != null) {\n\t\t\t\tcircular[id] = (circular[id] || 0) + 1;\n\t\t\t\tif (circular[id] > MAX_UPDATE_COUNT) {\n\t\t\t\t\twarn('You may have an infinite update loop ' + (watcher.user ? \"in watcher with expression \\\"\" + watcher.expression + \"\\\"\" : \"in a component render function.\"), watcher.vm);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// keep copies of post queues before resetting state\n\t\tvar activatedQueue = activatedChildren.slice();\n\t\tvar updatedQueue = queue.slice();\n\n\t\tresetSchedulerState();\n\n\t\t// call component updated and activated hooks\n\t\tcallActivatedHooks(activatedQueue);\n\t\tcallUpdateHooks(updatedQueue);\n\n\t\t// devtool hook\n\t\t/* istanbul ignore if */\n\t\tif (devtools && config.devtools) {\n\t\t\tdevtools.emit('flush');\n\t\t}\n\t}\n\n\tfunction callUpdateHooks(queue) {\n\t\tvar i = queue.length;\n\t\twhile (i--) {\n\t\t\tvar watcher = queue[i];\n\t\t\tvar vm = watcher.vm;\n\t\t\tif (vm._watcher === watcher && vm._isMounted) {\n\t\t\t\tcallHook(vm, 'updated');\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Queue a kept-alive component that was activated during patch.\n  * The queue will be processed after the entire tree has been patched.\n  */\n\tfunction queueActivatedComponent(vm) {\n\t\t// setting _inactive to false here so that a render function can\n\t\t// rely on checking whether it's in an inactive tree (e.g. router-view)\n\t\tvm._inactive = false;\n\t\tactivatedChildren.push(vm);\n\t}\n\n\tfunction callActivatedHooks(queue) {\n\t\tfor (var i = 0; i < queue.length; i++) {\n\t\t\tqueue[i]._inactive = true;\n\t\t\tactivateChildComponent(queue[i], true /* true */);\n\t\t}\n\t}\n\n\t/**\n  * Push a watcher into the watcher queue.\n  * Jobs with duplicate IDs will be skipped unless it's\n  * pushed when the queue is being flushed.\n  */\n\tfunction queueWatcher(watcher) {\n\t\tvar id = watcher.id;\n\t\tif (has[id] == null) {\n\t\t\thas[id] = true;\n\t\t\tif (!flushing) {\n\t\t\t\tqueue.push(watcher);\n\t\t\t} else {\n\t\t\t\t// if already flushing, splice the watcher based on its id\n\t\t\t\t// if already past its id, it will be run next immediately.\n\t\t\t\tvar i = queue.length - 1;\n\t\t\t\twhile (i > index && queue[i].id > watcher.id) {\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\tqueue.splice(i + 1, 0, watcher);\n\t\t\t}\n\t\t\t// queue the flush\n\t\t\tif (!waiting) {\n\t\t\t\twaiting = true;\n\t\t\t\tnextTick(flushSchedulerQueue);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar uid$2 = 0;\n\n\t/**\n  * A watcher parses an expression, collects dependencies,\n  * and fires callback when the expression value changes.\n  * This is used for both the $watch() api and directives.\n  */\n\tvar Watcher = function Watcher(vm, expOrFn, cb, options) {\n\t\tthis.vm = vm;\n\t\tvm._watchers.push(this);\n\t\t// options\n\t\tif (options) {\n\t\t\tthis.deep = !!options.deep;\n\t\t\tthis.user = !!options.user;\n\t\t\tthis.lazy = !!options.lazy;\n\t\t\tthis.sync = !!options.sync;\n\t\t} else {\n\t\t\tthis.deep = this.user = this.lazy = this.sync = false;\n\t\t}\n\t\tthis.cb = cb;\n\t\tthis.id = ++uid$2; // uid for batching\n\t\tthis.active = true;\n\t\tthis.dirty = this.lazy; // for lazy watchers\n\t\tthis.deps = [];\n\t\tthis.newDeps = [];\n\t\tthis.depIds = new _Set();\n\t\tthis.newDepIds = new _Set();\n\t\tthis.expression = expOrFn.toString();\n\t\t// parse expression for getter\n\t\tif (typeof expOrFn === 'function') {\n\t\t\tthis.getter = expOrFn;\n\t\t} else {\n\t\t\tthis.getter = parsePath(expOrFn);\n\t\t\tif (!this.getter) {\n\t\t\t\tthis.getter = function () {};\n\t\t\t\t\"development\" !== 'production' && warn(\"Failed watching path: \\\"\" + expOrFn + \"\\\" \" + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);\n\t\t\t}\n\t\t}\n\t\tthis.value = this.lazy ? undefined : this.get();\n\t};\n\n\t/**\n  * Evaluate the getter, and re-collect dependencies.\n  */\n\tWatcher.prototype.get = function get() {\n\t\tpushTarget(this);\n\t\tvar value;\n\t\tvar vm = this.vm;\n\t\tif (this.user) {\n\t\t\ttry {\n\t\t\t\tvalue = this.getter.call(vm, vm);\n\t\t\t} catch (e) {\n\t\t\t\thandleError(e, vm, \"getter for watcher \\\"\" + this.expression + \"\\\"\");\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = this.getter.call(vm, vm);\n\t\t}\n\t\t// \"touch\" every property so they are all tracked as\n\t\t// dependencies for deep watching\n\t\tif (this.deep) {\n\t\t\ttraverse(value);\n\t\t}\n\t\tpopTarget();\n\t\tthis.cleanupDeps();\n\t\treturn value;\n\t};\n\n\t/**\n  * Add a dependency to this directive.\n  */\n\tWatcher.prototype.addDep = function addDep(dep) {\n\t\tvar id = dep.id;\n\t\tif (!this.newDepIds.has(id)) {\n\t\t\tthis.newDepIds.add(id);\n\t\t\tthis.newDeps.push(dep);\n\t\t\tif (!this.depIds.has(id)) {\n\t\t\t\tdep.addSub(this);\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Clean up for dependency collection.\n  */\n\tWatcher.prototype.cleanupDeps = function cleanupDeps() {\n\t\tvar this$1 = this;\n\n\t\tvar i = this.deps.length;\n\t\twhile (i--) {\n\t\t\tvar dep = this$1.deps[i];\n\t\t\tif (!this$1.newDepIds.has(dep.id)) {\n\t\t\t\tdep.removeSub(this$1);\n\t\t\t}\n\t\t}\n\t\tvar tmp = this.depIds;\n\t\tthis.depIds = this.newDepIds;\n\t\tthis.newDepIds = tmp;\n\t\tthis.newDepIds.clear();\n\t\ttmp = this.deps;\n\t\tthis.deps = this.newDeps;\n\t\tthis.newDeps = tmp;\n\t\tthis.newDeps.length = 0;\n\t};\n\n\t/**\n  * Subscriber interface.\n  * Will be called when a dependency changes.\n  */\n\tWatcher.prototype.update = function update() {\n\t\t/* istanbul ignore else */\n\t\tif (this.lazy) {\n\t\t\tthis.dirty = true;\n\t\t} else if (this.sync) {\n\t\t\tthis.run();\n\t\t} else {\n\t\t\tqueueWatcher(this);\n\t\t}\n\t};\n\n\t/**\n  * Scheduler job interface.\n  * Will be called by the scheduler.\n  */\n\tWatcher.prototype.run = function run() {\n\t\tif (this.active) {\n\t\t\tvar value = this.get();\n\t\t\tif (value !== this.value ||\n\t\t\t// Deep watchers and watchers on Object/Arrays should fire even\n\t\t\t// when the value is the same, because the value may\n\t\t\t// have mutated.\n\t\t\tisObject(value) || this.deep) {\n\t\t\t\t// set new value\n\t\t\t\tvar oldValue = this.value;\n\t\t\t\tthis.value = value;\n\t\t\t\tif (this.user) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.cb.call(this.vm, value, oldValue);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\thandleError(e, this.vm, \"callback for watcher \\\"\" + this.expression + \"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.cb.call(this.vm, value, oldValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Evaluate the value of the watcher.\n  * This only gets called for lazy watchers.\n  */\n\tWatcher.prototype.evaluate = function evaluate() {\n\t\tthis.value = this.get();\n\t\tthis.dirty = false;\n\t};\n\n\t/**\n  * Depend on all deps collected by this watcher.\n  */\n\tWatcher.prototype.depend = function depend() {\n\t\tvar this$1 = this;\n\n\t\tvar i = this.deps.length;\n\t\twhile (i--) {\n\t\t\tthis$1.deps[i].depend();\n\t\t}\n\t};\n\n\t/**\n  * Remove self from all dependencies' subscriber list.\n  */\n\tWatcher.prototype.teardown = function teardown() {\n\t\tvar this$1 = this;\n\n\t\tif (this.active) {\n\t\t\t// remove self from vm's watcher list\n\t\t\t// this is a somewhat expensive operation so we skip it\n\t\t\t// if the vm is being destroyed.\n\t\t\tif (!this.vm._isBeingDestroyed) {\n\t\t\t\tremove(this.vm._watchers, this);\n\t\t\t}\n\t\t\tvar i = this.deps.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis$1.deps[i].removeSub(this$1);\n\t\t\t}\n\t\t\tthis.active = false;\n\t\t}\n\t};\n\n\t/**\n  * Recursively traverse an object to evoke all converted\n  * getters, so that every nested property inside the object\n  * is collected as a \"deep\" dependency.\n  */\n\tvar seenObjects = new _Set();\n\tfunction traverse(val) {\n\t\tseenObjects.clear();\n\t\t_traverse(val, seenObjects);\n\t}\n\n\tfunction _traverse(val, seen) {\n\t\tvar i, keys;\n\t\tvar isA = Array.isArray(val);\n\t\tif (!isA && !isObject(val) || !Object.isExtensible(val)) {\n\t\t\treturn;\n\t\t}\n\t\tif (val.__ob__) {\n\t\t\tvar depId = val.__ob__.dep.id;\n\t\t\tif (seen.has(depId)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tseen.add(depId);\n\t\t}\n\t\tif (isA) {\n\t\t\ti = val.length;\n\t\t\twhile (i--) {\n\t\t\t\t_traverse(val[i], seen);\n\t\t\t}\n\t\t} else {\n\t\t\tkeys = Object.keys(val);\n\t\t\ti = keys.length;\n\t\t\twhile (i--) {\n\t\t\t\t_traverse(val[keys[i]], seen);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar sharedPropertyDefinition = {\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t\tget: noop,\n\t\tset: noop\n\t};\n\n\tfunction proxy(target, sourceKey, key) {\n\t\tsharedPropertyDefinition.get = function proxyGetter() {\n\t\t\treturn this[sourceKey][key];\n\t\t};\n\t\tsharedPropertyDefinition.set = function proxySetter(val) {\n\t\t\tthis[sourceKey][key] = val;\n\t\t};\n\t\tObject.defineProperty(target, key, sharedPropertyDefinition);\n\t}\n\n\tfunction initState(vm) {\n\t\tvm._watchers = [];\n\t\tvar opts = vm.$options;\n\t\tif (opts.props) {\n\t\t\tinitProps(vm, opts.props);\n\t\t}\n\t\tif (opts.methods) {\n\t\t\tinitMethods(vm, opts.methods);\n\t\t}\n\t\tif (opts.data) {\n\t\t\tinitData(vm);\n\t\t} else {\n\t\t\tobserve(vm._data = {}, true /* asRootData */);\n\t\t}\n\t\tif (opts.computed) {\n\t\t\tinitComputed(vm, opts.computed);\n\t\t}\n\t\tif (opts.watch) {\n\t\t\tinitWatch(vm, opts.watch);\n\t\t}\n\t}\n\n\tvar isReservedProp = {\n\t\tkey: 1,\n\t\tref: 1,\n\t\tslot: 1\n\t};\n\n\tfunction initProps(vm, propsOptions) {\n\t\tvar propsData = vm.$options.propsData || {};\n\t\tvar props = vm._props = {};\n\t\t// cache prop keys so that future props updates can iterate using Array\n\t\t// instead of dynamic object key enumeration.\n\t\tvar keys = vm.$options._propKeys = [];\n\t\tvar isRoot = !vm.$parent;\n\t\t// root instance props should be converted\n\t\tobserverState.shouldConvert = isRoot;\n\t\tvar loop = function loop(key) {\n\t\t\tkeys.push(key);\n\t\t\tvar value = validateProp(key, propsOptions, propsData, vm);\n\t\t\t/* istanbul ignore else */\n\t\t\t{\n\t\t\t\tif (isReservedProp[key] || config.isReservedAttr(key)) {\n\t\t\t\t\twarn(\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\", vm);\n\t\t\t\t}\n\t\t\t\tdefineReactive$$1(props, key, value, function () {\n\t\t\t\t\tif (vm.$parent && !observerState.isSettingProps) {\n\t\t\t\t\t\twarn(\"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t// static props are already proxied on the component's prototype\n\t\t\t// during Vue.extend(). We only need to proxy props defined at\n\t\t\t// instantiation here.\n\t\t\tif (!(key in vm)) {\n\t\t\t\tproxy(vm, \"_props\", key);\n\t\t\t}\n\t\t};\n\n\t\tfor (var key in propsOptions) {\n\t\t\tloop(key);\n\t\t}observerState.shouldConvert = true;\n\t}\n\n\tfunction initData(vm) {\n\t\tvar data = vm.$options.data;\n\t\tdata = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};\n\t\tif (!isPlainObject(data)) {\n\t\t\tdata = {};\n\t\t\t\"development\" !== 'production' && warn('data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);\n\t\t}\n\t\t// proxy data on instance\n\t\tvar keys = Object.keys(data);\n\t\tvar props = vm.$options.props;\n\t\tvar i = keys.length;\n\t\twhile (i--) {\n\t\t\tif (props && hasOwn(props, keys[i])) {\n\t\t\t\t\"development\" !== 'production' && warn(\"The data property \\\"\" + keys[i] + \"\\\" is already declared as a prop. \" + \"Use prop default value instead.\", vm);\n\t\t\t} else if (!isReserved(keys[i])) {\n\t\t\t\tproxy(vm, \"_data\", keys[i]);\n\t\t\t}\n\t\t}\n\t\t// observe data\n\t\tobserve(data, true /* asRootData */);\n\t}\n\n\tfunction getData(data, vm) {\n\t\ttry {\n\t\t\treturn data.call(vm);\n\t\t} catch (e) {\n\t\t\thandleError(e, vm, \"data()\");\n\t\t\treturn {};\n\t\t}\n\t}\n\n\tvar computedWatcherOptions = { lazy: true };\n\n\tfunction initComputed(vm, computed) {\n\t\tvar watchers = vm._computedWatchers = Object.create(null);\n\n\t\tfor (var key in computed) {\n\t\t\tvar userDef = computed[key];\n\t\t\tvar getter = typeof userDef === 'function' ? userDef : userDef.get;\n\t\t\t{\n\t\t\t\tif (getter === undefined) {\n\t\t\t\t\twarn(\"No getter function has been defined for computed property \\\"\" + key + \"\\\".\", vm);\n\t\t\t\t\tgetter = noop;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// create internal watcher for the computed property.\n\t\t\twatchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);\n\n\t\t\t// component-defined computed properties are already defined on the\n\t\t\t// component prototype. We only need to define computed properties defined\n\t\t\t// at instantiation here.\n\t\t\tif (!(key in vm)) {\n\t\t\t\tdefineComputed(vm, key, userDef);\n\t\t\t} else {\n\t\t\t\tif (key in vm.$data) {\n\t\t\t\t\twarn(\"The computed property \\\"\" + key + \"\\\" is already defined in data.\", vm);\n\t\t\t\t} else if (vm.$options.props && key in vm.$options.props) {\n\t\t\t\t\twarn(\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\", vm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction defineComputed(target, key, userDef) {\n\t\tif (typeof userDef === 'function') {\n\t\t\tsharedPropertyDefinition.get = createComputedGetter(key);\n\t\t\tsharedPropertyDefinition.set = noop;\n\t\t} else {\n\t\t\tsharedPropertyDefinition.get = userDef.get ? userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;\n\t\t\tsharedPropertyDefinition.set = userDef.set ? userDef.set : noop;\n\t\t}\n\t\tObject.defineProperty(target, key, sharedPropertyDefinition);\n\t}\n\n\tfunction createComputedGetter(key) {\n\t\treturn function computedGetter() {\n\t\t\tvar watcher = this._computedWatchers && this._computedWatchers[key];\n\t\t\tif (watcher) {\n\t\t\t\tif (watcher.dirty) {\n\t\t\t\t\twatcher.evaluate();\n\t\t\t\t}\n\t\t\t\tif (Dep.target) {\n\t\t\t\t\twatcher.depend();\n\t\t\t\t}\n\t\t\t\treturn watcher.value;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction initMethods(vm, methods) {\n\t\tvar props = vm.$options.props;\n\t\tfor (var key in methods) {\n\t\t\tvm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n\t\t\t{\n\t\t\t\tif (methods[key] == null) {\n\t\t\t\t\twarn(\"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" + \"Did you reference the function correctly?\", vm);\n\t\t\t\t}\n\t\t\t\tif (props && hasOwn(props, key)) {\n\t\t\t\t\twarn(\"method \\\"\" + key + \"\\\" has already been defined as a prop.\", vm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction initWatch(vm, watch) {\n\t\tfor (var key in watch) {\n\t\t\tvar handler = watch[key];\n\t\t\tif (Array.isArray(handler)) {\n\t\t\t\tfor (var i = 0; i < handler.length; i++) {\n\t\t\t\t\tcreateWatcher(vm, key, handler[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcreateWatcher(vm, key, handler);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction createWatcher(vm, key, handler) {\n\t\tvar options;\n\t\tif (isPlainObject(handler)) {\n\t\t\toptions = handler;\n\t\t\thandler = handler.handler;\n\t\t}\n\t\tif (typeof handler === 'string') {\n\t\t\thandler = vm[handler];\n\t\t}\n\t\tvm.$watch(key, handler, options);\n\t}\n\n\tfunction stateMixin(Vue) {\n\t\t// flow somehow has problems with directly declared definition object\n\t\t// when using Object.defineProperty, so we have to procedurally build up\n\t\t// the object here.\n\t\tvar dataDef = {};\n\t\tdataDef.get = function () {\n\t\t\treturn this._data;\n\t\t};\n\t\tvar propsDef = {};\n\t\tpropsDef.get = function () {\n\t\t\treturn this._props;\n\t\t};\n\t\t{\n\t\t\tdataDef.set = function (newData) {\n\t\t\t\twarn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);\n\t\t\t};\n\t\t\tpropsDef.set = function () {\n\t\t\t\twarn(\"$props is readonly.\", this);\n\t\t\t};\n\t\t}\n\t\tObject.defineProperty(Vue.prototype, '$data', dataDef);\n\t\tObject.defineProperty(Vue.prototype, '$props', propsDef);\n\n\t\tVue.prototype.$set = set;\n\t\tVue.prototype.$delete = del;\n\n\t\tVue.prototype.$watch = function (expOrFn, cb, options) {\n\t\t\tvar vm = this;\n\t\t\toptions = options || {};\n\t\t\toptions.user = true;\n\t\t\tvar watcher = new Watcher(vm, expOrFn, cb, options);\n\t\t\tif (options.immediate) {\n\t\t\t\tcb.call(vm, watcher.value);\n\t\t\t}\n\t\t\treturn function unwatchFn() {\n\t\t\t\twatcher.teardown();\n\t\t\t};\n\t\t};\n\t}\n\n\t/*  */\n\n\tfunction initProvide(vm) {\n\t\tvar provide = vm.$options.provide;\n\t\tif (provide) {\n\t\t\tvm._provided = typeof provide === 'function' ? provide.call(vm) : provide;\n\t\t}\n\t}\n\n\tfunction initInjections(vm) {\n\t\tvar result = resolveInject(vm.$options.inject, vm);\n\t\tif (result) {\n\t\t\tObject.keys(result).forEach(function (key) {\n\t\t\t\t/* istanbul ignore else */\n\t\t\t\t{\n\t\t\t\t\tdefineReactive$$1(vm, key, result[key], function () {\n\t\t\t\t\t\twarn(\"Avoid mutating an injected value directly since the changes will be \" + \"overwritten whenever the provided component re-renders. \" + \"injection being mutated: \\\"\" + key + \"\\\"\", vm);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction resolveInject(inject, vm) {\n\t\tif (inject) {\n\t\t\t// inject is :any because flow is not smart enough to figure out cached\n\t\t\t// isArray here\n\t\t\tvar isArray = Array.isArray(inject);\n\t\t\tvar result = Object.create(null);\n\t\t\tvar keys = isArray ? inject : hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\tvar key = keys[i];\n\t\t\t\tvar provideKey = isArray ? key : inject[key];\n\t\t\t\tvar source = vm;\n\t\t\t\twhile (source) {\n\t\t\t\t\tif (source._provided && provideKey in source._provided) {\n\t\t\t\t\t\tresult[key] = source._provided[provideKey];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tsource = source.$parent;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction createFunctionalComponent(Ctor, propsData, data, context, children) {\n\t\tvar props = {};\n\t\tvar propOptions = Ctor.options.props;\n\t\tif (isDef(propOptions)) {\n\t\t\tfor (var key in propOptions) {\n\t\t\t\tprops[key] = validateProp(key, propOptions, propsData || {});\n\t\t\t}\n\t\t} else {\n\t\t\tif (isDef(data.attrs)) {\n\t\t\t\tmergeProps(props, data.attrs);\n\t\t\t}\n\t\t\tif (isDef(data.props)) {\n\t\t\t\tmergeProps(props, data.props);\n\t\t\t}\n\t\t}\n\t\t// ensure the createElement function in functional components\n\t\t// gets a unique context - this is necessary for correct named slot check\n\t\tvar _context = Object.create(context);\n\t\tvar h = function h(a, b, c, d) {\n\t\t\treturn createElement(_context, a, b, c, d, true);\n\t\t};\n\t\tvar vnode = Ctor.options.render.call(null, h, {\n\t\t\tdata: data,\n\t\t\tprops: props,\n\t\t\tchildren: children,\n\t\t\tparent: context,\n\t\t\tlisteners: data.on || {},\n\t\t\tinjections: resolveInject(Ctor.options.inject, context),\n\t\t\tslots: function slots() {\n\t\t\t\treturn resolveSlots(children, context);\n\t\t\t}\n\t\t});\n\t\tif (vnode instanceof VNode) {\n\t\t\tvnode.functionalContext = context;\n\t\t\tvnode.functionalOptions = Ctor.options;\n\t\t\tif (data.slot) {\n\t\t\t\t(vnode.data || (vnode.data = {})).slot = data.slot;\n\t\t\t}\n\t\t}\n\t\treturn vnode;\n\t}\n\n\tfunction mergeProps(to, from) {\n\t\tfor (var key in from) {\n\t\t\tto[camelize(key)] = from[key];\n\t\t}\n\t}\n\n\t/*  */\n\n\t// hooks to be invoked on component VNodes during patch\n\tvar componentVNodeHooks = {\n\t\tinit: function init(vnode, hydrating, parentElm, refElm) {\n\t\t\tif (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n\t\t\t\tvar child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);\n\t\t\t\tchild.$mount(hydrating ? vnode.elm : undefined, hydrating);\n\t\t\t} else if (vnode.data.keepAlive) {\n\t\t\t\t// kept-alive components, treat as a patch\n\t\t\t\tvar mountedNode = vnode; // work around flow\n\t\t\t\tcomponentVNodeHooks.prepatch(mountedNode, mountedNode);\n\t\t\t}\n\t\t},\n\n\t\tprepatch: function prepatch(oldVnode, vnode) {\n\t\t\tvar options = vnode.componentOptions;\n\t\t\tvar child = vnode.componentInstance = oldVnode.componentInstance;\n\t\t\tupdateChildComponent(child, options.propsData, // updated props\n\t\t\toptions.listeners, // updated listeners\n\t\t\tvnode, // new parent vnode\n\t\t\toptions.children // new children\n\t\t\t);\n\t\t},\n\n\t\tinsert: function insert(vnode) {\n\t\t\tvar context = vnode.context;\n\t\t\tvar componentInstance = vnode.componentInstance;\n\t\t\tif (!componentInstance._isMounted) {\n\t\t\t\tcomponentInstance._isMounted = true;\n\t\t\t\tcallHook(componentInstance, 'mounted');\n\t\t\t}\n\t\t\tif (vnode.data.keepAlive) {\n\t\t\t\tif (context._isMounted) {\n\t\t\t\t\t// vue-router#1212\n\t\t\t\t\t// During updates, a kept-alive component's child components may\n\t\t\t\t\t// change, so directly walking the tree here may call activated hooks\n\t\t\t\t\t// on incorrect children. Instead we push them into a queue which will\n\t\t\t\t\t// be processed after the whole patch process ended.\n\t\t\t\t\tqueueActivatedComponent(componentInstance);\n\t\t\t\t} else {\n\t\t\t\t\tactivateChildComponent(componentInstance, true /* direct */);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdestroy: function destroy(vnode) {\n\t\t\tvar componentInstance = vnode.componentInstance;\n\t\t\tif (!componentInstance._isDestroyed) {\n\t\t\t\tif (!vnode.data.keepAlive) {\n\t\t\t\t\tcomponentInstance.$destroy();\n\t\t\t\t} else {\n\t\t\t\t\tdeactivateChildComponent(componentInstance, true /* direct */);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar hooksToMerge = Object.keys(componentVNodeHooks);\n\n\tfunction createComponent(Ctor, data, context, children, tag) {\n\t\tif (isUndef(Ctor)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar baseCtor = context.$options._base;\n\n\t\t// plain options object: turn it into a constructor\n\t\tif (isObject(Ctor)) {\n\t\t\tCtor = baseCtor.extend(Ctor);\n\t\t}\n\n\t\t// if at this stage it's not a constructor or an async component factory,\n\t\t// reject.\n\t\tif (typeof Ctor !== 'function') {\n\t\t\t{\n\t\t\t\twarn(\"Invalid Component definition: \" + String(Ctor), context);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// async component\n\t\tif (isUndef(Ctor.cid)) {\n\t\t\tCtor = resolveAsyncComponent(Ctor, baseCtor, context);\n\t\t\tif (Ctor === undefined) {\n\t\t\t\t// return nothing if this is indeed an async component\n\t\t\t\t// wait for the callback to trigger parent update.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// resolve constructor options in case global mixins are applied after\n\t\t// component constructor creation\n\t\tresolveConstructorOptions(Ctor);\n\n\t\tdata = data || {};\n\n\t\t// transform component v-model data into props & events\n\t\tif (isDef(data.model)) {\n\t\t\ttransformModel(Ctor.options, data);\n\t\t}\n\n\t\t// extract props\n\t\tvar propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n\t\t// functional component\n\t\tif (isTrue(Ctor.options.functional)) {\n\t\t\treturn createFunctionalComponent(Ctor, propsData, data, context, children);\n\t\t}\n\n\t\t// extract listeners, since these needs to be treated as\n\t\t// child component listeners instead of DOM listeners\n\t\tvar listeners = data.on;\n\t\t// replace with listeners with .native modifier\n\t\tdata.on = data.nativeOn;\n\n\t\tif (isTrue(Ctor.options.abstract)) {\n\t\t\t// abstract components do not keep anything\n\t\t\t// other than props & listeners\n\t\t\tdata = {};\n\t\t}\n\n\t\t// merge component management hooks onto the placeholder node\n\t\tmergeHooks(data);\n\n\t\t// return a placeholder vnode\n\t\tvar name = Ctor.options.name || tag;\n\t\tvar vnode = new VNode(\"vue-component-\" + Ctor.cid + (name ? \"-\" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children });\n\t\treturn vnode;\n\t}\n\n\tfunction createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't\n\tparent, // activeInstance in lifecycle state\n\tparentElm, refElm) {\n\t\tvar vnodeComponentOptions = vnode.componentOptions;\n\t\tvar options = {\n\t\t\t_isComponent: true,\n\t\t\tparent: parent,\n\t\t\tpropsData: vnodeComponentOptions.propsData,\n\t\t\t_componentTag: vnodeComponentOptions.tag,\n\t\t\t_parentVnode: vnode,\n\t\t\t_parentListeners: vnodeComponentOptions.listeners,\n\t\t\t_renderChildren: vnodeComponentOptions.children,\n\t\t\t_parentElm: parentElm || null,\n\t\t\t_refElm: refElm || null\n\t\t};\n\t\t// check inline-template render functions\n\t\tvar inlineTemplate = vnode.data.inlineTemplate;\n\t\tif (isDef(inlineTemplate)) {\n\t\t\toptions.render = inlineTemplate.render;\n\t\t\toptions.staticRenderFns = inlineTemplate.staticRenderFns;\n\t\t}\n\t\treturn new vnodeComponentOptions.Ctor(options);\n\t}\n\n\tfunction mergeHooks(data) {\n\t\tif (!data.hook) {\n\t\t\tdata.hook = {};\n\t\t}\n\t\tfor (var i = 0; i < hooksToMerge.length; i++) {\n\t\t\tvar key = hooksToMerge[i];\n\t\t\tvar fromParent = data.hook[key];\n\t\t\tvar ours = componentVNodeHooks[key];\n\t\t\tdata.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n\t\t}\n\t}\n\n\tfunction mergeHook$1(one, two) {\n\t\treturn function (a, b, c, d) {\n\t\t\tone(a, b, c, d);\n\t\t\ttwo(a, b, c, d);\n\t\t};\n\t}\n\n\t// transform component v-model info (value and callback) into\n\t// prop and event handler respectively.\n\tfunction transformModel(options, data) {\n\t\tvar prop = options.model && options.model.prop || 'value';\n\t\tvar event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n\t\tvar on = data.on || (data.on = {});\n\t\tif (isDef(on[event])) {\n\t\t\ton[event] = [data.model.callback].concat(on[event]);\n\t\t} else {\n\t\t\ton[event] = data.model.callback;\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar SIMPLE_NORMALIZE = 1;\n\tvar ALWAYS_NORMALIZE = 2;\n\n\t// wrapper function for providing a more flexible interface\n\t// without getting yelled at by flow\n\tfunction createElement(context, tag, data, children, normalizationType, alwaysNormalize) {\n\t\tif (Array.isArray(data) || isPrimitive(data)) {\n\t\t\tnormalizationType = children;\n\t\t\tchildren = data;\n\t\t\tdata = undefined;\n\t\t}\n\t\tif (isTrue(alwaysNormalize)) {\n\t\t\tnormalizationType = ALWAYS_NORMALIZE;\n\t\t}\n\t\treturn _createElement(context, tag, data, children, normalizationType);\n\t}\n\n\tfunction _createElement(context, tag, data, children, normalizationType) {\n\t\tif (isDef(data) && isDef(data.__ob__)) {\n\t\t\t\"development\" !== 'production' && warn(\"Avoid using observed data object as vnode data: \" + JSON.stringify(data) + \"\\n\" + 'Always create fresh vnode data objects in each render!', context);\n\t\t\treturn createEmptyVNode();\n\t\t}\n\t\tif (!tag) {\n\t\t\t// in case of component :is set to falsy value\n\t\t\treturn createEmptyVNode();\n\t\t}\n\t\t// support single function children as default scoped slot\n\t\tif (Array.isArray(children) && typeof children[0] === 'function') {\n\t\t\tdata = data || {};\n\t\t\tdata.scopedSlots = { default: children[0] };\n\t\t\tchildren.length = 0;\n\t\t}\n\t\tif (normalizationType === ALWAYS_NORMALIZE) {\n\t\t\tchildren = normalizeChildren(children);\n\t\t} else if (normalizationType === SIMPLE_NORMALIZE) {\n\t\t\tchildren = simpleNormalizeChildren(children);\n\t\t}\n\t\tvar vnode, ns;\n\t\tif (typeof tag === 'string') {\n\t\t\tvar Ctor;\n\t\t\tns = config.getTagNamespace(tag);\n\t\t\tif (config.isReservedTag(tag)) {\n\t\t\t\t// platform built-in elements\n\t\t\t\tvnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);\n\t\t\t} else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n\t\t\t\t// component\n\t\t\t\tvnode = createComponent(Ctor, data, context, children, tag);\n\t\t\t} else {\n\t\t\t\t// unknown or unlisted namespaced elements\n\t\t\t\t// check at runtime because it may get assigned a namespace when its\n\t\t\t\t// parent normalizes children\n\t\t\t\tvnode = new VNode(tag, data, children, undefined, undefined, context);\n\t\t\t}\n\t\t} else {\n\t\t\t// direct component options / constructor\n\t\t\tvnode = createComponent(tag, data, context, children);\n\t\t}\n\t\tif (isDef(vnode)) {\n\t\t\tif (ns) {\n\t\t\t\tapplyNS(vnode, ns);\n\t\t\t}\n\t\t\treturn vnode;\n\t\t} else {\n\t\t\treturn createEmptyVNode();\n\t\t}\n\t}\n\n\tfunction applyNS(vnode, ns) {\n\t\tvnode.ns = ns;\n\t\tif (vnode.tag === 'foreignObject') {\n\t\t\t// use default namespace inside foreignObject\n\t\t\treturn;\n\t\t}\n\t\tif (isDef(vnode.children)) {\n\t\t\tfor (var i = 0, l = vnode.children.length; i < l; i++) {\n\t\t\t\tvar child = vnode.children[i];\n\t\t\t\tif (isDef(child.tag) && isUndef(child.ns)) {\n\t\t\t\t\tapplyNS(child, ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for rendering v-for lists.\n  */\n\tfunction renderList(val, render) {\n\t\tvar ret, i, l, keys, key;\n\t\tif (Array.isArray(val) || typeof val === 'string') {\n\t\t\tret = new Array(val.length);\n\t\t\tfor (i = 0, l = val.length; i < l; i++) {\n\t\t\t\tret[i] = render(val[i], i);\n\t\t\t}\n\t\t} else if (typeof val === 'number') {\n\t\t\tret = new Array(val);\n\t\t\tfor (i = 0; i < val; i++) {\n\t\t\t\tret[i] = render(i + 1, i);\n\t\t\t}\n\t\t} else if (isObject(val)) {\n\t\t\tkeys = Object.keys(val);\n\t\t\tret = new Array(keys.length);\n\t\t\tfor (i = 0, l = keys.length; i < l; i++) {\n\t\t\t\tkey = keys[i];\n\t\t\t\tret[i] = render(val[key], key, i);\n\t\t\t}\n\t\t}\n\t\tif (isDef(ret)) {\n\t\t\tret._isVList = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for rendering <slot>\n  */\n\tfunction renderSlot(name, fallback, props, bindObject) {\n\t\tvar scopedSlotFn = this.$scopedSlots[name];\n\t\tif (scopedSlotFn) {\n\t\t\t// scoped slot\n\t\t\tprops = props || {};\n\t\t\tif (bindObject) {\n\t\t\t\textend(props, bindObject);\n\t\t\t}\n\t\t\treturn scopedSlotFn(props) || fallback;\n\t\t} else {\n\t\t\tvar slotNodes = this.$slots[name];\n\t\t\t// warn duplicate slot usage\n\t\t\tif (slotNodes && \"development\" !== 'production') {\n\t\t\t\tslotNodes._rendered && warn(\"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" + \"- this will likely cause render errors.\", this);\n\t\t\t\tslotNodes._rendered = true;\n\t\t\t}\n\t\t\treturn slotNodes || fallback;\n\t\t}\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for resolving filters\n  */\n\tfunction resolveFilter(id) {\n\t\treturn resolveAsset(this.$options, 'filters', id, true) || identity;\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for checking keyCodes from config.\n  */\n\tfunction checkKeyCodes(eventKeyCode, key, builtInAlias) {\n\t\tvar keyCodes = config.keyCodes[key] || builtInAlias;\n\t\tif (Array.isArray(keyCodes)) {\n\t\t\treturn keyCodes.indexOf(eventKeyCode) === -1;\n\t\t} else {\n\t\t\treturn keyCodes !== eventKeyCode;\n\t\t}\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n  */\n\tfunction bindObjectProps(data, tag, value, asProp) {\n\t\tif (value) {\n\t\t\tif (!isObject(value)) {\n\t\t\t\t\"development\" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);\n\t\t\t} else {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tvalue = toObject(value);\n\t\t\t\t}\n\t\t\t\tvar hash;\n\t\t\t\tfor (var key in value) {\n\t\t\t\t\tif (key === 'class' || key === 'style') {\n\t\t\t\t\t\thash = data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar type = data.attrs && data.attrs.type;\n\t\t\t\t\t\thash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});\n\t\t\t\t\t}\n\t\t\t\t\tif (!(key in hash)) {\n\t\t\t\t\t\thash[key] = value[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}\n\n\t/*  */\n\n\t/**\n  * Runtime helper for rendering static trees.\n  */\n\tfunction renderStatic(index, isInFor) {\n\t\tvar tree = this._staticTrees[index];\n\t\t// if has already-rendered static tree and not inside v-for,\n\t\t// we can reuse the same tree by doing a shallow clone.\n\t\tif (tree && !isInFor) {\n\t\t\treturn Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);\n\t\t}\n\t\t// otherwise, render a fresh tree.\n\t\ttree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n\t\tmarkStatic(tree, \"__static__\" + index, false);\n\t\treturn tree;\n\t}\n\n\t/**\n  * Runtime helper for v-once.\n  * Effectively it means marking the node as static with a unique key.\n  */\n\tfunction markOnce(tree, index, key) {\n\t\tmarkStatic(tree, \"__once__\" + index + (key ? \"_\" + key : \"\"), true);\n\t\treturn tree;\n\t}\n\n\tfunction markStatic(tree, key, isOnce) {\n\t\tif (Array.isArray(tree)) {\n\t\t\tfor (var i = 0; i < tree.length; i++) {\n\t\t\t\tif (tree[i] && typeof tree[i] !== 'string') {\n\t\t\t\t\tmarkStaticNode(tree[i], key + \"_\" + i, isOnce);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmarkStaticNode(tree, key, isOnce);\n\t\t}\n\t}\n\n\tfunction markStaticNode(node, key, isOnce) {\n\t\tnode.isStatic = true;\n\t\tnode.key = key;\n\t\tnode.isOnce = isOnce;\n\t}\n\n\t/*  */\n\n\tfunction initRender(vm) {\n\t\tvm._vnode = null; // the root of the child tree\n\t\tvm._staticTrees = null;\n\t\tvar parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n\t\tvar renderContext = parentVnode && parentVnode.context;\n\t\tvm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n\t\tvm.$scopedSlots = emptyObject;\n\t\t// bind the createElement fn to this instance\n\t\t// so that we get proper render context inside it.\n\t\t// args order: tag, data, children, normalizationType, alwaysNormalize\n\t\t// internal version is used by render functions compiled from templates\n\t\tvm._c = function (a, b, c, d) {\n\t\t\treturn createElement(vm, a, b, c, d, false);\n\t\t};\n\t\t// normalization is always applied for the public version, used in\n\t\t// user-written render functions.\n\t\tvm.$createElement = function (a, b, c, d) {\n\t\t\treturn createElement(vm, a, b, c, d, true);\n\t\t};\n\t}\n\n\tfunction renderMixin(Vue) {\n\t\tVue.prototype.$nextTick = function (fn) {\n\t\t\treturn nextTick(fn, this);\n\t\t};\n\n\t\tVue.prototype._render = function () {\n\t\t\tvar vm = this;\n\t\t\tvar ref = vm.$options;\n\t\t\tvar render = ref.render;\n\t\t\tvar staticRenderFns = ref.staticRenderFns;\n\t\t\tvar _parentVnode = ref._parentVnode;\n\n\t\t\tif (vm._isMounted) {\n\t\t\t\t// clone slot nodes on re-renders\n\t\t\t\tfor (var key in vm.$slots) {\n\t\t\t\t\tvm.$slots[key] = cloneVNodes(vm.$slots[key]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;\n\n\t\t\tif (staticRenderFns && !vm._staticTrees) {\n\t\t\t\tvm._staticTrees = [];\n\t\t\t}\n\t\t\t// set parent vnode. this allows render functions to have access\n\t\t\t// to the data on the placeholder node.\n\t\t\tvm.$vnode = _parentVnode;\n\t\t\t// render self\n\t\t\tvar vnode;\n\t\t\ttry {\n\t\t\t\tvnode = render.call(vm._renderProxy, vm.$createElement);\n\t\t\t} catch (e) {\n\t\t\t\thandleError(e, vm, \"render function\");\n\t\t\t\t// return error render result,\n\t\t\t\t// or previous vnode to prevent render error causing blank component\n\t\t\t\t/* istanbul ignore else */\n\t\t\t\t{\n\t\t\t\t\tvnode = vm.$options.renderError ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) : vm._vnode;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return empty vnode in case the render function errored out\n\t\t\tif (!(vnode instanceof VNode)) {\n\t\t\t\tif (\"development\" !== 'production' && Array.isArray(vnode)) {\n\t\t\t\t\twarn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);\n\t\t\t\t}\n\t\t\t\tvnode = createEmptyVNode();\n\t\t\t}\n\t\t\t// set parent\n\t\t\tvnode.parent = _parentVnode;\n\t\t\treturn vnode;\n\t\t};\n\n\t\t// internal render helpers.\n\t\t// these are exposed on the instance prototype to reduce generated render\n\t\t// code size.\n\t\tVue.prototype._o = markOnce;\n\t\tVue.prototype._n = toNumber;\n\t\tVue.prototype._s = toString;\n\t\tVue.prototype._l = renderList;\n\t\tVue.prototype._t = renderSlot;\n\t\tVue.prototype._q = looseEqual;\n\t\tVue.prototype._i = looseIndexOf;\n\t\tVue.prototype._m = renderStatic;\n\t\tVue.prototype._f = resolveFilter;\n\t\tVue.prototype._k = checkKeyCodes;\n\t\tVue.prototype._b = bindObjectProps;\n\t\tVue.prototype._v = createTextVNode;\n\t\tVue.prototype._e = createEmptyVNode;\n\t\tVue.prototype._u = resolveScopedSlots;\n\t}\n\n\t/*  */\n\n\tvar uid$1 = 0;\n\n\tfunction initMixin(Vue) {\n\t\tVue.prototype._init = function (options) {\n\t\t\tvar vm = this;\n\t\t\t// a uid\n\t\t\tvm._uid = uid$1++;\n\n\t\t\tvar startTag, endTag;\n\t\t\t/* istanbul ignore if */\n\t\t\tif (\"development\" !== 'production' && config.performance && mark) {\n\t\t\t\tstartTag = \"vue-perf-init:\" + vm._uid;\n\t\t\t\tendTag = \"vue-perf-end:\" + vm._uid;\n\t\t\t\tmark(startTag);\n\t\t\t}\n\n\t\t\t// a flag to avoid this being observed\n\t\t\tvm._isVue = true;\n\t\t\t// merge options\n\t\t\tif (options && options._isComponent) {\n\t\t\t\t// optimize internal component instantiation\n\t\t\t\t// since dynamic options merging is pretty slow, and none of the\n\t\t\t\t// internal component options needs special treatment.\n\t\t\t\tinitInternalComponent(vm, options);\n\t\t\t} else {\n\t\t\t\tvm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);\n\t\t\t}\n\t\t\t/* istanbul ignore else */\n\t\t\t{\n\t\t\t\tinitProxy(vm);\n\t\t\t}\n\t\t\t// expose real self\n\t\t\tvm._self = vm;\n\t\t\tinitLifecycle(vm);\n\t\t\tinitEvents(vm);\n\t\t\tinitRender(vm);\n\t\t\tcallHook(vm, 'beforeCreate');\n\t\t\tinitInjections(vm); // resolve injections before data/props\n\t\t\tinitState(vm);\n\t\t\tinitProvide(vm); // resolve provide after data/props\n\t\t\tcallHook(vm, 'created');\n\n\t\t\t/* istanbul ignore if */\n\t\t\tif (\"development\" !== 'production' && config.performance && mark) {\n\t\t\t\tvm._name = formatComponentName(vm, false);\n\t\t\t\tmark(endTag);\n\t\t\t\tmeasure(vm._name + \" init\", startTag, endTag);\n\t\t\t}\n\n\t\t\tif (vm.$options.el) {\n\t\t\t\tvm.$mount(vm.$options.el);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction initInternalComponent(vm, options) {\n\t\tvar opts = vm.$options = Object.create(vm.constructor.options);\n\t\t// doing this because it's faster than dynamic enumeration.\n\t\topts.parent = options.parent;\n\t\topts.propsData = options.propsData;\n\t\topts._parentVnode = options._parentVnode;\n\t\topts._parentListeners = options._parentListeners;\n\t\topts._renderChildren = options._renderChildren;\n\t\topts._componentTag = options._componentTag;\n\t\topts._parentElm = options._parentElm;\n\t\topts._refElm = options._refElm;\n\t\tif (options.render) {\n\t\t\topts.render = options.render;\n\t\t\topts.staticRenderFns = options.staticRenderFns;\n\t\t}\n\t}\n\n\tfunction resolveConstructorOptions(Ctor) {\n\t\tvar options = Ctor.options;\n\t\tif (Ctor.super) {\n\t\t\tvar superOptions = resolveConstructorOptions(Ctor.super);\n\t\t\tvar cachedSuperOptions = Ctor.superOptions;\n\t\t\tif (superOptions !== cachedSuperOptions) {\n\t\t\t\t// super option changed,\n\t\t\t\t// need to resolve new options.\n\t\t\t\tCtor.superOptions = superOptions;\n\t\t\t\t// check if there are any late-modified/attached options (#4976)\n\t\t\t\tvar modifiedOptions = resolveModifiedOptions(Ctor);\n\t\t\t\t// update base extend options\n\t\t\t\tif (modifiedOptions) {\n\t\t\t\t\textend(Ctor.extendOptions, modifiedOptions);\n\t\t\t\t}\n\t\t\t\toptions = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n\t\t\t\tif (options.name) {\n\t\t\t\t\toptions.components[options.name] = Ctor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\tfunction resolveModifiedOptions(Ctor) {\n\t\tvar modified;\n\t\tvar latest = Ctor.options;\n\t\tvar extended = Ctor.extendOptions;\n\t\tvar sealed = Ctor.sealedOptions;\n\t\tfor (var key in latest) {\n\t\t\tif (latest[key] !== sealed[key]) {\n\t\t\t\tif (!modified) {\n\t\t\t\t\tmodified = {};\n\t\t\t\t}\n\t\t\t\tmodified[key] = dedupe(latest[key], extended[key], sealed[key]);\n\t\t\t}\n\t\t}\n\t\treturn modified;\n\t}\n\n\tfunction dedupe(latest, extended, sealed) {\n\t\t// compare latest and sealed to ensure lifecycle hooks won't be duplicated\n\t\t// between merges\n\t\tif (Array.isArray(latest)) {\n\t\t\tvar res = [];\n\t\t\tsealed = Array.isArray(sealed) ? sealed : [sealed];\n\t\t\textended = Array.isArray(extended) ? extended : [extended];\n\t\t\tfor (var i = 0; i < latest.length; i++) {\n\t\t\t\t// push original options and not sealed options to exclude duplicated options\n\t\t\t\tif (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n\t\t\t\t\tres.push(latest[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t} else {\n\t\t\treturn latest;\n\t\t}\n\t}\n\n\tfunction Vue$3(options) {\n\t\tif (\"development\" !== 'production' && !(this instanceof Vue$3)) {\n\t\t\twarn('Vue is a constructor and should be called with the `new` keyword');\n\t\t}\n\t\tthis._init(options);\n\t}\n\n\tinitMixin(Vue$3);\n\tstateMixin(Vue$3);\n\teventsMixin(Vue$3);\n\tlifecycleMixin(Vue$3);\n\trenderMixin(Vue$3);\n\n\t/*  */\n\n\tfunction initUse(Vue) {\n\t\tVue.use = function (plugin) {\n\t\t\t/* istanbul ignore if */\n\t\t\tif (plugin.installed) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t// additional parameters\n\t\t\tvar args = toArray(arguments, 1);\n\t\t\targs.unshift(this);\n\t\t\tif (typeof plugin.install === 'function') {\n\t\t\t\tplugin.install.apply(plugin, args);\n\t\t\t} else if (typeof plugin === 'function') {\n\t\t\t\tplugin.apply(null, args);\n\t\t\t}\n\t\t\tplugin.installed = true;\n\t\t\treturn this;\n\t\t};\n\t}\n\n\t/*  */\n\n\tfunction initMixin$1(Vue) {\n\t\tVue.mixin = function (mixin) {\n\t\t\tthis.options = mergeOptions(this.options, mixin);\n\t\t\treturn this;\n\t\t};\n\t}\n\n\t/*  */\n\n\tfunction initExtend(Vue) {\n\t\t/**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n\t\tVue.cid = 0;\n\t\tvar cid = 1;\n\n\t\t/**\n   * Class inheritance\n   */\n\t\tVue.extend = function (extendOptions) {\n\t\t\textendOptions = extendOptions || {};\n\t\t\tvar Super = this;\n\t\t\tvar SuperId = Super.cid;\n\t\t\tvar cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n\t\t\tif (cachedCtors[SuperId]) {\n\t\t\t\treturn cachedCtors[SuperId];\n\t\t\t}\n\n\t\t\tvar name = extendOptions.name || Super.options.name;\n\t\t\t{\n\t\t\t\tif (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n\t\t\t\t\twarn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar Sub = function VueComponent(options) {\n\t\t\t\tthis._init(options);\n\t\t\t};\n\t\t\tSub.prototype = Object.create(Super.prototype);\n\t\t\tSub.prototype.constructor = Sub;\n\t\t\tSub.cid = cid++;\n\t\t\tSub.options = mergeOptions(Super.options, extendOptions);\n\t\t\tSub['super'] = Super;\n\n\t\t\t// For props and computed properties, we define the proxy getters on\n\t\t\t// the Vue instances at extension time, on the extended prototype. This\n\t\t\t// avoids Object.defineProperty calls for each instance created.\n\t\t\tif (Sub.options.props) {\n\t\t\t\tinitProps$1(Sub);\n\t\t\t}\n\t\t\tif (Sub.options.computed) {\n\t\t\t\tinitComputed$1(Sub);\n\t\t\t}\n\n\t\t\t// allow further extension/mixin/plugin usage\n\t\t\tSub.extend = Super.extend;\n\t\t\tSub.mixin = Super.mixin;\n\t\t\tSub.use = Super.use;\n\n\t\t\t// create asset registers, so extended classes\n\t\t\t// can have their private assets too.\n\t\t\tASSET_TYPES.forEach(function (type) {\n\t\t\t\tSub[type] = Super[type];\n\t\t\t});\n\t\t\t// enable recursive self-lookup\n\t\t\tif (name) {\n\t\t\t\tSub.options.components[name] = Sub;\n\t\t\t}\n\n\t\t\t// keep a reference to the super options at extension time.\n\t\t\t// later at instantiation we can check if Super's options have\n\t\t\t// been updated.\n\t\t\tSub.superOptions = Super.options;\n\t\t\tSub.extendOptions = extendOptions;\n\t\t\tSub.sealedOptions = extend({}, Sub.options);\n\n\t\t\t// cache constructor\n\t\t\tcachedCtors[SuperId] = Sub;\n\t\t\treturn Sub;\n\t\t};\n\t}\n\n\tfunction initProps$1(Comp) {\n\t\tvar props = Comp.options.props;\n\t\tfor (var key in props) {\n\t\t\tproxy(Comp.prototype, \"_props\", key);\n\t\t}\n\t}\n\n\tfunction initComputed$1(Comp) {\n\t\tvar computed = Comp.options.computed;\n\t\tfor (var key in computed) {\n\t\t\tdefineComputed(Comp.prototype, key, computed[key]);\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction initAssetRegisters(Vue) {\n\t\t/**\n   * Create asset registration methods.\n   */\n\t\tASSET_TYPES.forEach(function (type) {\n\t\t\tVue[type] = function (id, definition) {\n\t\t\t\tif (!definition) {\n\t\t\t\t\treturn this.options[type + 's'][id];\n\t\t\t\t} else {\n\t\t\t\t\t/* istanbul ignore if */\n\t\t\t\t\t{\n\t\t\t\t\t\tif (type === 'component' && config.isReservedTag(id)) {\n\t\t\t\t\t\t\twarn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (type === 'component' && isPlainObject(definition)) {\n\t\t\t\t\t\tdefinition.name = definition.name || id;\n\t\t\t\t\t\tdefinition = this.options._base.extend(definition);\n\t\t\t\t\t}\n\t\t\t\t\tif (type === 'directive' && typeof definition === 'function') {\n\t\t\t\t\t\tdefinition = { bind: definition, update: definition };\n\t\t\t\t\t}\n\t\t\t\t\tthis.options[type + 's'][id] = definition;\n\t\t\t\t\treturn definition;\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t}\n\n\t/*  */\n\n\tvar patternTypes = [String, RegExp];\n\n\tfunction getComponentName(opts) {\n\t\treturn opts && (opts.Ctor.options.name || opts.tag);\n\t}\n\n\tfunction matches(pattern, name) {\n\t\tif (typeof pattern === 'string') {\n\t\t\treturn pattern.split(',').indexOf(name) > -1;\n\t\t} else if (isRegExp(pattern)) {\n\t\t\treturn pattern.test(name);\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn false;\n\t}\n\n\tfunction pruneCache(cache, current, filter) {\n\t\tfor (var key in cache) {\n\t\t\tvar cachedNode = cache[key];\n\t\t\tif (cachedNode) {\n\t\t\t\tvar name = getComponentName(cachedNode.componentOptions);\n\t\t\t\tif (name && !filter(name)) {\n\t\t\t\t\tif (cachedNode !== current) {\n\t\t\t\t\t\tpruneCacheEntry(cachedNode);\n\t\t\t\t\t}\n\t\t\t\t\tcache[key] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction pruneCacheEntry(vnode) {\n\t\tif (vnode) {\n\t\t\tvnode.componentInstance.$destroy();\n\t\t}\n\t}\n\n\tvar KeepAlive = {\n\t\tname: 'keep-alive',\n\t\tabstract: true,\n\n\t\tprops: {\n\t\t\tinclude: patternTypes,\n\t\t\texclude: patternTypes\n\t\t},\n\n\t\tcreated: function created() {\n\t\t\tthis.cache = Object.create(null);\n\t\t},\n\n\t\tdestroyed: function destroyed() {\n\t\t\tvar this$1 = this;\n\n\t\t\tfor (var key in this$1.cache) {\n\t\t\t\tpruneCacheEntry(this$1.cache[key]);\n\t\t\t}\n\t\t},\n\n\t\twatch: {\n\t\t\tinclude: function include(val) {\n\t\t\t\tpruneCache(this.cache, this._vnode, function (name) {\n\t\t\t\t\treturn matches(val, name);\n\t\t\t\t});\n\t\t\t},\n\t\t\texclude: function exclude(val) {\n\t\t\t\tpruneCache(this.cache, this._vnode, function (name) {\n\t\t\t\t\treturn !matches(val, name);\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\trender: function render() {\n\t\t\tvar vnode = getFirstComponentChild(this.$slots.default);\n\t\t\tvar componentOptions = vnode && vnode.componentOptions;\n\t\t\tif (componentOptions) {\n\t\t\t\t// check pattern\n\t\t\t\tvar name = getComponentName(componentOptions);\n\t\t\t\tif (name && (this.include && !matches(this.include, name) || this.exclude && matches(this.exclude, name))) {\n\t\t\t\t\treturn vnode;\n\t\t\t\t}\n\t\t\t\tvar key = vnode.key == null\n\t\t\t\t// same constructor may get registered as different local components\n\t\t\t\t// so cid alone is not enough (#3269)\n\t\t\t\t? componentOptions.Ctor.cid + (componentOptions.tag ? \"::\" + componentOptions.tag : '') : vnode.key;\n\t\t\t\tif (this.cache[key]) {\n\t\t\t\t\tvnode.componentInstance = this.cache[key].componentInstance;\n\t\t\t\t} else {\n\t\t\t\t\tthis.cache[key] = vnode;\n\t\t\t\t}\n\t\t\t\tvnode.data.keepAlive = true;\n\t\t\t}\n\t\t\treturn vnode;\n\t\t}\n\t};\n\n\tvar builtInComponents = {\n\t\tKeepAlive: KeepAlive\n\t};\n\n\t/*  */\n\n\tfunction initGlobalAPI(Vue) {\n\t\t// config\n\t\tvar configDef = {};\n\t\tconfigDef.get = function () {\n\t\t\treturn config;\n\t\t};\n\t\t{\n\t\t\tconfigDef.set = function () {\n\t\t\t\twarn('Do not replace the Vue.config object, set individual fields instead.');\n\t\t\t};\n\t\t}\n\t\tObject.defineProperty(Vue, 'config', configDef);\n\n\t\t// exposed util methods.\n\t\t// NOTE: these are not considered part of the public API - avoid relying on\n\t\t// them unless you are aware of the risk.\n\t\tVue.util = {\n\t\t\twarn: warn,\n\t\t\textend: extend,\n\t\t\tmergeOptions: mergeOptions,\n\t\t\tdefineReactive: defineReactive$$1\n\t\t};\n\n\t\tVue.set = set;\n\t\tVue.delete = del;\n\t\tVue.nextTick = nextTick;\n\n\t\tVue.options = Object.create(null);\n\t\tASSET_TYPES.forEach(function (type) {\n\t\t\tVue.options[type + 's'] = Object.create(null);\n\t\t});\n\n\t\t// this is used to identify the \"base\" constructor to extend all plain-object\n\t\t// components with in Weex's multi-instance scenarios.\n\t\tVue.options._base = Vue;\n\n\t\textend(Vue.options.components, builtInComponents);\n\n\t\tinitUse(Vue);\n\t\tinitMixin$1(Vue);\n\t\tinitExtend(Vue);\n\t\tinitAssetRegisters(Vue);\n\t}\n\n\tinitGlobalAPI(Vue$3);\n\n\tObject.defineProperty(Vue$3.prototype, '$isServer', {\n\t\tget: isServerRendering\n\t});\n\n\tObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n\t\tget: function get() {\n\t\t\t/* istanbul ignore next */\n\t\t\treturn this.$vnode.ssrContext;\n\t\t}\n\t});\n\n\tVue$3.version = '2.3.4';\n\n\t/*  */\n\n\t// these are reserved for web because they are directly compiled away\n\t// during template compilation\n\tvar isReservedAttr = makeMap('style,class');\n\n\t// attributes that should be using props for binding\n\tvar acceptValue = makeMap('input,textarea,option,select');\n\tvar mustUseProp = function mustUseProp(tag, type, attr) {\n\t\treturn attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';\n\t};\n\n\tvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n\tvar isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');\n\n\tvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\n\tvar isXlink = function isXlink(name) {\n\t\treturn name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';\n\t};\n\n\tvar getXlinkProp = function getXlinkProp(name) {\n\t\treturn isXlink(name) ? name.slice(6, name.length) : '';\n\t};\n\n\tvar isFalsyAttrValue = function isFalsyAttrValue(val) {\n\t\treturn val == null || val === false;\n\t};\n\n\t/*  */\n\n\tfunction genClassForVnode(vnode) {\n\t\tvar data = vnode.data;\n\t\tvar parentNode = vnode;\n\t\tvar childNode = vnode;\n\t\twhile (isDef(childNode.componentInstance)) {\n\t\t\tchildNode = childNode.componentInstance._vnode;\n\t\t\tif (childNode.data) {\n\t\t\t\tdata = mergeClassData(childNode.data, data);\n\t\t\t}\n\t\t}\n\t\twhile (isDef(parentNode = parentNode.parent)) {\n\t\t\tif (parentNode.data) {\n\t\t\t\tdata = mergeClassData(data, parentNode.data);\n\t\t\t}\n\t\t}\n\t\treturn genClassFromData(data);\n\t}\n\n\tfunction mergeClassData(child, parent) {\n\t\treturn {\n\t\t\tstaticClass: concat(child.staticClass, parent.staticClass),\n\t\t\tclass: isDef(child.class) ? [child.class, parent.class] : parent.class\n\t\t};\n\t}\n\n\tfunction genClassFromData(data) {\n\t\tvar dynamicClass = data.class;\n\t\tvar staticClass = data.staticClass;\n\t\tif (isDef(staticClass) || isDef(dynamicClass)) {\n\t\t\treturn concat(staticClass, stringifyClass(dynamicClass));\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn '';\n\t}\n\n\tfunction concat(a, b) {\n\t\treturn a ? b ? a + ' ' + b : a : b || '';\n\t}\n\n\tfunction stringifyClass(value) {\n\t\tif (isUndef(value)) {\n\t\t\treturn '';\n\t\t}\n\t\tif (typeof value === 'string') {\n\t\t\treturn value;\n\t\t}\n\t\tvar res = '';\n\t\tif (Array.isArray(value)) {\n\t\t\tvar stringified;\n\t\t\tfor (var i = 0, l = value.length; i < l; i++) {\n\t\t\t\tif (isDef(value[i])) {\n\t\t\t\t\tif (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n\t\t\t\t\t\tres += stringified + ' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.slice(0, -1);\n\t\t}\n\t\tif (isObject(value)) {\n\t\t\tfor (var key in value) {\n\t\t\t\tif (value[key]) {\n\t\t\t\t\tres += key + ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res.slice(0, -1);\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tvar namespaceMap = {\n\t\tsvg: 'http://www.w3.org/2000/svg',\n\t\tmath: 'http://www.w3.org/1998/Math/MathML'\n\t};\n\n\tvar isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template');\n\n\t// this map is intentionally selective, only covering SVG elements that may\n\t// contain child elements.\n\tvar isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);\n\n\tvar isPreTag = function isPreTag(tag) {\n\t\treturn tag === 'pre';\n\t};\n\n\tvar isReservedTag = function isReservedTag(tag) {\n\t\treturn isHTMLTag(tag) || isSVG(tag);\n\t};\n\n\tfunction getTagNamespace(tag) {\n\t\tif (isSVG(tag)) {\n\t\t\treturn 'svg';\n\t\t}\n\t\t// basic support for MathML\n\t\t// note it doesn't support other MathML elements being component roots\n\t\tif (tag === 'math') {\n\t\t\treturn 'math';\n\t\t}\n\t}\n\n\tvar unknownElementCache = Object.create(null);\n\tfunction isUnknownElement(tag) {\n\t\t/* istanbul ignore if */\n\t\tif (!inBrowser) {\n\t\t\treturn true;\n\t\t}\n\t\tif (isReservedTag(tag)) {\n\t\t\treturn false;\n\t\t}\n\t\ttag = tag.toLowerCase();\n\t\t/* istanbul ignore if */\n\t\tif (unknownElementCache[tag] != null) {\n\t\t\treturn unknownElementCache[tag];\n\t\t}\n\t\tvar el = document.createElement(tag);\n\t\tif (tag.indexOf('-') > -1) {\n\t\t\t// http://stackoverflow.com/a/28210364/1070244\n\t\t\treturn unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n\t\t} else {\n\t\t\treturn unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());\n\t\t}\n\t}\n\n\t/*  */\n\n\t/**\n  * Query an element selector if it's not an element already.\n  */\n\tfunction query(el) {\n\t\tif (typeof el === 'string') {\n\t\t\tvar selected = document.querySelector(el);\n\t\t\tif (!selected) {\n\t\t\t\t\"development\" !== 'production' && warn('Cannot find element: ' + el);\n\t\t\t\treturn document.createElement('div');\n\t\t\t}\n\t\t\treturn selected;\n\t\t} else {\n\t\t\treturn el;\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction createElement$1(tagName, vnode) {\n\t\tvar elm = document.createElement(tagName);\n\t\tif (tagName !== 'select') {\n\t\t\treturn elm;\n\t\t}\n\t\t// false or null will remove the attribute but undefined will not\n\t\tif (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n\t\t\telm.setAttribute('multiple', 'multiple');\n\t\t}\n\t\treturn elm;\n\t}\n\n\tfunction createElementNS(namespace, tagName) {\n\t\treturn document.createElementNS(namespaceMap[namespace], tagName);\n\t}\n\n\tfunction createTextNode(text) {\n\t\treturn document.createTextNode(text);\n\t}\n\n\tfunction createComment(text) {\n\t\treturn document.createComment(text);\n\t}\n\n\tfunction insertBefore(parentNode, newNode, referenceNode) {\n\t\tparentNode.insertBefore(newNode, referenceNode);\n\t}\n\n\tfunction removeChild(node, child) {\n\t\tnode.removeChild(child);\n\t}\n\n\tfunction appendChild(node, child) {\n\t\tnode.appendChild(child);\n\t}\n\n\tfunction parentNode(node) {\n\t\treturn node.parentNode;\n\t}\n\n\tfunction nextSibling(node) {\n\t\treturn node.nextSibling;\n\t}\n\n\tfunction tagName(node) {\n\t\treturn node.tagName;\n\t}\n\n\tfunction setTextContent(node, text) {\n\t\tnode.textContent = text;\n\t}\n\n\tfunction setAttribute(node, key, val) {\n\t\tnode.setAttribute(key, val);\n\t}\n\n\tvar nodeOps = Object.freeze({\n\t\tcreateElement: createElement$1,\n\t\tcreateElementNS: createElementNS,\n\t\tcreateTextNode: createTextNode,\n\t\tcreateComment: createComment,\n\t\tinsertBefore: insertBefore,\n\t\tremoveChild: removeChild,\n\t\tappendChild: appendChild,\n\t\tparentNode: parentNode,\n\t\tnextSibling: nextSibling,\n\t\ttagName: tagName,\n\t\tsetTextContent: setTextContent,\n\t\tsetAttribute: setAttribute\n\t});\n\n\t/*  */\n\n\tvar ref = {\n\t\tcreate: function create(_, vnode) {\n\t\t\tregisterRef(vnode);\n\t\t},\n\t\tupdate: function update(oldVnode, vnode) {\n\t\t\tif (oldVnode.data.ref !== vnode.data.ref) {\n\t\t\t\tregisterRef(oldVnode, true);\n\t\t\t\tregisterRef(vnode);\n\t\t\t}\n\t\t},\n\t\tdestroy: function destroy(vnode) {\n\t\t\tregisterRef(vnode, true);\n\t\t}\n\t};\n\n\tfunction registerRef(vnode, isRemoval) {\n\t\tvar key = vnode.data.ref;\n\t\tif (!key) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar vm = vnode.context;\n\t\tvar ref = vnode.componentInstance || vnode.elm;\n\t\tvar refs = vm.$refs;\n\t\tif (isRemoval) {\n\t\t\tif (Array.isArray(refs[key])) {\n\t\t\t\tremove(refs[key], ref);\n\t\t\t} else if (refs[key] === ref) {\n\t\t\t\trefs[key] = undefined;\n\t\t\t}\n\t\t} else {\n\t\t\tif (vnode.data.refInFor) {\n\t\t\t\tif (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n\t\t\t\t\trefs[key].push(ref);\n\t\t\t\t} else {\n\t\t\t\t\trefs[key] = [ref];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trefs[key] = ref;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Virtual DOM patching algorithm based on Snabbdom by\n  * Simon Friis Vindum (@paldepind)\n  * Licensed under the MIT License\n  * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n  *\n  * modified by Evan You (@yyx990803)\n  *\n \t /*\n  * Not type-checking this because this file is perf-critical and the cost\n  * of making flow understand it is not worth it.\n  */\n\n\tvar emptyNode = new VNode('', {}, []);\n\n\tvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n\tfunction sameVnode(a, b) {\n\t\treturn a.key === b.key && a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b);\n\t}\n\n\t// Some browsers do not support dynamically changing type for <input>\n\t// so they need to be treated as different nodes\n\tfunction sameInputType(a, b) {\n\t\tif (a.tag !== 'input') {\n\t\t\treturn true;\n\t\t}\n\t\tvar i;\n\t\tvar typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n\t\tvar typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n\t\treturn typeA === typeB;\n\t}\n\n\tfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n\t\tvar i, key;\n\t\tvar map = {};\n\t\tfor (i = beginIdx; i <= endIdx; ++i) {\n\t\t\tkey = children[i].key;\n\t\t\tif (isDef(key)) {\n\t\t\t\tmap[key] = i;\n\t\t\t}\n\t\t}\n\t\treturn map;\n\t}\n\n\tfunction createPatchFunction(backend) {\n\t\tvar i, j;\n\t\tvar cbs = {};\n\n\t\tvar modules = backend.modules;\n\t\tvar nodeOps = backend.nodeOps;\n\n\t\tfor (i = 0; i < hooks.length; ++i) {\n\t\t\tcbs[hooks[i]] = [];\n\t\t\tfor (j = 0; j < modules.length; ++j) {\n\t\t\t\tif (isDef(modules[j][hooks[i]])) {\n\t\t\t\t\tcbs[hooks[i]].push(modules[j][hooks[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction emptyNodeAt(elm) {\n\t\t\treturn new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);\n\t\t}\n\n\t\tfunction createRmCb(childElm, listeners) {\n\t\t\tfunction remove$$1() {\n\t\t\t\tif (--remove$$1.listeners === 0) {\n\t\t\t\t\tremoveNode(childElm);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove$$1.listeners = listeners;\n\t\t\treturn remove$$1;\n\t\t}\n\n\t\tfunction removeNode(el) {\n\t\t\tvar parent = nodeOps.parentNode(el);\n\t\t\t// element may have already been removed due to v-html / v-text\n\t\t\tif (isDef(parent)) {\n\t\t\t\tnodeOps.removeChild(parent, el);\n\t\t\t}\n\t\t}\n\n\t\tvar inPre = 0;\n\t\tfunction createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n\t\t\tvnode.isRootInsert = !nested; // for transition enter check\n\t\t\tif (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar data = vnode.data;\n\t\t\tvar children = vnode.children;\n\t\t\tvar tag = vnode.tag;\n\t\t\tif (isDef(tag)) {\n\t\t\t\t{\n\t\t\t\t\tif (data && data.pre) {\n\t\t\t\t\t\tinPre++;\n\t\t\t\t\t}\n\t\t\t\t\tif (!inPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) && config.isUnknownElement(tag)) {\n\t\t\t\t\t\twarn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.', vnode.context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);\n\t\t\t\tsetScope(vnode);\n\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\t{\n\t\t\t\t\tcreateChildren(vnode, children, insertedVnodeQueue);\n\t\t\t\t\tif (isDef(data)) {\n\t\t\t\t\t\tinvokeCreateHooks(vnode, insertedVnodeQueue);\n\t\t\t\t\t}\n\t\t\t\t\tinsert(parentElm, vnode.elm, refElm);\n\t\t\t\t}\n\n\t\t\t\tif (\"development\" !== 'production' && data && data.pre) {\n\t\t\t\t\tinPre--;\n\t\t\t\t}\n\t\t\t} else if (isTrue(vnode.isComment)) {\n\t\t\t\tvnode.elm = nodeOps.createComment(vnode.text);\n\t\t\t\tinsert(parentElm, vnode.elm, refElm);\n\t\t\t} else {\n\t\t\t\tvnode.elm = nodeOps.createTextNode(vnode.text);\n\t\t\t\tinsert(parentElm, vnode.elm, refElm);\n\t\t\t}\n\t\t}\n\n\t\tfunction createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n\t\t\tvar i = vnode.data;\n\t\t\tif (isDef(i)) {\n\t\t\t\tvar isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n\t\t\t\tif (isDef(i = i.hook) && isDef(i = i.init)) {\n\t\t\t\t\ti(vnode, false /* hydrating */, parentElm, refElm);\n\t\t\t\t}\n\t\t\t\t// after calling the init hook, if the vnode is a child component\n\t\t\t\t// it should've created a child instance and mounted it. the child\n\t\t\t\t// component also has set the placeholder vnode's elm.\n\t\t\t\t// in that case we can just return the element and be done.\n\t\t\t\tif (isDef(vnode.componentInstance)) {\n\t\t\t\t\tinitComponent(vnode, insertedVnodeQueue);\n\t\t\t\t\tif (isTrue(isReactivated)) {\n\t\t\t\t\t\treactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction initComponent(vnode, insertedVnodeQueue) {\n\t\t\tif (isDef(vnode.data.pendingInsert)) {\n\t\t\t\tinsertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n\t\t\t\tvnode.data.pendingInsert = null;\n\t\t\t}\n\t\t\tvnode.elm = vnode.componentInstance.$el;\n\t\t\tif (isPatchable(vnode)) {\n\t\t\t\tinvokeCreateHooks(vnode, insertedVnodeQueue);\n\t\t\t\tsetScope(vnode);\n\t\t\t} else {\n\t\t\t\t// empty component root.\n\t\t\t\t// skip all element-related modules except for ref (#3455)\n\t\t\t\tregisterRef(vnode);\n\t\t\t\t// make sure to invoke the insert hook\n\t\t\t\tinsertedVnodeQueue.push(vnode);\n\t\t\t}\n\t\t}\n\n\t\tfunction reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {\n\t\t\tvar i;\n\t\t\t// hack for #4339: a reactivated component with inner transition\n\t\t\t// does not trigger because the inner node's created hooks are not called\n\t\t\t// again. It's not ideal to involve module-specific logic in here but\n\t\t\t// there doesn't seem to be a better way to do it.\n\t\t\tvar innerNode = vnode;\n\t\t\twhile (innerNode.componentInstance) {\n\t\t\t\tinnerNode = innerNode.componentInstance._vnode;\n\t\t\t\tif (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n\t\t\t\t\tfor (i = 0; i < cbs.activate.length; ++i) {\n\t\t\t\t\t\tcbs.activate[i](emptyNode, innerNode);\n\t\t\t\t\t}\n\t\t\t\t\tinsertedVnodeQueue.push(innerNode);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// unlike a newly created component,\n\t\t\t// a reactivated keep-alive component doesn't insert itself\n\t\t\tinsert(parentElm, vnode.elm, refElm);\n\t\t}\n\n\t\tfunction insert(parent, elm, ref) {\n\t\t\tif (isDef(parent)) {\n\t\t\t\tif (isDef(ref)) {\n\t\t\t\t\tif (ref.parentNode === parent) {\n\t\t\t\t\t\tnodeOps.insertBefore(parent, elm, ref);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnodeOps.appendChild(parent, elm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction createChildren(vnode, children, insertedVnodeQueue) {\n\t\t\tif (Array.isArray(children)) {\n\t\t\t\tfor (var i = 0; i < children.length; ++i) {\n\t\t\t\t\tcreateElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n\t\t\t\t}\n\t\t\t} else if (isPrimitive(vnode.text)) {\n\t\t\t\tnodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n\t\t\t}\n\t\t}\n\n\t\tfunction isPatchable(vnode) {\n\t\t\twhile (vnode.componentInstance) {\n\t\t\t\tvnode = vnode.componentInstance._vnode;\n\t\t\t}\n\t\t\treturn isDef(vnode.tag);\n\t\t}\n\n\t\tfunction invokeCreateHooks(vnode, insertedVnodeQueue) {\n\t\t\tfor (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n\t\t\t\tcbs.create[i$1](emptyNode, vnode);\n\t\t\t}\n\t\t\ti = vnode.data.hook; // Reuse variable\n\t\t\tif (isDef(i)) {\n\t\t\t\tif (isDef(i.create)) {\n\t\t\t\t\ti.create(emptyNode, vnode);\n\t\t\t\t}\n\t\t\t\tif (isDef(i.insert)) {\n\t\t\t\t\tinsertedVnodeQueue.push(vnode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// set scope id attribute for scoped CSS.\n\t\t// this is implemented as a special case to avoid the overhead\n\t\t// of going through the normal attribute patching process.\n\t\tfunction setScope(vnode) {\n\t\t\tvar i;\n\t\t\tvar ancestor = vnode;\n\t\t\twhile (ancestor) {\n\t\t\t\tif (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n\t\t\t\t\tnodeOps.setAttribute(vnode.elm, i, '');\n\t\t\t\t}\n\t\t\t\tancestor = ancestor.parent;\n\t\t\t}\n\t\t\t// for slot content they should also get the scopeId from the host instance.\n\t\t\tif (isDef(i = activeInstance) && i !== vnode.context && isDef(i = i.$options._scopeId)) {\n\t\t\t\tnodeOps.setAttribute(vnode.elm, i, '');\n\t\t\t}\n\t\t}\n\n\t\tfunction addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n\t\t\tfor (; startIdx <= endIdx; ++startIdx) {\n\t\t\t\tcreateElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n\t\t\t}\n\t\t}\n\n\t\tfunction invokeDestroyHook(vnode) {\n\t\t\tvar i, j;\n\t\t\tvar data = vnode.data;\n\t\t\tif (isDef(data)) {\n\t\t\t\tif (isDef(i = data.hook) && isDef(i = i.destroy)) {\n\t\t\t\t\ti(vnode);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < cbs.destroy.length; ++i) {\n\t\t\t\t\tcbs.destroy[i](vnode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDef(i = vnode.children)) {\n\t\t\t\tfor (j = 0; j < vnode.children.length; ++j) {\n\t\t\t\t\tinvokeDestroyHook(vnode.children[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n\t\t\tfor (; startIdx <= endIdx; ++startIdx) {\n\t\t\t\tvar ch = vnodes[startIdx];\n\t\t\t\tif (isDef(ch)) {\n\t\t\t\t\tif (isDef(ch.tag)) {\n\t\t\t\t\t\tremoveAndInvokeRemoveHook(ch);\n\t\t\t\t\t\tinvokeDestroyHook(ch);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Text node\n\t\t\t\t\t\tremoveNode(ch.elm);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction removeAndInvokeRemoveHook(vnode, rm) {\n\t\t\tif (isDef(rm) || isDef(vnode.data)) {\n\t\t\t\tvar i;\n\t\t\t\tvar listeners = cbs.remove.length + 1;\n\t\t\t\tif (isDef(rm)) {\n\t\t\t\t\t// we have a recursively passed down rm callback\n\t\t\t\t\t// increase the listeners count\n\t\t\t\t\trm.listeners += listeners;\n\t\t\t\t} else {\n\t\t\t\t\t// directly removing\n\t\t\t\t\trm = createRmCb(vnode.elm, listeners);\n\t\t\t\t}\n\t\t\t\t// recursively invoke hooks on child component root node\n\t\t\t\tif (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n\t\t\t\t\tremoveAndInvokeRemoveHook(i, rm);\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < cbs.remove.length; ++i) {\n\t\t\t\t\tcbs.remove[i](vnode, rm);\n\t\t\t\t}\n\t\t\t\tif (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n\t\t\t\t\ti(vnode, rm);\n\t\t\t\t} else {\n\t\t\t\t\trm();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tremoveNode(vnode.elm);\n\t\t\t}\n\t\t}\n\n\t\tfunction updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n\t\t\tvar oldStartIdx = 0;\n\t\t\tvar newStartIdx = 0;\n\t\t\tvar oldEndIdx = oldCh.length - 1;\n\t\t\tvar oldStartVnode = oldCh[0];\n\t\t\tvar oldEndVnode = oldCh[oldEndIdx];\n\t\t\tvar newEndIdx = newCh.length - 1;\n\t\t\tvar newStartVnode = newCh[0];\n\t\t\tvar newEndVnode = newCh[newEndIdx];\n\t\t\tvar oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n\t\t\t// removeOnly is a special flag used only by <transition-group>\n\t\t\t// to ensure removed elements stay in correct relative positions\n\t\t\t// during leaving transitions\n\t\t\tvar canMove = !removeOnly;\n\n\t\t\twhile (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n\t\t\t\tif (isUndef(oldStartVnode)) {\n\t\t\t\t\toldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n\t\t\t\t} else if (isUndef(oldEndVnode)) {\n\t\t\t\t\toldEndVnode = oldCh[--oldEndIdx];\n\t\t\t\t} else if (sameVnode(oldStartVnode, newStartVnode)) {\n\t\t\t\t\tpatchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n\t\t\t\t\toldStartVnode = oldCh[++oldStartIdx];\n\t\t\t\t\tnewStartVnode = newCh[++newStartIdx];\n\t\t\t\t} else if (sameVnode(oldEndVnode, newEndVnode)) {\n\t\t\t\t\tpatchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n\t\t\t\t\toldEndVnode = oldCh[--oldEndIdx];\n\t\t\t\t\tnewEndVnode = newCh[--newEndIdx];\n\t\t\t\t} else if (sameVnode(oldStartVnode, newEndVnode)) {\n\t\t\t\t\t// Vnode moved right\n\t\t\t\t\tpatchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n\t\t\t\t\tcanMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n\t\t\t\t\toldStartVnode = oldCh[++oldStartIdx];\n\t\t\t\t\tnewEndVnode = newCh[--newEndIdx];\n\t\t\t\t} else if (sameVnode(oldEndVnode, newStartVnode)) {\n\t\t\t\t\t// Vnode moved left\n\t\t\t\t\tpatchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n\t\t\t\t\tcanMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n\t\t\t\t\toldEndVnode = oldCh[--oldEndIdx];\n\t\t\t\t\tnewStartVnode = newCh[++newStartIdx];\n\t\t\t\t} else {\n\t\t\t\t\tif (isUndef(oldKeyToIdx)) {\n\t\t\t\t\t\toldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n\t\t\t\t\t}\n\t\t\t\t\tidxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n\t\t\t\t\tif (isUndef(idxInOld)) {\n\t\t\t\t\t\t// New element\n\t\t\t\t\t\tcreateElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t\t\t\t\t\tnewStartVnode = newCh[++newStartIdx];\n\t\t\t\t\t} else {\n\t\t\t\t\t\telmToMove = oldCh[idxInOld];\n\t\t\t\t\t\t/* istanbul ignore if */\n\t\t\t\t\t\tif (\"development\" !== 'production' && !elmToMove) {\n\t\t\t\t\t\t\twarn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sameVnode(elmToMove, newStartVnode)) {\n\t\t\t\t\t\t\tpatchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n\t\t\t\t\t\t\toldCh[idxInOld] = undefined;\n\t\t\t\t\t\t\tcanMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n\t\t\t\t\t\t\tnewStartVnode = newCh[++newStartIdx];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// same key but different element. treat as new element\n\t\t\t\t\t\t\tcreateElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n\t\t\t\t\t\t\tnewStartVnode = newCh[++newStartIdx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (oldStartIdx > oldEndIdx) {\n\t\t\t\trefElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n\t\t\t\taddVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n\t\t\t} else if (newStartIdx > newEndIdx) {\n\t\t\t\tremoveVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n\t\t\t}\n\t\t}\n\n\t\tfunction patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n\t\t\tif (oldVnode === vnode) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// reuse element for static trees.\n\t\t\t// note we only do this if the vnode is cloned -\n\t\t\t// if the new node is not cloned it means the render functions have been\n\t\t\t// reset by the hot-reload-api and we need to do a proper re-render.\n\t\t\tif (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {\n\t\t\t\tvnode.elm = oldVnode.elm;\n\t\t\t\tvnode.componentInstance = oldVnode.componentInstance;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar i;\n\t\t\tvar data = vnode.data;\n\t\t\tif (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n\t\t\t\ti(oldVnode, vnode);\n\t\t\t}\n\t\t\tvar elm = vnode.elm = oldVnode.elm;\n\t\t\tvar oldCh = oldVnode.children;\n\t\t\tvar ch = vnode.children;\n\t\t\tif (isDef(data) && isPatchable(vnode)) {\n\t\t\t\tfor (i = 0; i < cbs.update.length; ++i) {\n\t\t\t\t\tcbs.update[i](oldVnode, vnode);\n\t\t\t\t}\n\t\t\t\tif (isDef(i = data.hook) && isDef(i = i.update)) {\n\t\t\t\t\ti(oldVnode, vnode);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isUndef(vnode.text)) {\n\t\t\t\tif (isDef(oldCh) && isDef(ch)) {\n\t\t\t\t\tif (oldCh !== ch) {\n\t\t\t\t\t\tupdateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);\n\t\t\t\t\t}\n\t\t\t\t} else if (isDef(ch)) {\n\t\t\t\t\tif (isDef(oldVnode.text)) {\n\t\t\t\t\t\tnodeOps.setTextContent(elm, '');\n\t\t\t\t\t}\n\t\t\t\t\taddVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n\t\t\t\t} else if (isDef(oldCh)) {\n\t\t\t\t\tremoveVnodes(elm, oldCh, 0, oldCh.length - 1);\n\t\t\t\t} else if (isDef(oldVnode.text)) {\n\t\t\t\t\tnodeOps.setTextContent(elm, '');\n\t\t\t\t}\n\t\t\t} else if (oldVnode.text !== vnode.text) {\n\t\t\t\tnodeOps.setTextContent(elm, vnode.text);\n\t\t\t}\n\t\t\tif (isDef(data)) {\n\t\t\t\tif (isDef(i = data.hook) && isDef(i = i.postpatch)) {\n\t\t\t\t\ti(oldVnode, vnode);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction invokeInsertHook(vnode, queue, initial) {\n\t\t\t// delay insert hooks for component root nodes, invoke them after the\n\t\t\t// element is really inserted\n\t\t\tif (isTrue(initial) && isDef(vnode.parent)) {\n\t\t\t\tvnode.parent.data.pendingInsert = queue;\n\t\t\t} else {\n\t\t\t\tfor (var i = 0; i < queue.length; ++i) {\n\t\t\t\t\tqueue[i].data.hook.insert(queue[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar bailed = false;\n\t\t// list of modules that can skip create hook during hydration because they\n\t\t// are already rendered on the client or has no need for initialization\n\t\tvar isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n\t\t// Note: this is a browser-only function so we can assume elms are DOM nodes.\n\t\tfunction hydrate(elm, vnode, insertedVnodeQueue) {\n\t\t\t{\n\t\t\t\tif (!assertNodeMatch(elm, vnode)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvnode.elm = elm;\n\t\t\tvar tag = vnode.tag;\n\t\t\tvar data = vnode.data;\n\t\t\tvar children = vnode.children;\n\t\t\tif (isDef(data)) {\n\t\t\t\tif (isDef(i = data.hook) && isDef(i = i.init)) {\n\t\t\t\t\ti(vnode, true /* hydrating */);\n\t\t\t\t}\n\t\t\t\tif (isDef(i = vnode.componentInstance)) {\n\t\t\t\t\t// child component. it should have hydrated its own tree.\n\t\t\t\t\tinitComponent(vnode, insertedVnodeQueue);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isDef(tag)) {\n\t\t\t\tif (isDef(children)) {\n\t\t\t\t\t// empty element, allow client to pick up and populate children\n\t\t\t\t\tif (!elm.hasChildNodes()) {\n\t\t\t\t\t\tcreateChildren(vnode, children, insertedVnodeQueue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar childrenMatch = true;\n\t\t\t\t\t\tvar childNode = elm.firstChild;\n\t\t\t\t\t\tfor (var i$1 = 0; i$1 < children.length; i$1++) {\n\t\t\t\t\t\t\tif (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n\t\t\t\t\t\t\t\tchildrenMatch = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchildNode = childNode.nextSibling;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if childNode is not null, it means the actual childNodes list is\n\t\t\t\t\t\t// longer than the virtual children list.\n\t\t\t\t\t\tif (!childrenMatch || childNode) {\n\t\t\t\t\t\t\tif (\"development\" !== 'production' && typeof console !== 'undefined' && !bailed) {\n\t\t\t\t\t\t\t\tbailed = true;\n\t\t\t\t\t\t\t\tconsole.warn('Parent: ', elm);\n\t\t\t\t\t\t\t\tconsole.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isDef(data)) {\n\t\t\t\t\tfor (var key in data) {\n\t\t\t\t\t\tif (!isRenderedModule(key)) {\n\t\t\t\t\t\t\tinvokeCreateHooks(vnode, insertedVnodeQueue);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (elm.data !== vnode.text) {\n\t\t\t\telm.data = vnode.text;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tfunction assertNodeMatch(node, vnode) {\n\t\t\tif (isDef(vnode.tag)) {\n\t\t\t\treturn vnode.tag.indexOf('vue-component') === 0 || vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());\n\t\t\t} else {\n\t\t\t\treturn node.nodeType === (vnode.isComment ? 8 : 3);\n\t\t\t}\n\t\t}\n\n\t\treturn function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n\t\t\tif (isUndef(vnode)) {\n\t\t\t\tif (isDef(oldVnode)) {\n\t\t\t\t\tinvokeDestroyHook(oldVnode);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar isInitialPatch = false;\n\t\t\tvar insertedVnodeQueue = [];\n\n\t\t\tif (isUndef(oldVnode)) {\n\t\t\t\t// empty mount (likely as component), create new root element\n\t\t\t\tisInitialPatch = true;\n\t\t\t\tcreateElm(vnode, insertedVnodeQueue, parentElm, refElm);\n\t\t\t} else {\n\t\t\t\tvar isRealElement = isDef(oldVnode.nodeType);\n\t\t\t\tif (!isRealElement && sameVnode(oldVnode, vnode)) {\n\t\t\t\t\t// patch existing root node\n\t\t\t\t\tpatchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n\t\t\t\t} else {\n\t\t\t\t\tif (isRealElement) {\n\t\t\t\t\t\t// mounting to a real element\n\t\t\t\t\t\t// check if this is server-rendered content and if we can perform\n\t\t\t\t\t\t// a successful hydration.\n\t\t\t\t\t\tif (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n\t\t\t\t\t\t\toldVnode.removeAttribute(SSR_ATTR);\n\t\t\t\t\t\t\thydrating = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isTrue(hydrating)) {\n\t\t\t\t\t\t\tif (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n\t\t\t\t\t\t\t\tinvokeInsertHook(vnode, insertedVnodeQueue, true);\n\t\t\t\t\t\t\t\treturn oldVnode;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twarn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// either not server-rendered, or hydration failed.\n\t\t\t\t\t\t// create an empty node and replace it\n\t\t\t\t\t\toldVnode = emptyNodeAt(oldVnode);\n\t\t\t\t\t}\n\t\t\t\t\t// replacing existing element\n\t\t\t\t\tvar oldElm = oldVnode.elm;\n\t\t\t\t\tvar parentElm$1 = nodeOps.parentNode(oldElm);\n\t\t\t\t\tcreateElm(vnode, insertedVnodeQueue,\n\t\t\t\t\t// extremely rare edge case: do not insert if old element is in a\n\t\t\t\t\t// leaving transition. Only happens when combining transition +\n\t\t\t\t\t// keep-alive + HOCs. (#4590)\n\t\t\t\t\toldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));\n\n\t\t\t\t\tif (isDef(vnode.parent)) {\n\t\t\t\t\t\t// component root element replaced.\n\t\t\t\t\t\t// update parent placeholder node element, recursively\n\t\t\t\t\t\tvar ancestor = vnode.parent;\n\t\t\t\t\t\twhile (ancestor) {\n\t\t\t\t\t\t\tancestor.elm = vnode.elm;\n\t\t\t\t\t\t\tancestor = ancestor.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isPatchable(vnode)) {\n\t\t\t\t\t\t\tfor (var i = 0; i < cbs.create.length; ++i) {\n\t\t\t\t\t\t\t\tcbs.create[i](emptyNode, vnode.parent);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isDef(parentElm$1)) {\n\t\t\t\t\t\tremoveVnodes(parentElm$1, [oldVnode], 0, 0);\n\t\t\t\t\t} else if (isDef(oldVnode.tag)) {\n\t\t\t\t\t\tinvokeDestroyHook(oldVnode);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tinvokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n\t\t\treturn vnode.elm;\n\t\t};\n\t}\n\n\t/*  */\n\n\tvar directives = {\n\t\tcreate: updateDirectives,\n\t\tupdate: updateDirectives,\n\t\tdestroy: function unbindDirectives(vnode) {\n\t\t\tupdateDirectives(vnode, emptyNode);\n\t\t}\n\t};\n\n\tfunction updateDirectives(oldVnode, vnode) {\n\t\tif (oldVnode.data.directives || vnode.data.directives) {\n\t\t\t_update(oldVnode, vnode);\n\t\t}\n\t}\n\n\tfunction _update(oldVnode, vnode) {\n\t\tvar isCreate = oldVnode === emptyNode;\n\t\tvar isDestroy = vnode === emptyNode;\n\t\tvar oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n\t\tvar newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n\t\tvar dirsWithInsert = [];\n\t\tvar dirsWithPostpatch = [];\n\n\t\tvar key, oldDir, dir;\n\t\tfor (key in newDirs) {\n\t\t\toldDir = oldDirs[key];\n\t\t\tdir = newDirs[key];\n\t\t\tif (!oldDir) {\n\t\t\t\t// new directive, bind\n\t\t\t\tcallHook$1(dir, 'bind', vnode, oldVnode);\n\t\t\t\tif (dir.def && dir.def.inserted) {\n\t\t\t\t\tdirsWithInsert.push(dir);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// existing directive, update\n\t\t\t\tdir.oldValue = oldDir.value;\n\t\t\t\tcallHook$1(dir, 'update', vnode, oldVnode);\n\t\t\t\tif (dir.def && dir.def.componentUpdated) {\n\t\t\t\t\tdirsWithPostpatch.push(dir);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dirsWithInsert.length) {\n\t\t\tvar callInsert = function callInsert() {\n\t\t\t\tfor (var i = 0; i < dirsWithInsert.length; i++) {\n\t\t\t\t\tcallHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (isCreate) {\n\t\t\t\tmergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n\t\t\t} else {\n\t\t\t\tcallInsert();\n\t\t\t}\n\t\t}\n\n\t\tif (dirsWithPostpatch.length) {\n\t\t\tmergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n\t\t\t\tfor (var i = 0; i < dirsWithPostpatch.length; i++) {\n\t\t\t\t\tcallHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (!isCreate) {\n\t\t\tfor (key in oldDirs) {\n\t\t\t\tif (!newDirs[key]) {\n\t\t\t\t\t// no longer present, unbind\n\t\t\t\t\tcallHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar emptyModifiers = Object.create(null);\n\n\tfunction normalizeDirectives$1(dirs, vm) {\n\t\tvar res = Object.create(null);\n\t\tif (!dirs) {\n\t\t\treturn res;\n\t\t}\n\t\tvar i, dir;\n\t\tfor (i = 0; i < dirs.length; i++) {\n\t\t\tdir = dirs[i];\n\t\t\tif (!dir.modifiers) {\n\t\t\t\tdir.modifiers = emptyModifiers;\n\t\t\t}\n\t\t\tres[getRawDirName(dir)] = dir;\n\t\t\tdir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction getRawDirName(dir) {\n\t\treturn dir.rawName || dir.name + \".\" + Object.keys(dir.modifiers || {}).join('.');\n\t}\n\n\tfunction callHook$1(dir, hook, vnode, oldVnode, isDestroy) {\n\t\tvar fn = dir.def && dir.def[hook];\n\t\tif (fn) {\n\t\t\ttry {\n\t\t\t\tfn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n\t\t\t} catch (e) {\n\t\t\t\thandleError(e, vnode.context, \"directive \" + dir.name + \" \" + hook + \" hook\");\n\t\t\t}\n\t\t}\n\t}\n\n\tvar baseModules = [ref, directives];\n\n\t/*  */\n\n\tfunction updateAttrs(oldVnode, vnode) {\n\t\tif (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n\t\t\treturn;\n\t\t}\n\t\tvar key, cur, old;\n\t\tvar elm = vnode.elm;\n\t\tvar oldAttrs = oldVnode.data.attrs || {};\n\t\tvar attrs = vnode.data.attrs || {};\n\t\t// clone observed objects, as the user probably wants to mutate it\n\t\tif (isDef(attrs.__ob__)) {\n\t\t\tattrs = vnode.data.attrs = extend({}, attrs);\n\t\t}\n\n\t\tfor (key in attrs) {\n\t\t\tcur = attrs[key];\n\t\t\told = oldAttrs[key];\n\t\t\tif (old !== cur) {\n\t\t\t\tsetAttr(elm, key, cur);\n\t\t\t}\n\t\t}\n\t\t// #4391: in IE9, setting type can reset value for input[type=radio]\n\t\t/* istanbul ignore if */\n\t\tif (isIE9 && attrs.value !== oldAttrs.value) {\n\t\t\tsetAttr(elm, 'value', attrs.value);\n\t\t}\n\t\tfor (key in oldAttrs) {\n\t\t\tif (isUndef(attrs[key])) {\n\t\t\t\tif (isXlink(key)) {\n\t\t\t\t\telm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t\t\t\t} else if (!isEnumeratedAttr(key)) {\n\t\t\t\t\telm.removeAttribute(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setAttr(el, key, value) {\n\t\tif (isBooleanAttr(key)) {\n\t\t\t// set attribute for blank value\n\t\t\t// e.g. <option disabled>Select one</option>\n\t\t\tif (isFalsyAttrValue(value)) {\n\t\t\t\tel.removeAttribute(key);\n\t\t\t} else {\n\t\t\t\tel.setAttribute(key, key);\n\t\t\t}\n\t\t} else if (isEnumeratedAttr(key)) {\n\t\t\tel.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n\t\t} else if (isXlink(key)) {\n\t\t\tif (isFalsyAttrValue(value)) {\n\t\t\t\tel.removeAttributeNS(xlinkNS, getXlinkProp(key));\n\t\t\t} else {\n\t\t\t\tel.setAttributeNS(xlinkNS, key, value);\n\t\t\t}\n\t\t} else {\n\t\t\tif (isFalsyAttrValue(value)) {\n\t\t\t\tel.removeAttribute(key);\n\t\t\t} else {\n\t\t\t\tel.setAttribute(key, value);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar attrs = {\n\t\tcreate: updateAttrs,\n\t\tupdate: updateAttrs\n\t};\n\n\t/*  */\n\n\tfunction updateClass(oldVnode, vnode) {\n\t\tvar el = vnode.elm;\n\t\tvar data = vnode.data;\n\t\tvar oldData = oldVnode.data;\n\t\tif (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar cls = genClassForVnode(vnode);\n\n\t\t// handle transition classes\n\t\tvar transitionClass = el._transitionClasses;\n\t\tif (isDef(transitionClass)) {\n\t\t\tcls = concat(cls, stringifyClass(transitionClass));\n\t\t}\n\n\t\t// set the class\n\t\tif (cls !== el._prevClass) {\n\t\t\tel.setAttribute('class', cls);\n\t\t\tel._prevClass = cls;\n\t\t}\n\t}\n\n\tvar klass = {\n\t\tcreate: updateClass,\n\t\tupdate: updateClass\n\t};\n\n\t/*  */\n\n\tvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n\tfunction parseFilters(exp) {\n\t\tvar inSingle = false;\n\t\tvar inDouble = false;\n\t\tvar inTemplateString = false;\n\t\tvar inRegex = false;\n\t\tvar curly = 0;\n\t\tvar square = 0;\n\t\tvar paren = 0;\n\t\tvar lastFilterIndex = 0;\n\t\tvar c, prev, i, expression, filters;\n\n\t\tfor (i = 0; i < exp.length; i++) {\n\t\t\tprev = c;\n\t\t\tc = exp.charCodeAt(i);\n\t\t\tif (inSingle) {\n\t\t\t\tif (c === 0x27 && prev !== 0x5C) {\n\t\t\t\t\tinSingle = false;\n\t\t\t\t}\n\t\t\t} else if (inDouble) {\n\t\t\t\tif (c === 0x22 && prev !== 0x5C) {\n\t\t\t\t\tinDouble = false;\n\t\t\t\t}\n\t\t\t} else if (inTemplateString) {\n\t\t\t\tif (c === 0x60 && prev !== 0x5C) {\n\t\t\t\t\tinTemplateString = false;\n\t\t\t\t}\n\t\t\t} else if (inRegex) {\n\t\t\t\tif (c === 0x2f && prev !== 0x5C) {\n\t\t\t\t\tinRegex = false;\n\t\t\t\t}\n\t\t\t} else if (c === 0x7C && // pipe\n\t\t\texp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {\n\t\t\t\tif (expression === undefined) {\n\t\t\t\t\t// first filter, end of expression\n\t\t\t\t\tlastFilterIndex = i + 1;\n\t\t\t\t\texpression = exp.slice(0, i).trim();\n\t\t\t\t} else {\n\t\t\t\t\tpushFilter();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (c) {\n\t\t\t\t\tcase 0x22:\n\t\t\t\t\t\tinDouble = true;break; // \"\n\t\t\t\t\tcase 0x27:\n\t\t\t\t\t\tinSingle = true;break; // '\n\t\t\t\t\tcase 0x60:\n\t\t\t\t\t\tinTemplateString = true;break; // `\n\t\t\t\t\tcase 0x28:\n\t\t\t\t\t\tparen++;break; // (\n\t\t\t\t\tcase 0x29:\n\t\t\t\t\t\tparen--;break; // )\n\t\t\t\t\tcase 0x5B:\n\t\t\t\t\t\tsquare++;break; // [\n\t\t\t\t\tcase 0x5D:\n\t\t\t\t\t\tsquare--;break; // ]\n\t\t\t\t\tcase 0x7B:\n\t\t\t\t\t\tcurly++;break; // {\n\t\t\t\t\tcase 0x7D:\n\t\t\t\t\t\tcurly--;break; // }\n\t\t\t\t}\n\t\t\t\tif (c === 0x2f) {\n\t\t\t\t\t// /\n\t\t\t\t\tvar j = i - 1;\n\t\t\t\t\tvar p = void 0;\n\t\t\t\t\t// find first non-whitespace prev char\n\t\t\t\t\tfor (; j >= 0; j--) {\n\t\t\t\t\t\tp = exp.charAt(j);\n\t\t\t\t\t\tif (p !== ' ') {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!p || !validDivisionCharRE.test(p)) {\n\t\t\t\t\t\tinRegex = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (expression === undefined) {\n\t\t\texpression = exp.slice(0, i).trim();\n\t\t} else if (lastFilterIndex !== 0) {\n\t\t\tpushFilter();\n\t\t}\n\n\t\tfunction pushFilter() {\n\t\t\t(filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n\t\t\tlastFilterIndex = i + 1;\n\t\t}\n\n\t\tif (filters) {\n\t\t\tfor (i = 0; i < filters.length; i++) {\n\t\t\t\texpression = wrapFilter(expression, filters[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn expression;\n\t}\n\n\tfunction wrapFilter(exp, filter) {\n\t\tvar i = filter.indexOf('(');\n\t\tif (i < 0) {\n\t\t\t// _f: resolveFilter\n\t\t\treturn \"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\";\n\t\t} else {\n\t\t\tvar name = filter.slice(0, i);\n\t\t\tvar args = filter.slice(i + 1);\n\t\t\treturn \"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args;\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction baseWarn(msg) {\n\t\tconsole.error(\"[Vue compiler]: \" + msg);\n\t}\n\n\tfunction pluckModuleFunction(modules, key) {\n\t\treturn modules ? modules.map(function (m) {\n\t\t\treturn m[key];\n\t\t}).filter(function (_) {\n\t\t\treturn _;\n\t\t}) : [];\n\t}\n\n\tfunction addProp(el, name, value) {\n\t\t(el.props || (el.props = [])).push({ name: name, value: value });\n\t}\n\n\tfunction addAttr(el, name, value) {\n\t\t(el.attrs || (el.attrs = [])).push({ name: name, value: value });\n\t}\n\n\tfunction addDirective(el, name, rawName, value, arg, modifiers) {\n\t\t(el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n\t}\n\n\tfunction addHandler(el, name, value, modifiers, important, warn) {\n\t\t// warn prevent and passive modifier\n\t\t/* istanbul ignore if */\n\t\tif (\"development\" !== 'production' && warn && modifiers && modifiers.prevent && modifiers.passive) {\n\t\t\twarn('passive and prevent can\\'t be used together. ' + 'Passive handler can\\'t prevent default event.');\n\t\t}\n\t\t// check capture modifier\n\t\tif (modifiers && modifiers.capture) {\n\t\t\tdelete modifiers.capture;\n\t\t\tname = '!' + name; // mark the event as captured\n\t\t}\n\t\tif (modifiers && modifiers.once) {\n\t\t\tdelete modifiers.once;\n\t\t\tname = '~' + name; // mark the event as once\n\t\t}\n\t\t/* istanbul ignore if */\n\t\tif (modifiers && modifiers.passive) {\n\t\t\tdelete modifiers.passive;\n\t\t\tname = '&' + name; // mark the event as passive\n\t\t}\n\t\tvar events;\n\t\tif (modifiers && modifiers.native) {\n\t\t\tdelete modifiers.native;\n\t\t\tevents = el.nativeEvents || (el.nativeEvents = {});\n\t\t} else {\n\t\t\tevents = el.events || (el.events = {});\n\t\t}\n\t\tvar newHandler = { value: value, modifiers: modifiers };\n\t\tvar handlers = events[name];\n\t\t/* istanbul ignore if */\n\t\tif (Array.isArray(handlers)) {\n\t\t\timportant ? handlers.unshift(newHandler) : handlers.push(newHandler);\n\t\t} else if (handlers) {\n\t\t\tevents[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n\t\t} else {\n\t\t\tevents[name] = newHandler;\n\t\t}\n\t}\n\n\tfunction getBindingAttr(el, name, getStatic) {\n\t\tvar dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);\n\t\tif (dynamicValue != null) {\n\t\t\treturn parseFilters(dynamicValue);\n\t\t} else if (getStatic !== false) {\n\t\t\tvar staticValue = getAndRemoveAttr(el, name);\n\t\t\tif (staticValue != null) {\n\t\t\t\treturn JSON.stringify(staticValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction getAndRemoveAttr(el, name) {\n\t\tvar val;\n\t\tif ((val = el.attrsMap[name]) != null) {\n\t\t\tvar list = el.attrsList;\n\t\t\tfor (var i = 0, l = list.length; i < l; i++) {\n\t\t\t\tif (list[i].name === name) {\n\t\t\t\t\tlist.splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn val;\n\t}\n\n\t/*  */\n\n\t/**\n  * Cross-platform code generation for component v-model\n  */\n\tfunction genComponentModel(el, value, modifiers) {\n\t\tvar ref = modifiers || {};\n\t\tvar number = ref.number;\n\t\tvar trim = ref.trim;\n\n\t\tvar baseValueExpression = '$$v';\n\t\tvar valueExpression = baseValueExpression;\n\t\tif (trim) {\n\t\t\tvalueExpression = \"(typeof \" + baseValueExpression + \" === 'string'\" + \"? \" + baseValueExpression + \".trim()\" + \": \" + baseValueExpression + \")\";\n\t\t}\n\t\tif (number) {\n\t\t\tvalueExpression = \"_n(\" + valueExpression + \")\";\n\t\t}\n\t\tvar assignment = genAssignmentCode(value, valueExpression);\n\n\t\tel.model = {\n\t\t\tvalue: \"(\" + value + \")\",\n\t\t\texpression: \"\\\"\" + value + \"\\\"\",\n\t\t\tcallback: \"function (\" + baseValueExpression + \") {\" + assignment + \"}\"\n\t\t};\n\t}\n\n\t/**\n  * Cross-platform codegen helper for generating v-model value assignment code.\n  */\n\tfunction genAssignmentCode(value, assignment) {\n\t\tvar modelRs = parseModel(value);\n\t\tif (modelRs.idx === null) {\n\t\t\treturn value + \"=\" + assignment;\n\t\t} else {\n\t\t\treturn \"var $$exp = \" + modelRs.exp + \", $$idx = \" + modelRs.idx + \";\" + \"if (!Array.isArray($$exp)){\" + value + \"=\" + assignment + \"}\" + \"else{$$exp.splice($$idx, 1, \" + assignment + \")}\";\n\t\t}\n\t}\n\n\t/**\n  * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n  *\n  * for loop possible cases:\n  *\n  * - test\n  * - test[idx]\n  * - test[test1[idx]]\n  * - test[\"a\"][idx]\n  * - xxx.test[a[a].test1[idx]]\n  * - test.xxx.a[\"asa\"][test1[idx]]\n  *\n  */\n\n\tvar len;\n\tvar str;\n\tvar chr;\n\tvar index$1;\n\tvar expressionPos;\n\tvar expressionEndPos;\n\n\tfunction parseModel(val) {\n\t\tstr = val;\n\t\tlen = str.length;\n\t\tindex$1 = expressionPos = expressionEndPos = 0;\n\n\t\tif (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n\t\t\treturn {\n\t\t\t\texp: val,\n\t\t\t\tidx: null\n\t\t\t};\n\t\t}\n\n\t\twhile (!eof()) {\n\t\t\tchr = next();\n\t\t\t/* istanbul ignore if */\n\t\t\tif (isStringStart(chr)) {\n\t\t\t\tparseString(chr);\n\t\t\t} else if (chr === 0x5B) {\n\t\t\t\tparseBracket(chr);\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\texp: val.substring(0, expressionPos),\n\t\t\tidx: val.substring(expressionPos + 1, expressionEndPos)\n\t\t};\n\t}\n\n\tfunction next() {\n\t\treturn str.charCodeAt(++index$1);\n\t}\n\n\tfunction eof() {\n\t\treturn index$1 >= len;\n\t}\n\n\tfunction isStringStart(chr) {\n\t\treturn chr === 0x22 || chr === 0x27;\n\t}\n\n\tfunction parseBracket(chr) {\n\t\tvar inBracket = 1;\n\t\texpressionPos = index$1;\n\t\twhile (!eof()) {\n\t\t\tchr = next();\n\t\t\tif (isStringStart(chr)) {\n\t\t\t\tparseString(chr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (chr === 0x5B) {\n\t\t\t\tinBracket++;\n\t\t\t}\n\t\t\tif (chr === 0x5D) {\n\t\t\t\tinBracket--;\n\t\t\t}\n\t\t\tif (inBracket === 0) {\n\t\t\t\texpressionEndPos = index$1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction parseString(chr) {\n\t\tvar stringQuote = chr;\n\t\twhile (!eof()) {\n\t\t\tchr = next();\n\t\t\tif (chr === stringQuote) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar warn$1;\n\n\t// in some cases, the event used has to be determined at runtime\n\t// so we used some reserved tokens during compile.\n\tvar RANGE_TOKEN = '__r';\n\tvar CHECKBOX_RADIO_TOKEN = '__c';\n\n\tfunction model(el, dir, _warn) {\n\t\twarn$1 = _warn;\n\t\tvar value = dir.value;\n\t\tvar modifiers = dir.modifiers;\n\t\tvar tag = el.tag;\n\t\tvar type = el.attrsMap.type;\n\n\t\t{\n\t\t\tvar dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n\t\t\tif (tag === 'input' && dynamicType) {\n\t\t\t\twarn$1(\"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" + \"v-model does not support dynamic input types. Use v-if branches instead.\");\n\t\t\t}\n\t\t\t// inputs with type=\"file\" are read only and setting the input's\n\t\t\t// value will throw an error.\n\t\t\tif (tag === 'input' && type === 'file') {\n\t\t\t\twarn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" + \"File inputs are read only. Use a v-on:change listener instead.\");\n\t\t\t}\n\t\t}\n\n\t\tif (tag === 'select') {\n\t\t\tgenSelect(el, value, modifiers);\n\t\t} else if (tag === 'input' && type === 'checkbox') {\n\t\t\tgenCheckboxModel(el, value, modifiers);\n\t\t} else if (tag === 'input' && type === 'radio') {\n\t\t\tgenRadioModel(el, value, modifiers);\n\t\t} else if (tag === 'input' || tag === 'textarea') {\n\t\t\tgenDefaultModel(el, value, modifiers);\n\t\t} else if (!config.isReservedTag(tag)) {\n\t\t\tgenComponentModel(el, value, modifiers);\n\t\t\t// component v-model doesn't need extra runtime\n\t\t\treturn false;\n\t\t} else {\n\t\t\twarn$1(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"v-model is not supported on this element type. \" + 'If you are working with contenteditable, it\\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');\n\t\t}\n\n\t\t// ensure runtime directive metadata\n\t\treturn true;\n\t}\n\n\tfunction genCheckboxModel(el, value, modifiers) {\n\t\tvar number = modifiers && modifiers.number;\n\t\tvar valueBinding = getBindingAttr(el, 'value') || 'null';\n\t\tvar trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n\t\tvar falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n\t\taddProp(el, 'checked', \"Array.isArray(\" + value + \")\" + \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (trueValueBinding === 'true' ? \":(\" + value + \")\" : \":_q(\" + value + \",\" + trueValueBinding + \")\"));\n\t\taddHandler(el, CHECKBOX_RADIO_TOKEN, \"var $$a=\" + value + \",\" + '$$el=$event.target,' + \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" + 'if(Array.isArray($$a)){' + \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" + '$$i=_i($$a,$$v);' + \"if($$c){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" + \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" + \"}else{\" + genAssignmentCode(value, '$$c') + \"}\", null, true);\n\t}\n\n\tfunction genRadioModel(el, value, modifiers) {\n\t\tvar number = modifiers && modifiers.number;\n\t\tvar valueBinding = getBindingAttr(el, 'value') || 'null';\n\t\tvalueBinding = number ? \"_n(\" + valueBinding + \")\" : valueBinding;\n\t\taddProp(el, 'checked', \"_q(\" + value + \",\" + valueBinding + \")\");\n\t\taddHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n\t}\n\n\tfunction genSelect(el, value, modifiers) {\n\t\tvar number = modifiers && modifiers.number;\n\t\tvar selectedVal = \"Array.prototype.filter\" + \".call($event.target.options,function(o){return o.selected})\" + \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" + \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n\t\tvar assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n\t\tvar code = \"var $$selectedVal = \" + selectedVal + \";\";\n\t\tcode = code + \" \" + genAssignmentCode(value, assignment);\n\t\taddHandler(el, 'change', code, null, true);\n\t}\n\n\tfunction genDefaultModel(el, value, modifiers) {\n\t\tvar type = el.attrsMap.type;\n\t\tvar ref = modifiers || {};\n\t\tvar lazy = ref.lazy;\n\t\tvar number = ref.number;\n\t\tvar trim = ref.trim;\n\t\tvar needCompositionGuard = !lazy && type !== 'range';\n\t\tvar event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';\n\n\t\tvar valueExpression = '$event.target.value';\n\t\tif (trim) {\n\t\t\tvalueExpression = \"$event.target.value.trim()\";\n\t\t}\n\t\tif (number) {\n\t\t\tvalueExpression = \"_n(\" + valueExpression + \")\";\n\t\t}\n\n\t\tvar code = genAssignmentCode(value, valueExpression);\n\t\tif (needCompositionGuard) {\n\t\t\tcode = \"if($event.target.composing)return;\" + code;\n\t\t}\n\n\t\taddProp(el, 'value', \"(\" + value + \")\");\n\t\taddHandler(el, event, code, null, true);\n\t\tif (trim || number || type === 'number') {\n\t\t\taddHandler(el, 'blur', '$forceUpdate()');\n\t\t}\n\t}\n\n\t/*  */\n\n\t// normalize v-model event tokens that can only be determined at runtime.\n\t// it's important to place the event as the first in the array because\n\t// the whole point is ensuring the v-model callback gets called before\n\t// user-attached handlers.\n\tfunction normalizeEvents(on) {\n\t\tvar event;\n\t\t/* istanbul ignore if */\n\t\tif (isDef(on[RANGE_TOKEN])) {\n\t\t\t// IE input[type=range] only supports `change` event\n\t\t\tevent = isIE ? 'change' : 'input';\n\t\t\ton[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n\t\t\tdelete on[RANGE_TOKEN];\n\t\t}\n\t\tif (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n\t\t\t// Chrome fires microtasks in between click/change, leads to #4521\n\t\t\tevent = isChrome ? 'click' : 'change';\n\t\t\ton[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n\t\t\tdelete on[CHECKBOX_RADIO_TOKEN];\n\t\t}\n\t}\n\n\tvar target$1;\n\n\tfunction add$1(event, _handler, once$$1, capture, passive) {\n\t\tif (once$$1) {\n\t\t\tvar oldHandler = _handler;\n\t\t\tvar _target = target$1; // save current target element in closure\n\t\t\t_handler = function handler(ev) {\n\t\t\t\tvar res = arguments.length === 1 ? oldHandler(ev) : oldHandler.apply(null, arguments);\n\t\t\t\tif (res !== null) {\n\t\t\t\t\tremove$2(event, _handler, capture, _target);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\ttarget$1.addEventListener(event, _handler, supportsPassive ? { capture: capture, passive: passive } : capture);\n\t}\n\n\tfunction remove$2(event, handler, capture, _target) {\n\t\t(_target || target$1).removeEventListener(event, handler, capture);\n\t}\n\n\tfunction updateDOMListeners(oldVnode, vnode) {\n\t\tif (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n\t\t\treturn;\n\t\t}\n\t\tvar on = vnode.data.on || {};\n\t\tvar oldOn = oldVnode.data.on || {};\n\t\ttarget$1 = vnode.elm;\n\t\tnormalizeEvents(on);\n\t\tupdateListeners(on, oldOn, add$1, remove$2, vnode.context);\n\t}\n\n\tvar events = {\n\t\tcreate: updateDOMListeners,\n\t\tupdate: updateDOMListeners\n\t};\n\n\t/*  */\n\n\tfunction updateDOMProps(oldVnode, vnode) {\n\t\tif (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n\t\t\treturn;\n\t\t}\n\t\tvar key, cur;\n\t\tvar elm = vnode.elm;\n\t\tvar oldProps = oldVnode.data.domProps || {};\n\t\tvar props = vnode.data.domProps || {};\n\t\t// clone observed objects, as the user probably wants to mutate it\n\t\tif (isDef(props.__ob__)) {\n\t\t\tprops = vnode.data.domProps = extend({}, props);\n\t\t}\n\n\t\tfor (key in oldProps) {\n\t\t\tif (isUndef(props[key])) {\n\t\t\t\telm[key] = '';\n\t\t\t}\n\t\t}\n\t\tfor (key in props) {\n\t\t\tcur = props[key];\n\t\t\t// ignore children if the node has textContent or innerHTML,\n\t\t\t// as these will throw away existing DOM nodes and cause removal errors\n\t\t\t// on subsequent patches (#3360)\n\t\t\tif (key === 'textContent' || key === 'innerHTML') {\n\t\t\t\tif (vnode.children) {\n\t\t\t\t\tvnode.children.length = 0;\n\t\t\t\t}\n\t\t\t\tif (cur === oldProps[key]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (key === 'value') {\n\t\t\t\t// store value as _value as well since\n\t\t\t\t// non-string values will be stringified\n\t\t\t\telm._value = cur;\n\t\t\t\t// avoid resetting cursor position when value is the same\n\t\t\t\tvar strCur = isUndef(cur) ? '' : String(cur);\n\t\t\t\tif (shouldUpdateValue(elm, vnode, strCur)) {\n\t\t\t\t\telm.value = strCur;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\telm[key] = cur;\n\t\t\t}\n\t\t}\n\t}\n\n\t// check platforms/web/util/attrs.js acceptValue\n\n\n\tfunction shouldUpdateValue(elm, vnode, checkVal) {\n\t\treturn !elm.composing && (vnode.tag === 'option' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));\n\t}\n\n\tfunction isDirty(elm, checkVal) {\n\t\t// return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value\n\t\treturn document.activeElement !== elm && elm.value !== checkVal;\n\t}\n\n\tfunction isInputChanged(elm, newVal) {\n\t\tvar value = elm.value;\n\t\tvar modifiers = elm._vModifiers; // injected by v-model runtime\n\t\tif (isDef(modifiers) && modifiers.number || elm.type === 'number') {\n\t\t\treturn toNumber(value) !== toNumber(newVal);\n\t\t}\n\t\tif (isDef(modifiers) && modifiers.trim) {\n\t\t\treturn value.trim() !== newVal.trim();\n\t\t}\n\t\treturn value !== newVal;\n\t}\n\n\tvar domProps = {\n\t\tcreate: updateDOMProps,\n\t\tupdate: updateDOMProps\n\t};\n\n\t/*  */\n\n\tvar parseStyleText = cached(function (cssText) {\n\t\tvar res = {};\n\t\tvar listDelimiter = /;(?![^(]*\\))/g;\n\t\tvar propertyDelimiter = /:(.+)/;\n\t\tcssText.split(listDelimiter).forEach(function (item) {\n\t\t\tif (item) {\n\t\t\t\tvar tmp = item.split(propertyDelimiter);\n\t\t\t\ttmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n\t\t\t}\n\t\t});\n\t\treturn res;\n\t});\n\n\t// merge static and dynamic style data on the same vnode\n\tfunction normalizeStyleData(data) {\n\t\tvar style = normalizeStyleBinding(data.style);\n\t\t// static style is pre-processed into an object during compilation\n\t\t// and is always a fresh object, so it's safe to merge into it\n\t\treturn data.staticStyle ? extend(data.staticStyle, style) : style;\n\t}\n\n\t// normalize possible array / string values into Object\n\tfunction normalizeStyleBinding(bindingStyle) {\n\t\tif (Array.isArray(bindingStyle)) {\n\t\t\treturn toObject(bindingStyle);\n\t\t}\n\t\tif (typeof bindingStyle === 'string') {\n\t\t\treturn parseStyleText(bindingStyle);\n\t\t}\n\t\treturn bindingStyle;\n\t}\n\n\t/**\n  * parent component style should be after child's\n  * so that parent component's style could override it\n  */\n\tfunction getStyle(vnode, checkChild) {\n\t\tvar res = {};\n\t\tvar styleData;\n\n\t\tif (checkChild) {\n\t\t\tvar childNode = vnode;\n\t\t\twhile (childNode.componentInstance) {\n\t\t\t\tchildNode = childNode.componentInstance._vnode;\n\t\t\t\tif (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n\t\t\t\t\textend(res, styleData);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (styleData = normalizeStyleData(vnode.data)) {\n\t\t\textend(res, styleData);\n\t\t}\n\n\t\tvar parentNode = vnode;\n\t\twhile (parentNode = parentNode.parent) {\n\t\t\tif (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n\t\t\t\textend(res, styleData);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\t/*  */\n\n\tvar cssVarRE = /^--/;\n\tvar importantRE = /\\s*!important$/;\n\tvar setProp = function setProp(el, name, val) {\n\t\t/* istanbul ignore if */\n\t\tif (cssVarRE.test(name)) {\n\t\t\tel.style.setProperty(name, val);\n\t\t} else if (importantRE.test(val)) {\n\t\t\tel.style.setProperty(name, val.replace(importantRE, ''), 'important');\n\t\t} else {\n\t\t\tvar normalizedName = normalize(name);\n\t\t\tif (Array.isArray(val)) {\n\t\t\t\t// Support values array created by autoprefixer, e.g.\n\t\t\t\t// {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n\t\t\t\t// Set them one by one, and the browser will only set those it can recognize\n\t\t\t\tfor (var i = 0, len = val.length; i < len; i++) {\n\t\t\t\t\tel.style[normalizedName] = val[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tel.style[normalizedName] = val;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar prefixes = ['Webkit', 'Moz', 'ms'];\n\n\tvar testEl;\n\tvar normalize = cached(function (prop) {\n\t\ttestEl = testEl || document.createElement('div');\n\t\tprop = camelize(prop);\n\t\tif (prop !== 'filter' && prop in testEl.style) {\n\t\t\treturn prop;\n\t\t}\n\t\tvar upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n\t\tfor (var i = 0; i < prefixes.length; i++) {\n\t\t\tvar prefixed = prefixes[i] + upper;\n\t\t\tif (prefixed in testEl.style) {\n\t\t\t\treturn prefixed;\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction updateStyle(oldVnode, vnode) {\n\t\tvar data = vnode.data;\n\t\tvar oldData = oldVnode.data;\n\n\t\tif (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar cur, name;\n\t\tvar el = vnode.elm;\n\t\tvar oldStaticStyle = oldData.staticStyle;\n\t\tvar oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n\t\t// if static style exists, stylebinding already merged into it when doing normalizeStyleData\n\t\tvar oldStyle = oldStaticStyle || oldStyleBinding;\n\n\t\tvar style = normalizeStyleBinding(vnode.data.style) || {};\n\n\t\t// store normalized style under a different key for next diff\n\t\t// make sure to clone it if it's reactive, since the user likley wants\n\t\t// to mutate it.\n\t\tvnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;\n\n\t\tvar newStyle = getStyle(vnode, true);\n\n\t\tfor (name in oldStyle) {\n\t\t\tif (isUndef(newStyle[name])) {\n\t\t\t\tsetProp(el, name, '');\n\t\t\t}\n\t\t}\n\t\tfor (name in newStyle) {\n\t\t\tcur = newStyle[name];\n\t\t\tif (cur !== oldStyle[name]) {\n\t\t\t\t// ie9 setting to null has no effect, must use empty string\n\t\t\t\tsetProp(el, name, cur == null ? '' : cur);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar style = {\n\t\tcreate: updateStyle,\n\t\tupdate: updateStyle\n\t};\n\n\t/*  */\n\n\t/**\n  * Add class with compatibility for SVG since classList is not supported on\n  * SVG elements in IE\n  */\n\tfunction addClass(el, cls) {\n\t\t/* istanbul ignore if */\n\t\tif (!cls || !(cls = cls.trim())) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* istanbul ignore else */\n\t\tif (el.classList) {\n\t\t\tif (cls.indexOf(' ') > -1) {\n\t\t\t\tcls.split(/\\s+/).forEach(function (c) {\n\t\t\t\t\treturn el.classList.add(c);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tel.classList.add(cls);\n\t\t\t}\n\t\t} else {\n\t\t\tvar cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\t\t\tif (cur.indexOf(' ' + cls + ' ') < 0) {\n\t\t\t\tel.setAttribute('class', (cur + cls).trim());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Remove class with compatibility for SVG since classList is not supported on\n  * SVG elements in IE\n  */\n\tfunction removeClass(el, cls) {\n\t\t/* istanbul ignore if */\n\t\tif (!cls || !(cls = cls.trim())) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* istanbul ignore else */\n\t\tif (el.classList) {\n\t\t\tif (cls.indexOf(' ') > -1) {\n\t\t\t\tcls.split(/\\s+/).forEach(function (c) {\n\t\t\t\t\treturn el.classList.remove(c);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tel.classList.remove(cls);\n\t\t\t}\n\t\t} else {\n\t\t\tvar cur = \" \" + (el.getAttribute('class') || '') + \" \";\n\t\t\tvar tar = ' ' + cls + ' ';\n\t\t\twhile (cur.indexOf(tar) >= 0) {\n\t\t\t\tcur = cur.replace(tar, ' ');\n\t\t\t}\n\t\t\tel.setAttribute('class', cur.trim());\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction resolveTransition(def$$1) {\n\t\tif (!def$$1) {\n\t\t\treturn;\n\t\t}\n\t\t/* istanbul ignore else */\n\t\tif ((typeof def$$1 === 'undefined' ? 'undefined' : _typeof(def$$1)) === 'object') {\n\t\t\tvar res = {};\n\t\t\tif (def$$1.css !== false) {\n\t\t\t\textend(res, autoCssTransition(def$$1.name || 'v'));\n\t\t\t}\n\t\t\textend(res, def$$1);\n\t\t\treturn res;\n\t\t} else if (typeof def$$1 === 'string') {\n\t\t\treturn autoCssTransition(def$$1);\n\t\t}\n\t}\n\n\tvar autoCssTransition = cached(function (name) {\n\t\treturn {\n\t\t\tenterClass: name + \"-enter\",\n\t\t\tenterToClass: name + \"-enter-to\",\n\t\t\tenterActiveClass: name + \"-enter-active\",\n\t\t\tleaveClass: name + \"-leave\",\n\t\t\tleaveToClass: name + \"-leave-to\",\n\t\t\tleaveActiveClass: name + \"-leave-active\"\n\t\t};\n\t});\n\n\tvar hasTransition = inBrowser && !isIE9;\n\tvar TRANSITION = 'transition';\n\tvar ANIMATION = 'animation';\n\n\t// Transition property/event sniffing\n\tvar transitionProp = 'transition';\n\tvar transitionEndEvent = 'transitionend';\n\tvar animationProp = 'animation';\n\tvar animationEndEvent = 'animationend';\n\tif (hasTransition) {\n\t\t/* istanbul ignore if */\n\t\tif (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {\n\t\t\ttransitionProp = 'WebkitTransition';\n\t\t\ttransitionEndEvent = 'webkitTransitionEnd';\n\t\t}\n\t\tif (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {\n\t\t\tanimationProp = 'WebkitAnimation';\n\t\t\tanimationEndEvent = 'webkitAnimationEnd';\n\t\t}\n\t}\n\n\t// binding to window is necessary to make hot reload work in IE in strict mode\n\tvar raf = inBrowser && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout;\n\n\tfunction nextFrame(fn) {\n\t\traf(function () {\n\t\t\traf(fn);\n\t\t});\n\t}\n\n\tfunction addTransitionClass(el, cls) {\n\t\t(el._transitionClasses || (el._transitionClasses = [])).push(cls);\n\t\taddClass(el, cls);\n\t}\n\n\tfunction removeTransitionClass(el, cls) {\n\t\tif (el._transitionClasses) {\n\t\t\tremove(el._transitionClasses, cls);\n\t\t}\n\t\tremoveClass(el, cls);\n\t}\n\n\tfunction whenTransitionEnds(el, expectedType, cb) {\n\t\tvar ref = getTransitionInfo(el, expectedType);\n\t\tvar type = ref.type;\n\t\tvar timeout = ref.timeout;\n\t\tvar propCount = ref.propCount;\n\t\tif (!type) {\n\t\t\treturn cb();\n\t\t}\n\t\tvar event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n\t\tvar ended = 0;\n\t\tvar end = function end() {\n\t\t\tel.removeEventListener(event, onEnd);\n\t\t\tcb();\n\t\t};\n\t\tvar onEnd = function onEnd(e) {\n\t\t\tif (e.target === el) {\n\t\t\t\tif (++ended >= propCount) {\n\t\t\t\t\tend();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tsetTimeout(function () {\n\t\t\tif (ended < propCount) {\n\t\t\t\tend();\n\t\t\t}\n\t\t}, timeout + 1);\n\t\tel.addEventListener(event, onEnd);\n\t}\n\n\tvar transformRE = /\\b(transform|all)(,|$)/;\n\n\tfunction getTransitionInfo(el, expectedType) {\n\t\tvar styles = window.getComputedStyle(el);\n\t\tvar transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n\t\tvar transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n\t\tvar transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n\t\tvar animationDelays = styles[animationProp + 'Delay'].split(', ');\n\t\tvar animationDurations = styles[animationProp + 'Duration'].split(', ');\n\t\tvar animationTimeout = getTimeout(animationDelays, animationDurations);\n\n\t\tvar type;\n\t\tvar timeout = 0;\n\t\tvar propCount = 0;\n\t\t/* istanbul ignore if */\n\t\tif (expectedType === TRANSITION) {\n\t\t\tif (transitionTimeout > 0) {\n\t\t\t\ttype = TRANSITION;\n\t\t\t\ttimeout = transitionTimeout;\n\t\t\t\tpropCount = transitionDurations.length;\n\t\t\t}\n\t\t} else if (expectedType === ANIMATION) {\n\t\t\tif (animationTimeout > 0) {\n\t\t\t\ttype = ANIMATION;\n\t\t\t\ttimeout = animationTimeout;\n\t\t\t\tpropCount = animationDurations.length;\n\t\t\t}\n\t\t} else {\n\t\t\ttimeout = Math.max(transitionTimeout, animationTimeout);\n\t\t\ttype = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n\t\t\tpropCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n\t\t}\n\t\tvar hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);\n\t\treturn {\n\t\t\ttype: type,\n\t\t\ttimeout: timeout,\n\t\t\tpropCount: propCount,\n\t\t\thasTransform: hasTransform\n\t\t};\n\t}\n\n\tfunction getTimeout(delays, durations) {\n\t\t/* istanbul ignore next */\n\t\twhile (delays.length < durations.length) {\n\t\t\tdelays = delays.concat(delays);\n\t\t}\n\n\t\treturn Math.max.apply(null, durations.map(function (d, i) {\n\t\t\treturn toMs(d) + toMs(delays[i]);\n\t\t}));\n\t}\n\n\tfunction toMs(s) {\n\t\treturn Number(s.slice(0, -1)) * 1000;\n\t}\n\n\t/*  */\n\n\tfunction enter(vnode, toggleDisplay) {\n\t\tvar el = vnode.elm;\n\n\t\t// call leave callback now\n\t\tif (isDef(el._leaveCb)) {\n\t\t\tel._leaveCb.cancelled = true;\n\t\t\tel._leaveCb();\n\t\t}\n\n\t\tvar data = resolveTransition(vnode.data.transition);\n\t\tif (isUndef(data)) {\n\t\t\treturn;\n\t\t}\n\n\t\t/* istanbul ignore if */\n\t\tif (isDef(el._enterCb) || el.nodeType !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar css = data.css;\n\t\tvar type = data.type;\n\t\tvar enterClass = data.enterClass;\n\t\tvar enterToClass = data.enterToClass;\n\t\tvar enterActiveClass = data.enterActiveClass;\n\t\tvar appearClass = data.appearClass;\n\t\tvar appearToClass = data.appearToClass;\n\t\tvar appearActiveClass = data.appearActiveClass;\n\t\tvar beforeEnter = data.beforeEnter;\n\t\tvar enter = data.enter;\n\t\tvar afterEnter = data.afterEnter;\n\t\tvar enterCancelled = data.enterCancelled;\n\t\tvar beforeAppear = data.beforeAppear;\n\t\tvar appear = data.appear;\n\t\tvar afterAppear = data.afterAppear;\n\t\tvar appearCancelled = data.appearCancelled;\n\t\tvar duration = data.duration;\n\n\t\t// activeInstance will always be the <transition> component managing this\n\t\t// transition. One edge case to check is when the <transition> is placed\n\t\t// as the root node of a child component. In that case we need to check\n\t\t// <transition>'s parent for appear check.\n\t\tvar context = activeInstance;\n\t\tvar transitionNode = activeInstance.$vnode;\n\t\twhile (transitionNode && transitionNode.parent) {\n\t\t\ttransitionNode = transitionNode.parent;\n\t\t\tcontext = transitionNode.context;\n\t\t}\n\n\t\tvar isAppear = !context._isMounted || !vnode.isRootInsert;\n\n\t\tif (isAppear && !appear && appear !== '') {\n\t\t\treturn;\n\t\t}\n\n\t\tvar startClass = isAppear && appearClass ? appearClass : enterClass;\n\t\tvar activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;\n\t\tvar toClass = isAppear && appearToClass ? appearToClass : enterToClass;\n\n\t\tvar beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;\n\t\tvar enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;\n\t\tvar afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;\n\t\tvar enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;\n\n\t\tvar explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);\n\n\t\tif (\"development\" !== 'production' && explicitEnterDuration != null) {\n\t\t\tcheckDuration(explicitEnterDuration, 'enter', vnode);\n\t\t}\n\n\t\tvar expectsCSS = css !== false && !isIE9;\n\t\tvar userWantsControl = getHookArgumentsLength(enterHook);\n\n\t\tvar cb = el._enterCb = once(function () {\n\t\t\tif (expectsCSS) {\n\t\t\t\tremoveTransitionClass(el, toClass);\n\t\t\t\tremoveTransitionClass(el, activeClass);\n\t\t\t}\n\t\t\tif (cb.cancelled) {\n\t\t\t\tif (expectsCSS) {\n\t\t\t\t\tremoveTransitionClass(el, startClass);\n\t\t\t\t}\n\t\t\t\tenterCancelledHook && enterCancelledHook(el);\n\t\t\t} else {\n\t\t\t\tafterEnterHook && afterEnterHook(el);\n\t\t\t}\n\t\t\tel._enterCb = null;\n\t\t});\n\n\t\tif (!vnode.data.show) {\n\t\t\t// remove pending leave element on enter by injecting an insert hook\n\t\t\tmergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n\t\t\t\tvar parent = el.parentNode;\n\t\t\t\tvar pendingNode = parent && parent._pending && parent._pending[vnode.key];\n\t\t\t\tif (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n\t\t\t\t\tpendingNode.elm._leaveCb();\n\t\t\t\t}\n\t\t\t\tenterHook && enterHook(el, cb);\n\t\t\t});\n\t\t}\n\n\t\t// start enter transition\n\t\tbeforeEnterHook && beforeEnterHook(el);\n\t\tif (expectsCSS) {\n\t\t\taddTransitionClass(el, startClass);\n\t\t\taddTransitionClass(el, activeClass);\n\t\t\tnextFrame(function () {\n\t\t\t\taddTransitionClass(el, toClass);\n\t\t\t\tremoveTransitionClass(el, startClass);\n\t\t\t\tif (!cb.cancelled && !userWantsControl) {\n\t\t\t\t\tif (isValidDuration(explicitEnterDuration)) {\n\t\t\t\t\t\tsetTimeout(cb, explicitEnterDuration);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhenTransitionEnds(el, type, cb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tif (vnode.data.show) {\n\t\t\ttoggleDisplay && toggleDisplay();\n\t\t\tenterHook && enterHook(el, cb);\n\t\t}\n\n\t\tif (!expectsCSS && !userWantsControl) {\n\t\t\tcb();\n\t\t}\n\t}\n\n\tfunction leave(vnode, rm) {\n\t\tvar el = vnode.elm;\n\n\t\t// call enter callback now\n\t\tif (isDef(el._enterCb)) {\n\t\t\tel._enterCb.cancelled = true;\n\t\t\tel._enterCb();\n\t\t}\n\n\t\tvar data = resolveTransition(vnode.data.transition);\n\t\tif (isUndef(data)) {\n\t\t\treturn rm();\n\t\t}\n\n\t\t/* istanbul ignore if */\n\t\tif (isDef(el._leaveCb) || el.nodeType !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar css = data.css;\n\t\tvar type = data.type;\n\t\tvar leaveClass = data.leaveClass;\n\t\tvar leaveToClass = data.leaveToClass;\n\t\tvar leaveActiveClass = data.leaveActiveClass;\n\t\tvar beforeLeave = data.beforeLeave;\n\t\tvar leave = data.leave;\n\t\tvar afterLeave = data.afterLeave;\n\t\tvar leaveCancelled = data.leaveCancelled;\n\t\tvar delayLeave = data.delayLeave;\n\t\tvar duration = data.duration;\n\n\t\tvar expectsCSS = css !== false && !isIE9;\n\t\tvar userWantsControl = getHookArgumentsLength(leave);\n\n\t\tvar explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);\n\n\t\tif (\"development\" !== 'production' && isDef(explicitLeaveDuration)) {\n\t\t\tcheckDuration(explicitLeaveDuration, 'leave', vnode);\n\t\t}\n\n\t\tvar cb = el._leaveCb = once(function () {\n\t\t\tif (el.parentNode && el.parentNode._pending) {\n\t\t\t\tel.parentNode._pending[vnode.key] = null;\n\t\t\t}\n\t\t\tif (expectsCSS) {\n\t\t\t\tremoveTransitionClass(el, leaveToClass);\n\t\t\t\tremoveTransitionClass(el, leaveActiveClass);\n\t\t\t}\n\t\t\tif (cb.cancelled) {\n\t\t\t\tif (expectsCSS) {\n\t\t\t\t\tremoveTransitionClass(el, leaveClass);\n\t\t\t\t}\n\t\t\t\tleaveCancelled && leaveCancelled(el);\n\t\t\t} else {\n\t\t\t\trm();\n\t\t\t\tafterLeave && afterLeave(el);\n\t\t\t}\n\t\t\tel._leaveCb = null;\n\t\t});\n\n\t\tif (delayLeave) {\n\t\t\tdelayLeave(performLeave);\n\t\t} else {\n\t\t\tperformLeave();\n\t\t}\n\n\t\tfunction performLeave() {\n\t\t\t// the delayed leave may have already been cancelled\n\t\t\tif (cb.cancelled) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// record leaving element\n\t\t\tif (!vnode.data.show) {\n\t\t\t\t(el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n\t\t\t}\n\t\t\tbeforeLeave && beforeLeave(el);\n\t\t\tif (expectsCSS) {\n\t\t\t\taddTransitionClass(el, leaveClass);\n\t\t\t\taddTransitionClass(el, leaveActiveClass);\n\t\t\t\tnextFrame(function () {\n\t\t\t\t\taddTransitionClass(el, leaveToClass);\n\t\t\t\t\tremoveTransitionClass(el, leaveClass);\n\t\t\t\t\tif (!cb.cancelled && !userWantsControl) {\n\t\t\t\t\t\tif (isValidDuration(explicitLeaveDuration)) {\n\t\t\t\t\t\t\tsetTimeout(cb, explicitLeaveDuration);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhenTransitionEnds(el, type, cb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tleave && leave(el, cb);\n\t\t\tif (!expectsCSS && !userWantsControl) {\n\t\t\t\tcb();\n\t\t\t}\n\t\t}\n\t}\n\n\t// only used in dev mode\n\tfunction checkDuration(val, name, vnode) {\n\t\tif (typeof val !== 'number') {\n\t\t\twarn(\"<transition> explicit \" + name + \" duration is not a valid number - \" + \"got \" + JSON.stringify(val) + \".\", vnode.context);\n\t\t} else if (isNaN(val)) {\n\t\t\twarn(\"<transition> explicit \" + name + \" duration is NaN - \" + 'the duration expression might be incorrect.', vnode.context);\n\t\t}\n\t}\n\n\tfunction isValidDuration(val) {\n\t\treturn typeof val === 'number' && !isNaN(val);\n\t}\n\n\t/**\n  * Normalize a transition hook's argument length. The hook may be:\n  * - a merged hook (invoker) with the original in .fns\n  * - a wrapped component method (check ._length)\n  * - a plain function (.length)\n  */\n\tfunction getHookArgumentsLength(fn) {\n\t\tif (isUndef(fn)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar invokerFns = fn.fns;\n\t\tif (isDef(invokerFns)) {\n\t\t\t// invoker\n\t\t\treturn getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);\n\t\t} else {\n\t\t\treturn (fn._length || fn.length) > 1;\n\t\t}\n\t}\n\n\tfunction _enter(_, vnode) {\n\t\tif (vnode.data.show !== true) {\n\t\t\tenter(vnode);\n\t\t}\n\t}\n\n\tvar transition = inBrowser ? {\n\t\tcreate: _enter,\n\t\tactivate: _enter,\n\t\tremove: function remove$$1(vnode, rm) {\n\t\t\t/* istanbul ignore else */\n\t\t\tif (vnode.data.show !== true) {\n\t\t\t\tleave(vnode, rm);\n\t\t\t} else {\n\t\t\t\trm();\n\t\t\t}\n\t\t}\n\t} : {};\n\n\tvar platformModules = [attrs, klass, events, domProps, style, transition];\n\n\t/*  */\n\n\t// the directive module should be applied last, after all\n\t// built-in modules have been applied.\n\tvar modules = platformModules.concat(baseModules);\n\n\tvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n\t/**\n  * Not type checking this file because flow doesn't like attaching\n  * properties to Elements.\n  */\n\n\t/* istanbul ignore if */\n\tif (isIE9) {\n\t\t// http://www.matts411.com/post/internet-explorer-9-oninput/\n\t\tdocument.addEventListener('selectionchange', function () {\n\t\t\tvar el = document.activeElement;\n\t\t\tif (el && el.vmodel) {\n\t\t\t\ttrigger(el, 'input');\n\t\t\t}\n\t\t});\n\t}\n\n\tvar model$1 = {\n\t\tinserted: function inserted(el, binding, vnode) {\n\t\t\tif (vnode.tag === 'select') {\n\t\t\t\tvar cb = function cb() {\n\t\t\t\t\tsetSelected(el, binding, vnode.context);\n\t\t\t\t};\n\t\t\t\tcb();\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (isIE || isEdge) {\n\t\t\t\t\tsetTimeout(cb, 0);\n\t\t\t\t}\n\t\t\t} else if (vnode.tag === 'textarea' || el.type === 'text' || el.type === 'password') {\n\t\t\t\tel._vModifiers = binding.modifiers;\n\t\t\t\tif (!binding.modifiers.lazy) {\n\t\t\t\t\t// Safari < 10.2 & UIWebView doesn't fire compositionend when\n\t\t\t\t\t// switching focus before confirming composition choice\n\t\t\t\t\t// this also fixes the issue where some browsers e.g. iOS Chrome\n\t\t\t\t\t// fires \"change\" instead of \"input\" on autocomplete.\n\t\t\t\t\tel.addEventListener('change', onCompositionEnd);\n\t\t\t\t\tif (!isAndroid) {\n\t\t\t\t\t\tel.addEventListener('compositionstart', onCompositionStart);\n\t\t\t\t\t\tel.addEventListener('compositionend', onCompositionEnd);\n\t\t\t\t\t}\n\t\t\t\t\t/* istanbul ignore if */\n\t\t\t\t\tif (isIE9) {\n\t\t\t\t\t\tel.vmodel = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcomponentUpdated: function componentUpdated(el, binding, vnode) {\n\t\t\tif (vnode.tag === 'select') {\n\t\t\t\tsetSelected(el, binding, vnode.context);\n\t\t\t\t// in case the options rendered by v-for have changed,\n\t\t\t\t// it's possible that the value is out-of-sync with the rendered options.\n\t\t\t\t// detect such cases and filter out values that no longer has a matching\n\t\t\t\t// option in the DOM.\n\t\t\t\tvar needReset = el.multiple ? binding.value.some(function (v) {\n\t\t\t\t\treturn hasNoMatchingOption(v, el.options);\n\t\t\t\t}) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n\t\t\t\tif (needReset) {\n\t\t\t\t\ttrigger(el, 'change');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction setSelected(el, binding, vm) {\n\t\tvar value = binding.value;\n\t\tvar isMultiple = el.multiple;\n\t\tif (isMultiple && !Array.isArray(value)) {\n\t\t\t\"development\" !== 'production' && warn(\"<select multiple v-model=\\\"\" + binding.expression + \"\\\"> \" + \"expects an Array value for its binding, but got \" + Object.prototype.toString.call(value).slice(8, -1), vm);\n\t\t\treturn;\n\t\t}\n\t\tvar selected, option;\n\t\tfor (var i = 0, l = el.options.length; i < l; i++) {\n\t\t\toption = el.options[i];\n\t\t\tif (isMultiple) {\n\t\t\t\tselected = looseIndexOf(value, getValue(option)) > -1;\n\t\t\t\tif (option.selected !== selected) {\n\t\t\t\t\toption.selected = selected;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (looseEqual(getValue(option), value)) {\n\t\t\t\t\tif (el.selectedIndex !== i) {\n\t\t\t\t\t\tel.selectedIndex = i;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!isMultiple) {\n\t\t\tel.selectedIndex = -1;\n\t\t}\n\t}\n\n\tfunction hasNoMatchingOption(value, options) {\n\t\tfor (var i = 0, l = options.length; i < l; i++) {\n\t\t\tif (looseEqual(getValue(options[i]), value)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tfunction getValue(option) {\n\t\treturn '_value' in option ? option._value : option.value;\n\t}\n\n\tfunction onCompositionStart(e) {\n\t\te.target.composing = true;\n\t}\n\n\tfunction onCompositionEnd(e) {\n\t\t// prevent triggering an input event for no reason\n\t\tif (!e.target.composing) {\n\t\t\treturn;\n\t\t}\n\t\te.target.composing = false;\n\t\ttrigger(e.target, 'input');\n\t}\n\n\tfunction trigger(el, type) {\n\t\tvar e = document.createEvent('HTMLEvents');\n\t\te.initEvent(type, true, true);\n\t\tel.dispatchEvent(e);\n\t}\n\n\t/*  */\n\n\t// recursively search for possible transition defined inside the component root\n\tfunction locateNode(vnode) {\n\t\treturn vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;\n\t}\n\n\tvar show = {\n\t\tbind: function bind(el, ref, vnode) {\n\t\t\tvar value = ref.value;\n\n\t\t\tvnode = locateNode(vnode);\n\t\t\tvar transition = vnode.data && vnode.data.transition;\n\t\t\tvar originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;\n\t\t\tif (value && transition && !isIE9) {\n\t\t\t\tvnode.data.show = true;\n\t\t\t\tenter(vnode, function () {\n\t\t\t\t\tel.style.display = originalDisplay;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tel.style.display = value ? originalDisplay : 'none';\n\t\t\t}\n\t\t},\n\n\t\tupdate: function update(el, ref, vnode) {\n\t\t\tvar value = ref.value;\n\t\t\tvar oldValue = ref.oldValue;\n\n\t\t\t/* istanbul ignore if */\n\t\t\tif (value === oldValue) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvnode = locateNode(vnode);\n\t\t\tvar transition = vnode.data && vnode.data.transition;\n\t\t\tif (transition && !isIE9) {\n\t\t\t\tvnode.data.show = true;\n\t\t\t\tif (value) {\n\t\t\t\t\tenter(vnode, function () {\n\t\t\t\t\t\tel.style.display = el.__vOriginalDisplay;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tleave(vnode, function () {\n\t\t\t\t\t\tel.style.display = 'none';\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tel.style.display = value ? el.__vOriginalDisplay : 'none';\n\t\t\t}\n\t\t},\n\n\t\tunbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {\n\t\t\tif (!isDestroy) {\n\t\t\t\tel.style.display = el.__vOriginalDisplay;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar platformDirectives = {\n\t\tmodel: model$1,\n\t\tshow: show\n\t};\n\n\t/*  */\n\n\t// Provides transition support for a single element/component.\n\t// supports transition mode (out-in / in-out)\n\n\tvar transitionProps = {\n\t\tname: String,\n\t\tappear: Boolean,\n\t\tcss: Boolean,\n\t\tmode: String,\n\t\ttype: String,\n\t\tenterClass: String,\n\t\tleaveClass: String,\n\t\tenterToClass: String,\n\t\tleaveToClass: String,\n\t\tenterActiveClass: String,\n\t\tleaveActiveClass: String,\n\t\tappearClass: String,\n\t\tappearActiveClass: String,\n\t\tappearToClass: String,\n\t\tduration: [Number, String, Object]\n\t};\n\n\t// in case the child is also an abstract component, e.g. <keep-alive>\n\t// we want to recursively retrieve the real component to be rendered\n\tfunction getRealChild(vnode) {\n\t\tvar compOptions = vnode && vnode.componentOptions;\n\t\tif (compOptions && compOptions.Ctor.options.abstract) {\n\t\t\treturn getRealChild(getFirstComponentChild(compOptions.children));\n\t\t} else {\n\t\t\treturn vnode;\n\t\t}\n\t}\n\n\tfunction extractTransitionData(comp) {\n\t\tvar data = {};\n\t\tvar options = comp.$options;\n\t\t// props\n\t\tfor (var key in options.propsData) {\n\t\t\tdata[key] = comp[key];\n\t\t}\n\t\t// events.\n\t\t// extract listeners and pass them directly to the transition methods\n\t\tvar listeners = options._parentListeners;\n\t\tfor (var key$1 in listeners) {\n\t\t\tdata[camelize(key$1)] = listeners[key$1];\n\t\t}\n\t\treturn data;\n\t}\n\n\tfunction placeholder(h, rawChild) {\n\t\tif (/\\d-keep-alive$/.test(rawChild.tag)) {\n\t\t\treturn h('keep-alive', {\n\t\t\t\tprops: rawChild.componentOptions.propsData\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction hasParentTransition(vnode) {\n\t\twhile (vnode = vnode.parent) {\n\t\t\tif (vnode.data.transition) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isSameChild(child, oldChild) {\n\t\treturn oldChild.key === child.key && oldChild.tag === child.tag;\n\t}\n\n\tvar Transition = {\n\t\tname: 'transition',\n\t\tprops: transitionProps,\n\t\tabstract: true,\n\n\t\trender: function render(h) {\n\t\t\tvar this$1 = this;\n\n\t\t\tvar children = this.$slots.default;\n\t\t\tif (!children) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// filter out text nodes (possible whitespaces)\n\t\t\tchildren = children.filter(function (c) {\n\t\t\t\treturn c.tag;\n\t\t\t});\n\t\t\t/* istanbul ignore if */\n\t\t\tif (!children.length) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// warn multiple elements\n\t\t\tif (\"development\" !== 'production' && children.length > 1) {\n\t\t\t\twarn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);\n\t\t\t}\n\n\t\t\tvar mode = this.mode;\n\n\t\t\t// warn invalid mode\n\t\t\tif (\"development\" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {\n\t\t\t\twarn('invalid <transition> mode: ' + mode, this.$parent);\n\t\t\t}\n\n\t\t\tvar rawChild = children[0];\n\n\t\t\t// if this is a component root node and the component's\n\t\t\t// parent container node also has transition, skip.\n\t\t\tif (hasParentTransition(this.$vnode)) {\n\t\t\t\treturn rawChild;\n\t\t\t}\n\n\t\t\t// apply transition data to child\n\t\t\t// use getRealChild() to ignore abstract components e.g. keep-alive\n\t\t\tvar child = getRealChild(rawChild);\n\t\t\t/* istanbul ignore if */\n\t\t\tif (!child) {\n\t\t\t\treturn rawChild;\n\t\t\t}\n\n\t\t\tif (this._leaving) {\n\t\t\t\treturn placeholder(h, rawChild);\n\t\t\t}\n\n\t\t\t// ensure a key that is unique to the vnode type and to this transition\n\t\t\t// component instance. This key will be used to remove pending leaving nodes\n\t\t\t// during entering.\n\t\t\tvar id = \"__transition-\" + this._uid + \"-\";\n\t\t\tchild.key = child.key == null ? id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;\n\n\t\t\tvar data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n\t\t\tvar oldRawChild = this._vnode;\n\t\t\tvar oldChild = getRealChild(oldRawChild);\n\n\t\t\t// mark v-show\n\t\t\t// so that the transition module can hand over the control to the directive\n\t\t\tif (child.data.directives && child.data.directives.some(function (d) {\n\t\t\t\treturn d.name === 'show';\n\t\t\t})) {\n\t\t\t\tchild.data.show = true;\n\t\t\t}\n\n\t\t\tif (oldChild && oldChild.data && !isSameChild(child, oldChild)) {\n\t\t\t\t// replace old child transition data with fresh one\n\t\t\t\t// important for dynamic transitions!\n\t\t\t\tvar oldData = oldChild && (oldChild.data.transition = extend({}, data));\n\t\t\t\t// handle transition mode\n\t\t\t\tif (mode === 'out-in') {\n\t\t\t\t\t// return placeholder node and queue update when leave finishes\n\t\t\t\t\tthis._leaving = true;\n\t\t\t\t\tmergeVNodeHook(oldData, 'afterLeave', function () {\n\t\t\t\t\t\tthis$1._leaving = false;\n\t\t\t\t\t\tthis$1.$forceUpdate();\n\t\t\t\t\t});\n\t\t\t\t\treturn placeholder(h, rawChild);\n\t\t\t\t} else if (mode === 'in-out') {\n\t\t\t\t\tvar delayedLeave;\n\t\t\t\t\tvar performLeave = function performLeave() {\n\t\t\t\t\t\tdelayedLeave();\n\t\t\t\t\t};\n\t\t\t\t\tmergeVNodeHook(data, 'afterEnter', performLeave);\n\t\t\t\t\tmergeVNodeHook(data, 'enterCancelled', performLeave);\n\t\t\t\t\tmergeVNodeHook(oldData, 'delayLeave', function (leave) {\n\t\t\t\t\t\tdelayedLeave = leave;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn rawChild;\n\t\t}\n\t};\n\n\t/*  */\n\n\t// Provides transition support for list items.\n\t// supports move transitions using the FLIP technique.\n\n\t// Because the vdom's children update algorithm is \"unstable\" - i.e.\n\t// it doesn't guarantee the relative positioning of removed elements,\n\t// we force transition-group to update its children into two passes:\n\t// in the first pass, we remove all nodes that need to be removed,\n\t// triggering their leaving transition; in the second pass, we insert/move\n\t// into the final desired state. This way in the second pass removed\n\t// nodes will remain where they should be.\n\n\tvar props = extend({\n\t\ttag: String,\n\t\tmoveClass: String\n\t}, transitionProps);\n\n\tdelete props.mode;\n\n\tvar TransitionGroup = {\n\t\tprops: props,\n\n\t\trender: function render(h) {\n\t\t\tvar tag = this.tag || this.$vnode.data.tag || 'span';\n\t\t\tvar map = Object.create(null);\n\t\t\tvar prevChildren = this.prevChildren = this.children;\n\t\t\tvar rawChildren = this.$slots.default || [];\n\t\t\tvar children = this.children = [];\n\t\t\tvar transitionData = extractTransitionData(this);\n\n\t\t\tfor (var i = 0; i < rawChildren.length; i++) {\n\t\t\t\tvar c = rawChildren[i];\n\t\t\t\tif (c.tag) {\n\t\t\t\t\tif (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n\t\t\t\t\t\tchildren.push(c);\n\t\t\t\t\t\tmap[c.key] = c;(c.data || (c.data = {})).transition = transitionData;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar opts = c.componentOptions;\n\t\t\t\t\t\tvar name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;\n\t\t\t\t\t\twarn(\"<transition-group> children must be keyed: <\" + name + \">\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (prevChildren) {\n\t\t\t\tvar kept = [];\n\t\t\t\tvar removed = [];\n\t\t\t\tfor (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n\t\t\t\t\tvar c$1 = prevChildren[i$1];\n\t\t\t\t\tc$1.data.transition = transitionData;\n\t\t\t\t\tc$1.data.pos = c$1.elm.getBoundingClientRect();\n\t\t\t\t\tif (map[c$1.key]) {\n\t\t\t\t\t\tkept.push(c$1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tremoved.push(c$1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.kept = h(tag, null, kept);\n\t\t\t\tthis.removed = removed;\n\t\t\t}\n\n\t\t\treturn h(tag, null, children);\n\t\t},\n\n\t\tbeforeUpdate: function beforeUpdate() {\n\t\t\t// force removing pass\n\t\t\tthis.__patch__(this._vnode, this.kept, false, // hydrating\n\t\t\ttrue // removeOnly (!important, avoids unnecessary moves)\n\t\t\t);\n\t\t\tthis._vnode = this.kept;\n\t\t},\n\n\t\tupdated: function updated() {\n\t\t\tvar children = this.prevChildren;\n\t\t\tvar moveClass = this.moveClass || (this.name || 'v') + '-move';\n\t\t\tif (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// we divide the work into three loops to avoid mixing DOM reads and writes\n\t\t\t// in each iteration - which helps prevent layout thrashing.\n\t\t\tchildren.forEach(callPendingCbs);\n\t\t\tchildren.forEach(recordPosition);\n\t\t\tchildren.forEach(applyTranslation);\n\n\t\t\t// force reflow to put everything in position\n\t\t\tvar body = document.body;\n\t\t\tvar f = body.offsetHeight; // eslint-disable-line\n\n\t\t\tchildren.forEach(function (c) {\n\t\t\t\tif (c.data.moved) {\n\t\t\t\t\tvar el = c.elm;\n\t\t\t\t\tvar s = el.style;\n\t\t\t\t\taddTransitionClass(el, moveClass);\n\t\t\t\t\ts.transform = s.WebkitTransform = s.transitionDuration = '';\n\t\t\t\t\tel.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {\n\t\t\t\t\t\tif (!e || /transform$/.test(e.propertyName)) {\n\t\t\t\t\t\t\tel.removeEventListener(transitionEndEvent, cb);\n\t\t\t\t\t\t\tel._moveCb = null;\n\t\t\t\t\t\t\tremoveTransitionClass(el, moveClass);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tmethods: {\n\t\t\thasMove: function hasMove(el, moveClass) {\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (!hasTransition) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (this._hasMove != null) {\n\t\t\t\t\treturn this._hasMove;\n\t\t\t\t}\n\t\t\t\t// Detect whether an element with the move class applied has\n\t\t\t\t// CSS transitions. Since the element may be inside an entering\n\t\t\t\t// transition at this very moment, we make a clone of it and remove\n\t\t\t\t// all other transition classes applied to ensure only the move class\n\t\t\t\t// is applied.\n\t\t\t\tvar clone = el.cloneNode();\n\t\t\t\tif (el._transitionClasses) {\n\t\t\t\t\tel._transitionClasses.forEach(function (cls) {\n\t\t\t\t\t\tremoveClass(clone, cls);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\taddClass(clone, moveClass);\n\t\t\t\tclone.style.display = 'none';\n\t\t\t\tthis.$el.appendChild(clone);\n\t\t\t\tvar info = getTransitionInfo(clone);\n\t\t\t\tthis.$el.removeChild(clone);\n\t\t\t\treturn this._hasMove = info.hasTransform;\n\t\t\t}\n\t\t}\n\t};\n\n\tfunction callPendingCbs(c) {\n\t\t/* istanbul ignore if */\n\t\tif (c.elm._moveCb) {\n\t\t\tc.elm._moveCb();\n\t\t}\n\t\t/* istanbul ignore if */\n\t\tif (c.elm._enterCb) {\n\t\t\tc.elm._enterCb();\n\t\t}\n\t}\n\n\tfunction recordPosition(c) {\n\t\tc.data.newPos = c.elm.getBoundingClientRect();\n\t}\n\n\tfunction applyTranslation(c) {\n\t\tvar oldPos = c.data.pos;\n\t\tvar newPos = c.data.newPos;\n\t\tvar dx = oldPos.left - newPos.left;\n\t\tvar dy = oldPos.top - newPos.top;\n\t\tif (dx || dy) {\n\t\t\tc.data.moved = true;\n\t\t\tvar s = c.elm.style;\n\t\t\ts.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n\t\t\ts.transitionDuration = '0s';\n\t\t}\n\t}\n\n\tvar platformComponents = {\n\t\tTransition: Transition,\n\t\tTransitionGroup: TransitionGroup\n\t};\n\n\t/*  */\n\n\t// install platform specific utils\n\tVue$3.config.mustUseProp = mustUseProp;\n\tVue$3.config.isReservedTag = isReservedTag;\n\tVue$3.config.isReservedAttr = isReservedAttr;\n\tVue$3.config.getTagNamespace = getTagNamespace;\n\tVue$3.config.isUnknownElement = isUnknownElement;\n\n\t// install platform runtime directives & components\n\textend(Vue$3.options.directives, platformDirectives);\n\textend(Vue$3.options.components, platformComponents);\n\n\t// install platform patch function\n\tVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n\t// public mount method\n\tVue$3.prototype.$mount = function (el, hydrating) {\n\t\tel = el && inBrowser ? query(el) : undefined;\n\t\treturn mountComponent(this, el, hydrating);\n\t};\n\n\t// devtools global hook\n\t/* istanbul ignore next */\n\tsetTimeout(function () {\n\t\tif (config.devtools) {\n\t\t\tif (devtools) {\n\t\t\t\tdevtools.emit('init', Vue$3);\n\t\t\t} else if (\"development\" !== 'production' && isChrome) {\n\t\t\t\tconsole[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n\t\t\t}\n\t\t}\n\t\tif (\"development\" !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {\n\t\t\tconsole[console.info ? 'info' : 'log'](\"You are running Vue in development mode.\\n\" + \"Make sure to turn on production mode when deploying for production.\\n\" + \"See more tips at https://vuejs.org/guide/deployment.html\");\n\t\t}\n\t}, 0);\n\n\t/*  */\n\n\t// check whether current browser encodes a char inside attribute values\n\tfunction shouldDecode(content, encoded) {\n\t\tvar div = document.createElement('div');\n\t\tdiv.innerHTML = \"<div a=\\\"\" + content + \"\\\">\";\n\t\treturn div.innerHTML.indexOf(encoded) > 0;\n\t}\n\n\t// #3663\n\t// IE encodes newlines inside attribute values while other browsers don't\n\tvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n\t/*  */\n\n\tvar isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');\n\n\t// Elements that you can, intentionally, leave open\n\t// (and which close themselves)\n\tvar canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');\n\n\t// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n\t// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n\tvar isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');\n\n\t/*  */\n\n\tvar decoder;\n\n\tfunction decode(html) {\n\t\tdecoder = decoder || document.createElement('div');\n\t\tdecoder.innerHTML = html;\n\t\treturn decoder.textContent;\n\t}\n\n\t/**\n  * Not type-checking this file because it's mostly vendor code.\n  */\n\n\t/*!\n  * HTML Parser By John Resig (ejohn.org)\n  * Modified by Juriy \"kangax\" Zaytsev\n  * Original code by Erik Arvidsson, Mozilla Public License\n  * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n  */\n\n\t// Regular Expressions for parsing tags and attributes\n\tvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\n\tvar singleAttrAssign = /(?:=)/;\n\tvar singleAttrValues = [\n\t// attr value double quotes\n\t/\"([^\"]*)\"+/.source,\n\t// attr value, single quotes\n\t/'([^']*)'+/.source,\n\t// attr value, no quotes\n\t/([^\\s\"'=<>`]+)/.source];\n\tvar attribute = new RegExp('^\\\\s*' + singleAttrIdentifier.source + '(?:\\\\s*(' + singleAttrAssign.source + ')' + '\\\\s*(?:' + singleAttrValues.join('|') + '))?');\n\n\t// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n\t// but for Vue templates we can enforce a simple charset\n\tvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\n\tvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\n\tvar startTagOpen = new RegExp('^<' + qnameCapture);\n\tvar startTagClose = /^\\s*(\\/?)>/;\n\tvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\n\tvar doctype = /^<!DOCTYPE [^>]+>/i;\n\tvar comment = /^<!--/;\n\tvar conditionalComment = /^<!\\[/;\n\n\tvar IS_REGEX_CAPTURING_BROKEN = false;\n\t'x'.replace(/x(.)?/g, function (m, g) {\n\t\tIS_REGEX_CAPTURING_BROKEN = g === '';\n\t});\n\n\t// Special Elements (can contain anything)\n\tvar isPlainTextElement = makeMap('script,style,textarea', true);\n\tvar reCache = {};\n\n\tvar decodingMap = {\n\t\t'&lt;': '<',\n\t\t'&gt;': '>',\n\t\t'&quot;': '\"',\n\t\t'&amp;': '&',\n\t\t'&#10;': '\\n'\n\t};\n\tvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\n\tvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\n\tfunction decodeAttr(value, shouldDecodeNewlines) {\n\t\tvar re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n\t\treturn value.replace(re, function (match) {\n\t\t\treturn decodingMap[match];\n\t\t});\n\t}\n\n\tfunction parseHTML(html, options) {\n\t\tvar stack = [];\n\t\tvar expectHTML = options.expectHTML;\n\t\tvar isUnaryTag$$1 = options.isUnaryTag || no;\n\t\tvar canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n\t\tvar index = 0;\n\t\tvar last, lastTag;\n\t\twhile (html) {\n\t\t\tlast = html;\n\t\t\t// Make sure we're not in a plaintext content element like script/style\n\t\t\tif (!lastTag || !isPlainTextElement(lastTag)) {\n\t\t\t\tvar textEnd = html.indexOf('<');\n\t\t\t\tif (textEnd === 0) {\n\t\t\t\t\t// Comment:\n\t\t\t\t\tif (comment.test(html)) {\n\t\t\t\t\t\tvar commentEnd = html.indexOf('-->');\n\n\t\t\t\t\t\tif (commentEnd >= 0) {\n\t\t\t\t\t\t\tadvance(commentEnd + 3);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n\t\t\t\t\tif (conditionalComment.test(html)) {\n\t\t\t\t\t\tvar conditionalEnd = html.indexOf(']>');\n\n\t\t\t\t\t\tif (conditionalEnd >= 0) {\n\t\t\t\t\t\t\tadvance(conditionalEnd + 2);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Doctype:\n\t\t\t\t\tvar doctypeMatch = html.match(doctype);\n\t\t\t\t\tif (doctypeMatch) {\n\t\t\t\t\t\tadvance(doctypeMatch[0].length);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// End tag:\n\t\t\t\t\tvar endTagMatch = html.match(endTag);\n\t\t\t\t\tif (endTagMatch) {\n\t\t\t\t\t\tvar curIndex = index;\n\t\t\t\t\t\tadvance(endTagMatch[0].length);\n\t\t\t\t\t\tparseEndTag(endTagMatch[1], curIndex, index);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Start tag:\n\t\t\t\t\tvar startTagMatch = parseStartTag();\n\t\t\t\t\tif (startTagMatch) {\n\t\t\t\t\t\thandleStartTag(startTagMatch);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar text = void 0,\n\t\t\t\t    rest$1 = void 0,\n\t\t\t\t    next = void 0;\n\t\t\t\tif (textEnd >= 0) {\n\t\t\t\t\trest$1 = html.slice(textEnd);\n\t\t\t\t\twhile (!endTag.test(rest$1) && !startTagOpen.test(rest$1) && !comment.test(rest$1) && !conditionalComment.test(rest$1)) {\n\t\t\t\t\t\t// < in plain text, be forgiving and treat it as text\n\t\t\t\t\t\tnext = rest$1.indexOf('<', 1);\n\t\t\t\t\t\tif (next < 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttextEnd += next;\n\t\t\t\t\t\trest$1 = html.slice(textEnd);\n\t\t\t\t\t}\n\t\t\t\t\ttext = html.substring(0, textEnd);\n\t\t\t\t\tadvance(textEnd);\n\t\t\t\t}\n\n\t\t\t\tif (textEnd < 0) {\n\t\t\t\t\ttext = html;\n\t\t\t\t\thtml = '';\n\t\t\t\t}\n\n\t\t\t\tif (options.chars && text) {\n\t\t\t\t\toptions.chars(text);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar stackedTag = lastTag.toLowerCase();\n\t\t\t\tvar reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n\t\t\t\tvar endTagLength = 0;\n\t\t\t\tvar rest = html.replace(reStackedTag, function (all, text, endTag) {\n\t\t\t\t\tendTagLength = endTag.length;\n\t\t\t\t\tif (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n\t\t\t\t\t\ttext = text.replace(/<!--([\\s\\S]*?)-->/g, '$1').replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n\t\t\t\t\t}\n\t\t\t\t\tif (options.chars) {\n\t\t\t\t\t\toptions.chars(text);\n\t\t\t\t\t}\n\t\t\t\t\treturn '';\n\t\t\t\t});\n\t\t\t\tindex += html.length - rest.length;\n\t\t\t\thtml = rest;\n\t\t\t\tparseEndTag(stackedTag, index - endTagLength, index);\n\t\t\t}\n\n\t\t\tif (html === last) {\n\t\t\t\toptions.chars && options.chars(html);\n\t\t\t\tif (\"development\" !== 'production' && !stack.length && options.warn) {\n\t\t\t\t\toptions.warn(\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Clean up any remaining tags\n\t\tparseEndTag();\n\n\t\tfunction advance(n) {\n\t\t\tindex += n;\n\t\t\thtml = html.substring(n);\n\t\t}\n\n\t\tfunction parseStartTag() {\n\t\t\tvar start = html.match(startTagOpen);\n\t\t\tif (start) {\n\t\t\t\tvar match = {\n\t\t\t\t\ttagName: start[1],\n\t\t\t\t\tattrs: [],\n\t\t\t\t\tstart: index\n\t\t\t\t};\n\t\t\t\tadvance(start[0].length);\n\t\t\t\tvar end, attr;\n\t\t\t\twhile (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n\t\t\t\t\tadvance(attr[0].length);\n\t\t\t\t\tmatch.attrs.push(attr);\n\t\t\t\t}\n\t\t\t\tif (end) {\n\t\t\t\t\tmatch.unarySlash = end[1];\n\t\t\t\t\tadvance(end[0].length);\n\t\t\t\t\tmatch.end = index;\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction handleStartTag(match) {\n\t\t\tvar tagName = match.tagName;\n\t\t\tvar unarySlash = match.unarySlash;\n\n\t\t\tif (expectHTML) {\n\t\t\t\tif (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n\t\t\t\t\tparseEndTag(lastTag);\n\t\t\t\t}\n\t\t\t\tif (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n\t\t\t\t\tparseEndTag(tagName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;\n\n\t\t\tvar l = match.attrs.length;\n\t\t\tvar attrs = new Array(l);\n\t\t\tfor (var i = 0; i < l; i++) {\n\t\t\t\tvar args = match.attrs[i];\n\t\t\t\t// hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n\t\t\t\tif (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n\t\t\t\t\tif (args[3] === '') {\n\t\t\t\t\t\tdelete args[3];\n\t\t\t\t\t}\n\t\t\t\t\tif (args[4] === '') {\n\t\t\t\t\t\tdelete args[4];\n\t\t\t\t\t}\n\t\t\t\t\tif (args[5] === '') {\n\t\t\t\t\t\tdelete args[5];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar value = args[3] || args[4] || args[5] || '';\n\t\t\t\tattrs[i] = {\n\t\t\t\t\tname: args[1],\n\t\t\t\t\tvalue: decodeAttr(value, options.shouldDecodeNewlines)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (!unary) {\n\t\t\t\tstack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n\t\t\t\tlastTag = tagName;\n\t\t\t}\n\n\t\t\tif (options.start) {\n\t\t\t\toptions.start(tagName, attrs, unary, match.start, match.end);\n\t\t\t}\n\t\t}\n\n\t\tfunction parseEndTag(tagName, start, end) {\n\t\t\tvar pos, lowerCasedTagName;\n\t\t\tif (start == null) {\n\t\t\t\tstart = index;\n\t\t\t}\n\t\t\tif (end == null) {\n\t\t\t\tend = index;\n\t\t\t}\n\n\t\t\tif (tagName) {\n\t\t\t\tlowerCasedTagName = tagName.toLowerCase();\n\t\t\t}\n\n\t\t\t// Find the closest opened tag of the same type\n\t\t\tif (tagName) {\n\t\t\t\tfor (pos = stack.length - 1; pos >= 0; pos--) {\n\t\t\t\t\tif (stack[pos].lowerCasedTag === lowerCasedTagName) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If no tag name is provided, clean shop\n\t\t\t\tpos = 0;\n\t\t\t}\n\n\t\t\tif (pos >= 0) {\n\t\t\t\t// Close all the open elements, up the stack\n\t\t\t\tfor (var i = stack.length - 1; i >= pos; i--) {\n\t\t\t\t\tif (\"development\" !== 'production' && (i > pos || !tagName) && options.warn) {\n\t\t\t\t\t\toptions.warn(\"tag <\" + stack[i].tag + \"> has no matching end tag.\");\n\t\t\t\t\t}\n\t\t\t\t\tif (options.end) {\n\t\t\t\t\t\toptions.end(stack[i].tag, start, end);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Remove the open elements from the stack\n\t\t\t\tstack.length = pos;\n\t\t\t\tlastTag = pos && stack[pos - 1].tag;\n\t\t\t} else if (lowerCasedTagName === 'br') {\n\t\t\t\tif (options.start) {\n\t\t\t\t\toptions.start(tagName, [], true, start, end);\n\t\t\t\t}\n\t\t\t} else if (lowerCasedTagName === 'p') {\n\t\t\t\tif (options.start) {\n\t\t\t\t\toptions.start(tagName, [], false, start, end);\n\t\t\t\t}\n\t\t\t\tif (options.end) {\n\t\t\t\t\toptions.end(tagName, start, end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\n\tvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n\tvar buildRegex = cached(function (delimiters) {\n\t\tvar open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n\t\tvar close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n\t\treturn new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g');\n\t});\n\n\tfunction parseText(text, delimiters) {\n\t\tvar tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n\t\tif (!tagRE.test(text)) {\n\t\t\treturn;\n\t\t}\n\t\tvar tokens = [];\n\t\tvar lastIndex = tagRE.lastIndex = 0;\n\t\tvar match, index;\n\t\twhile (match = tagRE.exec(text)) {\n\t\t\tindex = match.index;\n\t\t\t// push text token\n\t\t\tif (index > lastIndex) {\n\t\t\t\ttokens.push(JSON.stringify(text.slice(lastIndex, index)));\n\t\t\t}\n\t\t\t// tag token\n\t\t\tvar exp = parseFilters(match[1].trim());\n\t\t\ttokens.push(\"_s(\" + exp + \")\");\n\t\t\tlastIndex = index + match[0].length;\n\t\t}\n\t\tif (lastIndex < text.length) {\n\t\t\ttokens.push(JSON.stringify(text.slice(lastIndex)));\n\t\t}\n\t\treturn tokens.join('+');\n\t}\n\n\t/*  */\n\n\tvar onRE = /^@|^v-on:/;\n\tvar dirRE = /^v-|^@|^:/;\n\tvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\n\tvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\n\tvar argRE = /:(.*)$/;\n\tvar bindRE = /^:|^v-bind:/;\n\tvar modifierRE = /\\.[^.]+/g;\n\n\tvar decodeHTMLCached = cached(decode);\n\n\t// configurable state\n\tvar warn$2;\n\tvar delimiters;\n\tvar transforms;\n\tvar preTransforms;\n\tvar postTransforms;\n\tvar platformIsPreTag;\n\tvar platformMustUseProp;\n\tvar platformGetTagNamespace;\n\n\t/**\n  * Convert HTML string to AST.\n  */\n\tfunction parse(template, options) {\n\t\twarn$2 = options.warn || baseWarn;\n\t\tplatformGetTagNamespace = options.getTagNamespace || no;\n\t\tplatformMustUseProp = options.mustUseProp || no;\n\t\tplatformIsPreTag = options.isPreTag || no;\n\t\tpreTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n\t\ttransforms = pluckModuleFunction(options.modules, 'transformNode');\n\t\tpostTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\t\tdelimiters = options.delimiters;\n\n\t\tvar stack = [];\n\t\tvar preserveWhitespace = options.preserveWhitespace !== false;\n\t\tvar root;\n\t\tvar currentParent;\n\t\tvar inVPre = false;\n\t\tvar inPre = false;\n\t\tvar warned = false;\n\n\t\tfunction warnOnce(msg) {\n\t\t\tif (!warned) {\n\t\t\t\twarned = true;\n\t\t\t\twarn$2(msg);\n\t\t\t}\n\t\t}\n\n\t\tfunction endPre(element) {\n\t\t\t// check pre state\n\t\t\tif (element.pre) {\n\t\t\t\tinVPre = false;\n\t\t\t}\n\t\t\tif (platformIsPreTag(element.tag)) {\n\t\t\t\tinPre = false;\n\t\t\t}\n\t\t}\n\n\t\tparseHTML(template, {\n\t\t\twarn: warn$2,\n\t\t\texpectHTML: options.expectHTML,\n\t\t\tisUnaryTag: options.isUnaryTag,\n\t\t\tcanBeLeftOpenTag: options.canBeLeftOpenTag,\n\t\t\tshouldDecodeNewlines: options.shouldDecodeNewlines,\n\t\t\tstart: function start(tag, attrs, unary) {\n\t\t\t\t// check namespace.\n\t\t\t\t// inherit parent ns if there is one\n\t\t\t\tvar ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);\n\n\t\t\t\t// handle IE svg bug\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (isIE && ns === 'svg') {\n\t\t\t\t\tattrs = guardIESVGBug(attrs);\n\t\t\t\t}\n\n\t\t\t\tvar element = {\n\t\t\t\t\ttype: 1,\n\t\t\t\t\ttag: tag,\n\t\t\t\t\tattrsList: attrs,\n\t\t\t\t\tattrsMap: makeAttrsMap(attrs),\n\t\t\t\t\tparent: currentParent,\n\t\t\t\t\tchildren: []\n\t\t\t\t};\n\t\t\t\tif (ns) {\n\t\t\t\t\telement.ns = ns;\n\t\t\t\t}\n\n\t\t\t\tif (isForbiddenTag(element) && !isServerRendering()) {\n\t\t\t\t\telement.forbidden = true;\n\t\t\t\t\t\"development\" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + \"<\" + tag + \">\" + ', as they will not be parsed.');\n\t\t\t\t}\n\n\t\t\t\t// apply pre-transforms\n\t\t\t\tfor (var i = 0; i < preTransforms.length; i++) {\n\t\t\t\t\tpreTransforms[i](element, options);\n\t\t\t\t}\n\n\t\t\t\tif (!inVPre) {\n\t\t\t\t\tprocessPre(element);\n\t\t\t\t\tif (element.pre) {\n\t\t\t\t\t\tinVPre = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (platformIsPreTag(element.tag)) {\n\t\t\t\t\tinPre = true;\n\t\t\t\t}\n\t\t\t\tif (inVPre) {\n\t\t\t\t\tprocessRawAttrs(element);\n\t\t\t\t} else {\n\t\t\t\t\tprocessFor(element);\n\t\t\t\t\tprocessIf(element);\n\t\t\t\t\tprocessOnce(element);\n\t\t\t\t\tprocessKey(element);\n\n\t\t\t\t\t// determine whether this is a plain element after\n\t\t\t\t\t// removing structural attributes\n\t\t\t\t\telement.plain = !element.key && !attrs.length;\n\n\t\t\t\t\tprocessRef(element);\n\t\t\t\t\tprocessSlot(element);\n\t\t\t\t\tprocessComponent(element);\n\t\t\t\t\tfor (var i$1 = 0; i$1 < transforms.length; i$1++) {\n\t\t\t\t\t\ttransforms[i$1](element, options);\n\t\t\t\t\t}\n\t\t\t\t\tprocessAttrs(element);\n\t\t\t\t}\n\n\t\t\t\tfunction checkRootConstraints(el) {\n\t\t\t\t\t{\n\t\t\t\t\t\tif (el.tag === 'slot' || el.tag === 'template') {\n\t\t\t\t\t\t\twarnOnce(\"Cannot use <\" + el.tag + \"> as component root element because it may \" + 'contain multiple nodes.');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (el.attrsMap.hasOwnProperty('v-for')) {\n\t\t\t\t\t\t\twarnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// tree management\n\t\t\t\tif (!root) {\n\t\t\t\t\troot = element;\n\t\t\t\t\tcheckRootConstraints(root);\n\t\t\t\t} else if (!stack.length) {\n\t\t\t\t\t// allow root elements with v-if, v-else-if and v-else\n\t\t\t\t\tif (root.if && (element.elseif || element.else)) {\n\t\t\t\t\t\tcheckRootConstraints(element);\n\t\t\t\t\t\taddIfCondition(root, {\n\t\t\t\t\t\t\texp: element.elseif,\n\t\t\t\t\t\t\tblock: element\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\twarnOnce(\"Component template should contain exactly one root element. \" + \"If you are using v-if on multiple elements, \" + \"use v-else-if to chain them instead.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentParent && !element.forbidden) {\n\t\t\t\t\tif (element.elseif || element.else) {\n\t\t\t\t\t\tprocessIfConditions(element, currentParent);\n\t\t\t\t\t} else if (element.slotScope) {\n\t\t\t\t\t\t// scoped slot\n\t\t\t\t\t\tcurrentParent.plain = false;\n\t\t\t\t\t\tvar name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentParent.children.push(element);\n\t\t\t\t\t\telement.parent = currentParent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!unary) {\n\t\t\t\t\tcurrentParent = element;\n\t\t\t\t\tstack.push(element);\n\t\t\t\t} else {\n\t\t\t\t\tendPre(element);\n\t\t\t\t}\n\t\t\t\t// apply post-transforms\n\t\t\t\tfor (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n\t\t\t\t\tpostTransforms[i$2](element, options);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tend: function end() {\n\t\t\t\t// remove trailing whitespace\n\t\t\t\tvar element = stack[stack.length - 1];\n\t\t\t\tvar lastNode = element.children[element.children.length - 1];\n\t\t\t\tif (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n\t\t\t\t\telement.children.pop();\n\t\t\t\t}\n\t\t\t\t// pop stack\n\t\t\t\tstack.length -= 1;\n\t\t\t\tcurrentParent = stack[stack.length - 1];\n\t\t\t\tendPre(element);\n\t\t\t},\n\n\t\t\tchars: function chars(text) {\n\t\t\t\tif (!currentParent) {\n\t\t\t\t\t{\n\t\t\t\t\t\tif (text === template) {\n\t\t\t\t\t\t\twarnOnce('Component template requires a root element, rather than just text.');\n\t\t\t\t\t\t} else if (text = text.trim()) {\n\t\t\t\t\t\t\twarnOnce(\"text \\\"\" + text + \"\\\" outside root element will be ignored.\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t// IE textarea placeholder bug\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar children = currentParent.children;\n\t\t\t\ttext = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n\t\t\t\t// only preserve whitespace if its not right after a starting tag\n\t\t\t\t: preserveWhitespace && children.length ? ' ' : '';\n\t\t\t\tif (text) {\n\t\t\t\t\tvar expression;\n\t\t\t\t\tif (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n\t\t\t\t\t\tchildren.push({\n\t\t\t\t\t\t\ttype: 2,\n\t\t\t\t\t\t\texpression: expression,\n\t\t\t\t\t\t\ttext: text\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n\t\t\t\t\t\tchildren.push({\n\t\t\t\t\t\t\ttype: 3,\n\t\t\t\t\t\t\ttext: text\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn root;\n\t}\n\n\tfunction processPre(el) {\n\t\tif (getAndRemoveAttr(el, 'v-pre') != null) {\n\t\t\tel.pre = true;\n\t\t}\n\t}\n\n\tfunction processRawAttrs(el) {\n\t\tvar l = el.attrsList.length;\n\t\tif (l) {\n\t\t\tvar attrs = el.attrs = new Array(l);\n\t\t\tfor (var i = 0; i < l; i++) {\n\t\t\t\tattrs[i] = {\n\t\t\t\t\tname: el.attrsList[i].name,\n\t\t\t\t\tvalue: JSON.stringify(el.attrsList[i].value)\n\t\t\t\t};\n\t\t\t}\n\t\t} else if (!el.pre) {\n\t\t\t// non root node in pre blocks with no attributes\n\t\t\tel.plain = true;\n\t\t}\n\t}\n\n\tfunction processKey(el) {\n\t\tvar exp = getBindingAttr(el, 'key');\n\t\tif (exp) {\n\t\t\tif (\"development\" !== 'production' && el.tag === 'template') {\n\t\t\t\twarn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n\t\t\t}\n\t\t\tel.key = exp;\n\t\t}\n\t}\n\n\tfunction processRef(el) {\n\t\tvar ref = getBindingAttr(el, 'ref');\n\t\tif (ref) {\n\t\t\tel.ref = ref;\n\t\t\tel.refInFor = checkInFor(el);\n\t\t}\n\t}\n\n\tfunction processFor(el) {\n\t\tvar exp;\n\t\tif (exp = getAndRemoveAttr(el, 'v-for')) {\n\t\t\tvar inMatch = exp.match(forAliasRE);\n\t\t\tif (!inMatch) {\n\t\t\t\t\"development\" !== 'production' && warn$2(\"Invalid v-for expression: \" + exp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tel.for = inMatch[2].trim();\n\t\t\tvar alias = inMatch[1].trim();\n\t\t\tvar iteratorMatch = alias.match(forIteratorRE);\n\t\t\tif (iteratorMatch) {\n\t\t\t\tel.alias = iteratorMatch[1].trim();\n\t\t\t\tel.iterator1 = iteratorMatch[2].trim();\n\t\t\t\tif (iteratorMatch[3]) {\n\t\t\t\t\tel.iterator2 = iteratorMatch[3].trim();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tel.alias = alias;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction processIf(el) {\n\t\tvar exp = getAndRemoveAttr(el, 'v-if');\n\t\tif (exp) {\n\t\t\tel.if = exp;\n\t\t\taddIfCondition(el, {\n\t\t\t\texp: exp,\n\t\t\t\tblock: el\n\t\t\t});\n\t\t} else {\n\t\t\tif (getAndRemoveAttr(el, 'v-else') != null) {\n\t\t\t\tel.else = true;\n\t\t\t}\n\t\t\tvar elseif = getAndRemoveAttr(el, 'v-else-if');\n\t\t\tif (elseif) {\n\t\t\t\tel.elseif = elseif;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction processIfConditions(el, parent) {\n\t\tvar prev = findPrevElement(parent.children);\n\t\tif (prev && prev.if) {\n\t\t\taddIfCondition(prev, {\n\t\t\t\texp: el.elseif,\n\t\t\t\tblock: el\n\t\t\t});\n\t\t} else {\n\t\t\twarn$2(\"v-\" + (el.elseif ? 'else-if=\"' + el.elseif + '\"' : 'else') + \" \" + \"used on element <\" + el.tag + \"> without corresponding v-if.\");\n\t\t}\n\t}\n\n\tfunction findPrevElement(children) {\n\t\tvar i = children.length;\n\t\twhile (i--) {\n\t\t\tif (children[i].type === 1) {\n\t\t\t\treturn children[i];\n\t\t\t} else {\n\t\t\t\tif (\"development\" !== 'production' && children[i].text !== ' ') {\n\t\t\t\t\twarn$2(\"text \\\"\" + children[i].text.trim() + \"\\\" between v-if and v-else(-if) \" + \"will be ignored.\");\n\t\t\t\t}\n\t\t\t\tchildren.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addIfCondition(el, condition) {\n\t\tif (!el.ifConditions) {\n\t\t\tel.ifConditions = [];\n\t\t}\n\t\tel.ifConditions.push(condition);\n\t}\n\n\tfunction processOnce(el) {\n\t\tvar once$$1 = getAndRemoveAttr(el, 'v-once');\n\t\tif (once$$1 != null) {\n\t\t\tel.once = true;\n\t\t}\n\t}\n\n\tfunction processSlot(el) {\n\t\tif (el.tag === 'slot') {\n\t\t\tel.slotName = getBindingAttr(el, 'name');\n\t\t\tif (\"development\" !== 'production' && el.key) {\n\t\t\t\twarn$2(\"`key` does not work on <slot> because slots are abstract outlets \" + \"and can possibly expand into multiple elements. \" + \"Use the key on a wrapping element instead.\");\n\t\t\t}\n\t\t} else {\n\t\t\tvar slotTarget = getBindingAttr(el, 'slot');\n\t\t\tif (slotTarget) {\n\t\t\t\tel.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n\t\t\t}\n\t\t\tif (el.tag === 'template') {\n\t\t\t\tel.slotScope = getAndRemoveAttr(el, 'scope');\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction processComponent(el) {\n\t\tvar binding;\n\t\tif (binding = getBindingAttr(el, 'is')) {\n\t\t\tel.component = binding;\n\t\t}\n\t\tif (getAndRemoveAttr(el, 'inline-template') != null) {\n\t\t\tel.inlineTemplate = true;\n\t\t}\n\t}\n\n\tfunction processAttrs(el) {\n\t\tvar list = el.attrsList;\n\t\tvar i, l, name, rawName, value, modifiers, isProp;\n\t\tfor (i = 0, l = list.length; i < l; i++) {\n\t\t\tname = rawName = list[i].name;\n\t\t\tvalue = list[i].value;\n\t\t\tif (dirRE.test(name)) {\n\t\t\t\t// mark element as dynamic\n\t\t\t\tel.hasBindings = true;\n\t\t\t\t// modifiers\n\t\t\t\tmodifiers = parseModifiers(name);\n\t\t\t\tif (modifiers) {\n\t\t\t\t\tname = name.replace(modifierRE, '');\n\t\t\t\t}\n\t\t\t\tif (bindRE.test(name)) {\n\t\t\t\t\t// v-bind\n\t\t\t\t\tname = name.replace(bindRE, '');\n\t\t\t\t\tvalue = parseFilters(value);\n\t\t\t\t\tisProp = false;\n\t\t\t\t\tif (modifiers) {\n\t\t\t\t\t\tif (modifiers.prop) {\n\t\t\t\t\t\t\tisProp = true;\n\t\t\t\t\t\t\tname = camelize(name);\n\t\t\t\t\t\t\tif (name === 'innerHtml') {\n\t\t\t\t\t\t\t\tname = 'innerHTML';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (modifiers.camel) {\n\t\t\t\t\t\t\tname = camelize(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (modifiers.sync) {\n\t\t\t\t\t\t\taddHandler(el, \"update:\" + camelize(name), genAssignmentCode(value, \"$event\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n\t\t\t\t\t\taddProp(el, name, value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\taddAttr(el, name, value);\n\t\t\t\t\t}\n\t\t\t\t} else if (onRE.test(name)) {\n\t\t\t\t\t// v-on\n\t\t\t\t\tname = name.replace(onRE, '');\n\t\t\t\t\taddHandler(el, name, value, modifiers, false, warn$2);\n\t\t\t\t} else {\n\t\t\t\t\t// normal directives\n\t\t\t\t\tname = name.replace(dirRE, '');\n\t\t\t\t\t// parse arg\n\t\t\t\t\tvar argMatch = name.match(argRE);\n\t\t\t\t\tvar arg = argMatch && argMatch[1];\n\t\t\t\t\tif (arg) {\n\t\t\t\t\t\tname = name.slice(0, -(arg.length + 1));\n\t\t\t\t\t}\n\t\t\t\t\taddDirective(el, name, rawName, value, arg, modifiers);\n\t\t\t\t\tif (\"development\" !== 'production' && name === 'model') {\n\t\t\t\t\t\tcheckForAliasModel(el, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// literal attribute\n\t\t\t\t{\n\t\t\t\t\tvar expression = parseText(value, delimiters);\n\t\t\t\t\tif (expression) {\n\t\t\t\t\t\twarn$2(name + \"=\\\"\" + value + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taddAttr(el, name, JSON.stringify(value));\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction checkInFor(el) {\n\t\tvar parent = el;\n\t\twhile (parent) {\n\t\t\tif (parent.for !== undefined) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tparent = parent.parent;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction parseModifiers(name) {\n\t\tvar match = name.match(modifierRE);\n\t\tif (match) {\n\t\t\tvar ret = {};\n\t\t\tmatch.forEach(function (m) {\n\t\t\t\tret[m.slice(1)] = true;\n\t\t\t});\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfunction makeAttrsMap(attrs) {\n\t\tvar map = {};\n\t\tfor (var i = 0, l = attrs.length; i < l; i++) {\n\t\t\tif (\"development\" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {\n\t\t\t\twarn$2('duplicate attribute: ' + attrs[i].name);\n\t\t\t}\n\t\t\tmap[attrs[i].name] = attrs[i].value;\n\t\t}\n\t\treturn map;\n\t}\n\n\t// for script (e.g. type=\"x/template\") or style, do not decode content\n\tfunction isTextTag(el) {\n\t\treturn el.tag === 'script' || el.tag === 'style';\n\t}\n\n\tfunction isForbiddenTag(el) {\n\t\treturn el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');\n\t}\n\n\tvar ieNSBug = /^xmlns:NS\\d+/;\n\tvar ieNSPrefix = /^NS\\d+:/;\n\n\t/* istanbul ignore next */\n\tfunction guardIESVGBug(attrs) {\n\t\tvar res = [];\n\t\tfor (var i = 0; i < attrs.length; i++) {\n\t\t\tvar attr = attrs[i];\n\t\t\tif (!ieNSBug.test(attr.name)) {\n\t\t\t\tattr.name = attr.name.replace(ieNSPrefix, '');\n\t\t\t\tres.push(attr);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction checkForAliasModel(el, value) {\n\t\tvar _el = el;\n\t\twhile (_el) {\n\t\t\tif (_el.for && _el.alias === value) {\n\t\t\t\twarn$2(\"<\" + el.tag + \" v-model=\\\"\" + value + \"\\\">: \" + \"You are binding v-model directly to a v-for iteration alias. \" + \"This will not be able to modify the v-for source array because \" + \"writing to the alias is like modifying a function local variable. \" + \"Consider using an array of objects and use v-model on an object property instead.\");\n\t\t\t}\n\t\t\t_el = _el.parent;\n\t\t}\n\t}\n\n\t/*  */\n\n\tvar isStaticKey;\n\tvar isPlatformReservedTag;\n\n\tvar genStaticKeysCached = cached(genStaticKeys$1);\n\n\t/**\n  * Goal of the optimizer: walk the generated template AST tree\n  * and detect sub-trees that are purely static, i.e. parts of\n  * the DOM that never needs to change.\n  *\n  * Once we detect these sub-trees, we can:\n  *\n  * 1. Hoist them into constants, so that we no longer need to\n  *    create fresh nodes for them on each re-render;\n  * 2. Completely skip them in the patching process.\n  */\n\tfunction optimize(root, options) {\n\t\tif (!root) {\n\t\t\treturn;\n\t\t}\n\t\tisStaticKey = genStaticKeysCached(options.staticKeys || '');\n\t\tisPlatformReservedTag = options.isReservedTag || no;\n\t\t// first pass: mark all non-static nodes.\n\t\tmarkStatic$1(root);\n\t\t// second pass: mark static roots.\n\t\tmarkStaticRoots(root, false);\n\t}\n\n\tfunction genStaticKeys$1(keys) {\n\t\treturn makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));\n\t}\n\n\tfunction markStatic$1(node) {\n\t\tnode.static = isStatic(node);\n\t\tif (node.type === 1) {\n\t\t\t// do not make component slot content static. this avoids\n\t\t\t// 1. components not able to mutate slot nodes\n\t\t\t// 2. static slot content fails for hot-reloading\n\t\t\tif (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (var i = 0, l = node.children.length; i < l; i++) {\n\t\t\t\tvar child = node.children[i];\n\t\t\t\tmarkStatic$1(child);\n\t\t\t\tif (!child.static) {\n\t\t\t\t\tnode.static = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction markStaticRoots(node, isInFor) {\n\t\tif (node.type === 1) {\n\t\t\tif (node.static || node.once) {\n\t\t\t\tnode.staticInFor = isInFor;\n\t\t\t}\n\t\t\t// For a node to qualify as a static root, it should have children that\n\t\t\t// are not just static text. Otherwise the cost of hoisting out will\n\t\t\t// outweigh the benefits and it's better off to just always render it fresh.\n\t\t\tif (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {\n\t\t\t\tnode.staticRoot = true;\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tnode.staticRoot = false;\n\t\t\t}\n\t\t\tif (node.children) {\n\t\t\t\tfor (var i = 0, l = node.children.length; i < l; i++) {\n\t\t\t\t\tmarkStaticRoots(node.children[i], isInFor || !!node.for);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.ifConditions) {\n\t\t\t\twalkThroughConditionsBlocks(node.ifConditions, isInFor);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction walkThroughConditionsBlocks(conditionBlocks, isInFor) {\n\t\tfor (var i = 1, len = conditionBlocks.length; i < len; i++) {\n\t\t\tmarkStaticRoots(conditionBlocks[i].block, isInFor);\n\t\t}\n\t}\n\n\tfunction isStatic(node) {\n\t\tif (node.type === 2) {\n\t\t\t// expression\n\t\t\treturn false;\n\t\t}\n\t\tif (node.type === 3) {\n\t\t\t// text\n\t\t\treturn true;\n\t\t}\n\t\treturn !!(node.pre || !node.hasBindings && // no dynamic bindings\n\t\t!node.if && !node.for && // not v-if or v-for or v-else\n\t\t!isBuiltInTag(node.tag) && // not a built-in\n\t\tisPlatformReservedTag(node.tag) && // not a component\n\t\t!isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));\n\t}\n\n\tfunction isDirectChildOfTemplateFor(node) {\n\t\twhile (node.parent) {\n\t\t\tnode = node.parent;\n\t\t\tif (node.tag !== 'template') {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (node.for) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/*  */\n\n\tvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\n\tvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n\t// keyCode aliases\n\tvar keyCodes = {\n\t\tesc: 27,\n\t\ttab: 9,\n\t\tenter: 13,\n\t\tspace: 32,\n\t\tup: 38,\n\t\tleft: 37,\n\t\tright: 39,\n\t\tdown: 40,\n\t\t'delete': [8, 46]\n\t};\n\n\t// #4868: modifiers that prevent the execution of the listener\n\t// need to explicitly return null so that we can determine whether to remove\n\t// the listener for .once\n\tvar genGuard = function genGuard(condition) {\n\t\treturn \"if(\" + condition + \")return null;\";\n\t};\n\n\tvar modifierCode = {\n\t\tstop: '$event.stopPropagation();',\n\t\tprevent: '$event.preventDefault();',\n\t\tself: genGuard(\"$event.target !== $event.currentTarget\"),\n\t\tctrl: genGuard(\"!$event.ctrlKey\"),\n\t\tshift: genGuard(\"!$event.shiftKey\"),\n\t\talt: genGuard(\"!$event.altKey\"),\n\t\tmeta: genGuard(\"!$event.metaKey\"),\n\t\tleft: genGuard(\"'button' in $event && $event.button !== 0\"),\n\t\tmiddle: genGuard(\"'button' in $event && $event.button !== 1\"),\n\t\tright: genGuard(\"'button' in $event && $event.button !== 2\")\n\t};\n\n\tfunction genHandlers(events, isNative, warn) {\n\t\tvar res = isNative ? 'nativeOn:{' : 'on:{';\n\t\tfor (var name in events) {\n\t\t\tvar handler = events[name];\n\t\t\t// #5330: warn click.right, since right clicks do not actually fire click events.\n\t\t\tif (\"development\" !== 'production' && name === 'click' && handler && handler.modifiers && handler.modifiers.right) {\n\t\t\t\twarn(\"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" + \"do not actually fire \\\"click\\\" events.\");\n\t\t\t}\n\t\t\tres += \"\\\"\" + name + \"\\\":\" + genHandler(name, handler) + \",\";\n\t\t}\n\t\treturn res.slice(0, -1) + '}';\n\t}\n\n\tfunction genHandler(name, handler) {\n\t\tif (!handler) {\n\t\t\treturn 'function(){}';\n\t\t}\n\n\t\tif (Array.isArray(handler)) {\n\t\t\treturn \"[\" + handler.map(function (handler) {\n\t\t\t\treturn genHandler(name, handler);\n\t\t\t}).join(',') + \"]\";\n\t\t}\n\n\t\tvar isMethodPath = simplePathRE.test(handler.value);\n\t\tvar isFunctionExpression = fnExpRE.test(handler.value);\n\n\t\tif (!handler.modifiers) {\n\t\t\treturn isMethodPath || isFunctionExpression ? handler.value : \"function($event){\" + handler.value + \"}\"; // inline statement\n\t\t} else {\n\t\t\tvar code = '';\n\t\t\tvar genModifierCode = '';\n\t\t\tvar keys = [];\n\t\t\tfor (var key in handler.modifiers) {\n\t\t\t\tif (modifierCode[key]) {\n\t\t\t\t\tgenModifierCode += modifierCode[key];\n\t\t\t\t\t// left/right\n\t\t\t\t\tif (keyCodes[key]) {\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (keys.length) {\n\t\t\t\tcode += genKeyFilter(keys);\n\t\t\t}\n\t\t\t// Make sure modifiers like prevent and stop get executed after key filtering\n\t\t\tif (genModifierCode) {\n\t\t\t\tcode += genModifierCode;\n\t\t\t}\n\t\t\tvar handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? \"(\" + handler.value + \")($event)\" : handler.value;\n\t\t\treturn \"function($event){\" + code + handlerCode + \"}\";\n\t\t}\n\t}\n\n\tfunction genKeyFilter(keys) {\n\t\treturn \"if(!('button' in $event)&&\" + keys.map(genFilterCode).join('&&') + \")return null;\";\n\t}\n\n\tfunction genFilterCode(key) {\n\t\tvar keyVal = parseInt(key, 10);\n\t\tif (keyVal) {\n\t\t\treturn \"$event.keyCode!==\" + keyVal;\n\t\t}\n\t\tvar alias = keyCodes[key];\n\t\treturn \"_k($event.keyCode,\" + JSON.stringify(key) + (alias ? ',' + JSON.stringify(alias) : '') + \")\";\n\t}\n\n\t/*  */\n\n\tfunction bind$1(el, dir) {\n\t\tel.wrapData = function (code) {\n\t\t\treturn \"_b(\" + code + \",'\" + el.tag + \"',\" + dir.value + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + \")\";\n\t\t};\n\t}\n\n\t/*  */\n\n\tvar baseDirectives = {\n\t\tbind: bind$1,\n\t\tcloak: noop\n\t};\n\n\t/*  */\n\n\t// configurable state\n\tvar warn$3;\n\tvar transforms$1;\n\tvar dataGenFns;\n\tvar platformDirectives$1;\n\tvar isPlatformReservedTag$1;\n\tvar staticRenderFns;\n\tvar onceCount;\n\tvar currentOptions;\n\n\tfunction generate(ast, options) {\n\t\t// save previous staticRenderFns so generate calls can be nested\n\t\tvar prevStaticRenderFns = staticRenderFns;\n\t\tvar currentStaticRenderFns = staticRenderFns = [];\n\t\tvar prevOnceCount = onceCount;\n\t\tonceCount = 0;\n\t\tcurrentOptions = options;\n\t\twarn$3 = options.warn || baseWarn;\n\t\ttransforms$1 = pluckModuleFunction(options.modules, 'transformCode');\n\t\tdataGenFns = pluckModuleFunction(options.modules, 'genData');\n\t\tplatformDirectives$1 = options.directives || {};\n\t\tisPlatformReservedTag$1 = options.isReservedTag || no;\n\t\tvar code = ast ? genElement(ast) : '_c(\"div\")';\n\t\tstaticRenderFns = prevStaticRenderFns;\n\t\tonceCount = prevOnceCount;\n\t\treturn {\n\t\t\trender: \"with(this){return \" + code + \"}\",\n\t\t\tstaticRenderFns: currentStaticRenderFns\n\t\t};\n\t}\n\n\tfunction genElement(el) {\n\t\tif (el.staticRoot && !el.staticProcessed) {\n\t\t\treturn genStatic(el);\n\t\t} else if (el.once && !el.onceProcessed) {\n\t\t\treturn genOnce(el);\n\t\t} else if (el.for && !el.forProcessed) {\n\t\t\treturn genFor(el);\n\t\t} else if (el.if && !el.ifProcessed) {\n\t\t\treturn genIf(el);\n\t\t} else if (el.tag === 'template' && !el.slotTarget) {\n\t\t\treturn genChildren(el) || 'void 0';\n\t\t} else if (el.tag === 'slot') {\n\t\t\treturn genSlot(el);\n\t\t} else {\n\t\t\t// component or element\n\t\t\tvar code;\n\t\t\tif (el.component) {\n\t\t\t\tcode = genComponent(el.component, el);\n\t\t\t} else {\n\t\t\t\tvar data = el.plain ? undefined : genData(el);\n\n\t\t\t\tvar children = el.inlineTemplate ? null : genChildren(el, true);\n\t\t\t\tcode = \"_c('\" + el.tag + \"'\" + (data ? \",\" + data : '') + (children ? \",\" + children : '') + \")\";\n\t\t\t}\n\t\t\t// module transforms\n\t\t\tfor (var i = 0; i < transforms$1.length; i++) {\n\t\t\t\tcode = transforms$1[i](el, code);\n\t\t\t}\n\t\t\treturn code;\n\t\t}\n\t}\n\n\t// hoist static sub-trees out\n\tfunction genStatic(el) {\n\t\tel.staticProcessed = true;\n\t\tstaticRenderFns.push(\"with(this){return \" + genElement(el) + \"}\");\n\t\treturn \"_m(\" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\";\n\t}\n\n\t// v-once\n\tfunction genOnce(el) {\n\t\tel.onceProcessed = true;\n\t\tif (el.if && !el.ifProcessed) {\n\t\t\treturn genIf(el);\n\t\t} else if (el.staticInFor) {\n\t\t\tvar key = '';\n\t\t\tvar parent = el.parent;\n\t\t\twhile (parent) {\n\t\t\t\tif (parent.for) {\n\t\t\t\t\tkey = parent.key;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t\tif (!key) {\n\t\t\t\t\"development\" !== 'production' && warn$3(\"v-once can only be used inside v-for that is keyed. \");\n\t\t\t\treturn genElement(el);\n\t\t\t}\n\t\t\treturn \"_o(\" + genElement(el) + \",\" + onceCount++ + (key ? \",\" + key : \"\") + \")\";\n\t\t} else {\n\t\t\treturn genStatic(el);\n\t\t}\n\t}\n\n\tfunction genIf(el) {\n\t\tel.ifProcessed = true; // avoid recursion\n\t\treturn genIfConditions(el.ifConditions.slice());\n\t}\n\n\tfunction genIfConditions(conditions) {\n\t\tif (!conditions.length) {\n\t\t\treturn '_e()';\n\t\t}\n\n\t\tvar condition = conditions.shift();\n\t\tif (condition.exp) {\n\t\t\treturn \"(\" + condition.exp + \")?\" + genTernaryExp(condition.block) + \":\" + genIfConditions(conditions);\n\t\t} else {\n\t\t\treturn \"\" + genTernaryExp(condition.block);\n\t\t}\n\n\t\t// v-if with v-once should generate code like (a)?_m(0):_m(1)\n\t\tfunction genTernaryExp(el) {\n\t\t\treturn el.once ? genOnce(el) : genElement(el);\n\t\t}\n\t}\n\n\tfunction genFor(el) {\n\t\tvar exp = el.for;\n\t\tvar alias = el.alias;\n\t\tvar iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n\t\tvar iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\n\t\tif (\"development\" !== 'production' && maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {\n\t\t\twarn$3(\"<\" + el.tag + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" + \"v-for should have explicit keys. \" + \"See https://vuejs.org/guide/list.html#key for more info.\", true /* tip */\n\t\t\t);\n\t\t}\n\n\t\tel.forProcessed = true; // avoid recursion\n\t\treturn \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genElement(el) + '})';\n\t}\n\n\tfunction genData(el) {\n\t\tvar data = '{';\n\n\t\t// directives first.\n\t\t// directives may mutate the el's other properties before they are generated.\n\t\tvar dirs = genDirectives(el);\n\t\tif (dirs) {\n\t\t\tdata += dirs + ',';\n\t\t}\n\n\t\t// key\n\t\tif (el.key) {\n\t\t\tdata += \"key:\" + el.key + \",\";\n\t\t}\n\t\t// ref\n\t\tif (el.ref) {\n\t\t\tdata += \"ref:\" + el.ref + \",\";\n\t\t}\n\t\tif (el.refInFor) {\n\t\t\tdata += \"refInFor:true,\";\n\t\t}\n\t\t// pre\n\t\tif (el.pre) {\n\t\t\tdata += \"pre:true,\";\n\t\t}\n\t\t// record original tag name for components using \"is\" attribute\n\t\tif (el.component) {\n\t\t\tdata += \"tag:\\\"\" + el.tag + \"\\\",\";\n\t\t}\n\t\t// module data generation functions\n\t\tfor (var i = 0; i < dataGenFns.length; i++) {\n\t\t\tdata += dataGenFns[i](el);\n\t\t}\n\t\t// attributes\n\t\tif (el.attrs) {\n\t\t\tdata += \"attrs:{\" + genProps(el.attrs) + \"},\";\n\t\t}\n\t\t// DOM props\n\t\tif (el.props) {\n\t\t\tdata += \"domProps:{\" + genProps(el.props) + \"},\";\n\t\t}\n\t\t// event handlers\n\t\tif (el.events) {\n\t\t\tdata += genHandlers(el.events, false, warn$3) + \",\";\n\t\t}\n\t\tif (el.nativeEvents) {\n\t\t\tdata += genHandlers(el.nativeEvents, true, warn$3) + \",\";\n\t\t}\n\t\t// slot target\n\t\tif (el.slotTarget) {\n\t\t\tdata += \"slot:\" + el.slotTarget + \",\";\n\t\t}\n\t\t// scoped slots\n\t\tif (el.scopedSlots) {\n\t\t\tdata += genScopedSlots(el.scopedSlots) + \",\";\n\t\t}\n\t\t// component v-model\n\t\tif (el.model) {\n\t\t\tdata += \"model:{value:\" + el.model.value + \",callback:\" + el.model.callback + \",expression:\" + el.model.expression + \"},\";\n\t\t}\n\t\t// inline-template\n\t\tif (el.inlineTemplate) {\n\t\t\tvar inlineTemplate = genInlineTemplate(el);\n\t\t\tif (inlineTemplate) {\n\t\t\t\tdata += inlineTemplate + \",\";\n\t\t\t}\n\t\t}\n\t\tdata = data.replace(/,$/, '') + '}';\n\t\t// v-bind data wrap\n\t\tif (el.wrapData) {\n\t\t\tdata = el.wrapData(data);\n\t\t}\n\t\treturn data;\n\t}\n\n\tfunction genDirectives(el) {\n\t\tvar dirs = el.directives;\n\t\tif (!dirs) {\n\t\t\treturn;\n\t\t}\n\t\tvar res = 'directives:[';\n\t\tvar hasRuntime = false;\n\t\tvar i, l, dir, needRuntime;\n\t\tfor (i = 0, l = dirs.length; i < l; i++) {\n\t\t\tdir = dirs[i];\n\t\t\tneedRuntime = true;\n\t\t\tvar gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];\n\t\t\tif (gen) {\n\t\t\t\t// compile-time directive that manipulates AST.\n\t\t\t\t// returns true if it also needs a runtime counterpart.\n\t\t\t\tneedRuntime = !!gen(el, dir, warn$3);\n\t\t\t}\n\t\t\tif (needRuntime) {\n\t\t\t\thasRuntime = true;\n\t\t\t\tres += \"{name:\\\"\" + dir.name + \"\\\",rawName:\\\"\" + dir.rawName + \"\\\"\" + (dir.value ? \",value:(\" + dir.value + \"),expression:\" + JSON.stringify(dir.value) : '') + (dir.arg ? \",arg:\\\"\" + dir.arg + \"\\\"\" : '') + (dir.modifiers ? \",modifiers:\" + JSON.stringify(dir.modifiers) : '') + \"},\";\n\t\t\t}\n\t\t}\n\t\tif (hasRuntime) {\n\t\t\treturn res.slice(0, -1) + ']';\n\t\t}\n\t}\n\n\tfunction genInlineTemplate(el) {\n\t\tvar ast = el.children[0];\n\t\tif (\"development\" !== 'production' && (el.children.length > 1 || ast.type !== 1)) {\n\t\t\twarn$3('Inline-template components must have exactly one child element.');\n\t\t}\n\t\tif (ast.type === 1) {\n\t\t\tvar inlineRenderFns = generate(ast, currentOptions);\n\t\t\treturn \"inlineTemplate:{render:function(){\" + inlineRenderFns.render + \"},staticRenderFns:[\" + inlineRenderFns.staticRenderFns.map(function (code) {\n\t\t\t\treturn \"function(){\" + code + \"}\";\n\t\t\t}).join(',') + \"]}\";\n\t\t}\n\t}\n\n\tfunction genScopedSlots(slots) {\n\t\treturn \"scopedSlots:_u([\" + Object.keys(slots).map(function (key) {\n\t\t\treturn genScopedSlot(key, slots[key]);\n\t\t}).join(',') + \"])\";\n\t}\n\n\tfunction genScopedSlot(key, el) {\n\t\tif (el.for && !el.forProcessed) {\n\t\t\treturn genForScopedSlot(key, el);\n\t\t}\n\t\treturn \"{key:\" + key + \",fn:function(\" + String(el.attrsMap.scope) + \"){\" + \"return \" + (el.tag === 'template' ? genChildren(el) || 'void 0' : genElement(el)) + \"}}\";\n\t}\n\n\tfunction genForScopedSlot(key, el) {\n\t\tvar exp = el.for;\n\t\tvar alias = el.alias;\n\t\tvar iterator1 = el.iterator1 ? \",\" + el.iterator1 : '';\n\t\tvar iterator2 = el.iterator2 ? \",\" + el.iterator2 : '';\n\t\tel.forProcessed = true; // avoid recursion\n\t\treturn \"_l((\" + exp + \"),\" + \"function(\" + alias + iterator1 + iterator2 + \"){\" + \"return \" + genScopedSlot(key, el) + '})';\n\t}\n\n\tfunction genChildren(el, checkSkip) {\n\t\tvar children = el.children;\n\t\tif (children.length) {\n\t\t\tvar el$1 = children[0];\n\t\t\t// optimize single v-for\n\t\t\tif (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {\n\t\t\t\treturn genElement(el$1);\n\t\t\t}\n\t\t\tvar normalizationType = checkSkip ? getNormalizationType(children) : 0;\n\t\t\treturn \"[\" + children.map(genNode).join(',') + \"]\" + (normalizationType ? \",\" + normalizationType : '');\n\t\t}\n\t}\n\n\t// determine the normalization needed for the children array.\n\t// 0: no normalization needed\n\t// 1: simple normalization needed (possible 1-level deep nested array)\n\t// 2: full normalization needed\n\tfunction getNormalizationType(children) {\n\t\tvar res = 0;\n\t\tfor (var i = 0; i < children.length; i++) {\n\t\t\tvar el = children[i];\n\t\t\tif (el.type !== 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {\n\t\t\t\treturn needsNormalization(c.block);\n\t\t\t})) {\n\t\t\t\tres = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {\n\t\t\t\treturn maybeComponent(c.block);\n\t\t\t})) {\n\t\t\t\tres = 1;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tfunction needsNormalization(el) {\n\t\treturn el.for !== undefined || el.tag === 'template' || el.tag === 'slot';\n\t}\n\n\tfunction maybeComponent(el) {\n\t\treturn !isPlatformReservedTag$1(el.tag);\n\t}\n\n\tfunction genNode(node) {\n\t\tif (node.type === 1) {\n\t\t\treturn genElement(node);\n\t\t} else {\n\t\t\treturn genText(node);\n\t\t}\n\t}\n\n\tfunction genText(text) {\n\t\treturn \"_v(\" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()\n\t\t: transformSpecialNewlines(JSON.stringify(text.text))) + \")\";\n\t}\n\n\tfunction genSlot(el) {\n\t\tvar slotName = el.slotName || '\"default\"';\n\t\tvar children = genChildren(el);\n\t\tvar res = \"_t(\" + slotName + (children ? \",\" + children : '');\n\t\tvar attrs = el.attrs && \"{\" + el.attrs.map(function (a) {\n\t\t\treturn camelize(a.name) + \":\" + a.value;\n\t\t}).join(',') + \"}\";\n\t\tvar bind$$1 = el.attrsMap['v-bind'];\n\t\tif ((attrs || bind$$1) && !children) {\n\t\t\tres += \",null\";\n\t\t}\n\t\tif (attrs) {\n\t\t\tres += \",\" + attrs;\n\t\t}\n\t\tif (bind$$1) {\n\t\t\tres += (attrs ? '' : ',null') + \",\" + bind$$1;\n\t\t}\n\t\treturn res + ')';\n\t}\n\n\t// componentName is el.component, take it as argument to shun flow's pessimistic refinement\n\tfunction genComponent(componentName, el) {\n\t\tvar children = el.inlineTemplate ? null : genChildren(el, true);\n\t\treturn \"_c(\" + componentName + \",\" + genData(el) + (children ? \",\" + children : '') + \")\";\n\t}\n\n\tfunction genProps(props) {\n\t\tvar res = '';\n\t\tfor (var i = 0; i < props.length; i++) {\n\t\t\tvar prop = props[i];\n\t\t\tres += \"\\\"\" + prop.name + \"\\\":\" + transformSpecialNewlines(prop.value) + \",\";\n\t\t}\n\t\treturn res.slice(0, -1);\n\t}\n\n\t// #3895, #4268\n\tfunction transformSpecialNewlines(text) {\n\t\treturn text.replace(/\\u2028/g, '\\\\u2028').replace(/\\u2029/g, '\\\\u2029');\n\t}\n\n\t/*  */\n\n\t// these keywords should not appear inside expressions, but operators like\n\t// typeof, instanceof and in are allowed\n\tvar prohibitedKeywordRE = new RegExp('\\\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n\t// these unary operators should not be used as property/method names\n\tvar unaryOperatorsRE = new RegExp('\\\\b' + 'delete,typeof,void'.split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n\t// check valid identifier for v-for\n\tvar identRE = /[A-Za-z_$][\\w$]*/;\n\n\t// strip strings in expressions\n\tvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n\t// detect problematic expressions in a template\n\tfunction detectErrors(ast) {\n\t\tvar errors = [];\n\t\tif (ast) {\n\t\t\tcheckNode(ast, errors);\n\t\t}\n\t\treturn errors;\n\t}\n\n\tfunction checkNode(node, errors) {\n\t\tif (node.type === 1) {\n\t\t\tfor (var name in node.attrsMap) {\n\t\t\t\tif (dirRE.test(name)) {\n\t\t\t\t\tvar value = node.attrsMap[name];\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (name === 'v-for') {\n\t\t\t\t\t\t\tcheckFor(node, \"v-for=\\\"\" + value + \"\\\"\", errors);\n\t\t\t\t\t\t} else if (onRE.test(name)) {\n\t\t\t\t\t\t\tcheckEvent(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcheckExpression(value, name + \"=\\\"\" + value + \"\\\"\", errors);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.children) {\n\t\t\t\tfor (var i = 0; i < node.children.length; i++) {\n\t\t\t\t\tcheckNode(node.children[i], errors);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node.type === 2) {\n\t\t\tcheckExpression(node.expression, node.text, errors);\n\t\t}\n\t}\n\n\tfunction checkEvent(exp, text, errors) {\n\t\tvar stipped = exp.replace(stripStringRE, '');\n\t\tvar keywordMatch = stipped.match(unaryOperatorsRE);\n\t\tif (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n\t\t\terrors.push(\"avoid using JavaScript unary operator as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n\t\t}\n\t\tcheckExpression(exp, text, errors);\n\t}\n\n\tfunction checkFor(node, text, errors) {\n\t\tcheckExpression(node.for || '', text, errors);\n\t\tcheckIdentifier(node.alias, 'v-for alias', text, errors);\n\t\tcheckIdentifier(node.iterator1, 'v-for iterator', text, errors);\n\t\tcheckIdentifier(node.iterator2, 'v-for iterator', text, errors);\n\t}\n\n\tfunction checkIdentifier(ident, type, text, errors) {\n\t\tif (typeof ident === 'string' && !identRE.test(ident)) {\n\t\t\terrors.push(\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + text.trim());\n\t\t}\n\t}\n\n\tfunction checkExpression(exp, text, errors) {\n\t\ttry {\n\t\t\tnew Function(\"return \" + exp);\n\t\t} catch (e) {\n\t\t\tvar keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n\t\t\tif (keywordMatch) {\n\t\t\t\terrors.push(\"avoid using JavaScript keyword as property name: \" + \"\\\"\" + keywordMatch[0] + \"\\\" in expression \" + text.trim());\n\t\t\t} else {\n\t\t\t\terrors.push(\"invalid expression: \" + text.trim());\n\t\t\t}\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction baseCompile(template, options) {\n\t\tvar ast = parse(template.trim(), options);\n\t\toptimize(ast, options);\n\t\tvar code = generate(ast, options);\n\t\treturn {\n\t\t\tast: ast,\n\t\t\trender: code.render,\n\t\t\tstaticRenderFns: code.staticRenderFns\n\t\t};\n\t}\n\n\tfunction makeFunction(code, errors) {\n\t\ttry {\n\t\t\treturn new Function(code);\n\t\t} catch (err) {\n\t\t\terrors.push({ err: err, code: code });\n\t\t\treturn noop;\n\t\t}\n\t}\n\n\tfunction createCompiler(baseOptions) {\n\t\tvar functionCompileCache = Object.create(null);\n\n\t\tfunction compile(template, options) {\n\t\t\tvar finalOptions = Object.create(baseOptions);\n\t\t\tvar errors = [];\n\t\t\tvar tips = [];\n\t\t\tfinalOptions.warn = function (msg, tip$$1) {\n\t\t\t\t(tip$$1 ? tips : errors).push(msg);\n\t\t\t};\n\n\t\t\tif (options) {\n\t\t\t\t// merge custom modules\n\t\t\t\tif (options.modules) {\n\t\t\t\t\tfinalOptions.modules = (baseOptions.modules || []).concat(options.modules);\n\t\t\t\t}\n\t\t\t\t// merge custom directives\n\t\t\t\tif (options.directives) {\n\t\t\t\t\tfinalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);\n\t\t\t\t}\n\t\t\t\t// copy other options\n\t\t\t\tfor (var key in options) {\n\t\t\t\t\tif (key !== 'modules' && key !== 'directives') {\n\t\t\t\t\t\tfinalOptions[key] = options[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar compiled = baseCompile(template, finalOptions);\n\t\t\t{\n\t\t\t\terrors.push.apply(errors, detectErrors(compiled.ast));\n\t\t\t}\n\t\t\tcompiled.errors = errors;\n\t\t\tcompiled.tips = tips;\n\t\t\treturn compiled;\n\t\t}\n\n\t\tfunction compileToFunctions(template, options, vm) {\n\t\t\toptions = options || {};\n\n\t\t\t/* istanbul ignore if */\n\t\t\t{\n\t\t\t\t// detect possible CSP restriction\n\t\t\t\ttry {\n\t\t\t\t\tnew Function('return 1');\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e.toString().match(/unsafe-eval|CSP/)) {\n\t\t\t\t\t\twarn('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check cache\n\t\t\tvar key = options.delimiters ? String(options.delimiters) + template : template;\n\t\t\tif (functionCompileCache[key]) {\n\t\t\t\treturn functionCompileCache[key];\n\t\t\t}\n\n\t\t\t// compile\n\t\t\tvar compiled = compile(template, options);\n\n\t\t\t// check compilation errors/tips\n\t\t\t{\n\t\t\t\tif (compiled.errors && compiled.errors.length) {\n\t\t\t\t\twarn(\"Error compiling template:\\n\\n\" + template + \"\\n\\n\" + compiled.errors.map(function (e) {\n\t\t\t\t\t\treturn \"- \" + e;\n\t\t\t\t\t}).join('\\n') + '\\n', vm);\n\t\t\t\t}\n\t\t\t\tif (compiled.tips && compiled.tips.length) {\n\t\t\t\t\tcompiled.tips.forEach(function (msg) {\n\t\t\t\t\t\treturn tip(msg, vm);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// turn code into functions\n\t\t\tvar res = {};\n\t\t\tvar fnGenErrors = [];\n\t\t\tres.render = makeFunction(compiled.render, fnGenErrors);\n\t\t\tvar l = compiled.staticRenderFns.length;\n\t\t\tres.staticRenderFns = new Array(l);\n\t\t\tfor (var i = 0; i < l; i++) {\n\t\t\t\tres.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);\n\t\t\t}\n\n\t\t\t// check function generation errors.\n\t\t\t// this should only happen if there is a bug in the compiler itself.\n\t\t\t// mostly for codegen development use\n\t\t\t/* istanbul ignore if */\n\t\t\t{\n\t\t\t\tif ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n\t\t\t\t\twarn(\"Failed to generate render function:\\n\\n\" + fnGenErrors.map(function (ref) {\n\t\t\t\t\t\tvar err = ref.err;\n\t\t\t\t\t\tvar code = ref.code;\n\n\t\t\t\t\t\treturn err.toString() + \" in\\n\\n\" + code + \"\\n\";\n\t\t\t\t\t}).join('\\n'), vm);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn functionCompileCache[key] = res;\n\t\t}\n\n\t\treturn {\n\t\t\tcompile: compile,\n\t\t\tcompileToFunctions: compileToFunctions\n\t\t};\n\t}\n\n\t/*  */\n\n\tfunction transformNode(el, options) {\n\t\tvar warn = options.warn || baseWarn;\n\t\tvar staticClass = getAndRemoveAttr(el, 'class');\n\t\tif (\"development\" !== 'production' && staticClass) {\n\t\t\tvar expression = parseText(staticClass, options.delimiters);\n\t\t\tif (expression) {\n\t\t\t\twarn(\"class=\\\"\" + staticClass + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.');\n\t\t\t}\n\t\t}\n\t\tif (staticClass) {\n\t\t\tel.staticClass = JSON.stringify(staticClass);\n\t\t}\n\t\tvar classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n\t\tif (classBinding) {\n\t\t\tel.classBinding = classBinding;\n\t\t}\n\t}\n\n\tfunction genData$1(el) {\n\t\tvar data = '';\n\t\tif (el.staticClass) {\n\t\t\tdata += \"staticClass:\" + el.staticClass + \",\";\n\t\t}\n\t\tif (el.classBinding) {\n\t\t\tdata += \"class:\" + el.classBinding + \",\";\n\t\t}\n\t\treturn data;\n\t}\n\n\tvar klass$1 = {\n\t\tstaticKeys: ['staticClass'],\n\t\ttransformNode: transformNode,\n\t\tgenData: genData$1\n\t};\n\n\t/*  */\n\n\tfunction transformNode$1(el, options) {\n\t\tvar warn = options.warn || baseWarn;\n\t\tvar staticStyle = getAndRemoveAttr(el, 'style');\n\t\tif (staticStyle) {\n\t\t\t/* istanbul ignore if */\n\t\t\t{\n\t\t\t\tvar expression = parseText(staticStyle, options.delimiters);\n\t\t\t\tif (expression) {\n\t\t\t\t\twarn(\"style=\\\"\" + staticStyle + \"\\\": \" + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tel.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n\t\t}\n\n\t\tvar styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n\t\tif (styleBinding) {\n\t\t\tel.styleBinding = styleBinding;\n\t\t}\n\t}\n\n\tfunction genData$2(el) {\n\t\tvar data = '';\n\t\tif (el.staticStyle) {\n\t\t\tdata += \"staticStyle:\" + el.staticStyle + \",\";\n\t\t}\n\t\tif (el.styleBinding) {\n\t\t\tdata += \"style:(\" + el.styleBinding + \"),\";\n\t\t}\n\t\treturn data;\n\t}\n\n\tvar style$1 = {\n\t\tstaticKeys: ['staticStyle'],\n\t\ttransformNode: transformNode$1,\n\t\tgenData: genData$2\n\t};\n\n\tvar modules$1 = [klass$1, style$1];\n\n\t/*  */\n\n\tfunction text(el, dir) {\n\t\tif (dir.value) {\n\t\t\taddProp(el, 'textContent', \"_s(\" + dir.value + \")\");\n\t\t}\n\t}\n\n\t/*  */\n\n\tfunction html(el, dir) {\n\t\tif (dir.value) {\n\t\t\taddProp(el, 'innerHTML', \"_s(\" + dir.value + \")\");\n\t\t}\n\t}\n\n\tvar directives$1 = {\n\t\tmodel: model,\n\t\ttext: text,\n\t\thtml: html\n\t};\n\n\t/*  */\n\n\tvar baseOptions = {\n\t\texpectHTML: true,\n\t\tmodules: modules$1,\n\t\tdirectives: directives$1,\n\t\tisPreTag: isPreTag,\n\t\tisUnaryTag: isUnaryTag,\n\t\tmustUseProp: mustUseProp,\n\t\tcanBeLeftOpenTag: canBeLeftOpenTag,\n\t\tisReservedTag: isReservedTag,\n\t\tgetTagNamespace: getTagNamespace,\n\t\tstaticKeys: genStaticKeys(modules$1)\n\t};\n\n\tvar ref$1 = createCompiler(baseOptions);\n\tvar compileToFunctions = ref$1.compileToFunctions;\n\n\t/*  */\n\n\tvar idToTemplate = cached(function (id) {\n\t\tvar el = query(id);\n\t\treturn el && el.innerHTML;\n\t});\n\n\tvar mount = Vue$3.prototype.$mount;\n\tVue$3.prototype.$mount = function (el, hydrating) {\n\t\tel = el && query(el);\n\n\t\t/* istanbul ignore if */\n\t\tif (el === document.body || el === document.documentElement) {\n\t\t\t\"development\" !== 'production' && warn(\"Do not mount Vue to <html> or <body> - mount to normal elements instead.\");\n\t\t\treturn this;\n\t\t}\n\n\t\tvar options = this.$options;\n\t\t// resolve template/el and convert to render function\n\t\tif (!options.render) {\n\t\t\tvar template = options.template;\n\t\t\tif (template) {\n\t\t\t\tif (typeof template === 'string') {\n\t\t\t\t\tif (template.charAt(0) === '#') {\n\t\t\t\t\t\ttemplate = idToTemplate(template);\n\t\t\t\t\t\t/* istanbul ignore if */\n\t\t\t\t\t\tif (\"development\" !== 'production' && !template) {\n\t\t\t\t\t\t\twarn(\"Template element not found or is empty: \" + options.template, this);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (template.nodeType) {\n\t\t\t\t\ttemplate = template.innerHTML;\n\t\t\t\t} else {\n\t\t\t\t\t{\n\t\t\t\t\t\twarn('invalid template option:' + template, this);\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t} else if (el) {\n\t\t\t\ttemplate = getOuterHTML(el);\n\t\t\t}\n\t\t\tif (template) {\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (\"development\" !== 'production' && config.performance && mark) {\n\t\t\t\t\tmark('compile');\n\t\t\t\t}\n\n\t\t\t\tvar ref = compileToFunctions(template, {\n\t\t\t\t\tshouldDecodeNewlines: shouldDecodeNewlines,\n\t\t\t\t\tdelimiters: options.delimiters\n\t\t\t\t}, this);\n\t\t\t\tvar render = ref.render;\n\t\t\t\tvar staticRenderFns = ref.staticRenderFns;\n\t\t\t\toptions.render = render;\n\t\t\t\toptions.staticRenderFns = staticRenderFns;\n\n\t\t\t\t/* istanbul ignore if */\n\t\t\t\tif (\"development\" !== 'production' && config.performance && mark) {\n\t\t\t\t\tmark('compile end');\n\t\t\t\t\tmeasure(this._name + \" compile\", 'compile', 'compile end');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mount.call(this, el, hydrating);\n\t};\n\n\t/**\n  * Get outerHTML of elements, taking care\n  * of SVG elements in IE as well.\n  */\n\tfunction getOuterHTML(el) {\n\t\tif (el.outerHTML) {\n\t\t\treturn el.outerHTML;\n\t\t} else {\n\t\t\tvar container = document.createElement('div');\n\t\t\tcontainer.appendChild(el.cloneNode(true));\n\t\t\treturn container.innerHTML;\n\t\t}\n\t}\n\n\tVue$3.compile = compileToFunctions;\n\n\treturn Vue$3;\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ 41)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcHVibGljL3NjcmlwdHMvbGliL3Z1ZS5qcz8zMzUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjMuNFxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG5cdFx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0XHRcdChnbG9iYWwuVnVlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdC8qICAqL1xuXG4vLyB0aGVzZSBoZWxwZXJzIHByb2R1Y2VzIGJldHRlciB2bSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nXG5cdGZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcblx0XHRyZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRGVmICh2KSB7XG5cdFx0cmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG5cdH1cblxuXHRmdW5jdGlvbiBpc1RydWUgKHYpIHtcblx0XHRyZXR1cm4gdiA9PT0gdHJ1ZVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNGYWxzZSAodikge1xuXHRcdHJldHVybiB2ID09PSBmYWxzZVxuXHR9XG5cdC8qKlxuXHQgKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcblx0ICovXG5cdGZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcblx0fVxuXG5cdC8qKlxuXHQgKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcblx0ICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuXHQgKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG5cdCAqL1xuXHRmdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG5cdFx0cmV0dXJuIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0J1xuXHR9XG5cblx0dmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cblx0LyoqXG5cdCAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcblx0ICogZm9yIHBsYWluIEphdmFTY3JpcHQgb2JqZWN0cy5cblx0ICovXG5cdGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuXHRcdHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJ1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcblx0XHRyZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nXG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG5cdFx0cmV0dXJuIHZhbCA9PSBudWxsXG5cdFx0XHQ/ICcnXG5cdFx0XHQ6IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnXG5cdFx0XHQ/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcblx0XHRcdDogU3RyaW5nKHZhbClcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGEgaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuXHQgKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcblx0XHR2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcblx0XHRyZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG5cdH1cblxuXHQvKipcblx0ICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG5cdCAqIGlzIGluIHRoYXQgbWFwLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFrZU1hcCAoXG5cdFx0c3RyLFxuXHRcdGV4cGVjdHNMb3dlckNhc2Vcblx0KSB7XG5cdFx0dmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0dmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1hcFtsaXN0W2ldXSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG5cdFx0XHQ/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cblx0XHRcdDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cblx0ICovXG5cdHZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG5cdCAqL1xuXHRmdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuXHRcdGlmIChhcnIubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcblx0XHRcdGlmIChpbmRleCA+IC0xKSB7XG5cdFx0XHRcdHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIHRoZSBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eS5cblx0ICovXG5cdHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cdGZ1bmN0aW9uIGhhc093biAob2JqLCBrZXkpIHtcblx0XHRyZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBjYWNoZWQgKGZuKSB7XG5cdFx0dmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRyZXR1cm4gKGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcblx0XHRcdHZhciBoaXQgPSBjYWNoZVtzdHJdO1xuXHRcdFx0cmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG5cdFx0fSlcblx0fVxuXG5cdC8qKlxuXHQgKiBDYW1lbGl6ZSBhIGh5cGhlbi1kZWxpbWl0ZWQgc3RyaW5nLlxuXHQgKi9cblx0dmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5cdHZhciBjYW1lbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG5cdFx0cmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIGZ1bmN0aW9uIChfLCBjKSB7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogJyc7IH0pXG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBDYXBpdGFsaXplIGEgc3RyaW5nLlxuXHQgKi9cblx0dmFyIGNhcGl0YWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuXHRcdHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSlcblx0fSk7XG5cblx0LyoqXG5cdCAqIEh5cGhlbmF0ZSBhIGNhbWVsQ2FzZSBzdHJpbmcuXG5cdCAqL1xuXHR2YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xuXHR2YXIgaHlwaGVuYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcblx0XHRyZXR1cm4gc3RyXG5cdFx0XHQucmVwbGFjZShoeXBoZW5hdGVSRSwgJyQxLSQyJylcblx0XHRcdC5yZXBsYWNlKGh5cGhlbmF0ZVJFLCAnJDEtJDInKVxuXHRcdFx0LnRvTG93ZXJDYXNlKClcblx0fSk7XG5cblx0LyoqXG5cdCAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0ICovXG5cdGZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcblx0XHRmdW5jdGlvbiBib3VuZEZuIChhKSB7XG5cdFx0XHR2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gbFxuXHRcdFx0XHQ/IGwgPiAxXG5cdFx0XHRcdD8gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpXG5cdFx0XHRcdDogZm4uY2FsbChjdHgsIGEpXG5cdFx0XHRcdDogZm4uY2FsbChjdHgpXG5cdFx0fVxuXHRcdC8vIHJlY29yZCBvcmlnaW5hbCBmbiBsZW5ndGhcblx0XHRib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG5cdFx0cmV0dXJuIGJvdW5kRm5cblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG5cdFx0c3RhcnQgPSBzdGFydCB8fCAwO1xuXHRcdHZhciBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcblx0XHR2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdHJldFtpXSA9IGxpc3RbaSArIHN0YXJ0XTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldFxuXHR9XG5cblx0LyoqXG5cdCAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cblx0ICovXG5cdGZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG5cdFx0XHR0b1trZXldID0gX2Zyb21ba2V5XTtcblx0XHR9XG5cdFx0cmV0dXJuIHRvXG5cdH1cblxuXHQvKipcblx0ICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cblx0ICovXG5cdGZ1bmN0aW9uIHRvT2JqZWN0IChhcnIpIHtcblx0XHR2YXIgcmVzID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChhcnJbaV0pIHtcblx0XHRcdFx0ZXh0ZW5kKHJlcywgYXJyW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cblx0LyoqXG5cdCAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5cdC8qKlxuXHQgKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuXHQgKi9cblx0dmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cblx0LyoqXG5cdCAqIFJldHVybiBzYW1lIHZhbHVlXG5cdCAqL1xuXHR2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcblxuXHQvKipcblx0ICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyAobW9kdWxlcykge1xuXHRcdHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuXHRcdFx0cmV0dXJuIGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSlcblx0XHR9LCBbXSkuam9pbignLCcpXG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdHdvIHZhbHVlcyBhcmUgbG9vc2VseSBlcXVhbCAtIHRoYXQgaXMsXG5cdCAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cblx0ICovXG5cdGZ1bmN0aW9uIGxvb3NlRXF1YWwgKGEsIGIpIHtcblx0XHR2YXIgaXNPYmplY3RBID0gaXNPYmplY3QoYSk7XG5cdFx0dmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuXHRcdGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpXG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdC8vIHBvc3NpYmxlIGNpcmN1bGFyIHJlZmVyZW5jZVxuXHRcdFx0XHRyZXR1cm4gYSA9PT0gYlxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG5cdFx0XHRyZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuXHRcdH1cblx0XHRyZXR1cm4gLTFcblx0fVxuXG5cdC8qKlxuXHQgKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuXHQgKi9cblx0ZnVuY3Rpb24gb25jZSAoZm4pIHtcblx0XHR2YXIgY2FsbGVkID0gZmFsc2U7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICghY2FsbGVkKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxuXHR2YXIgQVNTRVRfVFlQRVMgPSBbXG5cdFx0J2NvbXBvbmVudCcsXG5cdFx0J2RpcmVjdGl2ZScsXG5cdFx0J2ZpbHRlcidcblx0XTtcblxuXHR2YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuXHRcdCdiZWZvcmVDcmVhdGUnLFxuXHRcdCdjcmVhdGVkJyxcblx0XHQnYmVmb3JlTW91bnQnLFxuXHRcdCdtb3VudGVkJyxcblx0XHQnYmVmb3JlVXBkYXRlJyxcblx0XHQndXBkYXRlZCcsXG5cdFx0J2JlZm9yZURlc3Ryb3knLFxuXHRcdCdkZXN0cm95ZWQnLFxuXHRcdCdhY3RpdmF0ZWQnLFxuXHRcdCdkZWFjdGl2YXRlZCdcblx0XTtcblxuXHQvKiAgKi9cblxuXHR2YXIgY29uZmlnID0gKHtcblx0XHQvKipcblx0XHQgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcblx0XHQgKi9cblx0XHRvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuXHRcdCAqL1xuXHRcdHNpbGVudDogZmFsc2UsXG5cblx0XHQvKipcblx0XHQgKiBTaG93IHByb2R1Y3Rpb24gbW9kZSB0aXAgbWVzc2FnZSBvbiBib290P1xuXHRcdCAqL1xuXHRcdHByb2R1Y3Rpb25UaXA6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG5cdFx0LyoqXG5cdFx0ICogV2hldGhlciB0byBlbmFibGUgZGV2dG9vbHNcblx0XHQgKi9cblx0XHRkZXZ0b29sczogXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicsXG5cblx0XHQvKipcblx0XHQgKiBXaGV0aGVyIHRvIHJlY29yZCBwZXJmXG5cdFx0ICovXG5cdFx0cGVyZm9ybWFuY2U6IGZhbHNlLFxuXG5cdFx0LyoqXG5cdFx0ICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcblx0XHQgKi9cblx0XHRlcnJvckhhbmRsZXI6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcblx0XHQgKi9cblx0XHRpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG5cdFx0LyoqXG5cdFx0ICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cblx0XHQgKi9cblx0XHRrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuXHRcdCAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cblx0XHQgKi9cblx0XHRpc1Jlc2VydmVkVGFnOiBubyxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG5cdFx0ICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cblx0XHQgKi9cblx0XHRpc1Jlc2VydmVkQXR0cjogbm8sXG5cblx0XHQvKipcblx0XHQgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG5cdFx0ICogUGxhdGZvcm0tZGVwZW5kZW50LlxuXHRcdCAqL1xuXHRcdGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG5cdFx0LyoqXG5cdFx0ICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuXHRcdCAqL1xuXHRcdGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuXHRcdC8qKlxuXHRcdCAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG5cdFx0ICovXG5cdFx0cGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcblx0XHQgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG5cdFx0ICovXG5cdFx0bXVzdFVzZVByb3A6IG5vLFxuXG5cdFx0LyoqXG5cdFx0ICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcblx0XHQgKi9cblx0XHRfbGlmZWN5Y2xlSG9va3M6IExJRkVDWUNMRV9IT09LU1xuXHR9KTtcblxuXHQvKiAgKi9cblxuXHR2YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG5cdCAqL1xuXHRmdW5jdGlvbiBpc1Jlc2VydmVkIChzdHIpIHtcblx0XHR2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcblx0XHRyZXR1cm4gYyA9PT0gMHgyNCB8fCBjID09PSAweDVGXG5cdH1cblxuXHQvKipcblx0ICogRGVmaW5lIGEgcHJvcGVydHkuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcblx0XHRcdHZhbHVlOiB2YWwsXG5cdFx0XHRlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG5cdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuXHQgKi9cblx0dmFyIGJhaWxSRSA9IC9bXlxcdy4kXS87XG5cdGZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuXHRcdGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAoIW9iaikgeyByZXR1cm4gfVxuXHRcdFx0XHRvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9ialxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciB3YXJuID0gbm9vcDtcblx0dmFyIHRpcCA9IG5vb3A7XG5cdHZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG51bGwpOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5cblx0e1xuXHRcdHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuXHRcdHZhciBjbGFzc2lmeVJFID0gLyg/Ol58Wy1fXSkoXFx3KS9nO1xuXHRcdHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuXHRcdFx0LnJlcGxhY2UoY2xhc3NpZnlSRSwgZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKTsgfSlcblx0XHRcdC5yZXBsYWNlKC9bLV9dL2csICcnKTsgfTtcblxuXHRcdHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuXHRcdFx0aWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKFwiW1Z1ZSB3YXJuXTogXCIgKyBtc2cgKyAoXG5cdFx0XHRcdFx0XHR2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcblx0XHRcdFx0XHQpKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcblx0XHRcdGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcblx0XHRcdFx0XHRcdHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJ1xuXHRcdFx0XHRcdCkpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmb3JtYXRDb21wb25lbnROYW1lID0gZnVuY3Rpb24gKHZtLCBpbmNsdWRlRmlsZSkge1xuXHRcdFx0aWYgKHZtLiRyb290ID09PSB2bSkge1xuXHRcdFx0XHRyZXR1cm4gJzxSb290Pidcblx0XHRcdH1cblx0XHRcdHZhciBuYW1lID0gdHlwZW9mIHZtID09PSAnc3RyaW5nJ1xuXHRcdFx0XHQ/IHZtXG5cdFx0XHRcdDogdHlwZW9mIHZtID09PSAnZnVuY3Rpb24nICYmIHZtLm9wdGlvbnNcblx0XHRcdFx0PyB2bS5vcHRpb25zLm5hbWVcblx0XHRcdFx0OiB2bS5faXNWdWVcblx0XHRcdFx0PyB2bS4kb3B0aW9ucy5uYW1lIHx8IHZtLiRvcHRpb25zLl9jb21wb25lbnRUYWdcblx0XHRcdFx0OiB2bS5uYW1lO1xuXG5cdFx0XHR2YXIgZmlsZSA9IHZtLl9pc1Z1ZSAmJiB2bS4kb3B0aW9ucy5fX2ZpbGU7XG5cdFx0XHRpZiAoIW5hbWUgJiYgZmlsZSkge1xuXHRcdFx0XHR2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcblx0XHRcdFx0bmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcblx0XHRcdFx0KGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcblx0XHRcdClcblx0XHR9O1xuXG5cdFx0dmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcblx0XHRcdHZhciByZXMgPSAnJztcblx0XHRcdHdoaWxlIChuKSB7XG5cdFx0XHRcdGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG5cdFx0XHRcdGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG5cdFx0XHRcdG4gPj49IDE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzXG5cdFx0fTtcblxuXHRcdHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG5cdFx0XHRpZiAodm0uX2lzVnVlICYmIHZtLiRwYXJlbnQpIHtcblx0XHRcdFx0dmFyIHRyZWUgPSBbXTtcblx0XHRcdFx0dmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG5cdFx0XHRcdHdoaWxlICh2bSkge1xuXHRcdFx0XHRcdGlmICh0cmVlLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRcdFx0aWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSsrO1xuXHRcdFx0XHRcdFx0XHR2bSA9IHZtLiRwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcblx0XHRcdFx0XHRcdFx0dHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRyZWUucHVzaCh2bSk7XG5cdFx0XHRcdFx0dm0gPSB2bS4kcGFyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAnXFxuXFxuZm91bmQgaW5cXG5cXG4nICsgdHJlZVxuXHRcdFx0XHRcdFx0Lm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcblx0XHRcdFx0XHRcdFx0PyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG5cdFx0XHRcdFx0XHRcdDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcblx0XHRcdFx0XHRcdC5qb2luKCdcXG4nKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gaGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcblx0XHRpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuXHRcdFx0Y29uZmlnLmVycm9ySGFuZGxlci5jYWxsKG51bGwsIGVyciwgdm0sIGluZm8pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR7XG5cdFx0XHRcdHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcblx0XHRcdH1cblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdFx0XHRpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRjb25zb2xlLmVycm9yKGVycik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBlcnJcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblx0LyogZ2xvYmFscyBNdXRhdGlvbk9ic2VydmVyICovXG5cbi8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xuXHR2YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xuXHR2YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5cdHZhciBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuXHR2YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xuXHR2YXIgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcblx0dmFyIGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xuXHR2YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcblx0dmFyIGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcblx0dmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cblx0dmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuXHRpZiAoaW5Ccm93c2VyKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBvcHRzID0ge307XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdFx0XHRzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdC1wYXNzaXZlJywgbnVsbCwgb3B0cyk7XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG5cdHZhciBfaXNTZXJ2ZXI7XG5cdHZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0aWYgKCFpbkJyb3dzZXIgJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0Ly8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG5cdFx0XHRcdC8vIFdlYnBhY2sgc2hpbW1pbmcgdGhlIHByb2Nlc3Ncblx0XHRcdFx0X2lzU2VydmVyID0gZ2xvYmFsWydwcm9jZXNzJ10uZW52LlZVRV9FTlYgPT09ICdzZXJ2ZXInO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X2lzU2VydmVyID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBfaXNTZXJ2ZXJcblx0fTtcblxuLy8gZGV0ZWN0IGRldnRvb2xzXG5cdHZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRmdW5jdGlvbiBpc05hdGl2ZSAoQ3Rvcikge1xuXHRcdHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxuXHR9XG5cblx0dmFyIGhhc1N5bWJvbCA9XG5cdFx0dHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuXHRcdHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShSZWZsZWN0Lm93bktleXMpO1xuXG5cdC8qKlxuXHQgKiBEZWZlciBhIHRhc2sgdG8gZXhlY3V0ZSBpdCBhc3luY2hyb25vdXNseS5cblx0ICovXG5cdHZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xuXHRcdHZhciBwZW5kaW5nID0gZmFsc2U7XG5cdFx0dmFyIHRpbWVyRnVuYztcblxuXHRcdGZ1bmN0aW9uIG5leHRUaWNrSGFuZGxlciAoKSB7XG5cdFx0XHRwZW5kaW5nID0gZmFsc2U7XG5cdFx0XHR2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuXHRcdFx0Y2FsbGJhY2tzLmxlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvcGllcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb3BpZXNbaV0oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuXHRcdC8vIHZpYSBlaXRoZXIgbmF0aXZlIFByb21pc2UudGhlbiBvciBNdXRhdGlvbk9ic2VydmVyLlxuXHRcdC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuXHRcdC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG5cdFx0Ly8gY29tcGxldGVseSBzdG9wcyB3b3JraW5nIGFmdGVyIHRyaWdnZXJpbmcgYSBmZXcgdGltZXMuLi4gc28sIGlmIG5hdGl2ZVxuXHRcdC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG5cdFx0XHR2YXIgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0dmFyIGxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikgeyBjb25zb2xlLmVycm9yKGVycik7IH07XG5cdFx0XHR0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHAudGhlbihuZXh0VGlja0hhbmRsZXIpLmNhdGNoKGxvZ0Vycm9yKTtcblx0XHRcdFx0Ly8gaW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG5cdFx0XHRcdC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuXHRcdFx0XHQvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuXHRcdFx0XHQvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cblx0XHRcdFx0Ly8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG5cdFx0XHRcdGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcblx0XHRcdFx0aXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcblx0XHRcdFx0XHQvLyBQaGFudG9tSlMgYW5kIGlPUyA3Lnhcblx0XHRcdFx0TXV0YXRpb25PYnNlcnZlci50b1N0cmluZygpID09PSAnW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdJ1xuXHRcdFx0KSkge1xuXHRcdFx0Ly8gdXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcblx0XHRcdC8vIGUuZy4gUGhhbnRvbUpTIElFMTEsIGlPUzcsIEFuZHJvaWQgNC40XG5cdFx0XHR2YXIgY291bnRlciA9IDE7XG5cdFx0XHR2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihuZXh0VGlja0hhbmRsZXIpO1xuXHRcdFx0dmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcblx0XHRcdG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcblx0XHRcdFx0Y2hhcmFjdGVyRGF0YTogdHJ1ZVxuXHRcdFx0fSk7XG5cdFx0XHR0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcblx0XHRcdFx0dGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGZhbGxiYWNrIHRvIHNldFRpbWVvdXRcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0XHR0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNldFRpbWVvdXQobmV4dFRpY2tIYW5kbGVyLCAwKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHF1ZXVlTmV4dFRpY2sgKGNiLCBjdHgpIHtcblx0XHRcdHZhciBfcmVzb2x2ZTtcblx0XHRcdGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKGNiKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGNiLmNhbGwoY3R4KTtcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuXHRcdFx0XHRcdF9yZXNvbHZlKGN0eCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0aWYgKCFwZW5kaW5nKSB7XG5cdFx0XHRcdHBlbmRpbmcgPSB0cnVlO1xuXHRcdFx0XHR0aW1lckZ1bmMoKTtcblx0XHRcdH1cblx0XHRcdGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdFx0X3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH1cblx0fSkoKTtcblxuXHR2YXIgX1NldDtcblx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdGlmICh0eXBlb2YgU2V0ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShTZXQpKSB7XG5cdFx0Ly8gdXNlIG5hdGl2ZSBTZXQgd2hlbiBhdmFpbGFibGUuXG5cdFx0X1NldCA9IFNldDtcblx0fSBlbHNlIHtcblx0XHQvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG5cdFx0X1NldCA9IChmdW5jdGlvbiAoKSB7XG5cdFx0XHRmdW5jdGlvbiBTZXQgKCkge1xuXHRcdFx0XHR0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHR9XG5cdFx0XHRTZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIGhhcyAoa2V5KSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlXG5cdFx0XHR9O1xuXHRcdFx0U2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuXHRcdFx0XHR0aGlzLnNldFtrZXldID0gdHJ1ZTtcblx0XHRcdH07XG5cdFx0XHRTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuXHRcdFx0XHR0aGlzLnNldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRyZXR1cm4gU2V0O1xuXHRcdH0oKSk7XG5cdH1cblxuXHQvKiAgKi9cblxuXG5cdHZhciB1aWQgPSAwO1xuXG5cdC8qKlxuXHQgKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcblx0ICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cblx0ICovXG5cdHZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuXHRcdHRoaXMuaWQgPSB1aWQrKztcblx0XHR0aGlzLnN1YnMgPSBbXTtcblx0fTtcblxuXHREZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG5cdFx0dGhpcy5zdWJzLnB1c2goc3ViKTtcblx0fTtcblxuXHREZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG5cdFx0cmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcblx0fTtcblxuXHREZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG5cdFx0aWYgKERlcC50YXJnZXQpIHtcblx0XHRcdERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuXHRcdH1cblx0fTtcblxuXHREZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG5cdFx0Ly8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3Rcblx0XHR2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHN1YnNbaV0udXBkYXRlKCk7XG5cdFx0fVxuXHR9O1xuXG4vLyB0aGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyB0aGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG9ubHkgb25lXG4vLyB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZCBhdCBhbnkgdGltZS5cblx0RGVwLnRhcmdldCA9IG51bGw7XG5cdHZhciB0YXJnZXRTdGFjayA9IFtdO1xuXG5cdGZ1bmN0aW9uIHB1c2hUYXJnZXQgKF90YXJnZXQpIHtcblx0XHRpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG5cdFx0RGVwLnRhcmdldCA9IF90YXJnZXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuXHRcdERlcC50YXJnZXQgPSB0YXJnZXRTdGFjay5wb3AoKTtcblx0fVxuXG5cdC8qXG5cdCAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuXHQgKiBkeW5hbWljYWxseSBhY2Nlc3NpbmcgbWV0aG9kcyBvbiBBcnJheSBwcm90b3R5cGVcblx0ICovXG5cblx0dmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cdHZhciBhcnJheU1ldGhvZHMgPSBPYmplY3QuY3JlYXRlKGFycmF5UHJvdG8pO1tcblx0XHQncHVzaCcsXG5cdFx0J3BvcCcsXG5cdFx0J3NoaWZ0Jyxcblx0XHQndW5zaGlmdCcsXG5cdFx0J3NwbGljZScsXG5cdFx0J3NvcnQnLFxuXHRcdCdyZXZlcnNlJ1xuXHRdXG5cdFx0LmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXHRcdFx0Ly8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG5cdFx0XHR2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG5cdFx0XHRkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuXHRcdFx0XHR2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0Ly8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG5cdFx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb3N1cmUtd2l0aC1hcmd1bWVudHNcblx0XHRcdFx0dmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdFx0XHR2YXIgYXJncyA9IG5ldyBBcnJheShpKTtcblx0XHRcdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0XHRcdGFyZ3NbaV0gPSBhcmd1bWVudHMkMVtpXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG5cdFx0XHRcdHZhciBvYiA9IHRoaXMuX19vYl9fO1xuXHRcdFx0XHR2YXIgaW5zZXJ0ZWQ7XG5cdFx0XHRcdHN3aXRjaCAobWV0aG9kKSB7XG5cdFx0XHRcdFx0Y2FzZSAncHVzaCc6XG5cdFx0XHRcdFx0XHRpbnNlcnRlZCA9IGFyZ3M7XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdGNhc2UgJ3Vuc2hpZnQnOlxuXHRcdFx0XHRcdFx0aW5zZXJ0ZWQgPSBhcmdzO1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRjYXNlICdzcGxpY2UnOlxuXHRcdFx0XHRcdFx0aW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuXHRcdFx0XHQvLyBub3RpZnkgY2hhbmdlXG5cdFx0XHRcdG9iLmRlcC5ub3RpZnkoKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0LyogICovXG5cblx0dmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cblx0LyoqXG5cdCAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcblx0ICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuXHQgKiB3ZSBkb24ndCB3YW50IHRvIGZvcmNlIGNvbnZlcnNpb24gYmVjYXVzZSB0aGUgdmFsdWUgbWF5IGJlIGEgbmVzdGVkIHZhbHVlXG5cdCAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuXHQgKi9cblx0dmFyIG9ic2VydmVyU3RhdGUgPSB7XG5cdFx0c2hvdWxkQ29udmVydDogdHJ1ZSxcblx0XHRpc1NldHRpbmdQcm9wczogZmFsc2Vcblx0fTtcblxuXHQvKipcblx0ICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuXHQgKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcblx0ICogb2JqZWN0J3MgcHJvcGVydHkga2V5cyBpbnRvIGdldHRlci9zZXR0ZXJzIHRoYXRcblx0ICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cblx0ICovXG5cdHZhciBPYnNlcnZlciA9IGZ1bmN0aW9uIE9ic2VydmVyICh2YWx1ZSkge1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHR0aGlzLmRlcCA9IG5ldyBEZXAoKTtcblx0XHR0aGlzLnZtQ291bnQgPSAwO1xuXHRcdGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0dmFyIGF1Z21lbnQgPSBoYXNQcm90b1xuXHRcdFx0XHQ/IHByb3RvQXVnbWVudFxuXHRcdFx0XHQ6IGNvcHlBdWdtZW50O1xuXHRcdFx0YXVnbWVudCh2YWx1ZSwgYXJyYXlNZXRob2RzLCBhcnJheUtleXMpO1xuXHRcdFx0dGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLndhbGsodmFsdWUpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG5cdCAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuXHQgKiB2YWx1ZSB0eXBlIGlzIE9iamVjdC5cblx0ICovXG5cdE9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZGVmaW5lUmVhY3RpdmUkJDEob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG5cdCAqL1xuXHRPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRvYnNlcnZlKGl0ZW1zW2ldKTtcblx0XHR9XG5cdH07XG5cbi8vIGhlbHBlcnNcblxuXHQvKipcblx0ICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuXHQgKiB0aGUgcHJvdG90eXBlIGNoYWluIHVzaW5nIF9fcHJvdG9fX1xuXHQgKi9cblx0ZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYykge1xuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cdFx0dGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcblx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG5cdH1cblxuXHQvKipcblx0ICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG5cdCAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0ZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG5cdCAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG5cdCAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuXHQgKi9cblx0ZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcblx0XHRpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHZhciBvYjtcblx0XHRpZiAoaGFzT3duKHZhbHVlLCAnX19vYl9fJykgJiYgdmFsdWUuX19vYl9fIGluc3RhbmNlb2YgT2JzZXJ2ZXIpIHtcblx0XHRcdG9iID0gdmFsdWUuX19vYl9fO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgJiZcblx0XHRcdCFpc1NlcnZlclJlbmRlcmluZygpICYmXG5cdFx0XHQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG5cdFx0XHRPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuXHRcdFx0IXZhbHVlLl9pc1Z1ZVxuXHRcdCkge1xuXHRcdFx0b2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuXHRcdH1cblx0XHRpZiAoYXNSb290RGF0YSAmJiBvYikge1xuXHRcdFx0b2Iudm1Db3VudCsrO1xuXHRcdH1cblx0XHRyZXR1cm4gb2Jcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG5cdFx0b2JqLFxuXHRcdGtleSxcblx0XHR2YWwsXG5cdFx0Y3VzdG9tU2V0dGVyXG5cdCkge1xuXHRcdHZhciBkZXAgPSBuZXcgRGVwKCk7XG5cblx0XHR2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcblx0XHRpZiAocHJvcGVydHkgJiYgcHJvcGVydHkuY29uZmlndXJhYmxlID09PSBmYWxzZSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0Ly8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG5cdFx0dmFyIGdldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LmdldDtcblx0XHR2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG5cdFx0dmFyIGNoaWxkT2IgPSBvYnNlcnZlKHZhbCk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG5cdFx0XHRcdGlmIChEZXAudGFyZ2V0KSB7XG5cdFx0XHRcdFx0ZGVwLmRlcGVuZCgpO1xuXHRcdFx0XHRcdGlmIChjaGlsZE9iKSB7XG5cdFx0XHRcdFx0XHRjaGlsZE9iLmRlcC5kZXBlbmQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRkZXBlbmRBcnJheSh2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0fSxcblx0XHRcdHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuXHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblx0XHRcdFx0aWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXHRcdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG5cdFx0XHRcdFx0Y3VzdG9tU2V0dGVyKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHNldHRlcikge1xuXHRcdFx0XHRcdHNldHRlci5jYWxsKG9iaiwgbmV3VmFsKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWwgPSBuZXdWYWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGRPYiA9IG9ic2VydmUobmV3VmFsKTtcblx0XHRcdFx0ZGVwLm5vdGlmeSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBhIHByb3BlcnR5IG9uIGFuIG9iamVjdC4gQWRkcyB0aGUgbmV3IHByb3BlcnR5IGFuZFxuXHQgKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG5cdCAqIGFscmVhZHkgZXhpc3QuXG5cdCAqL1xuXHRmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh0YXJnZXQpICYmIHR5cGVvZiBrZXkgPT09ICdudW1iZXInKSB7XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcblx0XHRcdHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuXHRcdFx0cmV0dXJuIHZhbFxuXHRcdH1cblx0XHRpZiAoaGFzT3duKHRhcmdldCwga2V5KSkge1xuXHRcdFx0dGFyZ2V0W2tleV0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gdmFsXG5cdFx0fVxuXHRcdHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG5cdFx0aWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG5cdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHQnQXZvaWQgYWRkaW5nIHJlYWN0aXZlIHByb3BlcnRpZXMgdG8gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG5cdFx0XHRcdCdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHZhbFxuXHRcdH1cblx0XHRpZiAoIW9iKSB7XG5cdFx0XHR0YXJnZXRba2V5XSA9IHZhbDtcblx0XHRcdHJldHVybiB2YWxcblx0XHR9XG5cdFx0ZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcblx0XHRvYi5kZXAubm90aWZ5KCk7XG5cdFx0cmV0dXJuIHZhbFxuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWwgKHRhcmdldCwga2V5KSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiB0eXBlb2Yga2V5ID09PSAnbnVtYmVyJykge1xuXHRcdFx0dGFyZ2V0LnNwbGljZShrZXksIDEpO1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHZhciBvYiA9ICh0YXJnZXQgKS5fX29iX187XG5cdFx0aWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG5cdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHQnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcblx0XHRcdFx0Jy0ganVzdCBzZXQgaXQgdG8gbnVsbC4nXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGRlbGV0ZSB0YXJnZXRba2V5XTtcblx0XHRpZiAoIW9iKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0b2IuZGVwLm5vdGlmeSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG5cdCAqIHdlIGNhbm5vdCBpbnRlcmNlcHQgYXJyYXkgZWxlbWVudCBhY2Nlc3MgbGlrZSBwcm9wZXJ0eSBnZXR0ZXJzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG5cdFx0Zm9yICh2YXIgZSA9ICh2b2lkIDApLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0ZSA9IHZhbHVlW2ldO1xuXHRcdFx0ZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuXHRcdFx0XHRkZXBlbmRBcnJheShlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuXHQgKiBob3cgdG8gbWVyZ2UgYSBwYXJlbnQgb3B0aW9uIHZhbHVlIGFuZCBhIGNoaWxkIG9wdGlvblxuXHQgKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cblx0ICovXG5cdHZhciBzdHJhdHMgPSBjb25maWcub3B0aW9uTWVyZ2VTdHJhdGVnaWVzO1xuXG5cdC8qKlxuXHQgKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG5cdCAqL1xuXHR7XG5cdFx0c3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG5cdFx0XHRpZiAoIXZtKSB7XG5cdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XCJvcHRpb24gXFxcIlwiICsga2V5ICsgXCJcXFwiIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGluc3RhbmNlIFwiICtcblx0XHRcdFx0XHQnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cblx0ICovXG5cdGZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcblx0XHRpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cblx0XHR2YXIga2V5LCB0b1ZhbCwgZnJvbVZhbDtcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdHRvVmFsID0gdG9ba2V5XTtcblx0XHRcdGZyb21WYWwgPSBmcm9tW2tleV07XG5cdFx0XHRpZiAoIWhhc093bih0bywga2V5KSkge1xuXHRcdFx0XHRzZXQodG8sIGtleSwgZnJvbVZhbCk7XG5cdFx0XHR9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcblx0XHRcdFx0bWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRvXG5cdH1cblxuXHQvKipcblx0ICogRGF0YVxuXHQgKi9cblx0c3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG5cdFx0cGFyZW50VmFsLFxuXHRcdGNoaWxkVmFsLFxuXHRcdHZtXG5cdCkge1xuXHRcdGlmICghdm0pIHtcblx0XHRcdC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG5cdFx0XHRpZiAoIWNoaWxkVmFsKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnRWYWxcblx0XHRcdH1cblx0XHRcdGlmICh0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybihcblx0XHRcdFx0XHQnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcblx0XHRcdFx0XHQndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcblx0XHRcdFx0XHQnZGVmaW5pdGlvbnMuJyxcblx0XHRcdFx0XHR2bVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50VmFsXG5cdFx0XHR9XG5cdFx0XHRpZiAoIXBhcmVudFZhbCkge1xuXHRcdFx0XHRyZXR1cm4gY2hpbGRWYWxcblx0XHRcdH1cblx0XHRcdC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcblx0XHRcdC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuXHRcdFx0Ly8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG5cdFx0XHQvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2Vcblx0XHRcdC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG5cdFx0XHRcdHJldHVybiBtZXJnZURhdGEoXG5cdFx0XHRcdFx0Y2hpbGRWYWwuY2FsbCh0aGlzKSxcblx0XHRcdFx0XHRwYXJlbnRWYWwuY2FsbCh0aGlzKVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG5cdFx0XHRcdC8vIGluc3RhbmNlIG1lcmdlXG5cdFx0XHRcdHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHQ/IGNoaWxkVmFsLmNhbGwodm0pXG5cdFx0XHRcdFx0OiBjaGlsZFZhbDtcblx0XHRcdFx0dmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdD8gcGFyZW50VmFsLmNhbGwodm0pXG5cdFx0XHRcdFx0OiB1bmRlZmluZWQ7XG5cdFx0XHRcdGlmIChpbnN0YW5jZURhdGEpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRlZmF1bHREYXRhXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cblx0ICovXG5cdGZ1bmN0aW9uIG1lcmdlSG9vayAoXG5cdFx0cGFyZW50VmFsLFxuXHRcdGNoaWxkVmFsXG5cdCkge1xuXHRcdHJldHVybiBjaGlsZFZhbFxuXHRcdFx0PyBwYXJlbnRWYWxcblx0XHRcdD8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcblx0XHRcdDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcblx0XHRcdD8gY2hpbGRWYWxcblx0XHRcdDogW2NoaWxkVmFsXVxuXHRcdFx0OiBwYXJlbnRWYWxcblx0fVxuXG5cdExJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG5cdFx0c3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xuXHR9KTtcblxuXHQvKipcblx0ICogQXNzZXRzXG5cdCAqXG5cdCAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cblx0ICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuXHQgKiBvcHRpb25zIGFuZCBwYXJlbnQgb3B0aW9ucy5cblx0ICovXG5cdGZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG5cdFx0dmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuXHRcdHJldHVybiBjaGlsZFZhbFxuXHRcdFx0PyBleHRlbmQocmVzLCBjaGlsZFZhbClcblx0XHRcdDogcmVzXG5cdH1cblxuXHRBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0c3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG5cdH0pO1xuXG5cdC8qKlxuXHQgKiBXYXRjaGVycy5cblx0ICpcblx0ICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuXHQgKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cblx0ICovXG5cdHN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuXHRcdGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG5cdFx0dmFyIHJldCA9IHt9O1xuXHRcdGV4dGVuZChyZXQsIHBhcmVudFZhbCk7XG5cdFx0Zm9yICh2YXIga2V5IGluIGNoaWxkVmFsKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gcmV0W2tleV07XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXldO1xuXHRcdFx0aWYgKHBhcmVudCAmJiAhQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG5cdFx0XHRcdHBhcmVudCA9IFtwYXJlbnRdO1xuXHRcdFx0fVxuXHRcdFx0cmV0W2tleV0gPSBwYXJlbnRcblx0XHRcdFx0PyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuXHRcdFx0XHQ6IFtjaGlsZF07XG5cdFx0fVxuXHRcdHJldHVybiByZXRcblx0fTtcblxuXHQvKipcblx0ICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cblx0ICovXG5cdHN0cmF0cy5wcm9wcyA9XG5cdFx0c3RyYXRzLm1ldGhvZHMgPVxuXHRcdFx0c3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcblx0XHRcdFx0aWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCkgfVxuXHRcdFx0XHRpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuXHRcdFx0XHR2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0ZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcblx0XHRcdFx0ZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuXHRcdFx0XHRyZXR1cm4gcmV0XG5cdFx0XHR9O1xuXG5cdC8qKlxuXHQgKiBEZWZhdWx0IHN0cmF0ZWd5LlxuXHQgKi9cblx0dmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG5cdFx0cmV0dXJuIGNoaWxkVmFsID09PSB1bmRlZmluZWRcblx0XHRcdD8gcGFyZW50VmFsXG5cdFx0XHQ6IGNoaWxkVmFsXG5cdH07XG5cblx0LyoqXG5cdCAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuXHQgKi9cblx0ZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuXHRcdFx0dmFyIGxvd2VyID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcblx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHQnRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCAnICtcblx0XHRcdFx0XHQnaWQ6ICcgKyBrZXlcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG5cdCAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG5cdCAqL1xuXHRmdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucykge1xuXHRcdHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG5cdFx0aWYgKCFwcm9wcykgeyByZXR1cm4gfVxuXHRcdHZhciByZXMgPSB7fTtcblx0XHR2YXIgaSwgdmFsLCBuYW1lO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuXHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0dmFsID0gcHJvcHNbaV07XG5cdFx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuXHRcdFx0XHRcdHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuXHRcdFx0XHR2YWwgPSBwcm9wc1trZXldO1xuXHRcdFx0XHRuYW1lID0gY2FtZWxpemUoa2V5KTtcblx0XHRcdFx0cmVzW25hbWVdID0gaXNQbGFpbk9iamVjdCh2YWwpXG5cdFx0XHRcdFx0PyB2YWxcblx0XHRcdFx0XHQ6IHsgdHlwZTogdmFsIH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdG9wdGlvbnMucHJvcHMgPSByZXM7XG5cdH1cblxuXHQvKipcblx0ICogTm9ybWFsaXplIHJhdyBmdW5jdGlvbiBkaXJlY3RpdmVzIGludG8gb2JqZWN0IGZvcm1hdC5cblx0ICovXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcblx0XHR2YXIgZGlycyA9IG9wdGlvbnMuZGlyZWN0aXZlcztcblx0XHRpZiAoZGlycykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGRpcnMpIHtcblx0XHRcdFx0dmFyIGRlZiA9IGRpcnNba2V5XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBkZWYgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG5cdCAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuXHRcdHBhcmVudCxcblx0XHRjaGlsZCxcblx0XHR2bVxuXHQpIHtcblx0XHR7XG5cdFx0XHRjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNoaWxkID0gY2hpbGQub3B0aW9ucztcblx0XHR9XG5cblx0XHRub3JtYWxpemVQcm9wcyhjaGlsZCk7XG5cdFx0bm9ybWFsaXplRGlyZWN0aXZlcyhjaGlsZCk7XG5cdFx0dmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcblx0XHRpZiAoZXh0ZW5kc0Zyb20pIHtcblx0XHRcdHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG5cdFx0fVxuXHRcdGlmIChjaGlsZC5taXhpbnMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIG9wdGlvbnMgPSB7fTtcblx0XHR2YXIga2V5O1xuXHRcdGZvciAoa2V5IGluIHBhcmVudCkge1xuXHRcdFx0bWVyZ2VGaWVsZChrZXkpO1xuXHRcdH1cblx0XHRmb3IgKGtleSBpbiBjaGlsZCkge1xuXHRcdFx0aWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG5cdFx0XHRcdG1lcmdlRmllbGQoa2V5KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gbWVyZ2VGaWVsZCAoa2V5KSB7XG5cdFx0XHR2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG5cdFx0XHRvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG5cdFx0fVxuXHRcdHJldHVybiBvcHRpb25zXG5cdH1cblxuXHQvKipcblx0ICogUmVzb2x2ZSBhbiBhc3NldC5cblx0ICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG5cdCAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cblx0ICovXG5cdGZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG5cdFx0b3B0aW9ucyxcblx0XHR0eXBlLFxuXHRcdGlkLFxuXHRcdHdhcm5NaXNzaW5nXG5cdCkge1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dmFyIGFzc2V0cyA9IG9wdGlvbnNbdHlwZV07XG5cdFx0Ly8gY2hlY2sgbG9jYWwgcmVnaXN0cmF0aW9uIHZhcmlhdGlvbnMgZmlyc3Rcblx0XHRpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cblx0XHR2YXIgY2FtZWxpemVkSWQgPSBjYW1lbGl6ZShpZCk7XG5cdFx0aWYgKGhhc093bihhc3NldHMsIGNhbWVsaXplZElkKSkgeyByZXR1cm4gYXNzZXRzW2NhbWVsaXplZElkXSB9XG5cdFx0dmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuXHRcdGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKSB7IHJldHVybiBhc3NldHNbUGFzY2FsQ2FzZUlkXSB9XG5cdFx0Ly8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG5cdFx0dmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcblx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuXHRcdFx0d2Fybihcblx0XHRcdFx0J0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcblx0XHRcdFx0b3B0aW9uc1xuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcblx0XHRrZXksXG5cdFx0cHJvcE9wdGlvbnMsXG5cdFx0cHJvcHNEYXRhLFxuXHRcdHZtXG5cdCkge1xuXHRcdHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcblx0XHR2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG5cdFx0dmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG5cdFx0Ly8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcblx0XHRpZiAoaXNUeXBlKEJvb2xlYW4sIHByb3AudHlwZSkpIHtcblx0XHRcdGlmIChhYnNlbnQgJiYgIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG5cdFx0XHRcdHZhbHVlID0gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCFpc1R5cGUoU3RyaW5nLCBwcm9wLnR5cGUpICYmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IGh5cGhlbmF0ZShrZXkpKSkge1xuXHRcdFx0XHR2YWx1ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGNoZWNrIGRlZmF1bHQgdmFsdWVcblx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dmFsdWUgPSBnZXRQcm9wRGVmYXVsdFZhbHVlKHZtLCBwcm9wLCBrZXkpO1xuXHRcdFx0Ly8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuXHRcdFx0Ly8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG5cdFx0XHR2YXIgcHJldlNob3VsZENvbnZlcnQgPSBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQ7XG5cdFx0XHRvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuXHRcdFx0b2JzZXJ2ZSh2YWx1ZSk7XG5cdFx0XHRvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBwcmV2U2hvdWxkQ29udmVydDtcblx0XHR9XG5cdFx0e1xuXHRcdFx0YXNzZXJ0UHJvcChwcm9wLCBrZXksIHZhbHVlLCB2bSwgYWJzZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlXG5cdH1cblxuXHQvKipcblx0ICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cblx0ICovXG5cdGZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcblx0XHQvLyBubyBkZWZhdWx0LCByZXR1cm4gdW5kZWZpbmVkXG5cdFx0aWYgKCFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZFxuXHRcdH1cblx0XHR2YXIgZGVmID0gcHJvcC5kZWZhdWx0O1xuXHRcdC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcblx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuXHRcdFx0d2Fybihcblx0XHRcdFx0J0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgKyBrZXkgKyAnXCI6ICcgK1xuXHRcdFx0XHQnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG5cdFx0XHRcdCd0byByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUuJyxcblx0XHRcdFx0dm1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdC8vIHRoZSByYXcgcHJvcCB2YWx1ZSB3YXMgYWxzbyB1bmRlZmluZWQgZnJvbSBwcmV2aW91cyByZW5kZXIsXG5cdFx0Ly8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG5cdFx0aWYgKHZtICYmIHZtLiRvcHRpb25zLnByb3BzRGF0YSAmJlxuXHRcdFx0dm0uJG9wdGlvbnMucHJvcHNEYXRhW2tleV0gPT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0dm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIHZtLl9wcm9wc1trZXldXG5cdFx0fVxuXHRcdC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG5cdFx0Ly8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuXHRcdHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuXHRcdFx0PyBkZWYuY2FsbCh2bSlcblx0XHRcdDogZGVmXG5cdH1cblxuXHQvKipcblx0ICogQXNzZXJ0IHdoZXRoZXIgYSBwcm9wIGlzIHZhbGlkLlxuXHQgKi9cblx0ZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG5cdFx0cHJvcCxcblx0XHRuYW1lLFxuXHRcdHZhbHVlLFxuXHRcdHZtLFxuXHRcdGFic2VudFxuXHQpIHtcblx0XHRpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcblx0XHRcdHdhcm4oXG5cdFx0XHRcdCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuXHRcdFx0XHR2bVxuXHRcdFx0KTtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHZhciB0eXBlID0gcHJvcC50eXBlO1xuXHRcdHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG5cdFx0dmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcblx0XHRpZiAodHlwZSkge1xuXHRcdFx0aWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG5cdFx0XHRcdHR5cGUgPSBbdHlwZV07XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG5cdFx0XHRcdHZhciBhc3NlcnRlZFR5cGUgPSBhc3NlcnRUeXBlKHZhbHVlLCB0eXBlW2ldKTtcblx0XHRcdFx0ZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuXHRcdFx0XHR2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCF2YWxpZCkge1xuXHRcdFx0d2Fybihcblx0XHRcdFx0J0ludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nICtcblx0XHRcdFx0JyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG5cdFx0XHRcdCcsIGdvdCAnICsgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkgKyAnLicsXG5cdFx0XHRcdHZtXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcblx0XHRpZiAodmFsaWRhdG9yKSB7XG5cdFx0XHRpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcblx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHQnSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsXG5cdFx0XHRcdFx0dm1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgc2ltcGxlQ2hlY2tSRSA9IC9eKFN0cmluZ3xOdW1iZXJ8Qm9vbGVhbnxGdW5jdGlvbnxTeW1ib2wpJC87XG5cblx0ZnVuY3Rpb24gYXNzZXJ0VHlwZSAodmFsdWUsIHR5cGUpIHtcblx0XHR2YXIgdmFsaWQ7XG5cdFx0dmFyIGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG5cdFx0aWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG5cdFx0XHR2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG5cdFx0fSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdPYmplY3QnKSB7XG5cdFx0XHR2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG5cdFx0XHR2YWxpZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWxpZCA9IHZhbHVlIGluc3RhbmNlb2YgdHlwZTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZhbGlkOiB2YWxpZCxcblx0XHRcdGV4cGVjdGVkVHlwZTogZXhwZWN0ZWRUeXBlXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcblx0ICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG5cdCAqIGFjcm9zcyBkaWZmZXJlbnQgdm1zIC8gaWZyYW1lcy5cblx0ICovXG5cdGZ1bmN0aW9uIGdldFR5cGUgKGZuKSB7XG5cdFx0dmFyIG1hdGNoID0gZm4gJiYgZm4udG9TdHJpbmcoKS5tYXRjaCgvXlxccypmdW5jdGlvbiAoXFx3KykvKTtcblx0XHRyZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG5cdH1cblxuXHRmdW5jdGlvbiBpc1R5cGUgKHR5cGUsIGZuKSB7XG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuXHRcdFx0cmV0dXJuIGdldFR5cGUoZm4pID09PSBnZXRUeXBlKHR5cGUpXG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGdldFR5cGUoZm5baV0pID09PSBnZXRUeXBlKHR5cGUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgbWFyaztcblx0dmFyIG1lYXN1cmU7XG5cblx0e1xuXHRcdHZhciBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoXG5cdFx0XHRwZXJmICYmXG5cdFx0XHRwZXJmLm1hcmsgJiZcblx0XHRcdHBlcmYubWVhc3VyZSAmJlxuXHRcdFx0cGVyZi5jbGVhck1hcmtzICYmXG5cdFx0XHRwZXJmLmNsZWFyTWVhc3VyZXNcblx0XHQpIHtcblx0XHRcdG1hcmsgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiBwZXJmLm1hcmsodGFnKTsgfTtcblx0XHRcdG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuXHRcdFx0XHRwZXJmLm1lYXN1cmUobmFtZSwgc3RhcnRUYWcsIGVuZFRhZyk7XG5cdFx0XHRcdHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG5cdFx0XHRcdHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuXHRcdFx0XHRwZXJmLmNsZWFyTWVhc3VyZXMobmFtZSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdC8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xuXG5cdHZhciBpbml0UHJveHk7XG5cblx0e1xuXHRcdHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG5cdFx0XHQnSW5maW5pdHksdW5kZWZpbmVkLE5hTixpc0Zpbml0ZSxpc05hTiwnICtcblx0XHRcdCdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcblx0XHRcdCdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG5cdFx0XHQncmVxdWlyZScgLy8gZm9yIFdlYnBhY2svQnJvd3NlcmlmeVxuXHRcdCk7XG5cblx0XHR2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcblx0XHRcdHdhcm4oXG5cdFx0XHRcdFwiUHJvcGVydHkgb3IgbWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBub3QgZGVmaW5lZCBvbiB0aGUgaW5zdGFuY2UgYnV0IFwiICtcblx0XHRcdFx0XCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuXHRcdFx0XHRcInByb3BlcnRpZXMgaW4gdGhlIGRhdGEgb3B0aW9uLlwiLFxuXHRcdFx0XHR0YXJnZXRcblx0XHRcdCk7XG5cdFx0fTtcblxuXHRcdHZhciBoYXNQcm94eSA9XG5cdFx0XHR0eXBlb2YgUHJveHkgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG5cdFx0aWYgKGhhc1Byb3h5KSB7XG5cdFx0XHR2YXIgaXNCdWlsdEluTW9kaWZpZXIgPSBtYWtlTWFwKCdzdG9wLHByZXZlbnQsc2VsZixjdHJsLHNoaWZ0LGFsdCxtZXRhJyk7XG5cdFx0XHRjb25maWcua2V5Q29kZXMgPSBuZXcgUHJveHkoY29uZmlnLmtleUNvZGVzLCB7XG5cdFx0XHRcdHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoaXNCdWlsdEluTW9kaWZpZXIoa2V5KSkge1xuXHRcdFx0XHRcdFx0d2FybigoXCJBdm9pZCBvdmVyd3JpdGluZyBidWlsdC1pbiBtb2RpZmllciBpbiBjb25maWcua2V5Q29kZXM6IC5cIiArIGtleSkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhcmdldFtrZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dmFyIGhhc0hhbmRsZXIgPSB7XG5cdFx0XHRoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcblx0XHRcdFx0dmFyIGhhcyA9IGtleSBpbiB0YXJnZXQ7XG5cdFx0XHRcdHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcblx0XHRcdFx0aWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuXHRcdFx0XHRcdHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dmFyIGdldEhhbmRsZXIgPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcblx0XHRcdFx0XHR3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRhcmdldFtrZXldXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSAodm0pIHtcblx0XHRcdGlmIChoYXNQcm94eSkge1xuXHRcdFx0XHQvLyBkZXRlcm1pbmUgd2hpY2ggcHJveHkgaGFuZGxlciB0byB1c2Vcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblx0XHRcdFx0dmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuXHRcdFx0XHRcdD8gZ2V0SGFuZGxlclxuXHRcdFx0XHRcdDogaGFzSGFuZGxlcjtcblx0XHRcdFx0dm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2bS5fcmVuZGVyUHJveHkgPSB2bTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0LyogICovXG5cblx0dmFyIFZOb2RlID0gZnVuY3Rpb24gVk5vZGUgKFxuXHRcdHRhZyxcblx0XHRkYXRhLFxuXHRcdGNoaWxkcmVuLFxuXHRcdHRleHQsXG5cdFx0ZWxtLFxuXHRcdGNvbnRleHQsXG5cdFx0Y29tcG9uZW50T3B0aW9uc1xuXHQpIHtcblx0XHR0aGlzLnRhZyA9IHRhZztcblx0XHR0aGlzLmRhdGEgPSBkYXRhO1xuXHRcdHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xuXHRcdHRoaXMuZWxtID0gZWxtO1xuXHRcdHRoaXMubnMgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcblx0XHR0aGlzLmZ1bmN0aW9uYWxDb250ZXh0ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcblx0XHR0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuXHRcdHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5yYXcgPSBmYWxzZTtcblx0XHR0aGlzLmlzU3RhdGljID0gZmFsc2U7XG5cdFx0dGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuXHRcdHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG5cdFx0dGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuXHRcdHRoaXMuaXNPbmNlID0gZmFsc2U7XG5cdH07XG5cblx0dmFyIHByb3RvdHlwZUFjY2Vzc29ycyA9IHsgY2hpbGQ6IHt9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0cHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxuXHR9O1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG5cdHZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG5cdFx0bm9kZS50ZXh0ID0gJyc7XG5cdFx0bm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuXHRcdHJldHVybiBub2RlXG5cdH07XG5cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcblx0XHRyZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKVxuXHR9XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5cdGZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlKSB7XG5cdFx0dmFyIGNsb25lZCA9IG5ldyBWTm9kZShcblx0XHRcdHZub2RlLnRhZyxcblx0XHRcdHZub2RlLmRhdGEsXG5cdFx0XHR2bm9kZS5jaGlsZHJlbixcblx0XHRcdHZub2RlLnRleHQsXG5cdFx0XHR2bm9kZS5lbG0sXG5cdFx0XHR2bm9kZS5jb250ZXh0LFxuXHRcdFx0dm5vZGUuY29tcG9uZW50T3B0aW9uc1xuXHRcdCk7XG5cdFx0Y2xvbmVkLm5zID0gdm5vZGUubnM7XG5cdFx0Y2xvbmVkLmlzU3RhdGljID0gdm5vZGUuaXNTdGF0aWM7XG5cdFx0Y2xvbmVkLmtleSA9IHZub2RlLmtleTtcblx0XHRjbG9uZWQuaXNDb21tZW50ID0gdm5vZGUuaXNDb21tZW50O1xuXHRcdGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG5cdFx0cmV0dXJuIGNsb25lZFxuXHR9XG5cblx0ZnVuY3Rpb24gY2xvbmVWTm9kZXMgKHZub2Rlcykge1xuXHRcdHZhciBsZW4gPSB2bm9kZXMubGVuZ3RoO1xuXHRcdHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRyZXNbaV0gPSBjbG9uZVZOb2RlKHZub2Rlc1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBub3JtYWxpemVFdmVudCA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuXHRcdHZhciBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcblx0XHRuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuXHRcdHZhciBvbmNlJCQxID0gbmFtZS5jaGFyQXQoMCkgPT09ICd+JzsgLy8gUHJlZml4ZWQgbGFzdCwgY2hlY2tlZCBmaXJzdFxuXHRcdG5hbWUgPSBvbmNlJCQxID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG5cdFx0dmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuXHRcdG5hbWUgPSBjYXB0dXJlID8gbmFtZS5zbGljZSgxKSA6IG5hbWU7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRvbmNlOiBvbmNlJCQxLFxuXHRcdFx0Y2FwdHVyZTogY2FwdHVyZSxcblx0XHRcdHBhc3NpdmU6IHBhc3NpdmVcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG5cdFx0ZnVuY3Rpb24gaW52b2tlciAoKSB7XG5cdFx0XHR2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cblx0XHRcdHZhciBmbnMgPSBpbnZva2VyLmZucztcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGZucykpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRmbnNbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuXHRcdFx0XHRyZXR1cm4gZm5zLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcblx0XHRcdH1cblx0XHR9XG5cdFx0aW52b2tlci5mbnMgPSBmbnM7XG5cdFx0cmV0dXJuIGludm9rZXJcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG5cdFx0b24sXG5cdFx0b2xkT24sXG5cdFx0YWRkLFxuXHRcdHJlbW92ZSQkMSxcblx0XHR2bVxuXHQpIHtcblx0XHR2YXIgbmFtZSwgY3VyLCBvbGQsIGV2ZW50O1xuXHRcdGZvciAobmFtZSBpbiBvbikge1xuXHRcdFx0Y3VyID0gb25bbmFtZV07XG5cdFx0XHRvbGQgPSBvbGRPbltuYW1lXTtcblx0XHRcdGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG5cdFx0XHRpZiAoaXNVbmRlZihjdXIpKSB7XG5cdFx0XHRcdFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG5cdFx0XHRcdFx0XCJJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFxcXCJcIiArIChldmVudC5uYW1lKSArIFwiXFxcIjogZ290IFwiICsgU3RyaW5nKGN1ciksXG5cdFx0XHRcdFx0dm1cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG5cdFx0XHRcdGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG5cdFx0XHRcdFx0Y3VyID0gb25bbmFtZV0gPSBjcmVhdGVGbkludm9rZXIoY3VyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlKTtcblx0XHRcdH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcblx0XHRcdFx0b2xkLmZucyA9IGN1cjtcblx0XHRcdFx0b25bbmFtZV0gPSBvbGQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAobmFtZSBpbiBvbGRPbikge1xuXHRcdFx0aWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG5cdFx0XHRcdGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG5cdFx0XHRcdHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuXHRcdHZhciBpbnZva2VyO1xuXHRcdHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG5cdFx0ZnVuY3Rpb24gd3JhcHBlZEhvb2sgKCkge1xuXHRcdFx0aG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0Ly8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuXHRcdFx0Ly8gYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtcblx0XHRcdHJlbW92ZShpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuXHRcdH1cblxuXHRcdGlmIChpc1VuZGVmKG9sZEhvb2spKSB7XG5cdFx0XHQvLyBubyBleGlzdGluZyBob29rXG5cdFx0XHRpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuXHRcdFx0XHQvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcblx0XHRcdFx0aW52b2tlciA9IG9sZEhvb2s7XG5cdFx0XHRcdGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZXhpc3RpbmcgcGxhaW4gaG9va1xuXHRcdFx0XHRpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcblx0XHRkZWZbaG9va0tleV0gPSBpbnZva2VyO1xuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YSAoXG5cdFx0ZGF0YSxcblx0XHRDdG9yLFxuXHRcdHRhZ1xuXHQpIHtcblx0XHQvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cblx0XHQvLyB2YWxpZGF0aW9uIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgaGFuZGxlZCBpbiB0aGUgY2hpbGRcblx0XHQvLyBjb21wb25lbnQgaXRzZWxmLlxuXHRcdHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcblx0XHRpZiAoaXNVbmRlZihwcm9wT3B0aW9ucykpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHR2YXIgcmVzID0ge307XG5cdFx0dmFyIGF0dHJzID0gZGF0YS5hdHRycztcblx0XHR2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuXHRcdGlmIChpc0RlZihhdHRycykgfHwgaXNEZWYocHJvcHMpKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcblx0XHRcdFx0dmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0a2V5ICE9PSBrZXlJbkxvd2VyQ2FzZSAmJlxuXHRcdFx0XHRcdFx0YXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdHRpcChcblx0XHRcdFx0XHRcdFx0XCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuXHRcdFx0XHRcdFx0XHQoZm9ybWF0Q29tcG9uZW50TmFtZSh0YWcgfHwgQ3RvcikpICsgXCIsIGJ1dCB0aGUgZGVjbGFyZWQgcHJvcCBuYW1lIGlzXCIgK1xuXHRcdFx0XHRcdFx0XHRcIiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuIFwiICtcblx0XHRcdFx0XHRcdFx0XCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcblx0XHRcdFx0XHRcdFx0XCJwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIFwiICtcblx0XHRcdFx0XHRcdFx0XCJ0ZW1wbGF0ZXMuIFlvdSBzaG91bGQgcHJvYmFibHkgdXNlIFxcXCJcIiArIGFsdEtleSArIFwiXFxcIiBpbnN0ZWFkIG9mIFxcXCJcIiArIGtleSArIFwiXFxcIi5cIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuXHRcdFx0XHRjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXksIGZhbHNlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tQcm9wIChcblx0XHRyZXMsXG5cdFx0aGFzaCxcblx0XHRrZXksXG5cdFx0YWx0S2V5LFxuXHRcdHByZXNlcnZlXG5cdCkge1xuXHRcdGlmIChpc0RlZihoYXNoKSkge1xuXHRcdFx0aWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG5cdFx0XHRcdHJlc1trZXldID0gaGFzaFtrZXldO1xuXHRcdFx0XHRpZiAoIXByZXNlcnZlKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGhhc2hba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fSBlbHNlIGlmIChoYXNPd24oaGFzaCwgYWx0S2V5KSkge1xuXHRcdFx0XHRyZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcblx0XHRcdFx0aWYgKCFwcmVzZXJ2ZSkge1xuXHRcdFx0XHRcdGRlbGV0ZSBoYXNoW2FsdEtleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblxuXHQvKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5cdGZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuXHRcdFx0XHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjaGlsZHJlblxuXHR9XG5cbi8vIDIuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbnN0cnVjdHMgdGhhdCBhbHdheXMgZ2VuZXJhdGVkIG5lc3RlZCBBcnJheXMsXG4vLyBlLmcuIDx0ZW1wbGF0ZT4sIDxzbG90Piwgdi1mb3IsIG9yIHdoZW4gdGhlIGNoaWxkcmVuIGlzIHByb3ZpZGVkIGJ5IHVzZXJcbi8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbi8vIGlzIG5lZWRlZCB0byBjYXRlciB0byBhbGwgcG9zc2libGUgdHlwZXMgb2YgY2hpbGRyZW4gdmFsdWVzLlxuXHRmdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcblx0XHRyZXR1cm4gaXNQcmltaXRpdmUoY2hpbGRyZW4pXG5cdFx0XHQ/IFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuXHRcdFx0OiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuXHRcdFx0PyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuXHRcdFx0OiB1bmRlZmluZWRcblx0fVxuXG5cdGZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcblx0XHRyZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxuXHR9XG5cblx0ZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG5cdFx0dmFyIHJlcyA9IFtdO1xuXHRcdHZhciBpLCBjLCBsYXN0O1xuXHRcdGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0YyA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG5cdFx0XHRsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcblx0XHRcdC8vICBuZXN0ZWRcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG5cdFx0XHRcdHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpKTtcblx0XHRcdH0gZWxzZSBpZiAoaXNQcmltaXRpdmUoYykpIHtcblx0XHRcdFx0aWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcblx0XHRcdFx0XHQvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG5cdFx0XHRcdFx0Ly8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuXHRcdFx0XHRcdC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuXHRcdFx0XHRcdChsYXN0KS50ZXh0ICs9IFN0cmluZyhjKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjICE9PSAnJykge1xuXHRcdFx0XHRcdC8vIGNvbnZlcnQgcHJpbWl0aXZlIHRvIHZub2RlXG5cdFx0XHRcdFx0cmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuXHRcdFx0XHRcdC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcblx0XHRcdFx0XHRyZXNbcmVzLmxlbmd0aCAtIDFdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gZGVmYXVsdCBrZXkgZm9yIG5lc3RlZCBhcnJheSBjaGlsZHJlbiAobGlrZWx5IGdlbmVyYXRlZCBieSB2LWZvcilcblx0XHRcdFx0XHRpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuXHRcdFx0XHRcdFx0aXNEZWYoYy50YWcpICYmXG5cdFx0XHRcdFx0XHRpc1VuZGVmKGMua2V5KSAmJlxuXHRcdFx0XHRcdFx0aXNEZWYobmVzdGVkSW5kZXgpKSB7XG5cdFx0XHRcdFx0XHRjLmtleSA9IFwiX192bGlzdFwiICsgbmVzdGVkSW5kZXggKyBcIl9cIiArIGkgKyBcIl9fXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlcy5wdXNoKGMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXNcblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGVuc3VyZUN0b3IgKGNvbXAsIGJhc2UpIHtcblx0XHRyZXR1cm4gaXNPYmplY3QoY29tcClcblx0XHRcdD8gYmFzZS5leHRlbmQoY29tcClcblx0XHRcdDogY29tcFxuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcblx0XHRmYWN0b3J5LFxuXHRcdGJhc2VDdG9yLFxuXHRcdGNvbnRleHRcblx0KSB7XG5cdFx0aWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcblx0XHRcdHJldHVybiBmYWN0b3J5LmVycm9yQ29tcFxuXHRcdH1cblxuXHRcdGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkucmVzb2x2ZWRcblx0XHR9XG5cblx0XHRpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcblx0XHRcdHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wXG5cdFx0fVxuXG5cdFx0aWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG5cdFx0XHQvLyBhbHJlYWR5IHBlbmRpbmdcblx0XHRcdGZhY3RvcnkuY29udGV4dHMucHVzaChjb250ZXh0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNvbnRleHRzID0gZmFjdG9yeS5jb250ZXh0cyA9IFtjb250ZXh0XTtcblx0XHRcdHZhciBzeW5jID0gdHJ1ZTtcblxuXHRcdFx0dmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbnRleHRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGNvbnRleHRzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuXHRcdFx0XHQvLyBjYWNoZSByZXNvbHZlZFxuXHRcdFx0XHRmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcblx0XHRcdFx0Ly8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuXHRcdFx0XHQvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcblx0XHRcdFx0aWYgKCFzeW5jKSB7XG5cdFx0XHRcdFx0Zm9yY2VSZW5kZXIoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHZhciByZWplY3QgPSBvbmNlKGZ1bmN0aW9uIChyZWFzb24pIHtcblx0XHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybihcblx0XHRcdFx0XHRcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG5cdFx0XHRcdFx0KHJlYXNvbiA/IChcIlxcblJlYXNvbjogXCIgKyByZWFzb24pIDogJycpXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcblx0XHRcdFx0XHRmYWN0b3J5LmVycm9yID0gdHJ1ZTtcblx0XHRcdFx0XHRmb3JjZVJlbmRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0dmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuXHRcdFx0aWYgKGlzT2JqZWN0KHJlcykpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdC8vICgpID0+IFByb21pc2Vcblx0XHRcdFx0XHRpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuXHRcdFx0XHRcdFx0cmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG5cdFx0XHRcdFx0aWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcblx0XHRcdFx0XHRcdGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG5cdFx0XHRcdFx0XHRmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuXHRcdFx0XHRcdFx0aWYgKHJlcy5kZWxheSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGZvcmNlUmVuZGVyKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LCByZXMuZGVsYXkgfHwgMjAwKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcblx0XHRcdFx0XHRcdFx0XHRyZWplY3QoXG5cdFx0XHRcdFx0XHRcdFx0XHRcInRpbWVvdXQgKFwiICsgKHJlcy50aW1lb3V0KSArIFwibXMpXCJcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCByZXMudGltZW91dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHN5bmMgPSBmYWxzZTtcblx0XHRcdC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcblx0XHRcdHJldHVybiBmYWN0b3J5LmxvYWRpbmdcblx0XHRcdFx0PyBmYWN0b3J5LmxvYWRpbmdDb21wXG5cdFx0XHRcdDogZmFjdG9yeS5yZXNvbHZlZFxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGdldEZpcnN0Q29tcG9uZW50Q2hpbGQgKGNoaWxkcmVuKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChpc0RlZihjKSAmJiBpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGluaXRFdmVudHMgKHZtKSB7XG5cdFx0dm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0dm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuXHRcdC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuXHRcdHZhciBsaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuXHRcdGlmIChsaXN0ZW5lcnMpIHtcblx0XHRcdHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgdGFyZ2V0O1xuXG5cdGZ1bmN0aW9uIGFkZCAoZXZlbnQsIGZuLCBvbmNlJCQxKSB7XG5cdFx0aWYgKG9uY2UkJDEpIHtcblx0XHRcdHRhcmdldC4kb25jZShldmVudCwgZm4pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuXHRcdHRhcmdldC4kb2ZmKGV2ZW50LCBmbik7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuXHRcdHZtLFxuXHRcdGxpc3RlbmVycyxcblx0XHRvbGRMaXN0ZW5lcnNcblx0KSB7XG5cdFx0dGFyZ2V0ID0gdm07XG5cdFx0dXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG5cdH1cblxuXHRmdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG5cdFx0dmFyIGhvb2tSRSA9IC9eaG9vazovO1xuXHRcdFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuXHRcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHRcdHZhciB2bSA9IHRoaXM7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR0aGlzJDEuJG9uKGV2ZW50W2ldLCBmbik7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCh2bS5fZXZlbnRzW2V2ZW50XSB8fCAodm0uX2V2ZW50c1tldmVudF0gPSBbXSkpLnB1c2goZm4pO1xuXHRcdFx0XHQvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuXHRcdFx0XHQvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcblx0XHRcdFx0aWYgKGhvb2tSRS50ZXN0KGV2ZW50KSkge1xuXHRcdFx0XHRcdHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdm1cblx0XHR9O1xuXG5cdFx0VnVlLnByb3RvdHlwZS4kb25jZSA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcblx0XHRcdHZhciB2bSA9IHRoaXM7XG5cdFx0XHRmdW5jdGlvbiBvbiAoKSB7XG5cdFx0XHRcdHZtLiRvZmYoZXZlbnQsIG9uKTtcblx0XHRcdFx0Zm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRvbi5mbiA9IGZuO1xuXHRcdFx0dm0uJG9uKGV2ZW50LCBvbik7XG5cdFx0XHRyZXR1cm4gdm1cblx0XHR9O1xuXG5cdFx0VnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuXHRcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHRcdHZhciB2bSA9IHRoaXM7XG5cdFx0XHQvLyBhbGxcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0cmV0dXJuIHZtXG5cdFx0XHR9XG5cdFx0XHQvLyBhcnJheSBvZiBldmVudHNcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuXHRcdFx0XHRmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuXHRcdFx0XHRcdHRoaXMkMS4kb2ZmKGV2ZW50W2kkMV0sIGZuKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm1cblx0XHRcdH1cblx0XHRcdC8vIHNwZWNpZmljIGV2ZW50XG5cdFx0XHR2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG5cdFx0XHRpZiAoIWNicykge1xuXHRcdFx0XHRyZXR1cm4gdm1cblx0XHRcdH1cblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIHZtXG5cdFx0XHR9XG5cdFx0XHQvLyBzcGVjaWZpYyBoYW5kbGVyXG5cdFx0XHR2YXIgY2I7XG5cdFx0XHR2YXIgaSA9IGNicy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdGNiID0gY2JzW2ldO1xuXHRcdFx0XHRpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuXHRcdFx0XHRcdGNicy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZtXG5cdFx0fTtcblxuXHRcdFZ1ZS5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdHZhciB2bSA9IHRoaXM7XG5cdFx0XHR7XG5cdFx0XHRcdHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcblx0XHRcdFx0XHR0aXAoXG5cdFx0XHRcdFx0XHRcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcblx0XHRcdFx0XHRcdChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIiBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuIFwiICtcblx0XHRcdFx0XHRcdFwiTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgXCIgK1xuXHRcdFx0XHRcdFx0XCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuXHRcdFx0XHRcdFx0XCJZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcXFwiXCIgKyAoaHlwaGVuYXRlKGV2ZW50KSkgKyBcIlxcXCIgaW5zdGVhZCBvZiBcXFwiXCIgKyBldmVudCArIFwiXFxcIi5cIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcblx0XHRcdGlmIChjYnMpIHtcblx0XHRcdFx0Y2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG5cdFx0XHRcdHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdm1cblx0XHR9O1xuXHR9XG5cblx0LyogICovXG5cblx0LyoqXG5cdCAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgcmF3IGNoaWxkcmVuIFZOb2RlcyBpbnRvIGEgc2xvdCBvYmplY3QuXG5cdCAqL1xuXHRmdW5jdGlvbiByZXNvbHZlU2xvdHMgKFxuXHRcdGNoaWxkcmVuLFxuXHRcdGNvbnRleHRcblx0KSB7XG5cdFx0dmFyIHNsb3RzID0ge307XG5cdFx0aWYgKCFjaGlsZHJlbikge1xuXHRcdFx0cmV0dXJuIHNsb3RzXG5cdFx0fVxuXHRcdHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdC8vIG5hbWVkIHNsb3RzIHNob3VsZCBvbmx5IGJlIHJlc3BlY3RlZCBpZiB0aGUgdm5vZGUgd2FzIHJlbmRlcmVkIGluIHRoZVxuXHRcdFx0Ly8gc2FtZSBjb250ZXh0LlxuXHRcdFx0aWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuXHRcdFx0XHRjaGlsZC5kYXRhICYmIGNoaWxkLmRhdGEuc2xvdCAhPSBudWxsXG5cdFx0XHQpIHtcblx0XHRcdFx0dmFyIG5hbWUgPSBjaGlsZC5kYXRhLnNsb3Q7XG5cdFx0XHRcdHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG5cdFx0XHRcdGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcblx0XHRcdFx0XHRzbG90LnB1c2guYXBwbHkoc2xvdCwgY2hpbGQuY2hpbGRyZW4pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNsb3QucHVzaChjaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBpZ25vcmUgd2hpdGVzcGFjZVxuXHRcdGlmICghZGVmYXVsdFNsb3QuZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuXHRcdFx0c2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuXHRcdH1cblx0XHRyZXR1cm4gc2xvdHNcblx0fVxuXG5cdGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuXHRcdHJldHVybiBub2RlLmlzQ29tbWVudCB8fCBub2RlLnRleHQgPT09ICcgJ1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcblx0XHRmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG5cdFx0cmVzXG5cdCkge1xuXHRcdHJlcyA9IHJlcyB8fCB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuXHRcdFx0XHRyZXNvbHZlU2NvcGVkU2xvdHMoZm5zW2ldLCByZXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzXG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xuXG5cdGZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcblxuXHRcdC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG5cdFx0dmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuXHRcdGlmIChwYXJlbnQgJiYgIW9wdGlvbnMuYWJzdHJhY3QpIHtcblx0XHRcdHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcblx0XHRcdFx0cGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHRwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuXHRcdH1cblxuXHRcdHZtLiRwYXJlbnQgPSBwYXJlbnQ7XG5cdFx0dm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuXHRcdHZtLiRjaGlsZHJlbiA9IFtdO1xuXHRcdHZtLiRyZWZzID0ge307XG5cblx0XHR2bS5fd2F0Y2hlciA9IG51bGw7XG5cdFx0dm0uX2luYWN0aXZlID0gbnVsbDtcblx0XHR2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcblx0XHR2bS5faXNNb3VudGVkID0gZmFsc2U7XG5cdFx0dm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG5cdFx0dm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcblx0XHRWdWUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAodm5vZGUsIGh5ZHJhdGluZykge1xuXHRcdFx0dmFyIHZtID0gdGhpcztcblx0XHRcdGlmICh2bS5faXNNb3VudGVkKSB7XG5cdFx0XHRcdGNhbGxIb29rKHZtLCAnYmVmb3JlVXBkYXRlJyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcHJldkVsID0gdm0uJGVsO1xuXHRcdFx0dmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcblx0XHRcdHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcblx0XHRcdGFjdGl2ZUluc3RhbmNlID0gdm07XG5cdFx0XHR2bS5fdm5vZGUgPSB2bm9kZTtcblx0XHRcdC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuXHRcdFx0Ly8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG5cdFx0XHRpZiAoIXByZXZWbm9kZSkge1xuXHRcdFx0XHQvLyBpbml0aWFsIHJlbmRlclxuXHRcdFx0XHR2bS4kZWwgPSB2bS5fX3BhdGNoX18oXG5cdFx0XHRcdFx0dm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovLFxuXHRcdFx0XHRcdHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG5cdFx0XHRcdFx0dm0uJG9wdGlvbnMuX3JlZkVsbVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gdXBkYXRlc1xuXHRcdFx0XHR2bS4kZWwgPSB2bS5fX3BhdGNoX18ocHJldlZub2RlLCB2bm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcblx0XHRcdC8vIHVwZGF0ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuXHRcdFx0aWYgKHByZXZFbCkge1xuXHRcdFx0XHRwcmV2RWwuX192dWVfXyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAodm0uJGVsKSB7XG5cdFx0XHRcdHZtLiRlbC5fX3Z1ZV9fID0gdm07XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG5cdFx0XHRpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuXHRcdFx0XHR2bS4kcGFyZW50LiRlbCA9IHZtLiRlbDtcblx0XHRcdH1cblx0XHRcdC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcblx0XHRcdC8vIHVwZGF0ZWQgaW4gYSBwYXJlbnQncyB1cGRhdGVkIGhvb2suXG5cdFx0fTtcblxuXHRcdFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIHZtID0gdGhpcztcblx0XHRcdGlmICh2bS5fd2F0Y2hlcikge1xuXHRcdFx0XHR2bS5fd2F0Y2hlci51cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0VnVlLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciB2bSA9IHRoaXM7XG5cdFx0XHRpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcblx0XHRcdHZtLl9pc0JlaW5nRGVzdHJveWVkID0gdHJ1ZTtcblx0XHRcdC8vIHJlbW92ZSBzZWxmIGZyb20gcGFyZW50XG5cdFx0XHR2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcblx0XHRcdGlmIChwYXJlbnQgJiYgIXBhcmVudC5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdm0uJG9wdGlvbnMuYWJzdHJhY3QpIHtcblx0XHRcdFx0cmVtb3ZlKHBhcmVudC4kY2hpbGRyZW4sIHZtKTtcblx0XHRcdH1cblx0XHRcdC8vIHRlYXJkb3duIHdhdGNoZXJzXG5cdFx0XHRpZiAodm0uX3dhdGNoZXIpIHtcblx0XHRcdFx0dm0uX3dhdGNoZXIudGVhcmRvd24oKTtcblx0XHRcdH1cblx0XHRcdHZhciBpID0gdm0uX3dhdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0dm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuXHRcdFx0Ly8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG5cdFx0XHRpZiAodm0uX2RhdGEuX19vYl9fKSB7XG5cdFx0XHRcdHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG5cdFx0XHR9XG5cdFx0XHQvLyBjYWxsIHRoZSBsYXN0IGhvb2suLi5cblx0XHRcdHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG5cdFx0XHQvLyBpbnZva2UgZGVzdHJveSBob29rcyBvbiBjdXJyZW50IHJlbmRlcmVkIHRyZWVcblx0XHRcdHZtLl9fcGF0Y2hfXyh2bS5fdm5vZGUsIG51bGwpO1xuXHRcdFx0Ly8gZmlyZSBkZXN0cm95ZWQgaG9va1xuXHRcdFx0Y2FsbEhvb2sodm0sICdkZXN0cm95ZWQnKTtcblx0XHRcdC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG5cdFx0XHR2bS4kb2ZmKCk7XG5cdFx0XHQvLyByZW1vdmUgX192dWVfXyByZWZlcmVuY2Vcblx0XHRcdGlmICh2bS4kZWwpIHtcblx0XHRcdFx0dm0uJGVsLl9fdnVlX18gPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVtb3ZlIHJlZmVyZW5jZSB0byBET00gbm9kZXMgKHByZXZlbnRzIGxlYWspXG5cdFx0XHR2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcblx0XHR2bSxcblx0XHRlbCxcblx0XHRoeWRyYXRpbmdcblx0KSB7XG5cdFx0dm0uJGVsID0gZWw7XG5cdFx0aWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcblx0XHRcdHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG5cdFx0XHR7XG5cdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0XHRpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuXHRcdFx0XHRcdHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG5cdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdCdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcblx0XHRcdFx0XHRcdCdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuXHRcdFx0XHRcdFx0J3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcblx0XHRcdFx0XHRcdHZtXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0J0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuXHRcdFx0XHRcdFx0dm1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuXHRcdHZhciB1cGRhdGVDb21wb25lbnQ7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG5cdFx0XHR1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gdm0uX25hbWU7XG5cdFx0XHRcdHZhciBpZCA9IHZtLl91aWQ7XG5cdFx0XHRcdHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcblx0XHRcdFx0dmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cblx0XHRcdFx0bWFyayhzdGFydFRhZyk7XG5cdFx0XHRcdHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcblx0XHRcdFx0bWFyayhlbmRUYWcpO1xuXHRcdFx0XHRtZWFzdXJlKChuYW1lICsgXCIgcmVuZGVyXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcblxuXHRcdFx0XHRtYXJrKHN0YXJ0VGFnKTtcblx0XHRcdFx0dm0uX3VwZGF0ZSh2bm9kZSwgaHlkcmF0aW5nKTtcblx0XHRcdFx0bWFyayhlbmRUYWcpO1xuXHRcdFx0XHRtZWFzdXJlKChuYW1lICsgXCIgcGF0Y2hcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wKTtcblx0XHRoeWRyYXRpbmcgPSBmYWxzZTtcblxuXHRcdC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG5cdFx0Ly8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcblx0XHRpZiAodm0uJHZub2RlID09IG51bGwpIHtcblx0XHRcdHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuXHRcdFx0Y2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG5cdFx0fVxuXHRcdHJldHVybiB2bVxuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuXHRcdHZtLFxuXHRcdHByb3BzRGF0YSxcblx0XHRsaXN0ZW5lcnMsXG5cdFx0cGFyZW50Vm5vZGUsXG5cdFx0cmVuZGVyQ2hpbGRyZW5cblx0KSB7XG5cdFx0Ly8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG5cdFx0Ly8gd2UgbmVlZCB0byBkbyB0aGlzIGJlZm9yZSBvdmVyd3JpdGluZyAkb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW5cblx0XHR2YXIgaGFzQ2hpbGRyZW4gPSAhIShcblx0XHRcdHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcblx0XHRcdHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiB8fCAgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcblx0XHRcdHBhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMgfHwgLy8gaGFzIG5ldyBzY29wZWQgc2xvdHNcblx0XHRcdHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcblx0XHQpO1xuXG5cdFx0dm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG5cdFx0dm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblx0XHRpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG5cdFx0XHR2bS5fdm5vZGUucGFyZW50ID0gcGFyZW50Vm5vZGU7XG5cdFx0fVxuXHRcdHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG5cdFx0Ly8gdXBkYXRlIHByb3BzXG5cdFx0aWYgKHByb3BzRGF0YSAmJiB2bS4kb3B0aW9ucy5wcm9wcykge1xuXHRcdFx0b2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gZmFsc2U7XG5cdFx0XHR7XG5cdFx0XHRcdG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHByb3BzID0gdm0uX3Byb3BzO1xuXHRcdFx0dmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIga2V5ID0gcHJvcEtleXNbaV07XG5cdFx0XHRcdHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG5cdFx0XHR9XG5cdFx0XHRvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuXHRcdFx0e1xuXHRcdFx0XHRvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBrZWVwIGEgY29weSBvZiByYXcgcHJvcHNEYXRhXG5cdFx0XHR2bS4kb3B0aW9ucy5wcm9wc0RhdGEgPSBwcm9wc0RhdGE7XG5cdFx0fVxuXHRcdC8vIHVwZGF0ZSBsaXN0ZW5lcnNcblx0XHRpZiAobGlzdGVuZXJzKSB7XG5cdFx0XHR2YXIgb2xkTGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcblx0XHRcdHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG5cdFx0XHR1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblx0XHR9XG5cdFx0Ly8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cblx0XHRpZiAoaGFzQ2hpbGRyZW4pIHtcblx0XHRcdHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG5cdFx0XHR2bS4kZm9yY2VVcGRhdGUoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuXHRcdHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuXHRcdFx0aWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cblx0ZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuXHRcdGlmIChkaXJlY3QpIHtcblx0XHRcdHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0aWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0aWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcblx0XHRcdHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0YWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcblx0XHRpZiAoZGlyZWN0KSB7XG5cdFx0XHR2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0aWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXZtLl9pbmFjdGl2ZSkge1xuXHRcdFx0dm0uX2luYWN0aXZlID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuXHRcdHZhciBoYW5kbGVycyA9IHZtLiRvcHRpb25zW2hvb2tdO1xuXHRcdGlmIChoYW5kbGVycykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRoYW5kbGVyc1tpXS5jYWxsKHZtKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGhhbmRsZUVycm9yKGUsIHZtLCAoaG9vayArIFwiIGhvb2tcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG5cdFx0XHR2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblxuXHR2YXIgTUFYX1VQREFURV9DT1VOVCA9IDEwMDtcblxuXHR2YXIgcXVldWUgPSBbXTtcblx0dmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG5cdHZhciBoYXMgPSB7fTtcblx0dmFyIGNpcmN1bGFyID0ge307XG5cdHZhciB3YWl0aW5nID0gZmFsc2U7XG5cdHZhciBmbHVzaGluZyA9IGZhbHNlO1xuXHR2YXIgaW5kZXggPSAwO1xuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG5cdCAqL1xuXHRmdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcblx0XHRpbmRleCA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG5cdFx0aGFzID0ge307XG5cdFx0e1xuXHRcdFx0Y2lyY3VsYXIgPSB7fTtcblx0XHR9XG5cdFx0d2FpdGluZyA9IGZsdXNoaW5nID0gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG5cdCAqL1xuXHRmdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcblx0XHRmbHVzaGluZyA9IHRydWU7XG5cdFx0dmFyIHdhdGNoZXIsIGlkO1xuXG5cdFx0Ly8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG5cdFx0Ly8gVGhpcyBlbnN1cmVzIHRoYXQ6XG5cdFx0Ly8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuXHRcdC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcblx0XHQvLyAyLiBBIGNvbXBvbmVudCdzIHVzZXIgd2F0Y2hlcnMgYXJlIHJ1biBiZWZvcmUgaXRzIHJlbmRlciB3YXRjaGVyIChiZWNhdXNlXG5cdFx0Ly8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuXHRcdC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG5cdFx0Ly8gICAgaXRzIHdhdGNoZXJzIGNhbiBiZSBza2lwcGVkLlxuXHRcdHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuXHRcdC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuXHRcdC8vIGFzIHdlIHJ1biBleGlzdGluZyB3YXRjaGVyc1xuXHRcdGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuXHRcdFx0d2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcblx0XHRcdGlkID0gd2F0Y2hlci5pZDtcblx0XHRcdGhhc1tpZF0gPSBudWxsO1xuXHRcdFx0d2F0Y2hlci5ydW4oKTtcblx0XHRcdC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cblx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXNbaWRdICE9IG51bGwpIHtcblx0XHRcdFx0Y2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG5cdFx0XHRcdGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG5cdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdCdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcblx0XHRcdFx0XHRcdFx0d2F0Y2hlci51c2VyXG5cdFx0XHRcdFx0XHRcdFx0PyAoXCJpbiB3YXRjaGVyIHdpdGggZXhwcmVzc2lvbiBcXFwiXCIgKyAod2F0Y2hlci5leHByZXNzaW9uKSArIFwiXFxcIlwiKVxuXHRcdFx0XHRcdFx0XHRcdDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcblx0XHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0XHR3YXRjaGVyLnZtXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8ga2VlcCBjb3BpZXMgb2YgcG9zdCBxdWV1ZXMgYmVmb3JlIHJlc2V0dGluZyBzdGF0ZVxuXHRcdHZhciBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG5cdFx0dmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cblx0XHRyZXNldFNjaGVkdWxlclN0YXRlKCk7XG5cblx0XHQvLyBjYWxsIGNvbXBvbmVudCB1cGRhdGVkIGFuZCBhY3RpdmF0ZWQgaG9va3Ncblx0XHRjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuXHRcdGNhbGxVcGRhdGVIb29rcyh1cGRhdGVkUXVldWUpO1xuXG5cdFx0Ly8gZGV2dG9vbCBob29rXG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKGRldnRvb2xzICYmIGNvbmZpZy5kZXZ0b29scykge1xuXHRcdFx0ZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjYWxsVXBkYXRlSG9va3MgKHF1ZXVlKSB7XG5cdFx0dmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0dmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcblx0XHRcdHZhciB2bSA9IHdhdGNoZXIudm07XG5cdFx0XHRpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuXHRcdFx0XHRjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuXHQgKiBUaGUgcXVldWUgd2lsbCBiZSBwcm9jZXNzZWQgYWZ0ZXIgdGhlIGVudGlyZSB0cmVlIGhhcyBiZWVuIHBhdGNoZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcblx0XHQvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG5cdFx0Ly8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcblx0XHR2bS5faW5hY3RpdmUgPSBmYWxzZTtcblx0XHRhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRxdWV1ZVtpXS5faW5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0YWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUHVzaCBhIHdhdGNoZXIgaW50byB0aGUgd2F0Y2hlciBxdWV1ZS5cblx0ICogSm9icyB3aXRoIGR1cGxpY2F0ZSBJRHMgd2lsbCBiZSBza2lwcGVkIHVubGVzcyBpdCdzXG5cdCAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuXHQgKi9cblx0ZnVuY3Rpb24gcXVldWVXYXRjaGVyICh3YXRjaGVyKSB7XG5cdFx0dmFyIGlkID0gd2F0Y2hlci5pZDtcblx0XHRpZiAoaGFzW2lkXSA9PSBudWxsKSB7XG5cdFx0XHRoYXNbaWRdID0gdHJ1ZTtcblx0XHRcdGlmICghZmx1c2hpbmcpIHtcblx0XHRcdFx0cXVldWUucHVzaCh3YXRjaGVyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcblx0XHRcdFx0Ly8gaWYgYWxyZWFkeSBwYXN0IGl0cyBpZCwgaXQgd2lsbCBiZSBydW4gbmV4dCBpbW1lZGlhdGVseS5cblx0XHRcdFx0dmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuXHRcdFx0XHR3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuXHRcdFx0XHRcdGktLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcXVldWUgdGhlIGZsdXNoXG5cdFx0XHRpZiAoIXdhaXRpbmcpIHtcblx0XHRcdFx0d2FpdGluZyA9IHRydWU7XG5cdFx0XHRcdG5leHRUaWNrKGZsdXNoU2NoZWR1bGVyUXVldWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciB1aWQkMiA9IDA7XG5cblx0LyoqXG5cdCAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuXHQgKiBhbmQgZmlyZXMgY2FsbGJhY2sgd2hlbiB0aGUgZXhwcmVzc2lvbiB2YWx1ZSBjaGFuZ2VzLlxuXHQgKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cblx0ICovXG5cdHZhciBXYXRjaGVyID0gZnVuY3Rpb24gV2F0Y2hlciAoXG5cdFx0dm0sXG5cdFx0ZXhwT3JGbixcblx0XHRjYixcblx0XHRvcHRpb25zXG5cdCkge1xuXHRcdHRoaXMudm0gPSB2bTtcblx0XHR2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcblx0XHQvLyBvcHRpb25zXG5cdFx0aWYgKG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuXHRcdFx0dGhpcy51c2VyID0gISFvcHRpb25zLnVzZXI7XG5cdFx0XHR0aGlzLmxhenkgPSAhIW9wdGlvbnMubGF6eTtcblx0XHRcdHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5jYiA9IGNiO1xuXHRcdHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG5cdFx0dGhpcy5hY3RpdmUgPSB0cnVlO1xuXHRcdHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG5cdFx0dGhpcy5kZXBzID0gW107XG5cdFx0dGhpcy5uZXdEZXBzID0gW107XG5cdFx0dGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuXHRcdHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcblx0XHR0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG5cdFx0Ly8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG5cdFx0aWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLmdldHRlciA9IGV4cE9yRm47XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuXHRcdFx0aWYgKCF0aGlzLmdldHRlcikge1xuXHRcdFx0XHR0aGlzLmdldHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHRcdFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuXHRcdFx0XHRcdCdXYXRjaGVyIG9ubHkgYWNjZXB0cyBzaW1wbGUgZG90LWRlbGltaXRlZCBwYXRocy4gJyArXG5cdFx0XHRcdFx0J0ZvciBmdWxsIGNvbnRyb2wsIHVzZSBhIGZ1bmN0aW9uIGluc3RlYWQuJyxcblx0XHRcdFx0XHR2bVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLnZhbHVlID0gdGhpcy5sYXp5XG5cdFx0XHQ/IHVuZGVmaW5lZFxuXHRcdFx0OiB0aGlzLmdldCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXHRXYXRjaGVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge1xuXHRcdHB1c2hUYXJnZXQodGhpcyk7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciB2bSA9IHRoaXMudm07XG5cdFx0aWYgKHRoaXMudXNlcikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcblx0XHR9XG5cdFx0Ly8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG5cdFx0Ly8gZGVwZW5kZW5jaWVzIGZvciBkZWVwIHdhdGNoaW5nXG5cdFx0aWYgKHRoaXMuZGVlcCkge1xuXHRcdFx0dHJhdmVyc2UodmFsdWUpO1xuXHRcdH1cblx0XHRwb3BUYXJnZXQoKTtcblx0XHR0aGlzLmNsZWFudXBEZXBzKCk7XG5cdFx0cmV0dXJuIHZhbHVlXG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZCBhIGRlcGVuZGVuY3kgdG8gdGhpcyBkaXJlY3RpdmUuXG5cdCAqL1xuXHRXYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuXHRcdHZhciBpZCA9IGRlcC5pZDtcblx0XHRpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcblx0XHRcdHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG5cdFx0XHR0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuXHRcdFx0aWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG5cdFx0XHRcdGRlcC5hZGRTdWIodGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuXHQgKi9cblx0V2F0Y2hlci5wcm90b3R5cGUuY2xlYW51cERlcHMgPSBmdW5jdGlvbiBjbGVhbnVwRGVwcyAoKSB7XG5cdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHR2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0dmFyIGRlcCA9IHRoaXMkMS5kZXBzW2ldO1xuXHRcdFx0aWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG5cdFx0XHRcdGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuXHRcdHRoaXMuZGVwSWRzID0gdGhpcy5uZXdEZXBJZHM7XG5cdFx0dGhpcy5uZXdEZXBJZHMgPSB0bXA7XG5cdFx0dGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcblx0XHR0bXAgPSB0aGlzLmRlcHM7XG5cdFx0dGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuXHRcdHRoaXMubmV3RGVwcyA9IHRtcDtcblx0XHR0aGlzLm5ld0RlcHMubGVuZ3RoID0gMDtcblx0fTtcblxuXHQvKipcblx0ICogU3Vic2NyaWJlciBpbnRlcmZhY2UuXG5cdCAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG5cdCAqL1xuXHRXYXRjaGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdFx0aWYgKHRoaXMubGF6eSkge1xuXHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cdFx0fSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcblx0XHRcdHRoaXMucnVuKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHF1ZXVlV2F0Y2hlcih0aGlzKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuXHQgKiBXaWxsIGJlIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyLlxuXHQgKi9cblx0V2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcblx0XHRpZiAodGhpcy5hY3RpdmUpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG5cdFx0XHRcdFx0Ly8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG5cdFx0XHRcdFx0Ly8gd2hlbiB0aGUgdmFsdWUgaXMgdGhlIHNhbWUsIGJlY2F1c2UgdGhlIHZhbHVlIG1heVxuXHRcdFx0XHRcdC8vIGhhdmUgbXV0YXRlZC5cblx0XHRcdFx0aXNPYmplY3QodmFsdWUpIHx8XG5cdFx0XHRcdHRoaXMuZGVlcFxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIHNldCBuZXcgdmFsdWVcblx0XHRcdFx0dmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAodGhpcy51c2VyKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cblx0ICogVGhpcyBvbmx5IGdldHMgY2FsbGVkIGZvciBsYXp5IHdhdGNoZXJzLlxuXHQgKi9cblx0V2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG5cdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBEZXBlbmQgb24gYWxsIGRlcHMgY29sbGVjdGVkIGJ5IHRoaXMgd2F0Y2hlci5cblx0ICovXG5cdFdhdGNoZXIucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG5cdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHR2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0dGhpcyQxLmRlcHNbaV0uZGVwZW5kKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cblx0ICovXG5cdFdhdGNoZXIucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gdGVhcmRvd24gKCkge1xuXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdFx0aWYgKHRoaXMuYWN0aXZlKSB7XG5cdFx0XHQvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG5cdFx0XHQvLyB0aGlzIGlzIGEgc29tZXdoYXQgZXhwZW5zaXZlIG9wZXJhdGlvbiBzbyB3ZSBza2lwIGl0XG5cdFx0XHQvLyBpZiB0aGUgdm0gaXMgYmVpbmcgZGVzdHJveWVkLlxuXHRcdFx0aWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG5cdFx0XHRcdHJlbW92ZSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdHRoaXMkMS5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzJDEpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5hY3RpdmUgPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG5cdCAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG5cdCAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG5cdCAqL1xuXHR2YXIgc2Vlbk9iamVjdHMgPSBuZXcgX1NldCgpO1xuXHRmdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG5cdFx0c2Vlbk9iamVjdHMuY2xlYXIoKTtcblx0XHRfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG5cdH1cblxuXHRmdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuXHRcdHZhciBpLCBrZXlzO1xuXHRcdHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG5cdFx0aWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWwpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0aWYgKHZhbC5fX29iX18pIHtcblx0XHRcdHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuXHRcdFx0aWYgKHNlZW4uaGFzKGRlcElkKSkge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHNlZW4uYWRkKGRlcElkKTtcblx0XHR9XG5cdFx0aWYgKGlzQSkge1xuXHRcdFx0aSA9IHZhbC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxbaV0sIHNlZW4pOyB9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuXHRcdFx0aSA9IGtleXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0Z2V0OiBub29wLFxuXHRcdHNldDogbm9vcFxuXHR9O1xuXG5cdGZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG5cdFx0c2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcblx0XHRcdHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuXHRcdH07XG5cdFx0c2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcblx0XHRcdHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuXHRcdH07XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuXHRcdHZtLl93YXRjaGVycyA9IFtdO1xuXHRcdHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG5cdFx0aWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuXHRcdGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cblx0XHRpZiAob3B0cy5kYXRhKSB7XG5cdFx0XHRpbml0RGF0YSh2bSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcblx0XHR9XG5cdFx0aWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuXHRcdGlmIChvcHRzLndhdGNoKSB7IGluaXRXYXRjaCh2bSwgb3B0cy53YXRjaCk7IH1cblx0fVxuXG5cdHZhciBpc1Jlc2VydmVkUHJvcCA9IHtcblx0XHRrZXk6IDEsXG5cdFx0cmVmOiAxLFxuXHRcdHNsb3Q6IDFcblx0fTtcblxuXHRmdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcblx0XHR2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuXHRcdHZhciBwcm9wcyA9IHZtLl9wcm9wcyA9IHt9O1xuXHRcdC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG5cdFx0Ly8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG5cdFx0dmFyIGtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXTtcblx0XHR2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG5cdFx0Ly8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG5cdFx0b2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gaXNSb290O1xuXHRcdHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG5cdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdHZhciB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRcdFx0e1xuXHRcdFx0XHRpZiAoaXNSZXNlcnZlZFByb3Bba2V5XSB8fCBjb25maWcuaXNSZXNlcnZlZEF0dHIoa2V5KSkge1xuXHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHQoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcblx0XHRcdFx0XHRcdHZtXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkZWZpbmVSZWFjdGl2ZSQkMShwcm9wcywga2V5LCB2YWx1ZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGlmICh2bS4kcGFyZW50ICYmICFvYnNlcnZlclN0YXRlLmlzU2V0dGluZ1Byb3BzKSB7XG5cdFx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0XHRcIkF2b2lkIG11dGF0aW5nIGEgcHJvcCBkaXJlY3RseSBzaW5jZSB0aGUgdmFsdWUgd2lsbCBiZSBcIiArXG5cdFx0XHRcdFx0XHRcdFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHBhcmVudCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuXHRcdFx0XHRcdFx0XHRcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG5cdFx0XHRcdFx0XHRcdFwidmFsdWUuIFByb3AgYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG5cdFx0XHRcdFx0XHRcdHZtXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG5cdFx0XHQvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuXHRcdFx0Ly8gaW5zdGFudGlhdGlvbiBoZXJlLlxuXHRcdFx0aWYgKCEoa2V5IGluIHZtKSkge1xuXHRcdFx0XHRwcm94eSh2bSwgXCJfcHJvcHNcIiwga2V5KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIHByb3BzT3B0aW9ucykgbG9vcCgga2V5ICk7XG5cdFx0b2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuXHRcdHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcblx0XHRkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0PyBnZXREYXRhKGRhdGEsIHZtKVxuXHRcdFx0OiBkYXRhIHx8IHt9O1xuXHRcdGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuXHRcdFx0ZGF0YSA9IHt9O1xuXHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybihcblx0XHRcdFx0J2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuXHRcdFx0XHQnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcblx0XHRcdFx0dm1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2Vcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuXHRcdHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuXHRcdHZhciBpID0ga2V5cy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0aWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5c1tpXSkpIHtcblx0XHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybihcblx0XHRcdFx0XHRcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIChrZXlzW2ldKSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuXHRcdFx0XHRcdFwiVXNlIHByb3AgZGVmYXVsdCB2YWx1ZSBpbnN0ZWFkLlwiLFxuXHRcdFx0XHRcdHZtXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2UgaWYgKCFpc1Jlc2VydmVkKGtleXNbaV0pKSB7XG5cdFx0XHRcdHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleXNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBvYnNlcnZlIGRhdGFcblx0XHRvYnNlcnZlKGRhdGEsIHRydWUgLyogYXNSb290RGF0YSAqLyk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXREYXRhIChkYXRhLCB2bSkge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gZGF0YS5jYWxsKHZtKVxuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcblx0XHRcdHJldHVybiB7fVxuXHRcdH1cblx0fVxuXG5cdHZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cblx0ZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcblx0XHR2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcblx0XHRcdHZhciB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcblx0XHRcdHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcblx0XHRcdHtcblx0XHRcdFx0aWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdChcIk5vIGdldHRlciBmdW5jdGlvbiBoYXMgYmVlbiBkZWZpbmVkIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIuXCIpLFxuXHRcdFx0XHRcdFx0dm1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdGdldHRlciA9IG5vb3A7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG5cdFx0XHR3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIodm0sIGdldHRlciwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XG5cblx0XHRcdC8vIGNvbXBvbmVudC1kZWZpbmVkIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGFscmVhZHkgZGVmaW5lZCBvbiB0aGVcblx0XHRcdC8vIGNvbXBvbmVudCBwcm90b3R5cGUuIFdlIG9ubHkgbmVlZCB0byBkZWZpbmUgY29tcHV0ZWQgcHJvcGVydGllcyBkZWZpbmVkXG5cdFx0XHQvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG5cdFx0XHRpZiAoIShrZXkgaW4gdm0pKSB7XG5cdFx0XHRcdGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGtleSBpbiB2bS4kZGF0YSkge1xuXHRcdFx0XHRcdHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcblx0XHRcdFx0fSBlbHNlIGlmICh2bS4kb3B0aW9ucy5wcm9wcyAmJiBrZXkgaW4gdm0uJG9wdGlvbnMucHJvcHMpIHtcblx0XHRcdFx0XHR3YXJuKChcIlRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFzIGEgcHJvcC5cIiksIHZtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRlZmluZUNvbXB1dGVkICh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuXHRcdGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0c2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSk7XG5cdFx0XHRzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gbm9vcDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG5cdFx0XHRcdD8gdXNlckRlZi5jYWNoZSAhPT0gZmFsc2Vcblx0XHRcdFx0PyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG5cdFx0XHRcdDogdXNlckRlZi5nZXRcblx0XHRcdFx0OiBub29wO1xuXHRcdFx0c2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG5cdFx0XHRcdD8gdXNlckRlZi5zZXRcblx0XHRcdFx0OiBub29wO1xuXHRcdH1cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVDb21wdXRlZEdldHRlciAoa2V5KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcblx0XHRcdHZhciB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG5cdFx0XHRpZiAod2F0Y2hlcikge1xuXHRcdFx0XHRpZiAod2F0Y2hlci5kaXJ0eSkge1xuXHRcdFx0XHRcdHdhdGNoZXIuZXZhbHVhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoRGVwLnRhcmdldCkge1xuXHRcdFx0XHRcdHdhdGNoZXIuZGVwZW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHdhdGNoZXIudmFsdWVcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0TWV0aG9kcyAodm0sIG1ldGhvZHMpIHtcblx0XHR2YXIgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcblx0XHRmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuXHRcdFx0dm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG5cdFx0XHR7XG5cdFx0XHRcdGlmIChtZXRob2RzW2tleV0gPT0gbnVsbCkge1xuXHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHRcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcblx0XHRcdFx0XHRcdFwiRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9cIixcblx0XHRcdFx0XHRcdHZtXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG5cdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdChcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgcHJvcC5cIiksXG5cdFx0XHRcdFx0XHR2bVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0V2F0Y2ggKHZtLCB3YXRjaCkge1xuXHRcdGZvciAodmFyIGtleSBpbiB3YXRjaCkge1xuXHRcdFx0dmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVXYXRjaGVyICh2bSwga2V5LCBoYW5kbGVyKSB7XG5cdFx0dmFyIG9wdGlvbnM7XG5cdFx0aWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcblx0XHRcdG9wdGlvbnMgPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuXHRcdFx0aGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuXHRcdH1cblx0XHR2bS4kd2F0Y2goa2V5LCBoYW5kbGVyLCBvcHRpb25zKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHN0YXRlTWl4aW4gKFZ1ZSkge1xuXHRcdC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuXHRcdC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuXHRcdC8vIHRoZSBvYmplY3QgaGVyZS5cblx0XHR2YXIgZGF0YURlZiA9IHt9O1xuXHRcdGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuXHRcdHZhciBwcm9wc0RlZiA9IHt9O1xuXHRcdHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Byb3BzIH07XG5cdFx0e1xuXHRcdFx0ZGF0YURlZi5zZXQgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xuXHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdCdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG5cdFx0XHRcdFx0J1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcblx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdCk7XG5cdFx0XHR9O1xuXHRcdFx0cHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHR3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuXHRcdFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcblx0XHRWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cblx0XHRWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcblx0XHRcdGV4cE9yRm4sXG5cdFx0XHRjYixcblx0XHRcdG9wdGlvbnNcblx0XHQpIHtcblx0XHRcdHZhciB2bSA9IHRoaXM7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdG9wdGlvbnMudXNlciA9IHRydWU7XG5cdFx0XHR2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG5cdFx0XHRpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcblx0XHRcdFx0Y2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcblx0XHRcdFx0d2F0Y2hlci50ZWFyZG93bigpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcblx0XHR2YXIgcHJvdmlkZSA9IHZtLiRvcHRpb25zLnByb3ZpZGU7XG5cdFx0aWYgKHByb3ZpZGUpIHtcblx0XHRcdHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdD8gcHJvdmlkZS5jYWxsKHZtKVxuXHRcdFx0XHQ6IHByb3ZpZGU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdEluamVjdGlvbnMgKHZtKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG5cdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0T2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRlZmluZVJlYWN0aXZlJCQxKHZtLCBrZXksIHJlc3VsdFtrZXldLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0XHRcIkF2b2lkIG11dGF0aW5nIGFuIGluamVjdGVkIHZhbHVlIGRpcmVjdGx5IHNpbmNlIHRoZSBjaGFuZ2VzIHdpbGwgYmUgXCIgK1xuXHRcdFx0XHRcdFx0XHRcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuXHRcdFx0XHRcdFx0XHRcImluamVjdGlvbiBiZWluZyBtdXRhdGVkOiBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIixcblx0XHRcdFx0XHRcdFx0dm1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHJlc29sdmVJbmplY3QgKGluamVjdCwgdm0pIHtcblx0XHRpZiAoaW5qZWN0KSB7XG5cdFx0XHQvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuXHRcdFx0Ly8gaXNBcnJheSBoZXJlXG5cdFx0XHR2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoaW5qZWN0KTtcblx0XHRcdHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdFx0dmFyIGtleXMgPSBpc0FycmF5XG5cdFx0XHRcdD8gaW5qZWN0XG5cdFx0XHRcdDogaGFzU3ltYm9sXG5cdFx0XHRcdD8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcblx0XHRcdFx0OiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRcdHZhciBwcm92aWRlS2V5ID0gaXNBcnJheSA/IGtleSA6IGluamVjdFtrZXldO1xuXHRcdFx0XHR2YXIgc291cmNlID0gdm07XG5cdFx0XHRcdHdoaWxlIChzb3VyY2UpIHtcblx0XHRcdFx0XHRpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcblx0XHRcdFx0XHRcdHJlc3VsdFtrZXldID0gc291cmNlLl9wcm92aWRlZFtwcm92aWRlS2V5XTtcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNvdXJjZSA9IHNvdXJjZS4kcGFyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCAoXG5cdFx0Q3Rvcixcblx0XHRwcm9wc0RhdGEsXG5cdFx0ZGF0YSxcblx0XHRjb250ZXh0LFxuXHRcdGNoaWxkcmVuXG5cdCkge1xuXHRcdHZhciBwcm9wcyA9IHt9O1xuXHRcdHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcblx0XHRpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcblx0XHRcdFx0cHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEgfHwge30pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoaXNEZWYoZGF0YS5hdHRycykpIHsgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7IH1cblx0XHRcdGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuXHRcdH1cblx0XHQvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG5cdFx0Ly8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuXHRcdHZhciBfY29udGV4dCA9IE9iamVjdC5jcmVhdGUoY29udGV4dCk7XG5cdFx0dmFyIGggPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChfY29udGV4dCwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cdFx0dmFyIHZub2RlID0gQ3Rvci5vcHRpb25zLnJlbmRlci5jYWxsKG51bGwsIGgsIHtcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRwcm9wczogcHJvcHMsXG5cdFx0XHRjaGlsZHJlbjogY2hpbGRyZW4sXG5cdFx0XHRwYXJlbnQ6IGNvbnRleHQsXG5cdFx0XHRsaXN0ZW5lcnM6IGRhdGEub24gfHwge30sXG5cdFx0XHRpbmplY3Rpb25zOiByZXNvbHZlSW5qZWN0KEN0b3Iub3B0aW9ucy5pbmplY3QsIGNvbnRleHQpLFxuXHRcdFx0c2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cblx0XHR9KTtcblx0XHRpZiAodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkge1xuXHRcdFx0dm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuXHRcdFx0dm5vZGUuZnVuY3Rpb25hbE9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG5cdFx0XHRpZiAoZGF0YS5zbG90KSB7XG5cdFx0XHRcdCh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdm5vZGVcblx0fVxuXG5cdGZ1bmN0aW9uIG1lcmdlUHJvcHMgKHRvLCBmcm9tKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdHRvW2NhbWVsaXplKGtleSldID0gZnJvbVtrZXldO1xuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG4vLyBob29rcyB0byBiZSBpbnZva2VkIG9uIGNvbXBvbmVudCBWTm9kZXMgZHVyaW5nIHBhdGNoXG5cdHZhciBjb21wb25lbnRWTm9kZUhvb2tzID0ge1xuXHRcdGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuXHRcdFx0dm5vZGUsXG5cdFx0XHRoeWRyYXRpbmcsXG5cdFx0XHRwYXJlbnRFbG0sXG5cdFx0XHRyZWZFbG1cblx0XHQpIHtcblx0XHRcdGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZShcblx0XHRcdFx0XHR2bm9kZSxcblx0XHRcdFx0XHRhY3RpdmVJbnN0YW5jZSxcblx0XHRcdFx0XHRwYXJlbnRFbG0sXG5cdFx0XHRcdFx0cmVmRWxtXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG5cdFx0XHR9IGVsc2UgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG5cdFx0XHRcdC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuXHRcdFx0XHR2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuXHRcdFx0XHRjb21wb25lbnRWTm9kZUhvb2tzLnByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG5cdFx0XHR2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuXHRcdFx0dXBkYXRlQ2hpbGRDb21wb25lbnQoXG5cdFx0XHRcdGNoaWxkLFxuXHRcdFx0XHRvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuXHRcdFx0XHRvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcblx0XHRcdFx0dm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcblx0XHRcdFx0b3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuXHRcdFx0dmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuXHRcdFx0dmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG5cdFx0XHRpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcblx0XHRcdFx0Y29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG5cdFx0XHRcdGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG5cdFx0XHRcdGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcblx0XHRcdFx0XHQvLyB2dWUtcm91dGVyIzEyMTJcblx0XHRcdFx0XHQvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG5cdFx0XHRcdFx0Ly8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG5cdFx0XHRcdFx0Ly8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuXHRcdFx0XHRcdC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cblx0XHRcdFx0XHRxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcblx0XHRcdGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG5cdFx0XHRcdGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcblx0XHRcdFx0XHRjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuXHRmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuXHRcdEN0b3IsXG5cdFx0ZGF0YSxcblx0XHRjb250ZXh0LFxuXHRcdGNoaWxkcmVuLFxuXHRcdHRhZ1xuXHQpIHtcblx0XHRpZiAoaXNVbmRlZihDdG9yKSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuXHRcdC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuXHRcdGlmIChpc09iamVjdChDdG9yKSkge1xuXHRcdFx0Q3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcblx0XHR9XG5cblx0XHQvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG5cdFx0Ly8gcmVqZWN0LlxuXHRcdGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0e1xuXHRcdFx0XHR3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcblx0XHRcdH1cblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdC8vIGFzeW5jIGNvbXBvbmVudFxuXHRcdGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuXHRcdFx0Q3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgY29udGV4dCk7XG5cdFx0XHRpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8vIHJldHVybiBub3RoaW5nIGlmIHRoaXMgaXMgaW5kZWVkIGFuIGFzeW5jIGNvbXBvbmVudFxuXHRcdFx0XHQvLyB3YWl0IGZvciB0aGUgY2FsbGJhY2sgdG8gdHJpZ2dlciBwYXJlbnQgdXBkYXRlLlxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG5cdFx0Ly8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG5cdFx0cmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuXHRcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXG5cdFx0Ly8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuXHRcdGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuXHRcdFx0dHJhbnNmb3JtTW9kZWwoQ3Rvci5vcHRpb25zLCBkYXRhKTtcblx0XHR9XG5cblx0XHQvLyBleHRyYWN0IHByb3BzXG5cdFx0dmFyIHByb3BzRGF0YSA9IGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEoZGF0YSwgQ3RvciwgdGFnKTtcblxuXHRcdC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG5cdFx0aWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcblx0XHRcdHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG5cdFx0fVxuXG5cdFx0Ly8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcblx0XHQvLyBjaGlsZCBjb21wb25lbnQgbGlzdGVuZXJzIGluc3RlYWQgb2YgRE9NIGxpc3RlbmVyc1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuXHRcdC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG5cdFx0ZGF0YS5vbiA9IGRhdGEubmF0aXZlT247XG5cblx0XHRpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcblx0XHRcdC8vIGFic3RyYWN0IGNvbXBvbmVudHMgZG8gbm90IGtlZXAgYW55dGhpbmdcblx0XHRcdC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcblx0XHRcdGRhdGEgPSB7fTtcblx0XHR9XG5cblx0XHQvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG5cdFx0bWVyZ2VIb29rcyhkYXRhKTtcblxuXHRcdC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG5cdFx0dmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG5cdFx0dmFyIHZub2RlID0gbmV3IFZOb2RlKFxuXHRcdFx0KFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcblx0XHRcdGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQsXG5cdFx0XHR7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9XG5cdFx0KTtcblx0XHRyZXR1cm4gdm5vZGVcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUgKFxuXHRcdHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3Rcblx0XHRwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuXHRcdHBhcmVudEVsbSxcblx0XHRyZWZFbG1cblx0KSB7XG5cdFx0dmFyIHZub2RlQ29tcG9uZW50T3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG5cdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRfaXNDb21wb25lbnQ6IHRydWUsXG5cdFx0XHRwYXJlbnQ6IHBhcmVudCxcblx0XHRcdHByb3BzRGF0YTogdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YSxcblx0XHRcdF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG5cdFx0XHRfcGFyZW50Vm5vZGU6IHZub2RlLFxuXHRcdFx0X3BhcmVudExpc3RlbmVyczogdm5vZGVDb21wb25lbnRPcHRpb25zLmxpc3RlbmVycyxcblx0XHRcdF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuXHRcdFx0X3BhcmVudEVsbTogcGFyZW50RWxtIHx8IG51bGwsXG5cdFx0XHRfcmVmRWxtOiByZWZFbG0gfHwgbnVsbFxuXHRcdH07XG5cdFx0Ly8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcblx0XHR2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuXHRcdGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcblx0XHRcdG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuXHRcdFx0b3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcblx0fVxuXG5cdGZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcblx0XHRpZiAoIWRhdGEuaG9vaykge1xuXHRcdFx0ZGF0YS5ob29rID0ge307XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3NUb01lcmdlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuXHRcdFx0dmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcblx0XHRcdHZhciBvdXJzID0gY29tcG9uZW50Vk5vZGVIb29rc1trZXldO1xuXHRcdFx0ZGF0YS5ob29rW2tleV0gPSBmcm9tUGFyZW50ID8gbWVyZ2VIb29rJDEob3VycywgZnJvbVBhcmVudCkgOiBvdXJzO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1lcmdlSG9vayQxIChvbmUsIHR3bykge1xuXHRcdHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuXHRcdFx0b25lKGEsIGIsIGMsIGQpO1xuXHRcdFx0dHdvKGEsIGIsIGMsIGQpO1xuXHRcdH1cblx0fVxuXG4vLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4vLyBwcm9wIGFuZCBldmVudCBoYW5kbGVyIHJlc3BlY3RpdmVseS5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwgKG9wdGlvbnMsIGRhdGEpIHtcblx0XHR2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcblx0XHR2YXIgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnOyhkYXRhLnByb3BzIHx8IChkYXRhLnByb3BzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG5cdFx0dmFyIG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcblx0XHRpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuXHRcdFx0b25bZXZlbnRdID0gW2RhdGEubW9kZWwuY2FsbGJhY2tdLmNvbmNhdChvbltldmVudF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBTSU1QTEVfTk9STUFMSVpFID0gMTtcblx0dmFyIEFMV0FZU19OT1JNQUxJWkUgPSAyO1xuXG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuXHRcdGNvbnRleHQsXG5cdFx0dGFnLFxuXHRcdGRhdGEsXG5cdFx0Y2hpbGRyZW4sXG5cdFx0bm9ybWFsaXphdGlvblR5cGUsXG5cdFx0YWx3YXlzTm9ybWFsaXplXG5cdCkge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG5cdFx0XHRub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuXHRcdFx0Y2hpbGRyZW4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG5cdFx0XHRub3JtYWxpemF0aW9uVHlwZSA9IEFMV0FZU19OT1JNQUxJWkU7XG5cdFx0fVxuXHRcdHJldHVybiBfY3JlYXRlRWxlbWVudChjb250ZXh0LCB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSlcblx0fVxuXG5cdGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcblx0XHRjb250ZXh0LFxuXHRcdHRhZyxcblx0XHRkYXRhLFxuXHRcdGNoaWxkcmVuLFxuXHRcdG5vcm1hbGl6YXRpb25UeXBlXG5cdCkge1xuXHRcdGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZigoZGF0YSkuX19vYl9fKSkge1xuXHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybihcblx0XHRcdFx0XCJBdm9pZCB1c2luZyBvYnNlcnZlZCBkYXRhIG9iamVjdCBhcyB2bm9kZSBkYXRhOiBcIiArIChKU09OLnN0cmluZ2lmeShkYXRhKSkgKyBcIlxcblwiICtcblx0XHRcdFx0J0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG5cdFx0XHRcdGNvbnRleHRcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG5cdFx0fVxuXHRcdGlmICghdGFnKSB7XG5cdFx0XHQvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG5cdFx0XHRyZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG5cdFx0fVxuXHRcdC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3Rcblx0XHRpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcblx0XHRcdHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdCkge1xuXHRcdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0XHRkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuXHRcdFx0Y2hpbGRyZW4ubGVuZ3RoID0gMDtcblx0XHR9XG5cdFx0aWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG5cdFx0XHRjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHR9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG5cdFx0XHRjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHR9XG5cdFx0dmFyIHZub2RlLCBucztcblx0XHRpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHZhciBDdG9yO1xuXHRcdFx0bnMgPSBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cdFx0XHRpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuXHRcdFx0XHQvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuXHRcdFx0XHR2bm9kZSA9IG5ldyBWTm9kZShcblx0XHRcdFx0XHRjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG5cdFx0XHRcdFx0dW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG5cdFx0XHRcdC8vIGNvbXBvbmVudFxuXHRcdFx0XHR2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHVua25vd24gb3IgdW5saXN0ZWQgbmFtZXNwYWNlZCBlbGVtZW50c1xuXHRcdFx0XHQvLyBjaGVjayBhdCBydW50aW1lIGJlY2F1c2UgaXQgbWF5IGdldCBhc3NpZ25lZCBhIG5hbWVzcGFjZSB3aGVuIGl0c1xuXHRcdFx0XHQvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuXHRcdFx0XHR2bm9kZSA9IG5ldyBWTm9kZShcblx0XHRcdFx0XHR0YWcsIGRhdGEsIGNoaWxkcmVuLFxuXHRcdFx0XHRcdHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGRpcmVjdCBjb21wb25lbnQgb3B0aW9ucyAvIGNvbnN0cnVjdG9yXG5cdFx0XHR2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcblx0XHR9XG5cdFx0aWYgKGlzRGVmKHZub2RlKSkge1xuXHRcdFx0aWYgKG5zKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuXHRcdFx0cmV0dXJuIHZub2RlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseU5TICh2bm9kZSwgbnMpIHtcblx0XHR2bm9kZS5ucyA9IG5zO1xuXHRcdGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuXHRcdFx0Ly8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0aWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChpc0RlZihjaGlsZC50YWcpICYmIGlzVW5kZWYoY2hpbGQubnMpKSB7XG5cdFx0XHRcdFx0YXBwbHlOUyhjaGlsZCwgbnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0LyoqXG5cdCAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG5cdCAqL1xuXHRmdW5jdGlvbiByZW5kZXJMaXN0IChcblx0XHR2YWwsXG5cdFx0cmVuZGVyXG5cdCkge1xuXHRcdHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWwpIHx8IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXQgPSBuZXcgQXJyYXkodmFsLmxlbmd0aCk7XG5cdFx0XHRmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRyZXRbaV0gPSByZW5kZXIodmFsW2ldLCBpKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG5cdFx0XHRyZXQgPSBuZXcgQXJyYXkodmFsKTtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuXHRcdFx0XHRyZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuXHRcdFx0a2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG5cdFx0XHRyZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuXHRcdFx0Zm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHRcdHJldFtpXSA9IHJlbmRlcih2YWxba2V5XSwga2V5LCBpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGlzRGVmKHJldCkpIHtcblx0XHRcdChyZXQpLl9pc1ZMaXN0ID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldFxuXHR9XG5cblx0LyogICovXG5cblx0LyoqXG5cdCAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgPHNsb3Q+XG5cdCAqL1xuXHRmdW5jdGlvbiByZW5kZXJTbG90IChcblx0XHRuYW1lLFxuXHRcdGZhbGxiYWNrLFxuXHRcdHByb3BzLFxuXHRcdGJpbmRPYmplY3Rcblx0KSB7XG5cdFx0dmFyIHNjb3BlZFNsb3RGbiA9IHRoaXMuJHNjb3BlZFNsb3RzW25hbWVdO1xuXHRcdGlmIChzY29wZWRTbG90Rm4pIHsgLy8gc2NvcGVkIHNsb3Rcblx0XHRcdHByb3BzID0gcHJvcHMgfHwge307XG5cdFx0XHRpZiAoYmluZE9iamVjdCkge1xuXHRcdFx0XHRleHRlbmQocHJvcHMsIGJpbmRPYmplY3QpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNjb3BlZFNsb3RGbihwcm9wcykgfHwgZmFsbGJhY2tcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNsb3ROb2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdO1xuXHRcdFx0Ly8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuXHRcdFx0aWYgKHNsb3ROb2RlcyAmJiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuXHRcdFx0XHRzbG90Tm9kZXMuX3JlbmRlcmVkICYmIHdhcm4oXG5cdFx0XHRcdFx0XCJEdXBsaWNhdGUgcHJlc2VuY2Ugb2Ygc2xvdCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGZvdW5kIGluIHRoZSBzYW1lIHJlbmRlciB0cmVlIFwiICtcblx0XHRcdFx0XHRcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuXHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0KTtcblx0XHRcdFx0c2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2xvdE5vZGVzIHx8IGZhbGxiYWNrXG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0LyoqXG5cdCAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuXHQgKi9cblx0ZnVuY3Rpb24gcmVzb2x2ZUZpbHRlciAoaWQpIHtcblx0XHRyZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG5cdH1cblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogUnVudGltZSBoZWxwZXIgZm9yIGNoZWNraW5nIGtleUNvZGVzIGZyb20gY29uZmlnLlxuXHQgKi9cblx0ZnVuY3Rpb24gY2hlY2tLZXlDb2RlcyAoXG5cdFx0ZXZlbnRLZXlDb2RlLFxuXHRcdGtleSxcblx0XHRidWlsdEluQWxpYXNcblx0KSB7XG5cdFx0dmFyIGtleUNvZGVzID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbkFsaWFzO1xuXHRcdGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuXHRcdFx0cmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogUnVudGltZSBoZWxwZXIgZm9yIG1lcmdpbmcgdi1iaW5kPVwib2JqZWN0XCIgaW50byBhIFZOb2RlJ3MgZGF0YS5cblx0ICovXG5cdGZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyAoXG5cdFx0ZGF0YSxcblx0XHR0YWcsXG5cdFx0dmFsdWUsXG5cdFx0YXNQcm9wXG5cdCkge1xuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcblx0XHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybihcblx0XHRcdFx0XHQndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuXHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBoYXNoO1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0XHRcdFx0aGFzaCA9IGRhdGE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG5cdFx0XHRcdFx0XHRoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcblx0XHRcdFx0XHRcdFx0PyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG5cdFx0XHRcdFx0XHRcdDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCEoa2V5IGluIGhhc2gpKSB7XG5cdFx0XHRcdFx0XHRoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cblx0LyogICovXG5cblx0LyoqXG5cdCAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgc3RhdGljIHRyZWVzLlxuXHQgKi9cblx0ZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcblx0XHRpbmRleCxcblx0XHRpc0luRm9yXG5cdCkge1xuXHRcdHZhciB0cmVlID0gdGhpcy5fc3RhdGljVHJlZXNbaW5kZXhdO1xuXHRcdC8vIGlmIGhhcyBhbHJlYWR5LXJlbmRlcmVkIHN0YXRpYyB0cmVlIGFuZCBub3QgaW5zaWRlIHYtZm9yLFxuXHRcdC8vIHdlIGNhbiByZXVzZSB0aGUgc2FtZSB0cmVlIGJ5IGRvaW5nIGEgc2hhbGxvdyBjbG9uZS5cblx0XHRpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuXHRcdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkodHJlZSlcblx0XHRcdFx0PyBjbG9uZVZOb2Rlcyh0cmVlKVxuXHRcdFx0XHQ6IGNsb25lVk5vZGUodHJlZSlcblx0XHR9XG5cdFx0Ly8gb3RoZXJ3aXNlLCByZW5kZXIgYSBmcmVzaCB0cmVlLlxuXHRcdHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF0gPVxuXHRcdFx0dGhpcy4kb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnNbaW5kZXhdLmNhbGwodGhpcy5fcmVuZGVyUHJveHkpO1xuXHRcdG1hcmtTdGF0aWModHJlZSwgKFwiX19zdGF0aWNfX1wiICsgaW5kZXgpLCBmYWxzZSk7XG5cdFx0cmV0dXJuIHRyZWVcblx0fVxuXG5cdC8qKlxuXHQgKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuXHQgKiBFZmZlY3RpdmVseSBpdCBtZWFucyBtYXJraW5nIHRoZSBub2RlIGFzIHN0YXRpYyB3aXRoIGEgdW5pcXVlIGtleS5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcmtPbmNlIChcblx0XHR0cmVlLFxuXHRcdGluZGV4LFxuXHRcdGtleVxuXHQpIHtcblx0XHRtYXJrU3RhdGljKHRyZWUsIChcIl9fb25jZV9fXCIgKyBpbmRleCArIChrZXkgPyAoXCJfXCIgKyBrZXkpIDogXCJcIikpLCB0cnVlKTtcblx0XHRyZXR1cm4gdHJlZVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFya1N0YXRpYyAoXG5cdFx0dHJlZSxcblx0XHRrZXksXG5cdFx0aXNPbmNlXG5cdCkge1xuXHRcdGlmIChBcnJheS5pc0FycmF5KHRyZWUpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0bWFya1N0YXRpY05vZGUodHJlZVtpXSwgKGtleSArIFwiX1wiICsgaSksIGlzT25jZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0bWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlIChub2RlLCBrZXksIGlzT25jZSkge1xuXHRcdG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuXHRcdG5vZGUua2V5ID0ga2V5O1xuXHRcdG5vZGUuaXNPbmNlID0gaXNPbmNlO1xuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gaW5pdFJlbmRlciAodm0pIHtcblx0XHR2bS5fdm5vZGUgPSBudWxsOyAvLyB0aGUgcm9vdCBvZiB0aGUgY2hpbGQgdHJlZVxuXHRcdHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG5cdFx0dmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlOyAvLyB0aGUgcGxhY2Vob2xkZXIgbm9kZSBpbiBwYXJlbnQgdHJlZVxuXHRcdHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcblx0XHR2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcblx0XHR2bS4kc2NvcGVkU2xvdHMgPSBlbXB0eU9iamVjdDtcblx0XHQvLyBiaW5kIHRoZSBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2Vcblx0XHQvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuXHRcdC8vIGFyZ3Mgb3JkZXI6IHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlLCBhbHdheXNOb3JtYWxpemVcblx0XHQvLyBpbnRlcm5hbCB2ZXJzaW9uIGlzIHVzZWQgYnkgcmVuZGVyIGZ1bmN0aW9ucyBjb21waWxlZCBmcm9tIHRlbXBsYXRlc1xuXHRcdHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcblx0XHQvLyBub3JtYWxpemF0aW9uIGlzIGFsd2F5cyBhcHBsaWVkIGZvciB0aGUgcHVibGljIHZlcnNpb24sIHVzZWQgaW5cblx0XHQvLyB1c2VyLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucy5cblx0XHR2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblx0fVxuXG5cdGZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcblx0XHRWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuXHRcdFx0cmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuXHRcdH07XG5cblx0XHRWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgdm0gPSB0aGlzO1xuXHRcdFx0dmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuXHRcdFx0dmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG5cdFx0XHR2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcblx0XHRcdHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG5cdFx0XHRpZiAodm0uX2lzTW91bnRlZCkge1xuXHRcdFx0XHQvLyBjbG9uZSBzbG90IG5vZGVzIG9uIHJlLXJlbmRlcnNcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuXHRcdFx0XHRcdHZtLiRzbG90c1trZXldID0gY2xvbmVWTm9kZXModm0uJHNsb3RzW2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZtLiRzY29wZWRTbG90cyA9IChfcGFyZW50Vm5vZGUgJiYgX3BhcmVudFZub2RlLmRhdGEuc2NvcGVkU2xvdHMpIHx8IGVtcHR5T2JqZWN0O1xuXG5cdFx0XHRpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcblx0XHRcdFx0dm0uX3N0YXRpY1RyZWVzID0gW107XG5cdFx0XHR9XG5cdFx0XHQvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG5cdFx0XHQvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cblx0XHRcdHZtLiR2bm9kZSA9IF9wYXJlbnRWbm9kZTtcblx0XHRcdC8vIHJlbmRlciBzZWxmXG5cdFx0XHR2YXIgdm5vZGU7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXIgZnVuY3Rpb25cIik7XG5cdFx0XHRcdC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuXHRcdFx0XHQvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuXHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvclxuXHRcdFx0XHRcdFx0PyB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpXG5cdFx0XHRcdFx0XHQ6IHZtLl92bm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuXHRcdFx0aWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcblx0XHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG5cdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdCdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG5cdFx0XHRcdFx0XHQnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcblx0XHRcdFx0XHRcdHZtXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcblx0XHRcdH1cblx0XHRcdC8vIHNldCBwYXJlbnRcblx0XHRcdHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcblx0XHRcdHJldHVybiB2bm9kZVxuXHRcdH07XG5cblx0XHQvLyBpbnRlcm5hbCByZW5kZXIgaGVscGVycy5cblx0XHQvLyB0aGVzZSBhcmUgZXhwb3NlZCBvbiB0aGUgaW5zdGFuY2UgcHJvdG90eXBlIHRvIHJlZHVjZSBnZW5lcmF0ZWQgcmVuZGVyXG5cdFx0Ly8gY29kZSBzaXplLlxuXHRcdFZ1ZS5wcm90b3R5cGUuX28gPSBtYXJrT25jZTtcblx0XHRWdWUucHJvdG90eXBlLl9uID0gdG9OdW1iZXI7XG5cdFx0VnVlLnByb3RvdHlwZS5fcyA9IHRvU3RyaW5nO1xuXHRcdFZ1ZS5wcm90b3R5cGUuX2wgPSByZW5kZXJMaXN0O1xuXHRcdFZ1ZS5wcm90b3R5cGUuX3QgPSByZW5kZXJTbG90O1xuXHRcdFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuXHRcdFZ1ZS5wcm90b3R5cGUuX2kgPSBsb29zZUluZGV4T2Y7XG5cdFx0VnVlLnByb3RvdHlwZS5fbSA9IHJlbmRlclN0YXRpYztcblx0XHRWdWUucHJvdG90eXBlLl9mID0gcmVzb2x2ZUZpbHRlcjtcblx0XHRWdWUucHJvdG90eXBlLl9rID0gY2hlY2tLZXlDb2Rlcztcblx0XHRWdWUucHJvdG90eXBlLl9iID0gYmluZE9iamVjdFByb3BzO1xuXHRcdFZ1ZS5wcm90b3R5cGUuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG5cdFx0VnVlLnByb3RvdHlwZS5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG5cdFx0VnVlLnByb3RvdHlwZS5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciB1aWQkMSA9IDA7XG5cblx0ZnVuY3Rpb24gaW5pdE1peGluIChWdWUpIHtcblx0XHRWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRcdHZhciB2bSA9IHRoaXM7XG5cdFx0XHQvLyBhIHVpZFxuXHRcdFx0dm0uX3VpZCA9IHVpZCQxKys7XG5cblx0XHRcdHZhciBzdGFydFRhZywgZW5kVGFnO1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcblx0XHRcdFx0c3RhcnRUYWcgPSBcInZ1ZS1wZXJmLWluaXQ6XCIgKyAodm0uX3VpZCk7XG5cdFx0XHRcdGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgKHZtLl91aWQpO1xuXHRcdFx0XHRtYXJrKHN0YXJ0VGFnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYSBmbGFnIHRvIGF2b2lkIHRoaXMgYmVpbmcgb2JzZXJ2ZWRcblx0XHRcdHZtLl9pc1Z1ZSA9IHRydWU7XG5cdFx0XHQvLyBtZXJnZSBvcHRpb25zXG5cdFx0XHRpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9pc0NvbXBvbmVudCkge1xuXHRcdFx0XHQvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuXHRcdFx0XHQvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG5cdFx0XHRcdC8vIGludGVybmFsIGNvbXBvbmVudCBvcHRpb25zIG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50LlxuXHRcdFx0XHRpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG5cdFx0XHRcdFx0b3B0aW9ucyB8fCB7fSxcblx0XHRcdFx0XHR2bVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRcdHtcblx0XHRcdFx0aW5pdFByb3h5KHZtKTtcblx0XHRcdH1cblx0XHRcdC8vIGV4cG9zZSByZWFsIHNlbGZcblx0XHRcdHZtLl9zZWxmID0gdm07XG5cdFx0XHRpbml0TGlmZWN5Y2xlKHZtKTtcblx0XHRcdGluaXRFdmVudHModm0pO1xuXHRcdFx0aW5pdFJlbmRlcih2bSk7XG5cdFx0XHRjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuXHRcdFx0aW5pdEluamVjdGlvbnModm0pOyAvLyByZXNvbHZlIGluamVjdGlvbnMgYmVmb3JlIGRhdGEvcHJvcHNcblx0XHRcdGluaXRTdGF0ZSh2bSk7XG5cdFx0XHRpbml0UHJvdmlkZSh2bSk7IC8vIHJlc29sdmUgcHJvdmlkZSBhZnRlciBkYXRhL3Byb3BzXG5cdFx0XHRjYWxsSG9vayh2bSwgJ2NyZWF0ZWQnKTtcblxuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcblx0XHRcdFx0dm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG5cdFx0XHRcdG1hcmsoZW5kVGFnKTtcblx0XHRcdFx0bWVhc3VyZSgoKHZtLl9uYW1lKSArIFwiIGluaXRcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodm0uJG9wdGlvbnMuZWwpIHtcblx0XHRcdFx0dm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuXHRcdHZhciBvcHRzID0gdm0uJG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKHZtLmNvbnN0cnVjdG9yLm9wdGlvbnMpO1xuXHRcdC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG5cdFx0b3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcblx0XHRvcHRzLnByb3BzRGF0YSA9IG9wdGlvbnMucHJvcHNEYXRhO1xuXHRcdG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG5cdFx0b3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuXHRcdG9wdHMuX3JlbmRlckNoaWxkcmVuID0gb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW47XG5cdFx0b3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuXHRcdG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcblx0XHRvcHRzLl9yZWZFbG0gPSBvcHRpb25zLl9yZWZFbG07XG5cdFx0aWYgKG9wdGlvbnMucmVuZGVyKSB7XG5cdFx0XHRvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuXHRcdFx0b3B0cy5zdGF0aWNSZW5kZXJGbnMgPSBvcHRpb25zLnN0YXRpY1JlbmRlckZucztcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIChDdG9yKSB7XG5cdFx0dmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG5cdFx0aWYgKEN0b3Iuc3VwZXIpIHtcblx0XHRcdHZhciBzdXBlck9wdGlvbnMgPSByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKEN0b3Iuc3VwZXIpO1xuXHRcdFx0dmFyIGNhY2hlZFN1cGVyT3B0aW9ucyA9IEN0b3Iuc3VwZXJPcHRpb25zO1xuXHRcdFx0aWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG5cdFx0XHRcdC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkLFxuXHRcdFx0XHQvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG5cdFx0XHRcdEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGxhdGUtbW9kaWZpZWQvYXR0YWNoZWQgb3B0aW9ucyAoIzQ5NzYpXG5cdFx0XHRcdHZhciBtb2RpZmllZE9wdGlvbnMgPSByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpO1xuXHRcdFx0XHQvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuXHRcdFx0XHRpZiAobW9kaWZpZWRPcHRpb25zKSB7XG5cdFx0XHRcdFx0ZXh0ZW5kKEN0b3IuZXh0ZW5kT3B0aW9ucywgbW9kaWZpZWRPcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcblx0XHRcdFx0aWYgKG9wdGlvbnMubmFtZSkge1xuXHRcdFx0XHRcdG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3Rvcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3B0aW9uc1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuXHRcdHZhciBtb2RpZmllZDtcblx0XHR2YXIgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuXHRcdHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcblx0XHR2YXIgc2VhbGVkID0gQ3Rvci5zZWFsZWRPcHRpb25zO1xuXHRcdGZvciAodmFyIGtleSBpbiBsYXRlc3QpIHtcblx0XHRcdGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcblx0XHRcdFx0aWYgKCFtb2RpZmllZCkgeyBtb2RpZmllZCA9IHt9OyB9XG5cdFx0XHRcdG1vZGlmaWVkW2tleV0gPSBkZWR1cGUobGF0ZXN0W2tleV0sIGV4dGVuZGVkW2tleV0sIHNlYWxlZFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1vZGlmaWVkXG5cdH1cblxuXHRmdW5jdGlvbiBkZWR1cGUgKGxhdGVzdCwgZXh0ZW5kZWQsIHNlYWxlZCkge1xuXHRcdC8vIGNvbXBhcmUgbGF0ZXN0IGFuZCBzZWFsZWQgdG8gZW5zdXJlIGxpZmVjeWNsZSBob29rcyB3b24ndCBiZSBkdXBsaWNhdGVkXG5cdFx0Ly8gYmV0d2VlbiBtZXJnZXNcblx0XHRpZiAoQXJyYXkuaXNBcnJheShsYXRlc3QpKSB7XG5cdFx0XHR2YXIgcmVzID0gW107XG5cdFx0XHRzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcblx0XHRcdGV4dGVuZGVkID0gQXJyYXkuaXNBcnJheShleHRlbmRlZCkgPyBleHRlbmRlZCA6IFtleHRlbmRlZF07XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxhdGVzdC5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHQvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuXHRcdFx0XHRpZiAoZXh0ZW5kZWQuaW5kZXhPZihsYXRlc3RbaV0pID49IDAgfHwgc2VhbGVkLmluZGV4T2YobGF0ZXN0W2ldKSA8IDApIHtcblx0XHRcdFx0XHRyZXMucHVzaChsYXRlc3RbaV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBsYXRlc3Rcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBWdWUkMyAob3B0aW9ucykge1xuXHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuXHRcdFx0ISh0aGlzIGluc3RhbmNlb2YgVnVlJDMpXG5cdFx0KSB7XG5cdFx0XHR3YXJuKCdWdWUgaXMgYSBjb25zdHJ1Y3RvciBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkJyk7XG5cdFx0fVxuXHRcdHRoaXMuX2luaXQob3B0aW9ucyk7XG5cdH1cblxuXHRpbml0TWl4aW4oVnVlJDMpO1xuXHRzdGF0ZU1peGluKFZ1ZSQzKTtcblx0ZXZlbnRzTWl4aW4oVnVlJDMpO1xuXHRsaWZlY3ljbGVNaXhpbihWdWUkMyk7XG5cdHJlbmRlck1peGluKFZ1ZSQzKTtcblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBpbml0VXNlIChWdWUpIHtcblx0XHRWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRpZiAocGx1Z2luLmluc3RhbGxlZCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG5cdFx0XHR2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcblx0XHRcdGFyZ3MudW5zaGlmdCh0aGlzKTtcblx0XHRcdGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG5cdFx0XHR9XG5cdFx0XHRwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fTtcblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcblx0XHRWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcblx0XHRcdHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fTtcblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuXHRcdC8qKlxuXHRcdCAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuXHRcdCAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcblx0XHQgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cblx0XHQgKi9cblx0XHRWdWUuY2lkID0gMDtcblx0XHR2YXIgY2lkID0gMTtcblxuXHRcdC8qKlxuXHRcdCAqIENsYXNzIGluaGVyaXRhbmNlXG5cdFx0ICovXG5cdFx0VnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG5cdFx0XHRleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcblx0XHRcdHZhciBTdXBlciA9IHRoaXM7XG5cdFx0XHR2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcblx0XHRcdHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG5cdFx0XHRpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcblx0XHRcdFx0cmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG5cdFx0XHR9XG5cblx0XHRcdHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcblx0XHRcdHtcblx0XHRcdFx0aWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0J0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcblx0XHRcdFx0XHRcdCdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCB0aGUgaHlwaGVuLCAnICtcblx0XHRcdFx0XHRcdCdhbmQgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLidcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5faW5pdChvcHRpb25zKTtcblx0XHRcdH07XG5cdFx0XHRTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuXHRcdFx0U3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1Yjtcblx0XHRcdFN1Yi5jaWQgPSBjaWQrKztcblx0XHRcdFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuXHRcdFx0XHRTdXBlci5vcHRpb25zLFxuXHRcdFx0XHRleHRlbmRPcHRpb25zXG5cdFx0XHQpO1xuXHRcdFx0U3ViWydzdXBlciddID0gU3VwZXI7XG5cblx0XHRcdC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG5cdFx0XHQvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuXHRcdFx0Ly8gYXZvaWRzIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxscyBmb3IgZWFjaCBpbnN0YW5jZSBjcmVhdGVkLlxuXHRcdFx0aWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG5cdFx0XHRcdGluaXRQcm9wcyQxKFN1Yik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcblx0XHRcdFx0aW5pdENvbXB1dGVkJDEoU3ViKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYWxsb3cgZnVydGhlciBleHRlbnNpb24vbWl4aW4vcGx1Z2luIHVzYWdlXG5cdFx0XHRTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuXHRcdFx0U3ViLm1peGluID0gU3VwZXIubWl4aW47XG5cdFx0XHRTdWIudXNlID0gU3VwZXIudXNlO1xuXG5cdFx0XHQvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG5cdFx0XHQvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG5cdFx0XHRBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG5cdFx0XHRcdFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuXHRcdFx0fSk7XG5cdFx0XHQvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG5cdFx0XHRpZiAobmFtZSkge1xuXHRcdFx0XHRTdWIub3B0aW9ucy5jb21wb25lbnRzW25hbWVdID0gU3ViO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuXHRcdFx0Ly8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcblx0XHRcdC8vIGJlZW4gdXBkYXRlZC5cblx0XHRcdFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuXHRcdFx0U3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuXHRcdFx0U3ViLnNlYWxlZE9wdGlvbnMgPSBleHRlbmQoe30sIFN1Yi5vcHRpb25zKTtcblxuXHRcdFx0Ly8gY2FjaGUgY29uc3RydWN0b3Jcblx0XHRcdGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuXHRcdFx0cmV0dXJuIFN1YlxuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBpbml0UHJvcHMkMSAoQ29tcCkge1xuXHRcdHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcblx0XHRmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcblx0XHRcdHByb3h5KENvbXAucHJvdG90eXBlLCBcIl9wcm9wc1wiLCBrZXkpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGluaXRDb21wdXRlZCQxIChDb21wKSB7XG5cdFx0dmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuXHRcdGZvciAodmFyIGtleSBpbiBjb21wdXRlZCkge1xuXHRcdFx0ZGVmaW5lQ29tcHV0ZWQoQ29tcC5wcm90b3R5cGUsIGtleSwgY29tcHV0ZWRba2V5XSk7XG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcblx0XHQvKipcblx0XHQgKiBDcmVhdGUgYXNzZXQgcmVnaXN0cmF0aW9uIG1ldGhvZHMuXG5cdFx0ICovXG5cdFx0QVNTRVRfVFlQRVMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuXHRcdFx0VnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuXHRcdFx0XHRpZCxcblx0XHRcdFx0ZGVmaW5pdGlvblxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmICghZGVmaW5pdGlvbikge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuXHRcdFx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0XHRcdCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuXHRcdFx0XHRcdFx0XHRcdCdpZDogJyArIGlkXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG5cdFx0XHRcdFx0XHRkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG5cdFx0XHRcdFx0XHRkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG5cdFx0XHRcdFx0cmV0dXJuIGRlZmluaXRpb25cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9KTtcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBwYXR0ZXJuVHlwZXMgPSBbU3RyaW5nLCBSZWdFeHBdO1xuXG5cdGZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcblx0XHRyZXR1cm4gb3B0cyAmJiAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZylcblx0fVxuXG5cdGZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcblx0XHRpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuXHRcdH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcblx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcblx0XHR9XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdGZ1bmN0aW9uIHBydW5lQ2FjaGUgKGNhY2hlLCBjdXJyZW50LCBmaWx0ZXIpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcblx0XHRcdHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcblx0XHRcdGlmIChjYWNoZWROb2RlKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuXHRcdFx0XHRpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG5cdFx0XHRcdFx0aWYgKGNhY2hlZE5vZGUgIT09IGN1cnJlbnQpIHtcblx0XHRcdFx0XHRcdHBydW5lQ2FjaGVFbnRyeShjYWNoZWROb2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2FjaGVba2V5XSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlKSB7XG5cdFx0XHR2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBLZWVwQWxpdmUgPSB7XG5cdFx0bmFtZTogJ2tlZXAtYWxpdmUnLFxuXHRcdGFic3RyYWN0OiB0cnVlLFxuXG5cdFx0cHJvcHM6IHtcblx0XHRcdGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcblx0XHRcdGV4Y2x1ZGU6IHBhdHRlcm5UeXBlc1xuXHRcdH0sXG5cblx0XHRjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcblx0XHRcdHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdH0sXG5cblx0XHRkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG5cdFx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdFx0Zm9yICh2YXIga2V5IGluIHRoaXMkMS5jYWNoZSkge1xuXHRcdFx0XHRwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR3YXRjaDoge1xuXHRcdFx0aW5jbHVkZTogZnVuY3Rpb24gaW5jbHVkZSAodmFsKSB7XG5cdFx0XHRcdHBydW5lQ2FjaGUodGhpcy5jYWNoZSwgdGhpcy5fdm5vZGUsIGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuXHRcdFx0fSxcblx0XHRcdGV4Y2x1ZGU6IGZ1bmN0aW9uIGV4Y2x1ZGUgKHZhbCkge1xuXHRcdFx0XHRwcnVuZUNhY2hlKHRoaXMuY2FjaGUsIHRoaXMuX3Zub2RlLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyICgpIHtcblx0XHRcdHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQodGhpcy4kc2xvdHMuZGVmYXVsdCk7XG5cdFx0XHR2YXIgY29tcG9uZW50T3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG5cdFx0XHRpZiAoY29tcG9uZW50T3B0aW9ucykge1xuXHRcdFx0XHQvLyBjaGVjayBwYXR0ZXJuXG5cdFx0XHRcdHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjb21wb25lbnRPcHRpb25zKTtcblx0XHRcdFx0aWYgKG5hbWUgJiYgKFxuXHRcdFx0XHRcdFx0KHRoaXMuaW5jbHVkZSAmJiAhbWF0Y2hlcyh0aGlzLmluY2x1ZGUsIG5hbWUpKSB8fFxuXHRcdFx0XHRcdFx0KHRoaXMuZXhjbHVkZSAmJiBtYXRjaGVzKHRoaXMuZXhjbHVkZSwgbmFtZSkpXG5cdFx0XHRcdFx0KSkge1xuXHRcdFx0XHRcdHJldHVybiB2bm9kZVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuXHRcdFx0XHRcdC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG5cdFx0XHRcdFx0Ly8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuXHRcdFx0XHRcdD8gY29tcG9uZW50T3B0aW9ucy5DdG9yLmNpZCArIChjb21wb25lbnRPcHRpb25zLnRhZyA/IChcIjo6XCIgKyAoY29tcG9uZW50T3B0aW9ucy50YWcpKSA6ICcnKVxuXHRcdFx0XHRcdDogdm5vZGUua2V5O1xuXHRcdFx0XHRpZiAodGhpcy5jYWNoZVtrZXldKSB7XG5cdFx0XHRcdFx0dm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSB0aGlzLmNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5jYWNoZVtrZXldID0gdm5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZub2RlXG5cdFx0fVxuXHR9O1xuXG5cdHZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcblx0XHRLZWVwQWxpdmU6IEtlZXBBbGl2ZVxuXHR9O1xuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGluaXRHbG9iYWxBUEkgKFZ1ZSkge1xuXHRcdC8vIGNvbmZpZ1xuXHRcdHZhciBjb25maWdEZWYgPSB7fTtcblx0XHRjb25maWdEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnOyB9O1xuXHRcdHtcblx0XHRcdGNvbmZpZ0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0J0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSwgJ2NvbmZpZycsIGNvbmZpZ0RlZik7XG5cblx0XHQvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cblx0XHQvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cblx0XHQvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuXHRcdFZ1ZS51dGlsID0ge1xuXHRcdFx0d2Fybjogd2Fybixcblx0XHRcdGV4dGVuZDogZXh0ZW5kLFxuXHRcdFx0bWVyZ2VPcHRpb25zOiBtZXJnZU9wdGlvbnMsXG5cdFx0XHRkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmUkJDFcblx0XHR9O1xuXG5cdFx0VnVlLnNldCA9IHNldDtcblx0XHRWdWUuZGVsZXRlID0gZGVsO1xuXHRcdFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG5cdFx0VnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRcdEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcblx0XHRcdFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR9KTtcblxuXHRcdC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3Rcblx0XHQvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cblx0XHRWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuXHRcdGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cblx0XHRpbml0VXNlKFZ1ZSk7XG5cdFx0aW5pdE1peGluJDEoVnVlKTtcblx0XHRpbml0RXh0ZW5kKFZ1ZSk7XG5cdFx0aW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG5cdH1cblxuXHRpbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlJDMucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuXHRcdGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcblx0fSk7XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuXHRcdGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0XHRyZXR1cm4gdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuXHRcdH1cblx0fSk7XG5cblx0VnVlJDMudmVyc2lvbiA9ICcyLjMuNCc7XG5cblx0LyogICovXG5cbi8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuLy8gZHVyaW5nIHRlbXBsYXRlIGNvbXBpbGF0aW9uXG5cdHZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcblx0dmFyIGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCcpO1xuXHR2YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCB0eXBlLCBhdHRyKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdChhdHRyID09PSAndmFsdWUnICYmIGFjY2VwdFZhbHVlKHRhZykpICYmIHR5cGUgIT09ICdidXR0b24nIHx8XG5cdFx0XHQoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuXHRcdFx0KGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG5cdFx0XHQoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG5cdFx0KVxuXHR9O1xuXG5cdHZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cblx0dmFyIGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKFxuXHRcdCdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuXHRcdCdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG5cdFx0J2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG5cdFx0J211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG5cdFx0J3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG5cdFx0J3RydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGUnXG5cdCk7XG5cblx0dmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cblx0dmFyIGlzWGxpbmsgPSBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcblx0fTtcblxuXHR2YXIgZ2V0WGxpbmtQcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcblx0fTtcblxuXHR2YXIgaXNGYWxzeUF0dHJWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxuXHR9O1xuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG5cdFx0dmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuXHRcdHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG5cdFx0dmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuXHRcdHdoaWxlIChpc0RlZihjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG5cdFx0XHRjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuXHRcdFx0aWYgKGNoaWxkTm9kZS5kYXRhKSB7XG5cdFx0XHRcdGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG5cdFx0XHRpZiAocGFyZW50Tm9kZS5kYXRhKSB7XG5cdFx0XHRcdGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZ2VuQ2xhc3NGcm9tRGF0YShkYXRhKVxuXHR9XG5cblx0ZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcblx0XHRcdGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcblx0XHRcdFx0PyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cblx0XHRcdFx0OiBwYXJlbnQuY2xhc3Ncblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5DbGFzc0Zyb21EYXRhIChkYXRhKSB7XG5cdFx0dmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG5cdFx0dmFyIHN0YXRpY0NsYXNzID0gZGF0YS5zdGF0aWNDbGFzcztcblx0XHRpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcblx0XHRcdHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG5cdFx0fVxuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0cmV0dXJuICcnXG5cdH1cblxuXHRmdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcblx0XHRyZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxuXHR9XG5cblx0ZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG5cdFx0aWYgKGlzVW5kZWYodmFsdWUpKSB7XG5cdFx0XHRyZXR1cm4gJydcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdH1cblx0XHR2YXIgcmVzID0gJyc7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHR2YXIgc3RyaW5naWZpZWQ7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoaXNEZWYodmFsdWVbaV0pKSB7XG5cdFx0XHRcdFx0aWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcblx0XHRcdFx0XHRcdHJlcyArPSBzdHJpbmdpZmllZCArICcgJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG5cdFx0fVxuXHRcdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRpZiAodmFsdWVba2V5XSkgeyByZXMgKz0ga2V5ICsgJyAnOyB9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuXHRcdH1cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdHJldHVybiByZXNcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBuYW1lc3BhY2VNYXAgPSB7XG5cdFx0c3ZnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdG1hdGg6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xuXHR9O1xuXG5cdHZhciBpc0hUTUxUYWcgPSBtYWtlTWFwKFxuXHRcdCdodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSwnICtcblx0XHQnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuXHRcdCdkaXYsZGQsZGwsZHQsZmlnY2FwdGlvbixmaWd1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG5cdFx0J2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcblx0XHQncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG5cdFx0J2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuXHRcdCdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcblx0XHQnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcblx0XHQnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcblx0XHQnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuXHRcdCdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlJ1xuXHQpO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG5cdHZhciBpc1NWRyA9IG1ha2VNYXAoXG5cdFx0J3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcblx0XHQnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG5cdFx0J3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuXHRcdHRydWVcblx0KTtcblxuXHR2YXIgaXNQcmVUYWcgPSBmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcgPT09ICdwcmUnOyB9O1xuXG5cdHZhciBpc1Jlc2VydmVkVGFnID0gZnVuY3Rpb24gKHRhZykge1xuXHRcdHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG5cdH07XG5cblx0ZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlICh0YWcpIHtcblx0XHRpZiAoaXNTVkcodGFnKSkge1xuXHRcdFx0cmV0dXJuICdzdmcnXG5cdFx0fVxuXHRcdC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuXHRcdC8vIG5vdGUgaXQgZG9lc24ndCBzdXBwb3J0IG90aGVyIE1hdGhNTCBlbGVtZW50cyBiZWluZyBjb21wb25lbnQgcm9vdHNcblx0XHRpZiAodGFnID09PSAnbWF0aCcpIHtcblx0XHRcdHJldHVybiAnbWF0aCdcblx0XHR9XG5cdH1cblxuXHR2YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQgKHRhZykge1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmICghaW5Ccm93c2VyKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0XHRpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHR9XG5cdFx0dGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSAhPSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG5cdFx0fVxuXHRcdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcblx0XHRpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG5cdFx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG5cdFx0XHRyZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IChcblx0XHRcdFx0ZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcblx0XHRcdFx0ZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudFxuXHRcdFx0KSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAvSFRNTFVua25vd25FbGVtZW50Ly50ZXN0KGVsLnRvU3RyaW5nKCkpKVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdC8qKlxuXHQgKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cblx0ICovXG5cdGZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuXHRcdGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcblx0XHRcdGlmICghc2VsZWN0ZWQpIHtcblx0XHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybihcblx0XHRcdFx0XHQnQ2Fubm90IGZpbmQgZWxlbWVudDogJyArIGVsXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHNlbGVjdGVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBlbFxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSAodGFnTmFtZSwgdm5vZGUpIHtcblx0XHR2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblx0XHRpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcblx0XHRcdHJldHVybiBlbG1cblx0XHR9XG5cdFx0Ly8gZmFsc2Ugb3IgbnVsbCB3aWxsIHJlbW92ZSB0aGUgYXR0cmlidXRlIGJ1dCB1bmRlZmluZWQgd2lsbCBub3Rcblx0XHRpZiAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzICYmIHZub2RlLmRhdGEuYXR0cnMubXVsdGlwbGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsbVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZU1hcFtuYW1lc3BhY2VdLCB0YWdOYW1lKVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dClcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0ZXh0KVxuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG5cdFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSk7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcblx0XHRub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuXHRcdG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuXHRcdHJldHVybiBub2RlLnBhcmVudE5vZGVcblx0fVxuXG5cdGZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG5cdFx0cmV0dXJuIG5vZGUubmV4dFNpYmxpbmdcblx0fVxuXG5cdGZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcblx0XHRyZXR1cm4gbm9kZS50YWdOYW1lXG5cdH1cblxuXHRmdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuXHRcdG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0QXR0cmlidXRlIChub2RlLCBrZXksIHZhbCkge1xuXHRcdG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcblx0fVxuXG5cblx0dmFyIG5vZGVPcHMgPSBPYmplY3QuZnJlZXplKHtcblx0XHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdFx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdFx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuXHRcdGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG5cdFx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdFx0cmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuXHRcdGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcblx0XHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRcdG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcblx0XHR0YWdOYW1lOiB0YWdOYW1lLFxuXHRcdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0XHRzZXRBdHRyaWJ1dGU6IHNldEF0dHJpYnV0ZVxuXHR9KTtcblxuXHQvKiAgKi9cblxuXHR2YXIgcmVmID0ge1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlIChfLCB2bm9kZSkge1xuXHRcdFx0cmVnaXN0ZXJSZWYodm5vZGUpO1xuXHRcdH0sXG5cdFx0dXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuXHRcdFx0aWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuXHRcdFx0XHRyZWdpc3RlclJlZihvbGRWbm9kZSwgdHJ1ZSk7XG5cdFx0XHRcdHJlZ2lzdGVyUmVmKHZub2RlKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG5cdFx0XHRyZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG5cdFx0dmFyIGtleSA9IHZub2RlLmRhdGEucmVmO1xuXHRcdGlmICgha2V5KSB7IHJldHVybiB9XG5cblx0XHR2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuXHRcdHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG5cdFx0dmFyIHJlZnMgPSB2bS4kcmVmcztcblx0XHRpZiAoaXNSZW1vdmFsKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG5cdFx0XHRcdHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG5cdFx0XHR9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG5cdFx0XHRcdHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSAmJiByZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuXHRcdFx0XHRcdHJlZnNba2V5XS5wdXNoKHJlZik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVmc1trZXldID0gW3JlZl07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlZnNba2V5XSA9IHJlZjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG5cdCAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcblx0ICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuXHQgKlxuXHQgKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcblx0ICpcblxuXHQgLypcblx0ICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuXHQgKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cblx0ICovXG5cblx0dmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxuXHR2YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuXHRmdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0YS5rZXkgPT09IGIua2V5ICYmXG5cdFx0XHRhLnRhZyA9PT0gYi50YWcgJiZcblx0XHRcdGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuXHRcdFx0aXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuXHRcdFx0c2FtZUlucHV0VHlwZShhLCBiKVxuXHRcdClcblx0fVxuXG4vLyBTb21lIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGR5bmFtaWNhbGx5IGNoYW5naW5nIHR5cGUgZm9yIDxpbnB1dD5cbi8vIHNvIHRoZXkgbmVlZCB0byBiZSB0cmVhdGVkIGFzIGRpZmZlcmVudCBub2Rlc1xuXHRmdW5jdGlvbiBzYW1lSW5wdXRUeXBlIChhLCBiKSB7XG5cdFx0aWYgKGEudGFnICE9PSAnaW5wdXQnKSB7IHJldHVybiB0cnVlIH1cblx0XHR2YXIgaTtcblx0XHR2YXIgdHlwZUEgPSBpc0RlZihpID0gYS5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuXHRcdHZhciB0eXBlQiA9IGlzRGVmKGkgPSBiLmRhdGEpICYmIGlzRGVmKGkgPSBpLmF0dHJzKSAmJiBpLnR5cGU7XG5cdFx0cmV0dXJuIHR5cGVBID09PSB0eXBlQlxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG5cdFx0dmFyIGksIGtleTtcblx0XHR2YXIgbWFwID0ge307XG5cdFx0Zm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcblx0XHRcdGtleSA9IGNoaWxkcmVuW2ldLmtleTtcblx0XHRcdGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuXHRcdH1cblx0XHRyZXR1cm4gbWFwXG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG5cdFx0dmFyIGksIGo7XG5cdFx0dmFyIGNicyA9IHt9O1xuXG5cdFx0dmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG5cdFx0dmFyIG5vZGVPcHMgPSBiYWNrZW5kLm5vZGVPcHM7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyArK2kpIHtcblx0XHRcdGNic1tob29rc1tpXV0gPSBbXTtcblx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcblx0XHRcdFx0XHRjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuXHRcdFx0cmV0dXJuIG5ldyBWTm9kZShub2RlT3BzLnRhZ05hbWUoZWxtKS50b0xvd2VyQ2FzZSgpLCB7fSwgW10sIHVuZGVmaW5lZCwgZWxtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcblx0XHRcdGZ1bmN0aW9uIHJlbW92ZSQkMSAoKSB7XG5cdFx0XHRcdGlmICgtLXJlbW92ZSQkMS5saXN0ZW5lcnMgPT09IDApIHtcblx0XHRcdFx0XHRyZW1vdmVOb2RlKGNoaWxkRWxtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcblx0XHRcdHJldHVybiByZW1vdmUkJDFcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVOb2RlIChlbCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbCk7XG5cdFx0XHQvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcblx0XHRcdGlmIChpc0RlZihwYXJlbnQpKSB7XG5cdFx0XHRcdG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGluUHJlID0gMDtcblx0XHRmdW5jdGlvbiBjcmVhdGVFbG0gKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQpIHtcblx0XHRcdHZub2RlLmlzUm9vdEluc2VydCA9ICFuZXN0ZWQ7IC8vIGZvciB0cmFuc2l0aW9uIGVudGVyIGNoZWNrXG5cdFx0XHRpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0dmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG5cdFx0XHR2YXIgdGFnID0gdm5vZGUudGFnO1xuXHRcdFx0aWYgKGlzRGVmKHRhZykpIHtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG5cdFx0XHRcdFx0XHRpblByZSsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHQhaW5QcmUgJiZcblx0XHRcdFx0XHRcdCF2bm9kZS5ucyAmJlxuXHRcdFx0XHRcdFx0IShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJiBjb25maWcuaWdub3JlZEVsZW1lbnRzLmluZGV4T2YodGFnKSA+IC0xKSAmJlxuXHRcdFx0XHRcdFx0Y29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdFx0J1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuXHRcdFx0XHRcdFx0XHQncmVnaXN0ZXIgdGhlIGNvbXBvbmVudCBjb3JyZWN0bHk/IEZvciByZWN1cnNpdmUgY29tcG9uZW50cywgJyArXG5cdFx0XHRcdFx0XHRcdCdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG5cdFx0XHRcdFx0XHRcdHZub2RlLmNvbnRleHRcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHZub2RlLmVsbSA9IHZub2RlLm5zXG5cdFx0XHRcdFx0PyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuXHRcdFx0XHRcdDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuXHRcdFx0XHRzZXRTY29wZSh2bm9kZSk7XG5cblx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdFx0XHRcdFx0aWYgKGlzRGVmKGRhdGEpKSB7XG5cdFx0XHRcdFx0XHRpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGRhdGEgJiYgZGF0YS5wcmUpIHtcblx0XHRcdFx0XHRpblByZS0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG5cdFx0XHRcdHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcblx0XHRcdFx0aW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcblx0XHRcdFx0aW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcblx0XHRcdHZhciBpID0gdm5vZGUuZGF0YTtcblx0XHRcdGlmIChpc0RlZihpKSkge1xuXHRcdFx0XHR2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcblx0XHRcdFx0aWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG5cdFx0XHRcdFx0aSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcblx0XHRcdFx0Ly8gaXQgc2hvdWxkJ3ZlIGNyZWF0ZWQgYSBjaGlsZCBpbnN0YW5jZSBhbmQgbW91bnRlZCBpdC4gdGhlIGNoaWxkXG5cdFx0XHRcdC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuXHRcdFx0XHQvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuXHRcdFx0XHRpZiAoaXNEZWYodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG5cdFx0XHRcdFx0aW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0XHRcdFx0XHRpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG5cdFx0XHRcdFx0XHRyZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcblx0XHRcdGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG5cdFx0XHRcdGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcblx0XHRcdFx0dm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcblx0XHRcdGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcblx0XHRcdFx0aW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdFx0XHRcdHNldFNjb3BlKHZub2RlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuXHRcdFx0XHQvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG5cdFx0XHRcdHJlZ2lzdGVyUmVmKHZub2RlKTtcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcblx0XHRcdFx0aW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cblx0XHRcdC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcblx0XHRcdC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuXHRcdFx0Ly8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cblx0XHRcdHZhciBpbm5lck5vZGUgPSB2bm9kZTtcblx0XHRcdHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcblx0XHRcdFx0aW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcblx0XHRcdFx0aWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0XHRjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuXHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuXHRcdFx0Ly8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcblx0XHRcdGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYpIHtcblx0XHRcdGlmIChpc0RlZihwYXJlbnQpKSB7XG5cdFx0XHRcdGlmIChpc0RlZihyZWYpKSB7XG5cdFx0XHRcdFx0aWYgKHJlZi5wYXJlbnROb2RlID09PSBwYXJlbnQpIHtcblx0XHRcdFx0XHRcdG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuXHRcdFx0XHRub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG5cdFx0XHR3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcblx0XHRcdFx0dm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG5cdFx0XHRmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcblx0XHRcdFx0Y2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuXHRcdFx0fVxuXHRcdFx0aSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcblx0XHRcdGlmIChpc0RlZihpKSkge1xuXHRcdFx0XHRpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG5cdFx0XHRcdGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cblx0XHQvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuXHRcdC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cblx0XHRmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0dmFyIGFuY2VzdG9yID0gdm5vZGU7XG5cdFx0XHR3aGlsZSAoYW5jZXN0b3IpIHtcblx0XHRcdFx0aWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcblx0XHRcdFx0XHRub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcblx0XHRcdH1cblx0XHRcdC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cblx0XHRcdGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG5cdFx0XHRcdGkgIT09IHZub2RlLmNvbnRleHQgJiZcblx0XHRcdFx0aXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpXG5cdFx0XHQpIHtcblx0XHRcdFx0bm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcblx0XHRcdGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcblx0XHRcdFx0Y3JlYXRlRWxtKHZub2Rlc1tzdGFydElkeF0sIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rICh2bm9kZSkge1xuXHRcdFx0dmFyIGksIGo7XG5cdFx0XHR2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG5cdFx0XHRpZiAoaXNEZWYoZGF0YSkpIHtcblx0XHRcdFx0aWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cblx0XHRcdH1cblx0XHRcdGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG5cdFx0XHRcdGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdGludm9rZURlc3Ryb3lIb29rKHZub2RlLmNoaWxkcmVuW2pdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcblx0XHRcdGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcblx0XHRcdFx0dmFyIGNoID0gdm5vZGVzW3N0YXJ0SWR4XTtcblx0XHRcdFx0aWYgKGlzRGVmKGNoKSkge1xuXHRcdFx0XHRcdGlmIChpc0RlZihjaC50YWcpKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGNoKTtcblx0XHRcdFx0XHRcdGludm9rZURlc3Ryb3lIb29rKGNoKTtcblx0XHRcdFx0XHR9IGVsc2UgeyAvLyBUZXh0IG5vZGVcblx0XHRcdFx0XHRcdHJlbW92ZU5vZGUoY2guZWxtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rICh2bm9kZSwgcm0pIHtcblx0XHRcdGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcblx0XHRcdFx0dmFyIGk7XG5cdFx0XHRcdHZhciBsaXN0ZW5lcnMgPSBjYnMucmVtb3ZlLmxlbmd0aCArIDE7XG5cdFx0XHRcdGlmIChpc0RlZihybSkpIHtcblx0XHRcdFx0XHQvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcblx0XHRcdFx0XHQvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG5cdFx0XHRcdFx0cm0ubGlzdGVuZXJzICs9IGxpc3RlbmVycztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBkaXJlY3RseSByZW1vdmluZ1xuXHRcdFx0XHRcdHJtID0gY3JlYXRlUm1DYih2bm9kZS5lbG0sIGxpc3RlbmVycyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcblx0XHRcdFx0aWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG5cdFx0XHRcdFx0cmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcblx0XHRcdFx0XHRjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcblx0XHRcdFx0XHRpKHZub2RlLCBybSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm0oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVtb3ZlTm9kZSh2bm9kZS5lbG0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG5cdFx0XHR2YXIgb2xkU3RhcnRJZHggPSAwO1xuXHRcdFx0dmFyIG5ld1N0YXJ0SWR4ID0gMDtcblx0XHRcdHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuXHRcdFx0dmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcblx0XHRcdHZhciBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG5cdFx0XHR2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcblx0XHRcdHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG5cdFx0XHR2YXIgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuXHRcdFx0dmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCByZWZFbG07XG5cblx0XHRcdC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuXHRcdFx0Ly8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuXHRcdFx0Ly8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcblx0XHRcdHZhciBjYW5Nb3ZlID0gIXJlbW92ZU9ubHk7XG5cblx0XHRcdHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG5cdFx0XHRcdGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG5cdFx0XHRcdFx0b2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcblx0XHRcdFx0XHRvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcblx0XHRcdFx0fSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcblx0XHRcdFx0XHRwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdFx0XHRcdFx0b2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuXHRcdFx0XHRcdG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcblx0XHRcdFx0fSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuXHRcdFx0XHRcdHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHRcdFx0XHRcdG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuXHRcdFx0XHRcdG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcblx0XHRcdFx0XHRwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHRcdFx0XHRcdGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcblx0XHRcdFx0XHRvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG5cdFx0XHRcdFx0bmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG5cdFx0XHRcdH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG5cdFx0XHRcdFx0cGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0XHRcdFx0XHRjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkRW5kVm5vZGUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG5cdFx0XHRcdFx0b2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG5cdFx0XHRcdFx0bmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuXHRcdFx0XHRcdGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcblx0XHRcdFx0XHRpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcblx0XHRcdFx0XHRcdGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuXHRcdFx0XHRcdFx0bmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG5cdFx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdFx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhZWxtVG9Nb3ZlKSB7XG5cdFx0XHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHRcdFx0J0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcblx0XHRcdFx0XHRcdFx0XHQnTWFrZSBzdXJlIGVhY2ggdi1mb3IgaXRlbSBoYXMgYSB1bmlxdWUga2V5Lidcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChzYW1lVm5vZGUoZWxtVG9Nb3ZlLCBuZXdTdGFydFZub2RlKSkge1xuXHRcdFx0XHRcdFx0XHRwYXRjaFZub2RlKGVsbVRvTW92ZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0XHRcdFx0XHRcdFx0b2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgbmV3U3RhcnRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcblx0XHRcdFx0XHRcdFx0bmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcblx0XHRcdFx0XHRcdFx0bmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG5cdFx0XHRcdHJlZkVsbSA9IGlzVW5kZWYobmV3Q2hbbmV3RW5kSWR4ICsgMV0pID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLmVsbTtcblx0XHRcdFx0YWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblx0XHRcdH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcblx0XHRcdFx0cmVtb3ZlVm5vZGVzKHBhcmVudEVsbSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhdGNoVm5vZGUgKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG5cdFx0XHRpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuXHRcdFx0Ly8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG5cdFx0XHQvLyBpZiB0aGUgbmV3IG5vZGUgaXMgbm90IGNsb25lZCBpdCBtZWFucyB0aGUgcmVuZGVyIGZ1bmN0aW9ucyBoYXZlIGJlZW5cblx0XHRcdC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG5cdFx0XHRpZiAoaXNUcnVlKHZub2RlLmlzU3RhdGljKSAmJlxuXHRcdFx0XHRpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG5cdFx0XHRcdHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG5cdFx0XHRcdChpc1RydWUodm5vZGUuaXNDbG9uZWQpIHx8IGlzVHJ1ZSh2bm9kZS5pc09uY2UpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblx0XHRcdFx0dm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHR2YXIgaTtcblx0XHRcdHZhciBkYXRhID0gdm5vZGUuZGF0YTtcblx0XHRcdGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcblx0XHRcdFx0aShvbGRWbm9kZSwgdm5vZGUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcblx0XHRcdHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuXHRcdFx0dmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG5cdFx0XHRpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuXHRcdFx0XHRpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cblx0XHRcdH1cblx0XHRcdGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG5cdFx0XHRcdGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG5cdFx0XHRcdFx0aWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuXHRcdFx0XHRcdGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG5cdFx0XHRcdFx0YWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG5cdFx0XHRcdFx0cmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG5cdFx0XHRcdFx0bm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG5cdFx0XHRcdG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcblx0XHRcdH1cblx0XHRcdGlmIChpc0RlZihkYXRhKSkge1xuXHRcdFx0XHRpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcblx0XHRcdC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuXHRcdFx0Ly8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcblx0XHRcdGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuXHRcdFx0XHR2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG5cdFx0XHRcdFx0cXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgYmFpbGVkID0gZmFsc2U7XG5cdFx0Ly8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcblx0XHQvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuXHRcdHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsc3R5bGUsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cblx0XHQvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuXHRcdGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuXHRcdFx0e1xuXHRcdFx0XHRpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2bm9kZS5lbG0gPSBlbG07XG5cdFx0XHR2YXIgdGFnID0gdm5vZGUudGFnO1xuXHRcdFx0dmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG5cdFx0XHRpZiAoaXNEZWYoZGF0YSkpIHtcblx0XHRcdFx0aWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuXHRcdFx0XHRpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuXHRcdFx0XHRcdC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuXHRcdFx0XHRcdGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlzRGVmKHRhZykpIHtcblx0XHRcdFx0aWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuXHRcdFx0XHRcdC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuXHRcdFx0XHRcdGlmICghZWxtLmhhc0NoaWxkTm9kZXMoKSkge1xuXHRcdFx0XHRcdFx0Y3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG5cdFx0XHRcdFx0XHR2YXIgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdFx0XHRmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjaGlsZHJlbi5sZW5ndGg7IGkkMSsrKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcblx0XHRcdFx0XHRcdC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG5cdFx0XHRcdFx0XHRpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0XHRcdFx0XHRcdCFiYWlsZWRcblx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0YmFpbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcblx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGlzRGVmKGRhdGEpKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGRhdGEpIHtcblx0XHRcdFx0XHRcdGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG5cdFx0XHRcdFx0XHRcdGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuXHRcdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuXHRcdFx0XHRlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcblx0XHRcdGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0dm5vZGUudGFnLmluZGV4T2YoJ3Z1ZS1jb21wb25lbnQnKSA9PT0gMCB8fFxuXHRcdFx0XHRcdHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHksIHBhcmVudEVsbSwgcmVmRWxtKSB7XG5cdFx0XHRpZiAoaXNVbmRlZih2bm9kZSkpIHtcblx0XHRcdFx0aWYgKGlzRGVmKG9sZFZub2RlKSkgeyBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7IH1cblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuXHRcdFx0dmFyIGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuXG5cdFx0XHRpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcblx0XHRcdFx0Ly8gZW1wdHkgbW91bnQgKGxpa2VseSBhcyBjb21wb25lbnQpLCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuXHRcdFx0XHRpc0luaXRpYWxQYXRjaCA9IHRydWU7XG5cdFx0XHRcdGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcblx0XHRcdFx0aWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG5cdFx0XHRcdFx0Ly8gcGF0Y2ggZXhpc3Rpbmcgcm9vdCBub2RlXG5cdFx0XHRcdFx0cGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGlzUmVhbEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG5cdFx0XHRcdFx0XHQvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuXHRcdFx0XHRcdFx0Ly8gYSBzdWNjZXNzZnVsIGh5ZHJhdGlvbi5cblx0XHRcdFx0XHRcdGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG5cdFx0XHRcdFx0XHRcdG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG5cdFx0XHRcdFx0XHRcdGh5ZHJhdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGh5ZHJhdGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gb2xkVm5vZGVcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0XHRcdFx0J1RoZSBjbGllbnQtc2lkZSByZW5kZXJlZCB2aXJ0dWFsIERPTSB0cmVlIGlzIG5vdCBtYXRjaGluZyAnICtcblx0XHRcdFx0XHRcdFx0XHRcdCdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcblx0XHRcdFx0XHRcdFx0XHRcdCdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG5cdFx0XHRcdFx0XHRcdFx0XHQnPHA+LCBvciBtaXNzaW5nIDx0Ym9keT4uIEJhaWxpbmcgaHlkcmF0aW9uIGFuZCBwZXJmb3JtaW5nICcgK1xuXHRcdFx0XHRcdFx0XHRcdFx0J2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cblx0XHRcdFx0XHRcdC8vIGNyZWF0ZSBhbiBlbXB0eSBub2RlIGFuZCByZXBsYWNlIGl0XG5cdFx0XHRcdFx0XHRvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcblx0XHRcdFx0XHR2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuXHRcdFx0XHRcdHZhciBwYXJlbnRFbG0kMSA9IG5vZGVPcHMucGFyZW50Tm9kZShvbGRFbG0pO1xuXHRcdFx0XHRcdGNyZWF0ZUVsbShcblx0XHRcdFx0XHRcdHZub2RlLFxuXHRcdFx0XHRcdFx0aW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuXHRcdFx0XHRcdFx0Ly8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcblx0XHRcdFx0XHRcdC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuXHRcdFx0XHRcdFx0Ly8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcblx0XHRcdFx0XHRcdG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcblx0XHRcdFx0XHRcdG5vZGVPcHMubmV4dFNpYmxpbmcob2xkRWxtKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoaXNEZWYodm5vZGUucGFyZW50KSkge1xuXHRcdFx0XHRcdFx0Ly8gY29tcG9uZW50IHJvb3QgZWxlbWVudCByZXBsYWNlZC5cblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0dmFyIGFuY2VzdG9yID0gdm5vZGUucGFyZW50O1xuXHRcdFx0XHRcdFx0d2hpbGUgKGFuY2VzdG9yKSB7XG5cdFx0XHRcdFx0XHRcdGFuY2VzdG9yLmVsbSA9IHZub2RlLmVsbTtcblx0XHRcdFx0XHRcdFx0YW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdFx0XHRcdGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGlzRGVmKHBhcmVudEVsbSQxKSkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRhZykpIHtcblx0XHRcdFx0XHRcdGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG5cdFx0XHRyZXR1cm4gdm5vZGUuZWxtXG5cdFx0fVxuXHR9XG5cblx0LyogICovXG5cblx0dmFyIGRpcmVjdGl2ZXMgPSB7XG5cdFx0Y3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuXHRcdHVwZGF0ZTogdXBkYXRlRGlyZWN0aXZlcyxcblx0XHRkZXN0cm95OiBmdW5jdGlvbiB1bmJpbmREaXJlY3RpdmVzICh2bm9kZSkge1xuXHRcdFx0dXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG5cdFx0aWYgKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcyB8fCB2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcblx0XHRcdF91cGRhdGUob2xkVm5vZGUsIHZub2RlKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBfdXBkYXRlIChvbGRWbm9kZSwgdm5vZGUpIHtcblx0XHR2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuXHRcdHZhciBpc0Rlc3Ryb3kgPSB2bm9kZSA9PT0gZW1wdHlOb2RlO1xuXHRcdHZhciBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyQxKG9sZFZub2RlLmRhdGEuZGlyZWN0aXZlcywgb2xkVm5vZGUuY29udGV4dCk7XG5cdFx0dmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuXHRcdHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuXHRcdHZhciBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuXG5cdFx0dmFyIGtleSwgb2xkRGlyLCBkaXI7XG5cdFx0Zm9yIChrZXkgaW4gbmV3RGlycykge1xuXHRcdFx0b2xkRGlyID0gb2xkRGlyc1trZXldO1xuXHRcdFx0ZGlyID0gbmV3RGlyc1trZXldO1xuXHRcdFx0aWYgKCFvbGREaXIpIHtcblx0XHRcdFx0Ly8gbmV3IGRpcmVjdGl2ZSwgYmluZFxuXHRcdFx0XHRjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuXHRcdFx0XHRpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG5cdFx0XHRcdFx0ZGlyc1dpdGhJbnNlcnQucHVzaChkaXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuXHRcdFx0XHRkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG5cdFx0XHRcdGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcblx0XHRcdFx0aWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG5cdFx0XHRcdFx0ZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuXHRcdFx0dmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0aWYgKGlzQ3JlYXRlKSB7XG5cdFx0XHRcdG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYWxsSW5zZXJ0KCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuXHRcdFx0bWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICghaXNDcmVhdGUpIHtcblx0XHRcdGZvciAoa2V5IGluIG9sZERpcnMpIHtcblx0XHRcdFx0aWYgKCFuZXdEaXJzW2tleV0pIHtcblx0XHRcdFx0XHQvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG5cdFx0XHRcdFx0Y2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG5cdFx0ZGlycyxcblx0XHR2bVxuXHQpIHtcblx0XHR2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRpZiAoIWRpcnMpIHtcblx0XHRcdHJldHVybiByZXNcblx0XHR9XG5cdFx0dmFyIGksIGRpcjtcblx0XHRmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZGlyID0gZGlyc1tpXTtcblx0XHRcdGlmICghZGlyLm1vZGlmaWVycykge1xuXHRcdFx0XHRkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG5cdFx0XHR9XG5cdFx0XHRyZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcblx0XHRcdGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzXG5cdH1cblxuXHRmdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcblx0XHRyZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxuXHR9XG5cblx0ZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuXHRcdHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgYmFzZU1vZHVsZXMgPSBbXG5cdFx0cmVmLFxuXHRcdGRpcmVjdGl2ZXNcblx0XTtcblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG5cdFx0aWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHZhciBrZXksIGN1ciwgb2xkO1xuXHRcdHZhciBlbG0gPSB2bm9kZS5lbG07XG5cdFx0dmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcblx0XHR2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuXHRcdC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuXHRcdGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG5cdFx0XHRhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcblx0XHR9XG5cblx0XHRmb3IgKGtleSBpbiBhdHRycykge1xuXHRcdFx0Y3VyID0gYXR0cnNba2V5XTtcblx0XHRcdG9sZCA9IG9sZEF0dHJzW2tleV07XG5cdFx0XHRpZiAob2xkICE9PSBjdXIpIHtcblx0XHRcdFx0c2V0QXR0cihlbG0sIGtleSwgY3VyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoaXNJRTkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG5cdFx0XHRzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuXHRcdH1cblx0XHRmb3IgKGtleSBpbiBvbGRBdHRycykge1xuXHRcdFx0aWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcblx0XHRcdFx0aWYgKGlzWGxpbmsoa2V5KSkge1xuXHRcdFx0XHRcdGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuXHRcdFx0XHRcdGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG5cdFx0aWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuXHRcdFx0Ly8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcblx0XHRcdC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG5cdFx0XHRpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcblx0XHRcdFx0ZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBrZXkpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG5cdFx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJyA/ICdmYWxzZScgOiAndHJ1ZScpO1xuXHRcdH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG5cdFx0XHRpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcblx0XHRcdFx0ZWwucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuXHRcdFx0XHRlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR2YXIgYXR0cnMgPSB7XG5cdFx0Y3JlYXRlOiB1cGRhdGVBdHRycyxcblx0XHR1cGRhdGU6IHVwZGF0ZUF0dHJzXG5cdH07XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuXHRcdHZhciBlbCA9IHZub2RlLmVsbTtcblx0XHR2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG5cdFx0dmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXHRcdGlmIChcblx0XHRcdGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcblx0XHRcdGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuXHRcdFx0XHRpc1VuZGVmKG9sZERhdGEpIHx8IChcblx0XHRcdFx0XHRpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG5cdFx0XHRcdFx0aXNVbmRlZihvbGREYXRhLmNsYXNzKVxuXHRcdFx0XHQpXG5cdFx0XHQpXG5cdFx0KSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHR2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cblx0XHQvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG5cdFx0dmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3Nlcztcblx0XHRpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuXHRcdFx0Y2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG5cdFx0fVxuXG5cdFx0Ly8gc2V0IHRoZSBjbGFzc1xuXHRcdGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcblx0XHRcdGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuXHRcdFx0ZWwuX3ByZXZDbGFzcyA9IGNscztcblx0XHR9XG5cdH1cblxuXHR2YXIga2xhc3MgPSB7XG5cdFx0Y3JlYXRlOiB1cGRhdGVDbGFzcyxcblx0XHR1cGRhdGU6IHVwZGF0ZUNsYXNzXG5cdH07XG5cblx0LyogICovXG5cblx0dmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cblx0ZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcblx0XHR2YXIgaW5TaW5nbGUgPSBmYWxzZTtcblx0XHR2YXIgaW5Eb3VibGUgPSBmYWxzZTtcblx0XHR2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuXHRcdHZhciBpblJlZ2V4ID0gZmFsc2U7XG5cdFx0dmFyIGN1cmx5ID0gMDtcblx0XHR2YXIgc3F1YXJlID0gMDtcblx0XHR2YXIgcGFyZW4gPSAwO1xuXHRcdHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuXHRcdHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuXHRcdFx0cHJldiA9IGM7XG5cdFx0XHRjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRpZiAoaW5TaW5nbGUpIHtcblx0XHRcdFx0aWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG5cdFx0XHR9IGVsc2UgaWYgKGluRG91YmxlKSB7XG5cdFx0XHRcdGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuXHRcdFx0fSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG5cdFx0XHRcdGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG5cdFx0XHR9IGVsc2UgaWYgKGluUmVnZXgpIHtcblx0XHRcdFx0aWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuXHRcdFx0XHRleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcblx0XHRcdFx0ZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG5cdFx0XHRcdCFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHQvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG5cdFx0XHRcdFx0bGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cHVzaEZpbHRlcigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzd2l0Y2ggKGMpIHtcblx0XHRcdFx0XHRjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuXHRcdFx0XHRcdGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcblx0XHRcdFx0XHRjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG5cdFx0XHRcdFx0Y2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuXHRcdFx0XHRcdGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcblx0XHRcdFx0XHRjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG5cdFx0XHRcdFx0Y2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuXHRcdFx0XHRcdGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcblx0XHRcdFx0XHRjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuXHRcdFx0XHRcdHZhciBqID0gaSAtIDE7XG5cdFx0XHRcdFx0dmFyIHAgPSAodm9pZCAwKTtcblx0XHRcdFx0XHQvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuXHRcdFx0XHRcdGZvciAoOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdFx0cCA9IGV4cC5jaGFyQXQoaik7XG5cdFx0XHRcdFx0XHRpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcblx0XHRcdFx0XHRcdGluUmVnZXggPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuXHRcdH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG5cdFx0XHRwdXNoRmlsdGVyKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG5cdFx0XHQoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuXHRcdFx0bGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG5cdFx0fVxuXG5cdFx0aWYgKGZpbHRlcnMpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBleHByZXNzaW9uXG5cdH1cblxuXHRmdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuXHRcdHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcblx0XHRpZiAoaSA8IDApIHtcblx0XHRcdC8vIF9mOiByZXNvbHZlRmlsdGVyXG5cdFx0XHRyZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcblx0XHRcdHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcblx0XHRcdHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBiYXNlV2FybiAobXNnKSB7XG5cdFx0Y29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBsdWNrTW9kdWxlRnVuY3Rpb24gKFxuXHRcdG1vZHVsZXMsXG5cdFx0a2V5XG5cdCkge1xuXHRcdHJldHVybiBtb2R1bGVzXG5cdFx0XHQ/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcblx0XHRcdDogW11cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuXHRcdChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2goeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUgfSk7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcblx0XHQoZWwuYXR0cnMgfHwgKGVsLmF0dHJzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcblx0XHRlbCxcblx0XHRuYW1lLFxuXHRcdHJhd05hbWUsXG5cdFx0dmFsdWUsXG5cdFx0YXJnLFxuXHRcdG1vZGlmaWVyc1xuXHQpIHtcblx0XHQoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHJhd05hbWU6IHJhd05hbWUsIHZhbHVlOiB2YWx1ZSwgYXJnOiBhcmcsIG1vZGlmaWVyczogbW9kaWZpZXJzIH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkSGFuZGxlciAoXG5cdFx0ZWwsXG5cdFx0bmFtZSxcblx0XHR2YWx1ZSxcblx0XHRtb2RpZmllcnMsXG5cdFx0aW1wb3J0YW50LFxuXHRcdHdhcm5cblx0KSB7XG5cdFx0Ly8gd2FybiBwcmV2ZW50IGFuZCBwYXNzaXZlIG1vZGlmaWVyXG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKFxuXHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiAmJlxuXHRcdFx0bW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG5cdFx0KSB7XG5cdFx0XHR3YXJuKFxuXHRcdFx0XHQncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuXHRcdFx0XHQnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50Lidcblx0XHRcdCk7XG5cdFx0fVxuXHRcdC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcblx0XHRpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5jYXB0dXJlKSB7XG5cdFx0XHRkZWxldGUgbW9kaWZpZXJzLmNhcHR1cmU7XG5cdFx0XHRuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcblx0XHR9XG5cdFx0aWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMub25jZSkge1xuXHRcdFx0ZGVsZXRlIG1vZGlmaWVycy5vbmNlO1xuXHRcdFx0bmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2Vcblx0XHR9XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKG1vZGlmaWVycyAmJiBtb2RpZmllcnMucGFzc2l2ZSkge1xuXHRcdFx0ZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuXHRcdFx0bmFtZSA9ICcmJyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIHBhc3NpdmVcblx0XHR9XG5cdFx0dmFyIGV2ZW50cztcblx0XHRpZiAobW9kaWZpZXJzICYmIG1vZGlmaWVycy5uYXRpdmUpIHtcblx0XHRcdGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuXHRcdFx0ZXZlbnRzID0gZWwubmF0aXZlRXZlbnRzIHx8IChlbC5uYXRpdmVFdmVudHMgPSB7fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuXHRcdH1cblx0XHR2YXIgbmV3SGFuZGxlciA9IHsgdmFsdWU6IHZhbHVlLCBtb2RpZmllcnM6IG1vZGlmaWVycyB9O1xuXHRcdHZhciBoYW5kbGVycyA9IGV2ZW50c1tuYW1lXTtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVycykpIHtcblx0XHRcdGltcG9ydGFudCA/IGhhbmRsZXJzLnVuc2hpZnQobmV3SGFuZGxlcikgOiBoYW5kbGVycy5wdXNoKG5ld0hhbmRsZXIpO1xuXHRcdH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcblx0XHRcdGV2ZW50c1tuYW1lXSA9IGltcG9ydGFudCA/IFtuZXdIYW5kbGVyLCBoYW5kbGVyc10gOiBbaGFuZGxlcnMsIG5ld0hhbmRsZXJdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcblx0XHRlbCxcblx0XHRuYW1lLFxuXHRcdGdldFN0YXRpY1xuXHQpIHtcblx0XHR2YXIgZHluYW1pY1ZhbHVlID1cblx0XHRcdGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG5cdFx0XHRnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcblx0XHRpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcblx0XHRcdHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuXHRcdH0gZWxzZSBpZiAoZ2V0U3RhdGljICE9PSBmYWxzZSkge1xuXHRcdFx0dmFyIHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG5cdFx0XHRpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoZWwsIG5hbWUpIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICgodmFsID0gZWwuYXR0cnNNYXBbbmFtZV0pICE9IG51bGwpIHtcblx0XHRcdHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG5cdFx0XHRcdFx0bGlzdC5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdmFsXG5cdH1cblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuXHRcdGVsLFxuXHRcdHZhbHVlLFxuXHRcdG1vZGlmaWVyc1xuXHQpIHtcblx0XHR2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuXHRcdHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuXHRcdHZhciB0cmltID0gcmVmLnRyaW07XG5cblx0XHR2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuXHRcdHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuXHRcdGlmICh0cmltKSB7XG5cdFx0XHR2YWx1ZUV4cHJlc3Npb24gPVxuXHRcdFx0XHRcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuXHRcdFx0XHRcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuXHRcdFx0XHRcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG5cdFx0fVxuXHRcdGlmIChudW1iZXIpIHtcblx0XHRcdHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcblx0XHR9XG5cdFx0dmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuXHRcdGVsLm1vZGVsID0ge1xuXHRcdFx0dmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuXHRcdFx0ZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG5cdFx0XHRjYWxsYmFjazogKFwiZnVuY3Rpb24gKFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKSB7XCIgKyBhc3NpZ25tZW50ICsgXCJ9XCIpXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cblx0ICovXG5cdGZ1bmN0aW9uIGdlbkFzc2lnbm1lbnRDb2RlIChcblx0XHR2YWx1ZSxcblx0XHRhc3NpZ25tZW50XG5cdCkge1xuXHRcdHZhciBtb2RlbFJzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG5cdFx0aWYgKG1vZGVsUnMuaWR4ID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gKHZhbHVlICsgXCI9XCIgKyBhc3NpZ25tZW50KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gXCJ2YXIgJCRleHAgPSBcIiArIChtb2RlbFJzLmV4cCkgKyBcIiwgJCRpZHggPSBcIiArIChtb2RlbFJzLmlkeCkgKyBcIjtcIiArXG5cdFx0XHRcdFwiaWYgKCFBcnJheS5pc0FycmF5KCQkZXhwKSl7XCIgK1xuXHRcdFx0XHR2YWx1ZSArIFwiPVwiICsgYXNzaWdubWVudCArIFwifVwiICtcblx0XHRcdFx0XCJlbHNleyQkZXhwLnNwbGljZSgkJGlkeCwgMSwgXCIgKyBhc3NpZ25tZW50ICsgXCIpfVwiXG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIHBhcnNlIGRpcmVjdGl2ZSBtb2RlbCB0byBkbyB0aGUgYXJyYXkgdXBkYXRlIHRyYW5zZm9ybS4gYVtpZHhdID0gdmFsID0+ICQkYS5zcGxpY2UoJCRpZHgsIDEsIHZhbClcblx0ICpcblx0ICogZm9yIGxvb3AgcG9zc2libGUgY2FzZXM6XG5cdCAqXG5cdCAqIC0gdGVzdFxuXHQgKiAtIHRlc3RbaWR4XVxuXHQgKiAtIHRlc3RbdGVzdDFbaWR4XV1cblx0ICogLSB0ZXN0W1wiYVwiXVtpZHhdXG5cdCAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtpZHhdXVxuXHQgKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFbaWR4XV1cblx0ICpcblx0ICovXG5cblx0dmFyIGxlbjtcblx0dmFyIHN0cjtcblx0dmFyIGNocjtcblx0dmFyIGluZGV4JDE7XG5cdHZhciBleHByZXNzaW9uUG9zO1xuXHR2YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuXHRmdW5jdGlvbiBwYXJzZU1vZGVsICh2YWwpIHtcblx0XHRzdHIgPSB2YWw7XG5cdFx0bGVuID0gc3RyLmxlbmd0aDtcblx0XHRpbmRleCQxID0gZXhwcmVzc2lvblBvcyA9IGV4cHJlc3Npb25FbmRQb3MgPSAwO1xuXG5cdFx0aWYgKHZhbC5pbmRleE9mKCdbJykgPCAwIHx8IHZhbC5sYXN0SW5kZXhPZignXScpIDwgbGVuIC0gMSkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXhwOiB2YWwsXG5cdFx0XHRcdGlkeDogbnVsbFxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHdoaWxlICghZW9mKCkpIHtcblx0XHRcdGNociA9IG5leHQoKTtcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0aWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuXHRcdFx0XHRwYXJzZVN0cmluZyhjaHIpO1xuXHRcdFx0fSBlbHNlIGlmIChjaHIgPT09IDB4NUIpIHtcblx0XHRcdFx0cGFyc2VCcmFja2V0KGNocik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGV4cDogdmFsLnN1YnN0cmluZygwLCBleHByZXNzaW9uUG9zKSxcblx0XHRcdGlkeDogdmFsLnN1YnN0cmluZyhleHByZXNzaW9uUG9zICsgMSwgZXhwcmVzc2lvbkVuZFBvcylcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBuZXh0ICgpIHtcblx0XHRyZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxuXHR9XG5cblx0ZnVuY3Rpb24gZW9mICgpIHtcblx0XHRyZXR1cm4gaW5kZXgkMSA+PSBsZW5cblx0fVxuXG5cdGZ1bmN0aW9uIGlzU3RyaW5nU3RhcnQgKGNocikge1xuXHRcdHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZUJyYWNrZXQgKGNocikge1xuXHRcdHZhciBpbkJyYWNrZXQgPSAxO1xuXHRcdGV4cHJlc3Npb25Qb3MgPSBpbmRleCQxO1xuXHRcdHdoaWxlICghZW9mKCkpIHtcblx0XHRcdGNociA9IG5leHQoKTtcblx0XHRcdGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcblx0XHRcdFx0cGFyc2VTdHJpbmcoY2hyKTtcblx0XHRcdFx0Y29udGludWVcblx0XHRcdH1cblx0XHRcdGlmIChjaHIgPT09IDB4NUIpIHsgaW5CcmFja2V0Kys7IH1cblx0XHRcdGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cblx0XHRcdGlmIChpbkJyYWNrZXQgPT09IDApIHtcblx0XHRcdFx0ZXhwcmVzc2lvbkVuZFBvcyA9IGluZGV4JDE7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VTdHJpbmcgKGNocikge1xuXHRcdHZhciBzdHJpbmdRdW90ZSA9IGNocjtcblx0XHR3aGlsZSAoIWVvZigpKSB7XG5cdFx0XHRjaHIgPSBuZXh0KCk7XG5cdFx0XHRpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciB3YXJuJDE7XG5cbi8vIGluIHNvbWUgY2FzZXMsIHRoZSBldmVudCB1c2VkIGhhcyB0byBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWVcbi8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG5cdHZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xuXHR2YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuXHRmdW5jdGlvbiBtb2RlbCAoXG5cdFx0ZWwsXG5cdFx0ZGlyLFxuXHRcdF93YXJuXG5cdCkge1xuXHRcdHdhcm4kMSA9IF93YXJuO1xuXHRcdHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcblx0XHR2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcblx0XHR2YXIgdGFnID0gZWwudGFnO1xuXHRcdHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuXHRcdHtcblx0XHRcdHZhciBkeW5hbWljVHlwZSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dHlwZSddIHx8IGVsLmF0dHJzTWFwWyc6dHlwZSddO1xuXHRcdFx0aWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBkeW5hbWljVHlwZSkge1xuXHRcdFx0XHR3YXJuJDEoXG5cdFx0XHRcdFx0XCI8aW5wdXQgOnR5cGU9XFxcIlwiICsgZHluYW1pY1R5cGUgKyBcIlxcXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46XFxuXCIgK1xuXHRcdFx0XHRcdFwidi1tb2RlbCBkb2VzIG5vdCBzdXBwb3J0IGR5bmFtaWMgaW5wdXQgdHlwZXMuIFVzZSB2LWlmIGJyYW5jaGVzIGluc3RlYWQuXCJcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuXHRcdFx0Ly8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cblx0XHRcdGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG5cdFx0XHRcdHdhcm4kMShcblx0XHRcdFx0XHRcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuXHRcdFx0XHRcdFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuXHRcdH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdjaGVja2JveCcpIHtcblx0XHRcdGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuXHRcdH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcblx0XHRcdGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuXHRcdH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuXHRcdFx0Z2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcblx0XHR9IGVsc2UgaWYgKCFjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG5cdFx0XHRnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG5cdFx0XHQvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHdhcm4kMShcblx0XHRcdFx0XCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG5cdFx0XHRcdFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG5cdFx0XHRcdCdJZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBjb250ZW50ZWRpdGFibGUsIGl0XFwncyByZWNvbW1lbmRlZCB0byAnICtcblx0XHRcdFx0J3dyYXAgYSBsaWJyYXJ5IGRlZGljYXRlZCBmb3IgdGhhdCBwdXJwb3NlIGluc2lkZSBhIGN1c3RvbSBjb21wb25lbnQuJ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyBlbnN1cmUgcnVudGltZSBkaXJlY3RpdmUgbWV0YWRhdGFcblx0XHRyZXR1cm4gdHJ1ZVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuQ2hlY2tib3hNb2RlbCAoXG5cdFx0ZWwsXG5cdFx0dmFsdWUsXG5cdFx0bW9kaWZpZXJzXG5cdCkge1xuXHRcdHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcblx0XHR2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcblx0XHR2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcblx0XHR2YXIgZmFsc2VWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2ZhbHNlLXZhbHVlJykgfHwgJ2ZhbHNlJztcblx0XHRhZGRQcm9wKGVsLCAnY2hlY2tlZCcsXG5cdFx0XHRcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcblx0XHRcdFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuXHRcdFx0XHR0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcblx0XHRcdFx0XHQ/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuXHRcdFx0XHRcdDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcblx0XHRcdClcblx0XHQpO1xuXHRcdGFkZEhhbmRsZXIoZWwsIENIRUNLQk9YX1JBRElPX1RPS0VOLFxuXHRcdFx0XCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG5cdFx0XHQnJCRlbD0kZXZlbnQudGFyZ2V0LCcgK1xuXHRcdFx0XCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuXHRcdFx0J2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG5cdFx0XHRcInZhciAkJHY9XCIgKyAobnVtYmVyID8gJ19uKCcgKyB2YWx1ZUJpbmRpbmcgKyAnKScgOiB2YWx1ZUJpbmRpbmcpICsgXCIsXCIgK1xuXHRcdFx0JyQkaT1faSgkJGEsJCR2KTsnICtcblx0XHRcdFwiaWYoJCRjKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KCQkdikpfVwiICtcblx0XHRcdFwiZWxzZXskJGk+LTEmJihcIiArIHZhbHVlICsgXCI9JCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSkpfVwiICtcblx0XHRcdFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcblx0XHRcdG51bGwsIHRydWVcblx0XHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuUmFkaW9Nb2RlbCAoXG5cdFx0ZWwsXG5cdFx0dmFsdWUsXG5cdFx0bW9kaWZpZXJzXG5cdCkge1xuXHRcdHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcblx0XHR2YXIgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcblx0XHR2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyAoXCJfbihcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSA6IHZhbHVlQmluZGluZztcblx0XHRhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG5cdFx0YWRkSGFuZGxlcihlbCwgQ0hFQ0tCT1hfUkFESU9fVE9LRU4sIGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUJpbmRpbmcpLCBudWxsLCB0cnVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdlblNlbGVjdCAoXG5cdFx0ZWwsXG5cdFx0dmFsdWUsXG5cdFx0bW9kaWZpZXJzXG5cdCkge1xuXHRcdHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcblx0XHR2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG5cdFx0XHRcIi5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pXCIgK1xuXHRcdFx0XCIubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcXFwiX3ZhbHVlXFxcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO1wiICtcblx0XHRcdFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuXHRcdHZhciBhc3NpZ25tZW50ID0gJyRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXSc7XG5cdFx0dmFyIGNvZGUgPSBcInZhciAkJHNlbGVjdGVkVmFsID0gXCIgKyBzZWxlY3RlZFZhbCArIFwiO1wiO1xuXHRcdGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcblx0XHRhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgY29kZSwgbnVsbCwgdHJ1ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuXHRcdGVsLFxuXHRcdHZhbHVlLFxuXHRcdG1vZGlmaWVyc1xuXHQpIHtcblx0XHR2YXIgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG5cdFx0dmFyIHJlZiA9IG1vZGlmaWVycyB8fCB7fTtcblx0XHR2YXIgbGF6eSA9IHJlZi5sYXp5O1xuXHRcdHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuXHRcdHZhciB0cmltID0gcmVmLnRyaW07XG5cdFx0dmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcblx0XHR2YXIgZXZlbnQgPSBsYXp5XG5cdFx0XHQ/ICdjaGFuZ2UnXG5cdFx0XHQ6IHR5cGUgPT09ICdyYW5nZSdcblx0XHRcdD8gUkFOR0VfVE9LRU5cblx0XHRcdDogJ2lucHV0JztcblxuXHRcdHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG5cdFx0aWYgKHRyaW0pIHtcblx0XHRcdHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcblx0XHR9XG5cdFx0aWYgKG51bWJlcikge1xuXHRcdFx0dmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuXHRcdH1cblxuXHRcdHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG5cdFx0aWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG5cdFx0XHRjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuXHRcdH1cblxuXHRcdGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcblx0XHRhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG5cdFx0aWYgKHRyaW0gfHwgbnVtYmVyIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuXHRmdW5jdGlvbiBub3JtYWxpemVFdmVudHMgKG9uKSB7XG5cdFx0dmFyIGV2ZW50O1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG5cdFx0XHQvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG5cdFx0XHRldmVudCA9IGlzSUUgPyAnY2hhbmdlJyA6ICdpbnB1dCc7XG5cdFx0XHRvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuXHRcdFx0ZGVsZXRlIG9uW1JBTkdFX1RPS0VOXTtcblx0XHR9XG5cdFx0aWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcblx0XHRcdC8vIENocm9tZSBmaXJlcyBtaWNyb3Rhc2tzIGluIGJldHdlZW4gY2xpY2svY2hhbmdlLCBsZWFkcyB0byAjNDUyMVxuXHRcdFx0ZXZlbnQgPSBpc0Nocm9tZSA/ICdjbGljaycgOiAnY2hhbmdlJztcblx0XHRcdG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltDSEVDS0JPWF9SQURJT19UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG5cdFx0XHRkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuXHRcdH1cblx0fVxuXG5cdHZhciB0YXJnZXQkMTtcblxuXHRmdW5jdGlvbiBhZGQkMSAoXG5cdFx0ZXZlbnQsXG5cdFx0aGFuZGxlcixcblx0XHRvbmNlJCQxLFxuXHRcdGNhcHR1cmUsXG5cdFx0cGFzc2l2ZVxuXHQpIHtcblx0XHRpZiAob25jZSQkMSkge1xuXHRcdFx0dmFyIG9sZEhhbmRsZXIgPSBoYW5kbGVyO1xuXHRcdFx0dmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcblx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZXYpIHtcblx0XHRcdFx0dmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDFcblx0XHRcdFx0XHQ/IG9sZEhhbmRsZXIoZXYpXG5cdFx0XHRcdFx0OiBvbGRIYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdGlmIChyZXMgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZW1vdmUkMihldmVudCwgaGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHRhcmdldCQxLmFkZEV2ZW50TGlzdGVuZXIoXG5cdFx0XHRldmVudCxcblx0XHRcdGhhbmRsZXIsXG5cdFx0XHRzdXBwb3J0c1Bhc3NpdmVcblx0XHRcdFx0PyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuXHRcdFx0XHQ6IGNhcHR1cmVcblx0XHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcmVtb3ZlJDIgKFxuXHRcdGV2ZW50LFxuXHRcdGhhbmRsZXIsXG5cdFx0Y2FwdHVyZSxcblx0XHRfdGFyZ2V0XG5cdCkge1xuXHRcdChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyAob2xkVm5vZGUsIHZub2RlKSB7XG5cdFx0aWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5vbikgJiYgaXNVbmRlZih2bm9kZS5kYXRhLm9uKSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdHZhciBvbiA9IHZub2RlLmRhdGEub24gfHwge307XG5cdFx0dmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcblx0XHR0YXJnZXQkMSA9IHZub2RlLmVsbTtcblx0XHRub3JtYWxpemVFdmVudHMob24pO1xuXHRcdHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG5cdH1cblxuXHR2YXIgZXZlbnRzID0ge1xuXHRcdGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuXHRcdHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzXG5cdH07XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuXHRcdGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHR2YXIga2V5LCBjdXI7XG5cdFx0dmFyIGVsbSA9IHZub2RlLmVsbTtcblx0XHR2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuXHRcdHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG5cdFx0Ly8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG5cdFx0aWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcblx0XHRcdHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuXHRcdH1cblxuXHRcdGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG5cdFx0XHRpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuXHRcdFx0XHRlbG1ba2V5XSA9ICcnO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKGtleSBpbiBwcm9wcykge1xuXHRcdFx0Y3VyID0gcHJvcHNba2V5XTtcblx0XHRcdC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuXHRcdFx0Ly8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcblx0XHRcdC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG5cdFx0XHRpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcblx0XHRcdFx0aWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cblx0XHRcdFx0aWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChrZXkgPT09ICd2YWx1ZScpIHtcblx0XHRcdFx0Ly8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2Vcblx0XHRcdFx0Ly8gbm9uLXN0cmluZyB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZFxuXHRcdFx0XHRlbG0uX3ZhbHVlID0gY3VyO1xuXHRcdFx0XHQvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcblx0XHRcdFx0dmFyIHN0ckN1ciA9IGlzVW5kZWYoY3VyKSA/ICcnIDogU3RyaW5nKGN1cik7XG5cdFx0XHRcdGlmIChzaG91bGRVcGRhdGVWYWx1ZShlbG0sIHZub2RlLCBzdHJDdXIpKSB7XG5cdFx0XHRcdFx0ZWxtLnZhbHVlID0gc3RyQ3VyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbG1ba2V5XSA9IGN1cjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuLy8gY2hlY2sgcGxhdGZvcm1zL3dlYi91dGlsL2F0dHJzLmpzIGFjY2VwdFZhbHVlXG5cblxuXHRmdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoXG5cdFx0ZWxtLFxuXHRcdHZub2RlLFxuXHRcdGNoZWNrVmFsXG5cdCkge1xuXHRcdHJldHVybiAoIWVsbS5jb21wb3NpbmcgJiYgKFxuXHRcdFx0dm5vZGUudGFnID09PSAnb3B0aW9uJyB8fFxuXHRcdFx0aXNEaXJ0eShlbG0sIGNoZWNrVmFsKSB8fFxuXHRcdFx0aXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcblx0XHQpKVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuXHRcdC8vIHJldHVybiB0cnVlIHdoZW4gdGV4dGJveCAoLm51bWJlciBhbmQgLnRyaW0pIGxvc2VzIGZvY3VzIGFuZCBpdHMgdmFsdWUgaXMgbm90IGVxdWFsIHRvIHRoZSB1cGRhdGVkIHZhbHVlXG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGVsbSAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG5cdH1cblxuXHRmdW5jdGlvbiBpc0lucHV0Q2hhbmdlZCAoZWxtLCBuZXdWYWwpIHtcblx0XHR2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG5cdFx0dmFyIG1vZGlmaWVycyA9IGVsbS5fdk1vZGlmaWVyczsgLy8gaW5qZWN0ZWQgYnkgdi1tb2RlbCBydW50aW1lXG5cdFx0aWYgKChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy5udW1iZXIpIHx8IGVsbS50eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0cmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuXHRcdH1cblx0XHRpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMudHJpbSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxuXHR9XG5cblx0dmFyIGRvbVByb3BzID0ge1xuXHRcdGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG5cdFx0dXBkYXRlOiB1cGRhdGVET01Qcm9wc1xuXHR9O1xuXG5cdC8qICAqL1xuXG5cdHZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuXHRcdHZhciByZXMgPSB7fTtcblx0XHR2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG5cdFx0dmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcblx0XHRjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdGlmIChpdGVtKSB7XG5cdFx0XHRcdHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcblx0XHRcdFx0dG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHJldHVybiByZXNcblx0fSk7XG5cbi8vIG1lcmdlIHN0YXRpYyBhbmQgZHluYW1pYyBzdHlsZSBkYXRhIG9uIHRoZSBzYW1lIHZub2RlXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuXHRcdHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcblx0XHQvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cblx0XHQvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuXHRcdHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG5cdFx0XHQ/IGV4dGVuZChkYXRhLnN0YXRpY1N0eWxlLCBzdHlsZSlcblx0XHRcdDogc3R5bGVcblx0fVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlQmluZGluZyAoYmluZGluZ1N0eWxlKSB7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuXHRcdFx0cmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuXHRcdH1cblx0XHRyZXR1cm4gYmluZGluZ1N0eWxlXG5cdH1cblxuXHQvKipcblx0ICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuXHQgKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG5cdFx0dmFyIHJlcyA9IHt9O1xuXHRcdHZhciBzdHlsZURhdGE7XG5cblx0XHRpZiAoY2hlY2tDaGlsZCkge1xuXHRcdFx0dmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuXHRcdFx0d2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuXHRcdFx0XHRjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuXHRcdFx0XHRpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG5cdFx0XHRcdFx0ZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuXHRcdFx0ZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcblx0XHR9XG5cblx0XHR2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuXHRcdHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuXHRcdFx0aWYgKHBhcmVudE5vZGUuZGF0YSAmJiAoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHBhcmVudE5vZGUuZGF0YSkpKSB7XG5cdFx0XHRcdGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXNcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBjc3NWYXJSRSA9IC9eLS0vO1xuXHR2YXIgaW1wb3J0YW50UkUgPSAvXFxzKiFpbXBvcnRhbnQkLztcblx0dmFyIHNldFByb3AgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIHZhbCkge1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmIChjc3NWYXJSRS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuXHRcdH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG5cdFx0XHRlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRcdFx0Ly8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cblx0XHRcdFx0Ly8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuXHRcdFx0XHQvLyBTZXQgdGhlbSBvbmUgYnkgb25lLCBhbmQgdGhlIGJyb3dzZXIgd2lsbCBvbmx5IHNldCB0aG9zZSBpdCBjYW4gcmVjb2duaXplXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0XHRlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0dmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cblx0dmFyIHRlc3RFbDtcblx0dmFyIG5vcm1hbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAocHJvcCkge1xuXHRcdHRlc3RFbCA9IHRlc3RFbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRwcm9wID0gY2FtZWxpemUocHJvcCk7XG5cdFx0aWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIHRlc3RFbC5zdHlsZSkpIHtcblx0XHRcdHJldHVybiBwcm9wXG5cdFx0fVxuXHRcdHZhciB1cHBlciA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwcmVmaXhlZCA9IHByZWZpeGVzW2ldICsgdXBwZXI7XG5cdFx0XHRpZiAocHJlZml4ZWQgaW4gdGVzdEVsLnN0eWxlKSB7XG5cdFx0XHRcdHJldHVybiBwcmVmaXhlZFxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG9sZFZub2RlLCB2bm9kZSkge1xuXHRcdHZhciBkYXRhID0gdm5vZGUuZGF0YTtcblx0XHR2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cblx0XHRpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG5cdFx0XHRpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcblx0XHQpIHtcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdHZhciBjdXIsIG5hbWU7XG5cdFx0dmFyIGVsID0gdm5vZGUuZWxtO1xuXHRcdHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG5cdFx0dmFyIG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG5cblx0XHQvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuXHRcdHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuXHRcdHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcblxuXHRcdC8vIHN0b3JlIG5vcm1hbGl6ZWQgc3R5bGUgdW5kZXIgYSBkaWZmZXJlbnQga2V5IGZvciBuZXh0IGRpZmZcblx0XHQvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrbGV5IHdhbnRzXG5cdFx0Ly8gdG8gbXV0YXRlIGl0LlxuXHRcdHZub2RlLmRhdGEubm9ybWFsaXplZFN0eWxlID0gaXNEZWYoc3R5bGUuX19vYl9fKVxuXHRcdFx0PyBleHRlbmQoe30sIHN0eWxlKVxuXHRcdFx0OiBzdHlsZTtcblxuXHRcdHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuXHRcdGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuXHRcdFx0aWYgKGlzVW5kZWYobmV3U3R5bGVbbmFtZV0pKSB7XG5cdFx0XHRcdHNldFByb3AoZWwsIG5hbWUsICcnKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yIChuYW1lIGluIG5ld1N0eWxlKSB7XG5cdFx0XHRjdXIgPSBuZXdTdHlsZVtuYW1lXTtcblx0XHRcdGlmIChjdXIgIT09IG9sZFN0eWxlW25hbWVdKSB7XG5cdFx0XHRcdC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG5cdFx0XHRcdHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHZhciBzdHlsZSA9IHtcblx0XHRjcmVhdGU6IHVwZGF0ZVN0eWxlLFxuXHRcdHVwZGF0ZTogdXBkYXRlU3R5bGVcblx0fTtcblxuXHQvKiAgKi9cblxuXHQvKipcblx0ICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG5cdCAqIFNWRyBlbGVtZW50cyBpbiBJRVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRcdGlmIChlbC5jbGFzc0xpc3QpIHtcblx0XHRcdGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcblx0XHRcdFx0Y2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG5cdFx0XHRpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcblx0XHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuXHQgKiBTVkcgZWxlbWVudHMgaW4gSUVcblx0ICovXG5cdGZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRpZiAoZWwuY2xhc3NMaXN0KSB7XG5cdFx0XHRpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG5cdFx0XHRcdGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY3VyID0gXCIgXCIgKyAoZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnKSArIFwiIFwiO1xuXHRcdFx0dmFyIHRhciA9ICcgJyArIGNscyArICcgJztcblx0XHRcdHdoaWxlIChjdXIuaW5kZXhPZih0YXIpID49IDApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuXHRcdFx0fVxuXHRcdFx0ZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1ci50cmltKCkpO1xuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcblx0XHRpZiAoIWRlZiQkMSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdFx0aWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG5cdFx0XHR2YXIgcmVzID0ge307XG5cdFx0XHRpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcblx0XHRcdFx0ZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG5cdFx0XHR9XG5cdFx0XHRleHRlbmQocmVzLCBkZWYkJDEpO1xuXHRcdFx0cmV0dXJuIHJlc1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG5cdFx0fVxuXHR9XG5cblx0dmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG5cdFx0XHRlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG5cdFx0XHRlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcblx0XHRcdGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG5cdFx0XHRsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG5cdFx0XHRsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuXHRcdH1cblx0fSk7XG5cblx0dmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xuXHR2YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcblx0dmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG5cdHZhciB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcblx0dmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcblx0dmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcblx0dmFyIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5cdGlmIChoYXNUcmFuc2l0aW9uKSB7XG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKHdpbmRvdy5vbnRyYW5zaXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0d2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG5cdFx0KSB7XG5cdFx0XHR0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcblx0XHRcdHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcblx0XHR9XG5cdFx0aWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG5cdFx0XHR3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuXHRcdCkge1xuXHRcdFx0YW5pbWF0aW9uUHJvcCA9ICdXZWJraXRBbmltYXRpb24nO1xuXHRcdFx0YW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcblx0XHR9XG5cdH1cblxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG5cdHZhciByYWYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZVxuXHRcdD8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcblx0XHQ6IHNldFRpbWVvdXQ7XG5cblx0ZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuXHRcdHJhZihmdW5jdGlvbiAoKSB7XG5cdFx0XHRyYWYoZm4pO1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG5cdFx0KGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pKS5wdXNoKGNscyk7XG5cdFx0YWRkQ2xhc3MoZWwsIGNscyk7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcblx0XHRpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG5cdFx0XHRyZW1vdmUoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuXHRcdH1cblx0XHRyZW1vdmVDbGFzcyhlbCwgY2xzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyAoXG5cdFx0ZWwsXG5cdFx0ZXhwZWN0ZWRUeXBlLFxuXHRcdGNiXG5cdCkge1xuXHRcdHZhciByZWYgPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcblx0XHR2YXIgdHlwZSA9IHJlZi50eXBlO1xuXHRcdHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG5cdFx0dmFyIHByb3BDb3VudCA9IHJlZi5wcm9wQ291bnQ7XG5cdFx0aWYgKCF0eXBlKSB7IHJldHVybiBjYigpIH1cblx0XHR2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG5cdFx0dmFyIGVuZGVkID0gMDtcblx0XHR2YXIgZW5kID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuXHRcdFx0Y2IoKTtcblx0XHR9O1xuXHRcdHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRpZiAoZS50YXJnZXQgPT09IGVsKSB7XG5cdFx0XHRcdGlmICgrK2VuZGVkID49IHByb3BDb3VudCkge1xuXHRcdFx0XHRcdGVuZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuXHRcdFx0XHRlbmQoKTtcblx0XHRcdH1cblx0XHR9LCB0aW1lb3V0ICsgMSk7XG5cdFx0ZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuXHR9XG5cblx0dmFyIHRyYW5zZm9ybVJFID0gL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztcblxuXHRmdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuXHRcdHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG5cdFx0dmFyIHRyYW5zaXRpb25EZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcblx0XHR2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuXHRcdHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG5cdFx0dmFyIGFuaW1hdGlvbkRlbGF5cyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0RlbGF5J10uc3BsaXQoJywgJyk7XG5cdFx0dmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG5cdFx0dmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuXHRcdHZhciB0eXBlO1xuXHRcdHZhciB0aW1lb3V0ID0gMDtcblx0XHR2YXIgcHJvcENvdW50ID0gMDtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG5cdFx0XHRpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG5cdFx0XHRcdHR5cGUgPSBUUkFOU0lUSU9OO1xuXHRcdFx0XHR0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG5cdFx0XHRcdHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcblx0XHRcdGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuXHRcdFx0XHR0eXBlID0gQU5JTUFUSU9OO1xuXHRcdFx0XHR0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcblx0XHRcdFx0cHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcblx0XHRcdHR5cGUgPSB0aW1lb3V0ID4gMFxuXHRcdFx0XHQ/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuXHRcdFx0XHQ/IFRSQU5TSVRJT05cblx0XHRcdFx0OiBBTklNQVRJT05cblx0XHRcdFx0OiBudWxsO1xuXHRcdFx0cHJvcENvdW50ID0gdHlwZVxuXHRcdFx0XHQ/IHR5cGUgPT09IFRSQU5TSVRJT05cblx0XHRcdFx0PyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuXHRcdFx0XHQ6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcblx0XHRcdFx0OiAwO1xuXHRcdH1cblx0XHR2YXIgaGFzVHJhbnNmb3JtID1cblx0XHRcdHR5cGUgPT09IFRSQU5TSVRJT04gJiZcblx0XHRcdHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0dGltZW91dDogdGltZW91dCxcblx0XHRcdHByb3BDb3VudDogcHJvcENvdW50LFxuXHRcdFx0aGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0d2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG5cdFx0XHRkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcblx0XHRcdHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG5cdFx0fSkpXG5cdH1cblxuXHRmdW5jdGlvbiB0b01zIChzKSB7XG5cdFx0cmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKSkgKiAxMDAwXG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcblx0XHR2YXIgZWwgPSB2bm9kZS5lbG07XG5cblx0XHQvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuXHRcdGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcblx0XHRcdGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG5cdFx0XHRlbC5fbGVhdmVDYigpO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcblx0XHRpZiAoaXNVbmRlZihkYXRhKSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dmFyIGNzcyA9IGRhdGEuY3NzO1xuXHRcdHZhciB0eXBlID0gZGF0YS50eXBlO1xuXHRcdHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuXHRcdHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcblx0XHR2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcblx0XHR2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuXHRcdHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuXHRcdHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG5cdFx0dmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcblx0XHR2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuXHRcdHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuXHRcdHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG5cdFx0dmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuXHRcdHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcblx0XHR2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuXHRcdHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcblx0XHR2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG5cdFx0Ly8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuXHRcdC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuXHRcdC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG5cdFx0Ly8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG5cdFx0dmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcblx0XHR2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG5cdFx0d2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuXHRcdFx0dHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG5cdFx0XHRjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcblx0XHR9XG5cblx0XHR2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cblx0XHRpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHR2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG5cdFx0XHQ/IGFwcGVhckNsYXNzXG5cdFx0XHQ6IGVudGVyQ2xhc3M7XG5cdFx0dmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3Ncblx0XHRcdD8gYXBwZWFyQWN0aXZlQ2xhc3Ncblx0XHRcdDogZW50ZXJBY3RpdmVDbGFzcztcblx0XHR2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3Ncblx0XHRcdD8gYXBwZWFyVG9DbGFzc1xuXHRcdFx0OiBlbnRlclRvQ2xhc3M7XG5cblx0XHR2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcblx0XHRcdD8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcblx0XHRcdDogYmVmb3JlRW50ZXI7XG5cdFx0dmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG5cdFx0XHQ/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG5cdFx0XHQ6IGVudGVyO1xuXHRcdHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG5cdFx0XHQ/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuXHRcdFx0OiBhZnRlckVudGVyO1xuXHRcdHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuXHRcdFx0PyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuXHRcdFx0OiBlbnRlckNhbmNlbGxlZDtcblxuXHRcdHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcblx0XHRcdGlzT2JqZWN0KGR1cmF0aW9uKVxuXHRcdFx0XHQ/IGR1cmF0aW9uLmVudGVyXG5cdFx0XHRcdDogZHVyYXRpb25cblx0XHQpO1xuXG5cdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG5cdFx0XHRjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuXHRcdH1cblxuXHRcdHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG5cdFx0dmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cblx0XHR2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGV4cGVjdHNDU1MpIHtcblx0XHRcdFx0cmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcblx0XHRcdFx0cmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2IuY2FuY2VsbGVkKSB7XG5cdFx0XHRcdGlmIChleHBlY3RzQ1NTKSB7XG5cdFx0XHRcdFx0cmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcblx0XHRcdH1cblx0XHRcdGVsLl9lbnRlckNiID0gbnVsbDtcblx0XHR9KTtcblxuXHRcdGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG5cdFx0XHQvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuXHRcdFx0bWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuXHRcdFx0XHR2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuXHRcdFx0XHRpZiAocGVuZGluZ05vZGUgJiZcblx0XHRcdFx0XHRwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuXHRcdFx0XHRcdHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG5cdFx0YmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG5cdFx0aWYgKGV4cGVjdHNDU1MpIHtcblx0XHRcdGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG5cdFx0XHRhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcblx0XHRcdG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG5cdFx0XHRcdHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG5cdFx0XHRcdGlmICghY2IuY2FuY2VsbGVkICYmICF1c2VyV2FudHNDb250cm9sKSB7XG5cdFx0XHRcdFx0aWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24pKSB7XG5cdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh2bm9kZS5kYXRhLnNob3cpIHtcblx0XHRcdHRvZ2dsZURpc3BsYXkgJiYgdG9nZ2xlRGlzcGxheSgpO1xuXHRcdFx0ZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuXHRcdH1cblxuXHRcdGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuXHRcdFx0Y2IoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG5cdFx0dmFyIGVsID0gdm5vZGUuZWxtO1xuXG5cdFx0Ly8gY2FsbCBlbnRlciBjYWxsYmFjayBub3dcblx0XHRpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG5cdFx0XHRlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuXHRcdFx0ZWwuX2VudGVyQ2IoKTtcblx0XHR9XG5cblx0XHR2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG5cdFx0aWYgKGlzVW5kZWYoZGF0YSkpIHtcblx0XHRcdHJldHVybiBybSgpXG5cdFx0fVxuXG5cdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0aWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dmFyIGNzcyA9IGRhdGEuY3NzO1xuXHRcdHZhciB0eXBlID0gZGF0YS50eXBlO1xuXHRcdHZhciBsZWF2ZUNsYXNzID0gZGF0YS5sZWF2ZUNsYXNzO1xuXHRcdHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcblx0XHR2YXIgbGVhdmVBY3RpdmVDbGFzcyA9IGRhdGEubGVhdmVBY3RpdmVDbGFzcztcblx0XHR2YXIgYmVmb3JlTGVhdmUgPSBkYXRhLmJlZm9yZUxlYXZlO1xuXHRcdHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG5cdFx0dmFyIGFmdGVyTGVhdmUgPSBkYXRhLmFmdGVyTGVhdmU7XG5cdFx0dmFyIGxlYXZlQ2FuY2VsbGVkID0gZGF0YS5sZWF2ZUNhbmNlbGxlZDtcblx0XHR2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcblx0XHR2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG5cdFx0dmFyIGV4cGVjdHNDU1MgPSBjc3MgIT09IGZhbHNlICYmICFpc0lFOTtcblx0XHR2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG5cdFx0dmFyIGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKFxuXHRcdFx0aXNPYmplY3QoZHVyYXRpb24pXG5cdFx0XHRcdD8gZHVyYXRpb24ubGVhdmVcblx0XHRcdFx0OiBkdXJhdGlvblxuXHRcdCk7XG5cblx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgaXNEZWYoZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuXHRcdFx0Y2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcblx0XHR9XG5cblx0XHR2YXIgY2IgPSBlbC5fbGVhdmVDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuXHRcdFx0XHRlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGV4cGVjdHNDU1MpIHtcblx0XHRcdFx0cmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuXHRcdFx0XHRyZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNiLmNhbmNlbGxlZCkge1xuXHRcdFx0XHRpZiAoZXhwZWN0c0NTUykge1xuXHRcdFx0XHRcdHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVhdmVDYW5jZWxsZWQgJiYgbGVhdmVDYW5jZWxsZWQoZWwpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cm0oKTtcblx0XHRcdFx0YWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcblx0XHRcdH1cblx0XHRcdGVsLl9sZWF2ZUNiID0gbnVsbDtcblx0XHR9KTtcblxuXHRcdGlmIChkZWxheUxlYXZlKSB7XG5cdFx0XHRkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBlcmZvcm1MZWF2ZSgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBlcmZvcm1MZWF2ZSAoKSB7XG5cdFx0XHQvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG5cdFx0XHRpZiAoY2IuY2FuY2VsbGVkKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ly8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuXHRcdFx0aWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcblx0XHRcdFx0KGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuXHRcdFx0fVxuXHRcdFx0YmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuXHRcdFx0aWYgKGV4cGVjdHNDU1MpIHtcblx0XHRcdFx0YWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcblx0XHRcdFx0YWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcblx0XHRcdFx0bmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG5cdFx0XHRcdFx0cmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcblx0XHRcdFx0XHRpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuXHRcdFx0XHRcdFx0aWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoY2IsIGV4cGxpY2l0TGVhdmVEdXJhdGlvbik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0bGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcblx0XHRcdGlmICghZXhwZWN0c0NTUyAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuXHRcdFx0XHRjYigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcblx0ZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuXHRcdGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuXHRcdFx0d2Fybihcblx0XHRcdFx0XCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuXHRcdFx0XHRcImdvdCBcIiArIChKU09OLnN0cmluZ2lmeSh2YWwpKSArIFwiLlwiLFxuXHRcdFx0XHR2bm9kZS5jb250ZXh0XG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xuXHRcdFx0d2Fybihcblx0XHRcdFx0XCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuXHRcdFx0XHQndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsXG5cdFx0XHRcdHZub2RlLmNvbnRleHRcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbClcblx0fVxuXG5cdC8qKlxuXHQgKiBOb3JtYWxpemUgYSB0cmFuc2l0aW9uIGhvb2sncyBhcmd1bWVudCBsZW5ndGguIFRoZSBob29rIG1heSBiZTpcblx0ICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG5cdCAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuXHQgKiAtIGEgcGxhaW4gZnVuY3Rpb24gKC5sZW5ndGgpXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuXHRcdGlmIChpc1VuZGVmKGZuKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0fVxuXHRcdHZhciBpbnZva2VyRm5zID0gZm4uZm5zO1xuXHRcdGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuXHRcdFx0Ly8gaW52b2tlclxuXHRcdFx0cmV0dXJuIGdldEhvb2tBcmd1bWVudHNMZW5ndGgoXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkoaW52b2tlckZucylcblx0XHRcdFx0XHQ/IGludm9rZXJGbnNbMF1cblx0XHRcdFx0XHQ6IGludm9rZXJGbnNcblx0XHRcdClcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChmbi5fbGVuZ3RoIHx8IGZuLmxlbmd0aCkgPiAxXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gX2VudGVyIChfLCB2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcblx0XHRcdGVudGVyKHZub2RlKTtcblx0XHR9XG5cdH1cblxuXHR2YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcblx0XHRjcmVhdGU6IF9lbnRlcixcblx0XHRhY3RpdmF0ZTogX2VudGVyLFxuXHRcdHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdFx0XHRpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG5cdFx0XHRcdGxlYXZlKHZub2RlLCBybSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRybSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSA6IHt9O1xuXG5cdHZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG5cdFx0YXR0cnMsXG5cdFx0a2xhc3MsXG5cdFx0ZXZlbnRzLFxuXHRcdGRvbVByb3BzLFxuXHRcdHN0eWxlLFxuXHRcdHRyYW5zaXRpb25cblx0XTtcblxuXHQvKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxuXHR2YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG5cdHZhciBwYXRjaCA9IGNyZWF0ZVBhdGNoRnVuY3Rpb24oeyBub2RlT3BzOiBub2RlT3BzLCBtb2R1bGVzOiBtb2R1bGVzIH0pO1xuXG5cdC8qKlxuXHQgKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcblx0ICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cblx0ICovXG5cblx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdGlmIChpc0lFOSkge1xuXHRcdC8vIGh0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBlbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdFx0XHRpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG5cdFx0XHRcdHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0dmFyIG1vZGVsJDEgPSB7XG5cdFx0aW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcblx0XHRcdGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG5cdFx0XHRcdHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0XHRpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGNiLCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgZWwudHlwZSA9PT0gJ3RleHQnIHx8IGVsLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcblx0XHRcdFx0ZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcblx0XHRcdFx0aWYgKCFiaW5kaW5nLm1vZGlmaWVycy5sYXp5KSB7XG5cdFx0XHRcdFx0Ly8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuXHRcdFx0XHRcdC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2Vcblx0XHRcdFx0XHQvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG5cdFx0XHRcdFx0Ly8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG5cdFx0XHRcdFx0ZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG5cdFx0XHRcdFx0aWYgKCFpc0FuZHJvaWQpIHtcblx0XHRcdFx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuXHRcdFx0XHRcdFx0ZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRcdFx0aWYgKGlzSUU5KSB7XG5cdFx0XHRcdFx0XHRlbC52bW9kZWwgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG5cdFx0XHRpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuXHRcdFx0XHRzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG5cdFx0XHRcdC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuXHRcdFx0XHQvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG5cdFx0XHRcdC8vIGRldGVjdCBzdWNoIGNhc2VzIGFuZCBmaWx0ZXIgb3V0IHZhbHVlcyB0aGF0IG5vIGxvbmdlciBoYXMgYSBtYXRjaGluZ1xuXHRcdFx0XHQvLyBvcHRpb24gaW4gdGhlIERPTS5cblx0XHRcdFx0dmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG5cdFx0XHRcdFx0PyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgZWwub3B0aW9ucyk7IH0pXG5cdFx0XHRcdFx0OiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmIGhhc05vTWF0Y2hpbmdPcHRpb24oYmluZGluZy52YWx1ZSwgZWwub3B0aW9ucyk7XG5cdFx0XHRcdGlmIChuZWVkUmVzZXQpIHtcblx0XHRcdFx0XHR0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuXHRcdHZhciB2YWx1ZSA9IGJpbmRpbmcudmFsdWU7XG5cdFx0dmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcblx0XHRpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG5cdFx0XHRcdFwiPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVxcXCJcIiArIChiaW5kaW5nLmV4cHJlc3Npb24pICsgXCJcXFwiPiBcIiArXG5cdFx0XHRcdFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuXHRcdFx0XHR2bVxuXHRcdFx0KTtcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHR2YXIgc2VsZWN0ZWQsIG9wdGlvbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuXHRcdFx0aWYgKGlzTXVsdGlwbGUpIHtcblx0XHRcdFx0c2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG5cdFx0XHRcdGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuXHRcdFx0XHRcdGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG5cdFx0XHRcdFx0XHRlbC5zZWxlY3RlZEluZGV4ID0gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFpc011bHRpcGxlKSB7XG5cdFx0XHRlbC5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFzTm9NYXRjaGluZ09wdGlvbiAodmFsdWUsIG9wdGlvbnMpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb25zW2ldKSwgdmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuXHRcdHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cblx0XHRcdD8gb3B0aW9uLl92YWx1ZVxuXHRcdFx0OiBvcHRpb24udmFsdWVcblx0fVxuXG5cdGZ1bmN0aW9uIG9uQ29tcG9zaXRpb25TdGFydCAoZSkge1xuXHRcdGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG5cdH1cblxuXHRmdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kIChlKSB7XG5cdFx0Ly8gcHJldmVudCB0cmlnZ2VyaW5nIGFuIGlucHV0IGV2ZW50IGZvciBubyByZWFzb25cblx0XHRpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuXHRcdGUudGFyZ2V0LmNvbXBvc2luZyA9IGZhbHNlO1xuXHRcdHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJpZ2dlciAoZWwsIHR5cGUpIHtcblx0XHR2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG5cdFx0ZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG5cdFx0ZWwuZGlzcGF0Y2hFdmVudChlKTtcblx0fVxuXG5cdC8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5cdGZ1bmN0aW9uIGxvY2F0ZU5vZGUgKHZub2RlKSB7XG5cdFx0cmV0dXJuIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuXHRcdFx0PyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcblx0XHRcdDogdm5vZGVcblx0fVxuXG5cdHZhciBzaG93ID0ge1xuXHRcdGJpbmQ6IGZ1bmN0aW9uIGJpbmQgKGVsLCByZWYsIHZub2RlKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cblx0XHRcdHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG5cdFx0XHR2YXIgdHJhbnNpdGlvbiA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuXHRcdFx0dmFyIG9yaWdpbmFsRGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG5cdFx0XHRcdGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcblx0XHRcdGlmICh2YWx1ZSAmJiB0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuXHRcdFx0XHR2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuXHRcdFx0XHRlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblx0XHRcdHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRpZiAodmFsdWUgPT09IG9sZFZhbHVlKSB7IHJldHVybiB9XG5cdFx0XHR2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuXHRcdFx0dmFyIHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcblx0XHRcdGlmICh0cmFuc2l0aW9uICYmICFpc0lFOSkge1xuXHRcdFx0XHR2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuXHRcdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZWF2ZSh2bm9kZSwgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG5cdFx0XHRlbCxcblx0XHRcdGJpbmRpbmcsXG5cdFx0XHR2bm9kZSxcblx0XHRcdG9sZFZub2RlLFxuXHRcdFx0aXNEZXN0cm95XG5cdFx0KSB7XG5cdFx0XHRpZiAoIWlzRGVzdHJveSkge1xuXHRcdFx0XHRlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR2YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuXHRcdG1vZGVsOiBtb2RlbCQxLFxuXHRcdHNob3c6IHNob3dcblx0fTtcblxuXHQvKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG5cdHZhciB0cmFuc2l0aW9uUHJvcHMgPSB7XG5cdFx0bmFtZTogU3RyaW5nLFxuXHRcdGFwcGVhcjogQm9vbGVhbixcblx0XHRjc3M6IEJvb2xlYW4sXG5cdFx0bW9kZTogU3RyaW5nLFxuXHRcdHR5cGU6IFN0cmluZyxcblx0XHRlbnRlckNsYXNzOiBTdHJpbmcsXG5cdFx0bGVhdmVDbGFzczogU3RyaW5nLFxuXHRcdGVudGVyVG9DbGFzczogU3RyaW5nLFxuXHRcdGxlYXZlVG9DbGFzczogU3RyaW5nLFxuXHRcdGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcblx0XHRsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG5cdFx0YXBwZWFyQ2xhc3M6IFN0cmluZyxcblx0XHRhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nLFxuXHRcdGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcblx0XHRkdXJhdGlvbjogW051bWJlciwgU3RyaW5nLCBPYmplY3RdXG5cdH07XG5cbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcblx0ZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuXHRcdHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG5cdFx0aWYgKGNvbXBPcHRpb25zICYmIGNvbXBPcHRpb25zLkN0b3Iub3B0aW9ucy5hYnN0cmFjdCkge1xuXHRcdFx0cmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHZub2RlXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZXh0cmFjdFRyYW5zaXRpb25EYXRhIChjb21wKSB7XG5cdFx0dmFyIGRhdGEgPSB7fTtcblx0XHR2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG5cdFx0Ly8gcHJvcHNcblx0XHRmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcblx0XHRcdGRhdGFba2V5XSA9IGNvbXBba2V5XTtcblx0XHR9XG5cdFx0Ly8gZXZlbnRzLlxuXHRcdC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuXHRcdHZhciBsaXN0ZW5lcnMgPSBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG5cdFx0Zm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG5cdFx0XHRkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cblx0ZnVuY3Rpb24gcGxhY2Vob2xkZXIgKGgsIHJhd0NoaWxkKSB7XG5cdFx0aWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuXHRcdFx0cmV0dXJuIGgoJ2tlZXAtYWxpdmUnLCB7XG5cdFx0XHRcdHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuXHRcdHdoaWxlICgodm5vZGUgPSB2bm9kZS5wYXJlbnQpKSB7XG5cdFx0XHRpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNTYW1lQ2hpbGQgKGNoaWxkLCBvbGRDaGlsZCkge1xuXHRcdHJldHVybiBvbGRDaGlsZC5rZXkgPT09IGNoaWxkLmtleSAmJiBvbGRDaGlsZC50YWcgPT09IGNoaWxkLnRhZ1xuXHR9XG5cblx0dmFyIFRyYW5zaXRpb24gPSB7XG5cdFx0bmFtZTogJ3RyYW5zaXRpb24nLFxuXHRcdHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG5cdFx0YWJzdHJhY3Q6IHRydWUsXG5cblx0XHRyZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuXHRcdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG5cdFx0XHRpZiAoIWNoaWxkcmVuKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuXHRcdFx0Y2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnOyB9KTtcblx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0aWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcblx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0Jzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcblx0XHRcdFx0XHQnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuXHRcdFx0XHRcdHRoaXMuJHBhcmVudFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbW9kZSA9IHRoaXMubW9kZTtcblxuXHRcdFx0Ly8gd2FybiBpbnZhbGlkIG1vZGVcblx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuXHRcdFx0XHRtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG5cdFx0XHQpIHtcblx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHQnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG5cdFx0XHRcdFx0dGhpcy4kcGFyZW50XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciByYXdDaGlsZCA9IGNoaWxkcmVuWzBdO1xuXG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgY29tcG9uZW50IHJvb3Qgbm9kZSBhbmQgdGhlIGNvbXBvbmVudCdzXG5cdFx0XHQvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cblx0XHRcdGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuXHRcdFx0XHRyZXR1cm4gcmF3Q2hpbGRcblx0XHRcdH1cblxuXHRcdFx0Ly8gYXBwbHkgdHJhbnNpdGlvbiBkYXRhIHRvIGNoaWxkXG5cdFx0XHQvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG5cdFx0XHR2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRpZiAoIWNoaWxkKSB7XG5cdFx0XHRcdHJldHVybiByYXdDaGlsZFxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fbGVhdmluZykge1xuXHRcdFx0XHRyZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG5cdFx0XHR9XG5cblx0XHRcdC8vIGVuc3VyZSBhIGtleSB0aGF0IGlzIHVuaXF1ZSB0byB0aGUgdm5vZGUgdHlwZSBhbmQgdG8gdGhpcyB0cmFuc2l0aW9uXG5cdFx0XHQvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG5cdFx0XHQvLyBkdXJpbmcgZW50ZXJpbmcuXG5cdFx0XHR2YXIgaWQgPSBcIl9fdHJhbnNpdGlvbi1cIiArICh0aGlzLl91aWQpICsgXCItXCI7XG5cdFx0XHRjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuXHRcdFx0XHQ/IGlkICsgY2hpbGQudGFnXG5cdFx0XHRcdDogaXNQcmltaXRpdmUoY2hpbGQua2V5KVxuXHRcdFx0XHQ/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuXHRcdFx0XHQ6IGNoaWxkLmtleTtcblxuXHRcdFx0dmFyIGRhdGEgPSAoY2hpbGQuZGF0YSB8fCAoY2hpbGQuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblx0XHRcdHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuXHRcdFx0dmFyIG9sZENoaWxkID0gZ2V0UmVhbENoaWxkKG9sZFJhd0NoaWxkKTtcblxuXHRcdFx0Ly8gbWFyayB2LXNob3dcblx0XHRcdC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuXHRcdFx0aWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH0pKSB7XG5cdFx0XHRcdGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvbGRDaGlsZCAmJiBvbGRDaGlsZC5kYXRhICYmICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpKSB7XG5cdFx0XHRcdC8vIHJlcGxhY2Ugb2xkIGNoaWxkIHRyYW5zaXRpb24gZGF0YSB3aXRoIGZyZXNoIG9uZVxuXHRcdFx0XHQvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG5cdFx0XHRcdHZhciBvbGREYXRhID0gb2xkQ2hpbGQgJiYgKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuXHRcdFx0XHQvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG5cdFx0XHRcdGlmIChtb2RlID09PSAnb3V0LWluJykge1xuXHRcdFx0XHRcdC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuXHRcdFx0XHRcdHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuXHRcdFx0XHR9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG5cdFx0XHRcdFx0dmFyIGRlbGF5ZWRMZWF2ZTtcblx0XHRcdFx0XHR2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcblx0XHRcdFx0XHRtZXJnZVZOb2RlSG9vayhkYXRhLCAnYWZ0ZXJFbnRlcicsIHBlcmZvcm1MZWF2ZSk7XG5cdFx0XHRcdFx0bWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcblx0XHRcdFx0XHRtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnZGVsYXlMZWF2ZScsIGZ1bmN0aW9uIChsZWF2ZSkgeyBkZWxheWVkTGVhdmUgPSBsZWF2ZTsgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHJhd0NoaWxkXG5cdFx0fVxuXHR9O1xuXG5cdC8qICAqL1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGxpc3QgaXRlbXMuXG4vLyBzdXBwb3J0cyBtb3ZlIHRyYW5zaXRpb25zIHVzaW5nIHRoZSBGTElQIHRlY2huaXF1ZS5cblxuLy8gQmVjYXVzZSB0aGUgdmRvbSdzIGNoaWxkcmVuIHVwZGF0ZSBhbGdvcml0aG0gaXMgXCJ1bnN0YWJsZVwiIC0gaS5lLlxuLy8gaXQgZG9lc24ndCBndWFyYW50ZWUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHJlbW92ZWQgZWxlbWVudHMsXG4vLyB3ZSBmb3JjZSB0cmFuc2l0aW9uLWdyb3VwIHRvIHVwZGF0ZSBpdHMgY2hpbGRyZW4gaW50byB0d28gcGFzc2VzOlxuLy8gaW4gdGhlIGZpcnN0IHBhc3MsIHdlIHJlbW92ZSBhbGwgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQsXG4vLyB0cmlnZ2VyaW5nIHRoZWlyIGxlYXZpbmcgdHJhbnNpdGlvbjsgaW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBpbnNlcnQvbW92ZVxuLy8gaW50byB0aGUgZmluYWwgZGVzaXJlZCBzdGF0ZS4gVGhpcyB3YXkgaW4gdGhlIHNlY29uZCBwYXNzIHJlbW92ZWRcbi8vIG5vZGVzIHdpbGwgcmVtYWluIHdoZXJlIHRoZXkgc2hvdWxkIGJlLlxuXG5cdHZhciBwcm9wcyA9IGV4dGVuZCh7XG5cdFx0dGFnOiBTdHJpbmcsXG5cdFx0bW92ZUNsYXNzOiBTdHJpbmdcblx0fSwgdHJhbnNpdGlvblByb3BzKTtcblxuXHRkZWxldGUgcHJvcHMubW9kZTtcblxuXHR2YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuXHRcdHByb3BzOiBwcm9wcyxcblxuXHRcdHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG5cdFx0XHR2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuXHRcdFx0dmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHR2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXHRcdFx0dmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcblx0XHRcdHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuXHRcdFx0XHRpZiAoYy50YWcpIHtcblx0XHRcdFx0XHRpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuXHRcdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaChjKTtcblx0XHRcdFx0XHRcdG1hcFtjLmtleV0gPSBjXG5cdFx0XHRcdFx0XHQ7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuXHRcdFx0XHRcdFx0dmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG5cdFx0XHRcdFx0XHR3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHByZXZDaGlsZHJlbikge1xuXHRcdFx0XHR2YXIga2VwdCA9IFtdO1xuXHRcdFx0XHR2YXIgcmVtb3ZlZCA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuXHRcdFx0XHRcdHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcblx0XHRcdFx0XHRjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG5cdFx0XHRcdFx0YyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0XHRpZiAobWFwW2MkMS5rZXldKSB7XG5cdFx0XHRcdFx0XHRrZXB0LnB1c2goYyQxKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVtb3ZlZC5wdXNoKGMkMSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcblx0XHRcdFx0dGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcblx0XHR9LFxuXG5cdFx0YmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBiZWZvcmVVcGRhdGUgKCkge1xuXHRcdFx0Ly8gZm9yY2UgcmVtb3ZpbmcgcGFzc1xuXHRcdFx0dGhpcy5fX3BhdGNoX18oXG5cdFx0XHRcdHRoaXMuX3Zub2RlLFxuXHRcdFx0XHR0aGlzLmtlcHQsXG5cdFx0XHRcdGZhbHNlLCAvLyBoeWRyYXRpbmdcblx0XHRcdFx0dHJ1ZSAvLyByZW1vdmVPbmx5ICghaW1wb3J0YW50LCBhdm9pZHMgdW5uZWNlc3NhcnkgbW92ZXMpXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG5cdFx0fSxcblxuXHRcdHVwZGF0ZWQ6IGZ1bmN0aW9uIHVwZGF0ZWQgKCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG5cdFx0XHR2YXIgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKCh0aGlzLm5hbWUgfHwgJ3YnKSArICctbW92ZScpO1xuXHRcdFx0aWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdC8vIHdlIGRpdmlkZSB0aGUgd29yayBpbnRvIHRocmVlIGxvb3BzIHRvIGF2b2lkIG1peGluZyBET00gcmVhZHMgYW5kIHdyaXRlc1xuXHRcdFx0Ly8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG5cdFx0XHRjaGlsZHJlbi5mb3JFYWNoKGNhbGxQZW5kaW5nQ2JzKTtcblx0XHRcdGNoaWxkcmVuLmZvckVhY2gocmVjb3JkUG9zaXRpb24pO1xuXHRcdFx0Y2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuXHRcdFx0Ly8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG5cdFx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG5cdFx0XHR2YXIgZiA9IGJvZHkub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cblx0XHRcdGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0aWYgKGMuZGF0YS5tb3ZlZCkge1xuXHRcdFx0XHRcdHZhciBlbCA9IGMuZWxtO1xuXHRcdFx0XHRcdHZhciBzID0gZWwuc3R5bGU7XG5cdFx0XHRcdFx0YWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuXHRcdFx0XHRcdHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuXHRcdFx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcblx0XHRcdFx0XHRcdGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcblx0XHRcdFx0XHRcdFx0ZWwuX21vdmVDYiA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdG1ldGhvZHM6IHtcblx0XHRcdGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcblx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHRcdGlmICghaGFzVHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9oYXNNb3ZlICE9IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5faGFzTW92ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuXHRcdFx0XHQvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcblx0XHRcdFx0Ly8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuXHRcdFx0XHQvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3Ncblx0XHRcdFx0Ly8gaXMgYXBwbGllZC5cblx0XHRcdFx0dmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG5cdFx0XHRcdGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcblx0XHRcdFx0XHRlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcblx0XHRcdFx0Y2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0dGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuXHRcdFx0XHR2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcblx0XHRcdFx0dGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuXHRcdFx0XHRyZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoYy5lbG0uX21vdmVDYikge1xuXHRcdFx0Yy5lbG0uX21vdmVDYigpO1xuXHRcdH1cblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRpZiAoYy5lbG0uX2VudGVyQ2IpIHtcblx0XHRcdGMuZWxtLl9lbnRlckNiKCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcblx0XHRjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG5cdFx0dmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG5cdFx0dmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG5cdFx0dmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcblx0XHR2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcblx0XHRpZiAoZHggfHwgZHkpIHtcblx0XHRcdGMuZGF0YS5tb3ZlZCA9IHRydWU7XG5cdFx0XHR2YXIgcyA9IGMuZWxtLnN0eWxlO1xuXHRcdFx0cy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuXHRcdFx0cy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuXHRcdH1cblx0fVxuXG5cdHZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG5cdFx0VHJhbnNpdGlvbjogVHJhbnNpdGlvbixcblx0XHRUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxuXHR9O1xuXG5cdC8qICAqL1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5cdFZ1ZSQzLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuXHRWdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5cdFZ1ZSQzLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuXHRWdWUkMy5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuXHRWdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuXHRleHRlbmQoVnVlJDMub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuXHRleHRlbmQoVnVlJDMub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHBhdGNoIGZ1bmN0aW9uXG5cdFZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2Rcblx0VnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcblx0XHRlbCxcblx0XHRoeWRyYXRpbmdcblx0KSB7XG5cdFx0ZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG5cdFx0cmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG5cdH07XG5cbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdGlmIChjb25maWcuZGV2dG9vbHMpIHtcblx0XHRcdGlmIChkZXZ0b29scykge1xuXHRcdFx0XHRkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlJDMpO1xuXHRcdFx0fSBlbHNlIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0Nocm9tZSkge1xuXHRcdFx0XHRjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcblx0XHRcdFx0XHQnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG5cdFx0XHRcdFx0J2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuXHRcdFx0Y29uZmlnLnByb2R1Y3Rpb25UaXAgIT09IGZhbHNlICYmXG5cdFx0XHRpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG5cdFx0KSB7XG5cdFx0XHRjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcblx0XHRcdFx0XCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuXHRcdFx0XHRcIk1ha2Ugc3VyZSB0byB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSB3aGVuIGRlcGxveWluZyBmb3IgcHJvZHVjdGlvbi5cXG5cIiArXG5cdFx0XHRcdFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuXHRcdFx0KTtcblx0XHR9XG5cdH0sIDApO1xuXG5cdC8qICAqL1xuXG4vLyBjaGVjayB3aGV0aGVyIGN1cnJlbnQgYnJvd3NlciBlbmNvZGVzIGEgY2hhciBpbnNpZGUgYXR0cmlidXRlIHZhbHVlc1xuXHRmdW5jdGlvbiBzaG91bGREZWNvZGUgKGNvbnRlbnQsIGVuY29kZWQpIHtcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiPGRpdiBhPVxcXCJcIiArIGNvbnRlbnQgKyBcIlxcXCI+XCI7XG5cdFx0cmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZihlbmNvZGVkKSA+IDBcblx0fVxuXG4vLyAjMzY2M1xuLy8gSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxuXHR2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBzaG91bGREZWNvZGUoJ1xcbicsICcmIzEwOycpIDogZmFsc2U7XG5cblx0LyogICovXG5cblx0dmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuXHRcdCdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcblx0XHQnbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnInXG5cdCk7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxuXHR2YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG5cdFx0J2NvbGdyb3VwLGRkLGR0LGxpLG9wdGlvbnMscCx0ZCx0Zm9vdCx0aCx0aGVhZCx0cixzb3VyY2UnXG5cdCk7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuXHR2YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG5cdFx0J2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcblx0XHQnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuXHRcdCdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcblx0XHQnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuXHRcdCd0aXRsZSx0cix0cmFjaydcblx0KTtcblxuXHQvKiAgKi9cblxuXHR2YXIgZGVjb2RlcjtcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGh0bWwpIHtcblx0XHRkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRkZWNvZGVyLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0cmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnRcblx0fVxuXG5cdC8qKlxuXHQgKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cblx0ICovXG5cblx0LyohXG5cdCAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcblx0ICogTW9kaWZpZWQgYnkgSnVyaXkgXCJrYW5nYXhcIiBaYXl0c2V2XG5cdCAqIE9yaWdpbmFsIGNvZGUgYnkgRXJpayBBcnZpZHNzb24sIE1vemlsbGEgUHVibGljIExpY2Vuc2Vcblx0ICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcblx0ICovXG5cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuXHR2YXIgc2luZ2xlQXR0cklkZW50aWZpZXIgPSAvKFteXFxzXCInPD4vPV0rKS87XG5cdHZhciBzaW5nbGVBdHRyQXNzaWduID0gLyg/Oj0pLztcblx0dmFyIHNpbmdsZUF0dHJWYWx1ZXMgPSBbXG5cdFx0Ly8gYXR0ciB2YWx1ZSBkb3VibGUgcXVvdGVzXG5cdFx0L1wiKFteXCJdKilcIisvLnNvdXJjZSxcblx0XHQvLyBhdHRyIHZhbHVlLCBzaW5nbGUgcXVvdGVzXG5cdFx0LycoW14nXSopJysvLnNvdXJjZSxcblx0XHQvLyBhdHRyIHZhbHVlLCBubyBxdW90ZXNcblx0XHQvKFteXFxzXCInPTw+YF0rKS8uc291cmNlXG5cdF07XG5cdHZhciBhdHRyaWJ1dGUgPSBuZXcgUmVnRXhwKFxuXHRcdCdeXFxcXHMqJyArIHNpbmdsZUF0dHJJZGVudGlmaWVyLnNvdXJjZSArXG5cdFx0Jyg/OlxcXFxzKignICsgc2luZ2xlQXR0ckFzc2lnbi5zb3VyY2UgKyAnKScgK1xuXHRcdCdcXFxccyooPzonICsgc2luZ2xlQXR0clZhbHVlcy5qb2luKCd8JykgKyAnKSk/J1xuXHQpO1xuXG4vLyBjb3VsZCB1c2UgaHR0cHM6Ly93d3cudzMub3JnL1RSLzE5OTkvUkVDLXhtbC1uYW1lcy0xOTk5MDExNC8jTlQtUU5hbWVcbi8vIGJ1dCBmb3IgVnVlIHRlbXBsYXRlcyB3ZSBjYW4gZW5mb3JjZSBhIHNpbXBsZSBjaGFyc2V0XG5cdHZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcblx0dmFyIHFuYW1lQ2FwdHVyZSA9ICcoKD86JyArIG5jbmFtZSArICdcXFxcOik/JyArIG5jbmFtZSArICcpJztcblx0dmFyIHN0YXJ0VGFnT3BlbiA9IG5ldyBSZWdFeHAoJ148JyArIHFuYW1lQ2FwdHVyZSk7XG5cdHZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG5cdHZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKCdePFxcXFwvJyArIHFuYW1lQ2FwdHVyZSArICdbXj5dKj4nKTtcblx0dmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcblx0dmFyIGNvbW1lbnQgPSAvXjwhLS0vO1xuXHR2YXIgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG5cblx0dmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcblx0J3gnLnJlcGxhY2UoL3goLik/L2csIGZ1bmN0aW9uIChtLCBnKSB7XG5cdFx0SVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiA9IGcgPT09ICcnO1xuXHR9KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG5cdHZhciBpc1BsYWluVGV4dEVsZW1lbnQgPSBtYWtlTWFwKCdzY3JpcHQsc3R5bGUsdGV4dGFyZWEnLCB0cnVlKTtcblx0dmFyIHJlQ2FjaGUgPSB7fTtcblxuXHR2YXIgZGVjb2RpbmdNYXAgPSB7XG5cdFx0JyZsdDsnOiAnPCcsXG5cdFx0JyZndDsnOiAnPicsXG5cdFx0JyZxdW90Oyc6ICdcIicsXG5cdFx0JyZhbXA7JzogJyYnLFxuXHRcdCcmIzEwOyc6ICdcXG4nXG5cdH07XG5cdHZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXApOy9nO1xuXHR2YXIgZW5jb2RlZEF0dHJXaXRoTmV3TGluZXMgPSAvJig/Omx0fGd0fHF1b3R8YW1wfCMxMCk7L2c7XG5cblx0ZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG5cdFx0dmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuXHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuXHRcdHZhciBzdGFjayA9IFtdO1xuXHRcdHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuXHRcdHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuXHRcdHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuXHRcdHZhciBpbmRleCA9IDA7XG5cdFx0dmFyIGxhc3QsIGxhc3RUYWc7XG5cdFx0d2hpbGUgKGh0bWwpIHtcblx0XHRcdGxhc3QgPSBodG1sO1xuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcblx0XHRcdGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG5cdFx0XHRcdHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG5cdFx0XHRcdGlmICh0ZXh0RW5kID09PSAwKSB7XG5cdFx0XHRcdFx0Ly8gQ29tbWVudDpcblx0XHRcdFx0XHRpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG5cdFx0XHRcdFx0XHR2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cblx0XHRcdFx0XHRcdGlmIChjb21tZW50RW5kID49IDApIHtcblx0XHRcdFx0XHRcdFx0YWR2YW5jZShjb21tZW50RW5kICsgMyk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG5cdFx0XHRcdFx0aWYgKGNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KGh0bWwpKSB7XG5cdFx0XHRcdFx0XHR2YXIgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG5cblx0XHRcdFx0XHRcdGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGFkdmFuY2UoY29uZGl0aW9uYWxFbmQgKyAyKTtcblx0XHRcdFx0XHRcdFx0Y29udGludWVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEb2N0eXBlOlxuXHRcdFx0XHRcdHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuXHRcdFx0XHRcdGlmIChkb2N0eXBlTWF0Y2gpIHtcblx0XHRcdFx0XHRcdGFkdmFuY2UoZG9jdHlwZU1hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRjb250aW51ZVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVuZCB0YWc6XG5cdFx0XHRcdFx0dmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuXHRcdFx0XHRcdGlmIChlbmRUYWdNYXRjaCkge1xuXHRcdFx0XHRcdFx0dmFyIGN1ckluZGV4ID0gaW5kZXg7XG5cdFx0XHRcdFx0XHRhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3RhcnQgdGFnOlxuXHRcdFx0XHRcdHZhciBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuXHRcdFx0XHRcdGlmIChzdGFydFRhZ01hdGNoKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVTdGFydFRhZyhzdGFydFRhZ01hdGNoKTtcblx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHRleHQgPSAodm9pZCAwKSwgcmVzdCQxID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcblx0XHRcdFx0aWYgKHRleHRFbmQgPj0gMCkge1xuXHRcdFx0XHRcdHJlc3QkMSA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG5cdFx0XHRcdFx0d2hpbGUgKFxuXHRcdFx0XHRcdCFlbmRUYWcudGVzdChyZXN0JDEpICYmXG5cdFx0XHRcdFx0IXN0YXJ0VGFnT3Blbi50ZXN0KHJlc3QkMSkgJiZcblx0XHRcdFx0XHQhY29tbWVudC50ZXN0KHJlc3QkMSkgJiZcblx0XHRcdFx0XHQhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdCQxKVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHQvLyA8IGluIHBsYWluIHRleHQsIGJlIGZvcmdpdmluZyBhbmQgdHJlYXQgaXQgYXMgdGV4dFxuXHRcdFx0XHRcdFx0bmV4dCA9IHJlc3QkMS5pbmRleE9mKCc8JywgMSk7XG5cdFx0XHRcdFx0XHRpZiAobmV4dCA8IDApIHsgYnJlYWsgfVxuXHRcdFx0XHRcdFx0dGV4dEVuZCArPSBuZXh0O1xuXHRcdFx0XHRcdFx0cmVzdCQxID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuXHRcdFx0XHRcdGFkdmFuY2UodGV4dEVuZCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAodGV4dEVuZCA8IDApIHtcblx0XHRcdFx0XHR0ZXh0ID0gaHRtbDtcblx0XHRcdFx0XHRodG1sID0gJyc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAob3B0aW9ucy5jaGFycyAmJiB0ZXh0KSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5jaGFycyh0ZXh0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcblx0XHRcdFx0dmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG5cdFx0XHRcdHZhciByZXN0ID0gaHRtbC5yZXBsYWNlKHJlU3RhY2tlZFRhZywgZnVuY3Rpb24gKGFsbCwgdGV4dCwgZW5kVGFnKSB7XG5cdFx0XHRcdFx0ZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAoIWlzUGxhaW5UZXh0RWxlbWVudChzdGFja2VkVGFnKSAmJiBzdGFja2VkVGFnICE9PSAnbm9zY3JpcHQnKSB7XG5cdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dFxuXHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKVxuXHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMuY2hhcnMpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnMuY2hhcnModGV4dCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAnJ1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0aW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0Lmxlbmd0aDtcblx0XHRcdFx0aHRtbCA9IHJlc3Q7XG5cdFx0XHRcdHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChodG1sID09PSBsYXN0KSB7XG5cdFx0XHRcdG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcblx0XHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy53YXJuKChcIk1hbC1mb3JtYXR0ZWQgdGFnIGF0IGVuZCBvZiB0ZW1wbGF0ZTogXFxcIlwiICsgaHRtbCArIFwiXFxcIlwiKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3Ncblx0XHRwYXJzZUVuZFRhZygpO1xuXG5cdFx0ZnVuY3Rpb24gYWR2YW5jZSAobikge1xuXHRcdFx0aW5kZXggKz0gbjtcblx0XHRcdGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcblx0XHRcdHZhciBzdGFydCA9IGh0bWwubWF0Y2goc3RhcnRUYWdPcGVuKTtcblx0XHRcdGlmIChzdGFydCkge1xuXHRcdFx0XHR2YXIgbWF0Y2ggPSB7XG5cdFx0XHRcdFx0dGFnTmFtZTogc3RhcnRbMV0sXG5cdFx0XHRcdFx0YXR0cnM6IFtdLFxuXHRcdFx0XHRcdHN0YXJ0OiBpbmRleFxuXHRcdFx0XHR9O1xuXHRcdFx0XHRhZHZhbmNlKHN0YXJ0WzBdLmxlbmd0aCk7XG5cdFx0XHRcdHZhciBlbmQsIGF0dHI7XG5cdFx0XHRcdHdoaWxlICghKGVuZCA9IGh0bWwubWF0Y2goc3RhcnRUYWdDbG9zZSkpICYmIChhdHRyID0gaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuXHRcdFx0XHRcdGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuXHRcdFx0XHRcdG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGVuZCkge1xuXHRcdFx0XHRcdG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG5cdFx0XHRcdFx0YWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcblx0XHRcdFx0XHRtYXRjaC5lbmQgPSBpbmRleDtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuXHRcdFx0dmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuXHRcdFx0dmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG5cdFx0XHRpZiAoZXhwZWN0SFRNTCkge1xuXHRcdFx0XHRpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcblx0XHRcdFx0XHRwYXJzZUVuZFRhZyhsYXN0VGFnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG5cdFx0XHRcdFx0cGFyc2VFbmRUYWcodGFnTmFtZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCB0YWdOYW1lID09PSAnaHRtbCcgJiYgbGFzdFRhZyA9PT0gJ2hlYWQnIHx8ICEhdW5hcnlTbGFzaDtcblxuXHRcdFx0dmFyIGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG5cdFx0XHR2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuXHRcdFx0XHQvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3Nzhcblx0XHRcdFx0aWYgKElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gJiYgYXJnc1swXS5pbmRleE9mKCdcIlwiJykgPT09IC0xKSB7XG5cdFx0XHRcdFx0aWYgKGFyZ3NbM10gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzNdOyB9XG5cdFx0XHRcdFx0aWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG5cdFx0XHRcdFx0aWYgKGFyZ3NbNV0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzVdOyB9XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG5cdFx0XHRcdGF0dHJzW2ldID0ge1xuXHRcdFx0XHRcdG5hbWU6IGFyZ3NbMV0sXG5cdFx0XHRcdFx0dmFsdWU6IGRlY29kZUF0dHIoXG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHRcdG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNcblx0XHRcdFx0XHQpXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGlmICghdW5hcnkpIHtcblx0XHRcdFx0c3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG5cdFx0XHRcdGxhc3RUYWcgPSB0YWdOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob3B0aW9ucy5zdGFydCkge1xuXHRcdFx0XHRvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIGF0dHJzLCB1bmFyeSwgbWF0Y2guc3RhcnQsIG1hdGNoLmVuZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcGFyc2VFbmRUYWcgKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcblx0XHRcdHZhciBwb3MsIGxvd2VyQ2FzZWRUYWdOYW1lO1xuXHRcdFx0aWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuXHRcdFx0aWYgKGVuZCA9PSBudWxsKSB7IGVuZCA9IGluZGV4OyB9XG5cblx0XHRcdGlmICh0YWdOYW1lKSB7XG5cdFx0XHRcdGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuXHRcdFx0aWYgKHRhZ05hbWUpIHtcblx0XHRcdFx0Zm9yIChwb3MgPSBzdGFjay5sZW5ndGggLSAxOyBwb3MgPj0gMDsgcG9zLS0pIHtcblx0XHRcdFx0XHRpZiAoc3RhY2tbcG9zXS5sb3dlckNhc2VkVGFnID09PSBsb3dlckNhc2VkVGFnTmFtZSkge1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIElmIG5vIHRhZyBuYW1lIGlzIHByb3ZpZGVkLCBjbGVhbiBzaG9wXG5cdFx0XHRcdHBvcyA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwb3MgPj0gMCkge1xuXHRcdFx0XHQvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuXHRcdFx0XHRmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuXHRcdFx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuXHRcdFx0XHRcdFx0KGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLndhcm5cblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvbnMud2Fybihcblx0XHRcdFx0XHRcdFx0KFwidGFnIDxcIiArIChzdGFja1tpXS50YWcpICsgXCI+IGhhcyBubyBtYXRjaGluZyBlbmQgdGFnLlwiKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG9wdGlvbnMuZW5kKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuXHRcdFx0XHRzdGFjay5sZW5ndGggPSBwb3M7XG5cdFx0XHRcdGxhc3RUYWcgPSBwb3MgJiYgc3RhY2tbcG9zIC0gMV0udGFnO1xuXHRcdFx0fSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuXHRcdFx0XHRpZiAob3B0aW9ucy5zdGFydCkge1xuXHRcdFx0XHRcdG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIHRydWUsIHN0YXJ0LCBlbmQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGxvd2VyQ2FzZWRUYWdOYW1lID09PSAncCcpIHtcblx0XHRcdFx0aWYgKG9wdGlvbnMuc3RhcnQpIHtcblx0XHRcdFx0XHRvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9wdGlvbnMuZW5kKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcblx0dmFyIHJlZ2V4RXNjYXBlUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nO1xuXG5cdHZhciBidWlsZFJlZ2V4ID0gY2FjaGVkKGZ1bmN0aW9uIChkZWxpbWl0ZXJzKSB7XG5cdFx0dmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuXHRcdHZhciBjbG9zZSA9IGRlbGltaXRlcnNbMV0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG5cdFx0cmV0dXJuIG5ldyBSZWdFeHAob3BlbiArICcoKD86LnxcXFxcbikrPyknICsgY2xvc2UsICdnJylcblx0fSk7XG5cblx0ZnVuY3Rpb24gcGFyc2VUZXh0IChcblx0XHR0ZXh0LFxuXHRcdGRlbGltaXRlcnNcblx0KSB7XG5cdFx0dmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG5cdFx0aWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0dmFyIHRva2VucyA9IFtdO1xuXHRcdHZhciBsYXN0SW5kZXggPSB0YWdSRS5sYXN0SW5kZXggPSAwO1xuXHRcdHZhciBtYXRjaCwgaW5kZXg7XG5cdFx0d2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG5cdFx0XHRpbmRleCA9IG1hdGNoLmluZGV4O1xuXHRcdFx0Ly8gcHVzaCB0ZXh0IHRva2VuXG5cdFx0XHRpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcblx0XHRcdFx0dG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodGV4dC5zbGljZShsYXN0SW5kZXgsIGluZGV4KSkpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdGFnIHRva2VuXG5cdFx0XHR2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG5cdFx0XHR0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG5cdFx0XHRsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblx0XHR9XG5cdFx0aWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG5cdFx0XHR0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCcrJylcblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBvblJFID0gL15AfF52LW9uOi87XG5cdHZhciBkaXJSRSA9IC9edi18XkB8XjovO1xuXHR2YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG5cdHZhciBmb3JJdGVyYXRvclJFID0gL1xcKChcXHtbXn1dKlxcfXxbXixdKiksKFteLF0qKSg/OiwoW14sXSopKT9cXCkvO1xuXG5cdHZhciBhcmdSRSA9IC86KC4qKSQvO1xuXHR2YXIgYmluZFJFID0gL146fF52LWJpbmQ6Lztcblx0dmFyIG1vZGlmaWVyUkUgPSAvXFwuW14uXSsvZztcblxuXHR2YXIgZGVjb2RlSFRNTENhY2hlZCA9IGNhY2hlZChkZWNvZGUpO1xuXG4vLyBjb25maWd1cmFibGUgc3RhdGVcblx0dmFyIHdhcm4kMjtcblx0dmFyIGRlbGltaXRlcnM7XG5cdHZhciB0cmFuc2Zvcm1zO1xuXHR2YXIgcHJlVHJhbnNmb3Jtcztcblx0dmFyIHBvc3RUcmFuc2Zvcm1zO1xuXHR2YXIgcGxhdGZvcm1Jc1ByZVRhZztcblx0dmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG5cdHZhciBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZTtcblxuXHQvKipcblx0ICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG5cdCAqL1xuXHRmdW5jdGlvbiBwYXJzZSAoXG5cdFx0dGVtcGxhdGUsXG5cdFx0b3B0aW9uc1xuXHQpIHtcblx0XHR3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cdFx0cGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UgPSBvcHRpb25zLmdldFRhZ05hbWVzcGFjZSB8fCBubztcblx0XHRwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcblx0XHRwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcblx0XHRwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG5cdFx0dHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuXHRcdHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXHRcdGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cblx0XHR2YXIgc3RhY2sgPSBbXTtcblx0XHR2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuXHRcdHZhciByb290O1xuXHRcdHZhciBjdXJyZW50UGFyZW50O1xuXHRcdHZhciBpblZQcmUgPSBmYWxzZTtcblx0XHR2YXIgaW5QcmUgPSBmYWxzZTtcblx0XHR2YXIgd2FybmVkID0gZmFsc2U7XG5cblx0XHRmdW5jdGlvbiB3YXJuT25jZSAobXNnKSB7XG5cdFx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0XHR3YXJuJDIobXNnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBlbmRQcmUgKGVsZW1lbnQpIHtcblx0XHRcdC8vIGNoZWNrIHByZSBzdGF0ZVxuXHRcdFx0aWYgKGVsZW1lbnQucHJlKSB7XG5cdFx0XHRcdGluVlByZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG5cdFx0XHRcdGluUHJlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cGFyc2VIVE1MKHRlbXBsYXRlLCB7XG5cdFx0XHR3YXJuOiB3YXJuJDIsXG5cdFx0XHRleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG5cdFx0XHRpc1VuYXJ5VGFnOiBvcHRpb25zLmlzVW5hcnlUYWcsXG5cdFx0XHRjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG5cdFx0XHRzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcblx0XHRcdHN0YXJ0OiBmdW5jdGlvbiBzdGFydCAodGFnLCBhdHRycywgdW5hcnkpIHtcblx0XHRcdFx0Ly8gY2hlY2sgbmFtZXNwYWNlLlxuXHRcdFx0XHQvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcblx0XHRcdFx0dmFyIG5zID0gKGN1cnJlbnRQYXJlbnQgJiYgY3VycmVudFBhcmVudC5ucykgfHwgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2UodGFnKTtcblxuXHRcdFx0XHQvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuXHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdFx0aWYgKGlzSUUgJiYgbnMgPT09ICdzdmcnKSB7XG5cdFx0XHRcdFx0YXR0cnMgPSBndWFyZElFU1ZHQnVnKGF0dHJzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBlbGVtZW50ID0ge1xuXHRcdFx0XHRcdHR5cGU6IDEsXG5cdFx0XHRcdFx0dGFnOiB0YWcsXG5cdFx0XHRcdFx0YXR0cnNMaXN0OiBhdHRycyxcblx0XHRcdFx0XHRhdHRyc01hcDogbWFrZUF0dHJzTWFwKGF0dHJzKSxcblx0XHRcdFx0XHRwYXJlbnQ6IGN1cnJlbnRQYXJlbnQsXG5cdFx0XHRcdFx0Y2hpbGRyZW46IFtdXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChucykge1xuXHRcdFx0XHRcdGVsZW1lbnQubnMgPSBucztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuXHRcdFx0XHRcdGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuJDIoXG5cdFx0XHRcdFx0XHQnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG5cdFx0XHRcdFx0XHQnVUkuIEF2b2lkIHBsYWNpbmcgdGFncyB3aXRoIHNpZGUtZWZmZWN0cyBpbiB5b3VyIHRlbXBsYXRlcywgc3VjaCBhcyAnICtcblx0XHRcdFx0XHRcdFwiPFwiICsgdGFnICsgXCI+XCIgKyAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGFwcGx5IHByZS10cmFuc2Zvcm1zXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHByZVRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIWluVlByZSkge1xuXHRcdFx0XHRcdHByb2Nlc3NQcmUoZWxlbWVudCk7XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQucHJlKSB7XG5cdFx0XHRcdFx0XHRpblZQcmUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcblx0XHRcdFx0XHRpblByZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGluVlByZSkge1xuXHRcdFx0XHRcdHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwcm9jZXNzRm9yKGVsZW1lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NJZihlbGVtZW50KTtcblx0XHRcdFx0XHRwcm9jZXNzT25jZShlbGVtZW50KTtcblx0XHRcdFx0XHRwcm9jZXNzS2V5KGVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0Ly8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBpcyBhIHBsYWluIGVsZW1lbnQgYWZ0ZXJcblx0XHRcdFx0XHQvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRlbGVtZW50LnBsYWluID0gIWVsZW1lbnQua2V5ICYmICFhdHRycy5sZW5ndGg7XG5cblx0XHRcdFx0XHRwcm9jZXNzUmVmKGVsZW1lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuXHRcdFx0XHRcdHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkkMSsrKSB7XG5cdFx0XHRcdFx0XHR0cmFuc2Zvcm1zW2kkMV0oZWxlbWVudCwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByb2Nlc3NBdHRycyhlbGVtZW50KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcblx0XHRcdFx0XHRcdFx0d2Fybk9uY2UoXG5cdFx0XHRcdFx0XHRcdFx0XCJDYW5ub3QgdXNlIDxcIiArIChlbC50YWcpICsgXCI+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgXCIgK1xuXHRcdFx0XHRcdFx0XHRcdCdjb250YWluIG11bHRpcGxlIG5vZGVzLidcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChlbC5hdHRyc01hcC5oYXNPd25Qcm9wZXJ0eSgndi1mb3InKSkge1xuXHRcdFx0XHRcdFx0XHR3YXJuT25jZShcblx0XHRcdFx0XHRcdFx0XHQnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG5cdFx0XHRcdFx0XHRcdFx0J2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJ1xuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHRyZWUgbWFuYWdlbWVudFxuXHRcdFx0XHRpZiAoIXJvb3QpIHtcblx0XHRcdFx0XHRyb290ID0gZWxlbWVudDtcblx0XHRcdFx0XHRjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcblx0XHRcdFx0fSBlbHNlIGlmICghc3RhY2subGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG5cdFx0XHRcdFx0aWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcblx0XHRcdFx0XHRcdGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuXHRcdFx0XHRcdFx0YWRkSWZDb25kaXRpb24ocm9vdCwge1xuXHRcdFx0XHRcdFx0XHRleHA6IGVsZW1lbnQuZWxzZWlmLFxuXHRcdFx0XHRcdFx0XHRibG9jazogZWxlbWVudFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHdhcm5PbmNlKFxuXHRcdFx0XHRcdFx0XHRcIkNvbXBvbmVudCB0ZW1wbGF0ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IG9uZSByb290IGVsZW1lbnQuIFwiICtcblx0XHRcdFx0XHRcdFx0XCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcblx0XHRcdFx0XHRcdFx0XCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGN1cnJlbnRQYXJlbnQgJiYgIWVsZW1lbnQuZm9yYmlkZGVuKSB7XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuXHRcdFx0XHRcdFx0cHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7IC8vIHNjb3BlZCBzbG90XG5cdFx0XHRcdFx0XHRjdXJyZW50UGFyZW50LnBsYWluID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChlbGVtZW50KTtcblx0XHRcdFx0XHRcdGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF1bmFyeSkge1xuXHRcdFx0XHRcdGN1cnJlbnRQYXJlbnQgPSBlbGVtZW50O1xuXHRcdFx0XHRcdHN0YWNrLnB1c2goZWxlbWVudCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZW5kUHJlKGVsZW1lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuXHRcdFx0XHRmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkkMisrKSB7XG5cdFx0XHRcdFx0cG9zdFRyYW5zZm9ybXNbaSQyXShlbGVtZW50LCBvcHRpb25zKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0ZW5kOiBmdW5jdGlvbiBlbmQgKCkge1xuXHRcdFx0XHQvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR2YXIgbGFzdE5vZGUgPSBlbGVtZW50LmNoaWxkcmVuW2VsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcblx0XHRcdFx0XHRlbGVtZW50LmNoaWxkcmVuLnBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHBvcCBzdGFja1xuXHRcdFx0XHRzdGFjay5sZW5ndGggLT0gMTtcblx0XHRcdFx0Y3VycmVudFBhcmVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRlbmRQcmUoZWxlbWVudCk7XG5cdFx0XHR9LFxuXG5cdFx0XHRjaGFyczogZnVuY3Rpb24gY2hhcnMgKHRleHQpIHtcblx0XHRcdFx0aWYgKCFjdXJyZW50UGFyZW50KSB7XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG5cdFx0XHRcdFx0XHRcdHdhcm5PbmNlKFxuXHRcdFx0XHRcdFx0XHRcdCdDb21wb25lbnQgdGVtcGxhdGUgcmVxdWlyZXMgYSByb290IGVsZW1lbnQsIHJhdGhlciB0aGFuIGp1c3QgdGV4dC4nXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCh0ZXh0ID0gdGV4dC50cmltKCkpKSB7XG5cdFx0XHRcdFx0XHRcdHdhcm5PbmNlKFxuXHRcdFx0XHRcdFx0XHRcdChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuXHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdFx0aWYgKGlzSUUgJiZcblx0XHRcdFx0XHRjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuXHRcdFx0XHRcdGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcblx0XHRcdFx0dGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG5cdFx0XHRcdFx0PyBpc1RleHRUYWcoY3VycmVudFBhcmVudCkgPyB0ZXh0IDogZGVjb2RlSFRNTENhY2hlZCh0ZXh0KVxuXHRcdFx0XHRcdC8vIG9ubHkgcHJlc2VydmUgd2hpdGVzcGFjZSBpZiBpdHMgbm90IHJpZ2h0IGFmdGVyIGEgc3RhcnRpbmcgdGFnXG5cdFx0XHRcdFx0OiBwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgY2hpbGRyZW4ubGVuZ3RoID8gJyAnIDogJyc7XG5cdFx0XHRcdGlmICh0ZXh0KSB7XG5cdFx0XHRcdFx0dmFyIGV4cHJlc3Npb247XG5cdFx0XHRcdFx0aWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChleHByZXNzaW9uID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuXHRcdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaCh7XG5cdFx0XHRcdFx0XHRcdHR5cGU6IDIsXG5cdFx0XHRcdFx0XHRcdGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG5cdFx0XHRcdFx0XHRcdHRleHQ6IHRleHRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG5cdFx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKHtcblx0XHRcdFx0XHRcdFx0dHlwZTogMyxcblx0XHRcdFx0XHRcdFx0dGV4dDogdGV4dFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHJvb3Rcblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG5cdFx0aWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LXByZScpICE9IG51bGwpIHtcblx0XHRcdGVsLnByZSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzIChlbCkge1xuXHRcdHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcblx0XHRpZiAobCkge1xuXHRcdFx0dmFyIGF0dHJzID0gZWwuYXR0cnMgPSBuZXcgQXJyYXkobCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRhdHRyc1tpXSA9IHtcblx0XHRcdFx0XHRuYW1lOiBlbC5hdHRyc0xpc3RbaV0ubmFtZSxcblx0XHRcdFx0XHR2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWVsLnByZSkge1xuXHRcdFx0Ly8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuXHRcdFx0ZWwucGxhaW4gPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NLZXkgKGVsKSB7XG5cdFx0dmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG5cdFx0aWYgKGV4cCkge1xuXHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuXHRcdFx0XHR3YXJuJDIoXCI8dGVtcGxhdGU+IGNhbm5vdCBiZSBrZXllZC4gUGxhY2UgdGhlIGtleSBvbiByZWFsIGVsZW1lbnRzIGluc3RlYWQuXCIpO1xuXHRcdFx0fVxuXHRcdFx0ZWwua2V5ID0gZXhwO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG5cdFx0dmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG5cdFx0aWYgKHJlZikge1xuXHRcdFx0ZWwucmVmID0gcmVmO1xuXHRcdFx0ZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuXHRcdHZhciBleHA7XG5cdFx0aWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcblx0XHRcdHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuXHRcdFx0aWYgKCFpbk1hdGNoKSB7XG5cdFx0XHRcdFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcblx0XHRcdFx0XHQoXCJJbnZhbGlkIHYtZm9yIGV4cHJlc3Npb246IFwiICsgZXhwKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdGVsLmZvciA9IGluTWF0Y2hbMl0udHJpbSgpO1xuXHRcdFx0dmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XG5cdFx0XHR2YXIgaXRlcmF0b3JNYXRjaCA9IGFsaWFzLm1hdGNoKGZvckl0ZXJhdG9yUkUpO1xuXHRcdFx0aWYgKGl0ZXJhdG9yTWF0Y2gpIHtcblx0XHRcdFx0ZWwuYWxpYXMgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcblx0XHRcdFx0ZWwuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG5cdFx0XHRcdGlmIChpdGVyYXRvck1hdGNoWzNdKSB7XG5cdFx0XHRcdFx0ZWwuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFszXS50cmltKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsLmFsaWFzID0gYWxpYXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuXHRcdHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuXHRcdGlmIChleHApIHtcblx0XHRcdGVsLmlmID0gZXhwO1xuXHRcdFx0YWRkSWZDb25kaXRpb24oZWwsIHtcblx0XHRcdFx0ZXhwOiBleHAsXG5cdFx0XHRcdGJsb2NrOiBlbFxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuXHRcdFx0XHRlbC5lbHNlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG5cdFx0XHRpZiAoZWxzZWlmKSB7XG5cdFx0XHRcdGVsLmVsc2VpZiA9IGVsc2VpZjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG5cdFx0dmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcblx0XHRpZiAocHJldiAmJiBwcmV2LmlmKSB7XG5cdFx0XHRhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG5cdFx0XHRcdGV4cDogZWwuZWxzZWlmLFxuXHRcdFx0XHRibG9jazogZWxcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3YXJuJDIoXG5cdFx0XHRcdFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuXHRcdFx0XHRcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQgKGNoaWxkcmVuKSB7XG5cdFx0dmFyIGkgPSBjaGlsZHJlbi5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0aWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IDEpIHtcblx0XHRcdFx0cmV0dXJuIGNoaWxkcmVuW2ldXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG5cdFx0XHRcdFx0d2FybiQyKFxuXHRcdFx0XHRcdFx0XCJ0ZXh0IFxcXCJcIiArIChjaGlsZHJlbltpXS50ZXh0LnRyaW0oKSkgKyBcIlxcXCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBcIiArXG5cdFx0XHRcdFx0XHRcIndpbGwgYmUgaWdub3JlZC5cIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2hpbGRyZW4ucG9wKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcblx0XHRpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuXHRcdFx0ZWwuaWZDb25kaXRpb25zID0gW107XG5cdFx0fVxuXHRcdGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcblx0XHR2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcblx0XHRpZiAob25jZSQkMSAhPSBudWxsKSB7XG5cdFx0XHRlbC5vbmNlID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzU2xvdCAoZWwpIHtcblx0XHRpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcblx0XHRcdGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG5cdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG5cdFx0XHRcdHdhcm4kMihcblx0XHRcdFx0XHRcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuXHRcdFx0XHRcdFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuXHRcdFx0XHRcdFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCJcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNsb3RUYXJnZXQgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3Nsb3QnKTtcblx0XHRcdGlmIChzbG90VGFyZ2V0KSB7XG5cdFx0XHRcdGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcblx0XHRcdH1cblx0XHRcdGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcblx0XHRcdFx0ZWwuc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcblx0XHR2YXIgYmluZGluZztcblx0XHRpZiAoKGJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2lzJykpKSB7XG5cdFx0XHRlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuXHRcdH1cblx0XHRpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcblx0XHRcdGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG5cdFx0dmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG5cdFx0dmFyIGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGlzUHJvcDtcblx0XHRmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdG5hbWUgPSByYXdOYW1lID0gbGlzdFtpXS5uYW1lO1xuXHRcdFx0dmFsdWUgPSBsaXN0W2ldLnZhbHVlO1xuXHRcdFx0aWYgKGRpclJFLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0Ly8gbWFyayBlbGVtZW50IGFzIGR5bmFtaWNcblx0XHRcdFx0ZWwuaGFzQmluZGluZ3MgPSB0cnVlO1xuXHRcdFx0XHQvLyBtb2RpZmllcnNcblx0XHRcdFx0bW9kaWZpZXJzID0gcGFyc2VNb2RpZmllcnMobmFtZSk7XG5cdFx0XHRcdGlmIChtb2RpZmllcnMpIHtcblx0XHRcdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYmluZFJFLnRlc3QobmFtZSkpIHsgLy8gdi1iaW5kXG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcblx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlRmlsdGVycyh2YWx1ZSk7XG5cdFx0XHRcdFx0aXNQcm9wID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKG1vZGlmaWVycykge1xuXHRcdFx0XHRcdFx0aWYgKG1vZGlmaWVycy5wcm9wKSB7XG5cdFx0XHRcdFx0XHRcdGlzUHJvcCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcblx0XHRcdFx0XHRcdFx0aWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKSB7IG5hbWUgPSAnaW5uZXJIVE1MJzsgfVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKG1vZGlmaWVycy5jYW1lbCkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxpemUobmFtZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobW9kaWZpZXJzLnN5bmMpIHtcblx0XHRcdFx0XHRcdFx0YWRkSGFuZGxlcihcblx0XHRcdFx0XHRcdFx0XHRlbCxcblx0XHRcdFx0XHRcdFx0XHQoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcblx0XHRcdFx0XHRcdFx0XHRnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIilcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGlzUHJvcCB8fCBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcblx0XHRcdFx0XHRcdGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YWRkQXR0cihlbCwgbmFtZSwgdmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuXHRcdFx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuXHRcdFx0XHRcdGFkZEhhbmRsZXIoZWwsIG5hbWUsIHZhbHVlLCBtb2RpZmllcnMsIGZhbHNlLCB3YXJuJDIpO1xuXHRcdFx0XHR9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoZGlyUkUsICcnKTtcblx0XHRcdFx0XHQvLyBwYXJzZSBhcmdcblx0XHRcdFx0XHR2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcblx0XHRcdFx0XHR2YXIgYXJnID0gYXJnTWF0Y2ggJiYgYXJnTWF0Y2hbMV07XG5cdFx0XHRcdFx0aWYgKGFyZykge1xuXHRcdFx0XHRcdFx0bmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhZGREaXJlY3RpdmUoZWwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBhcmcsIG1vZGlmaWVycyk7XG5cdFx0XHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIG5hbWUgPT09ICdtb2RlbCcpIHtcblx0XHRcdFx0XHRcdGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gbGl0ZXJhbCBhdHRyaWJ1dGVcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcblx0XHRcdFx0XHRpZiAoZXhwcmVzc2lvbikge1xuXHRcdFx0XHRcdFx0d2FybiQyKFxuXHRcdFx0XHRcdFx0XHRuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI6IFwiICtcblx0XHRcdFx0XHRcdFx0J0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG5cdFx0XHRcdFx0XHRcdCdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuXHRcdFx0XHRcdFx0XHQnaW5zdGVhZCBvZiA8ZGl2IGlkPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6aWQ9XCJ2YWxcIj4uJ1xuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YWRkQXR0cihlbCwgbmFtZSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja0luRm9yIChlbCkge1xuXHRcdHZhciBwYXJlbnQgPSBlbDtcblx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50LmZvciAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzIChuYW1lKSB7XG5cdFx0dmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdHZhciByZXQgPSB7fTtcblx0XHRcdG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG5cdFx0XHRyZXR1cm4gcmV0XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFrZUF0dHJzTWFwIChhdHRycykge1xuXHRcdHZhciBtYXAgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJlxuXHRcdFx0XHRtYXBbYXR0cnNbaV0ubmFtZV0gJiYgIWlzSUUgJiYgIWlzRWRnZVxuXHRcdFx0KSB7XG5cdFx0XHRcdHdhcm4kMignZHVwbGljYXRlIGF0dHJpYnV0ZTogJyArIGF0dHJzW2ldLm5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0bWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG5cdFx0fVxuXHRcdHJldHVybiBtYXBcblx0fVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcblx0ZnVuY3Rpb24gaXNUZXh0VGFnIChlbCkge1xuXHRcdHJldHVybiBlbC50YWcgPT09ICdzY3JpcHQnIHx8IGVsLnRhZyA9PT0gJ3N0eWxlJ1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNGb3JiaWRkZW5UYWcgKGVsKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuXHRcdFx0KGVsLnRhZyA9PT0gJ3NjcmlwdCcgJiYgKFxuXHRcdFx0XHQhZWwuYXR0cnNNYXAudHlwZSB8fFxuXHRcdFx0XHRlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuXHRcdFx0KSlcblx0XHQpXG5cdH1cblxuXHR2YXIgaWVOU0J1ZyA9IC9eeG1sbnM6TlNcXGQrLztcblx0dmFyIGllTlNQcmVmaXggPSAvXk5TXFxkKzovO1xuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGZ1bmN0aW9uIGd1YXJkSUVTVkdCdWcgKGF0dHJzKSB7XG5cdFx0dmFyIHJlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBhdHRyID0gYXR0cnNbaV07XG5cdFx0XHRpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG5cdFx0XHRcdGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcblx0XHRcdFx0cmVzLnB1c2goYXR0cik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG5cdFx0dmFyIF9lbCA9IGVsO1xuXHRcdHdoaWxlIChfZWwpIHtcblx0XHRcdGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcblx0XHRcdFx0d2FybiQyKFxuXHRcdFx0XHRcdFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuXHRcdFx0XHRcdFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcblx0XHRcdFx0XHRcIlRoaXMgd2lsbCBub3QgYmUgYWJsZSB0byBtb2RpZnkgdGhlIHYtZm9yIHNvdXJjZSBhcnJheSBiZWNhdXNlIFwiICtcblx0XHRcdFx0XHRcIndyaXRpbmcgdG8gdGhlIGFsaWFzIGlzIGxpa2UgbW9kaWZ5aW5nIGEgZnVuY3Rpb24gbG9jYWwgdmFyaWFibGUuIFwiICtcblx0XHRcdFx0XHRcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRfZWwgPSBfZWwucGFyZW50O1xuXHRcdH1cblx0fVxuXG5cdC8qICAqL1xuXG5cdHZhciBpc1N0YXRpY0tleTtcblx0dmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxuXHR2YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG5cdC8qKlxuXHQgKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuXHQgKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG5cdCAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG5cdCAqXG5cdCAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuXHQgKlxuXHQgKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG5cdCAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcblx0ICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuXHRcdGlmICghcm9vdCkgeyByZXR1cm4gfVxuXHRcdGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuXHRcdGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcblx0XHQvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuXHRcdG1hcmtTdGF0aWMkMShyb290KTtcblx0XHQvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG5cdFx0bWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuXHRcdHJldHVybiBtYWtlTWFwKFxuXHRcdFx0J3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMnICtcblx0XHRcdChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuXHRcdClcblx0fVxuXG5cdGZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuXHRcdG5vZGUuc3RhdGljID0gaXNTdGF0aWMobm9kZSk7XG5cdFx0aWYgKG5vZGUudHlwZSA9PT0gMSkge1xuXHRcdFx0Ly8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG5cdFx0XHQvLyAxLiBjb21wb25lbnRzIG5vdCBhYmxlIHRvIG11dGF0ZSBzbG90IG5vZGVzXG5cdFx0XHQvLyAyLiBzdGF0aWMgc2xvdCBjb250ZW50IGZhaWxzIGZvciBob3QtcmVsb2FkaW5nXG5cdFx0XHRpZiAoXG5cdFx0XHRcdCFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmXG5cdFx0XHRcdG5vZGUudGFnICE9PSAnc2xvdCcgJiZcblx0XHRcdFx0bm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXHRcdFx0XHRtYXJrU3RhdGljJDEoY2hpbGQpO1xuXHRcdFx0XHRpZiAoIWNoaWxkLnN0YXRpYykge1xuXHRcdFx0XHRcdG5vZGUuc3RhdGljID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBtYXJrU3RhdGljUm9vdHMgKG5vZGUsIGlzSW5Gb3IpIHtcblx0XHRpZiAobm9kZS50eXBlID09PSAxKSB7XG5cdFx0XHRpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG5cdFx0XHRcdG5vZGUuc3RhdGljSW5Gb3IgPSBpc0luRm9yO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRm9yIGEgbm9kZSB0byBxdWFsaWZ5IGFzIGEgc3RhdGljIHJvb3QsIGl0IHNob3VsZCBoYXZlIGNoaWxkcmVuIHRoYXRcblx0XHRcdC8vIGFyZSBub3QganVzdCBzdGF0aWMgdGV4dC4gT3RoZXJ3aXNlIHRoZSBjb3N0IG9mIGhvaXN0aW5nIG91dCB3aWxsXG5cdFx0XHQvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG5cdFx0XHRpZiAobm9kZS5zdGF0aWMgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiYgIShcblx0XHRcdFx0XHRub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuXHRcdFx0XHRcdG5vZGUuY2hpbGRyZW5bMF0udHlwZSA9PT0gM1xuXHRcdFx0XHQpKSB7XG5cdFx0XHRcdG5vZGUuc3RhdGljUm9vdCA9IHRydWU7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5zdGF0aWNSb290ID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpZiAobm9kZS5jaGlsZHJlbikge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0bWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuXHRcdFx0XHR3YWxrVGhyb3VnaENvbmRpdGlvbnNCbG9ja3Mobm9kZS5pZkNvbmRpdGlvbnMsIGlzSW5Gb3IpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHdhbGtUaHJvdWdoQ29uZGl0aW9uc0Jsb2NrcyAoY29uZGl0aW9uQmxvY2tzLCBpc0luRm9yKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGxlbiA9IGNvbmRpdGlvbkJsb2Nrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0bWFya1N0YXRpY1Jvb3RzKGNvbmRpdGlvbkJsb2Nrc1tpXS5ibG9jaywgaXNJbkZvcik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcblx0XHRpZiAobm9kZS50eXBlID09PSAyKSB7IC8vIGV4cHJlc3Npb25cblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdH1cblx0XHRpZiAobm9kZS50eXBlID09PSAzKSB7IC8vIHRleHRcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXHRcdHJldHVybiAhIShub2RlLnByZSB8fCAoXG5cdFx0XHQhbm9kZS5oYXNCaW5kaW5ncyAmJiAvLyBubyBkeW5hbWljIGJpbmRpbmdzXG5cdFx0XHQhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG5cdFx0XHQhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuXHRcdFx0aXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcblx0XHRcdCFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuXHRcdFx0T2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpXG5cdFx0KSlcblx0fVxuXG5cdGZ1bmN0aW9uIGlzRGlyZWN0Q2hpbGRPZlRlbXBsYXRlRm9yIChub2RlKSB7XG5cdFx0d2hpbGUgKG5vZGUucGFyZW50KSB7XG5cdFx0XHRub2RlID0gbm9kZS5wYXJlbnQ7XG5cdFx0XHRpZiAobm9kZS50YWcgIT09ICd0ZW1wbGF0ZScpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHR9XG5cdFx0XHRpZiAobm9kZS5mb3IpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgZm5FeHBSRSA9IC9eXFxzKihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xuXHR2YXIgc2ltcGxlUGF0aFJFID0gL15cXHMqW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J118XFxbXCIuKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSpcXHMqJC87XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xuXHR2YXIga2V5Q29kZXMgPSB7XG5cdFx0ZXNjOiAyNyxcblx0XHR0YWI6IDksXG5cdFx0ZW50ZXI6IDEzLFxuXHRcdHNwYWNlOiAzMixcblx0XHR1cDogMzgsXG5cdFx0bGVmdDogMzcsXG5cdFx0cmlnaHQ6IDM5LFxuXHRcdGRvd246IDQwLFxuXHRcdCdkZWxldGUnOiBbOCwgNDZdXG5cdH07XG5cbi8vICM0ODY4OiBtb2RpZmllcnMgdGhhdCBwcmV2ZW50IHRoZSBleGVjdXRpb24gb2YgdGhlIGxpc3RlbmVyXG4vLyBuZWVkIHRvIGV4cGxpY2l0bHkgcmV0dXJuIG51bGwgc28gdGhhdCB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmVtb3ZlXG4vLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG5cdHZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG5cdHZhciBtb2RpZmllckNvZGUgPSB7XG5cdFx0c3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuXHRcdHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuXHRcdHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG5cdFx0Y3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG5cdFx0c2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcblx0XHRhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG5cdFx0bWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG5cdFx0bGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcblx0XHRtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG5cdFx0cmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcblx0fTtcblxuXHRmdW5jdGlvbiBnZW5IYW5kbGVycyAoXG5cdFx0ZXZlbnRzLFxuXHRcdGlzTmF0aXZlLFxuXHRcdHdhcm5cblx0KSB7XG5cdFx0dmFyIHJlcyA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuXHRcdGZvciAodmFyIG5hbWUgaW4gZXZlbnRzKSB7XG5cdFx0XHR2YXIgaGFuZGxlciA9IGV2ZW50c1tuYW1lXTtcblx0XHRcdC8vICM1MzMwOiB3YXJuIGNsaWNrLnJpZ2h0LCBzaW5jZSByaWdodCBjbGlja3MgZG8gbm90IGFjdHVhbGx5IGZpcmUgY2xpY2sgZXZlbnRzLlxuXHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmXG5cdFx0XHRcdG5hbWUgPT09ICdjbGljaycgJiZcblx0XHRcdFx0aGFuZGxlciAmJiBoYW5kbGVyLm1vZGlmaWVycyAmJiBoYW5kbGVyLm1vZGlmaWVycy5yaWdodFxuXHRcdFx0KSB7XG5cdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XCJVc2UgXFxcImNvbnRleHRtZW51XFxcIiBpbnN0ZWFkIG9mIFxcXCJjbGljay5yaWdodFxcXCIgc2luY2UgcmlnaHQgY2xpY2tzIFwiICtcblx0XHRcdFx0XHRcImRvIG5vdCBhY3R1YWxseSBmaXJlIFxcXCJjbGlja1xcXCIgZXZlbnRzLlwiXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0XHRyZXMgKz0gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiOlwiICsgKGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcikpICsgXCIsXCI7XG5cdFx0fVxuXHRcdHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5IYW5kbGVyIChcblx0XHRuYW1lLFxuXHRcdGhhbmRsZXJcblx0KSB7XG5cdFx0aWYgKCFoYW5kbGVyKSB7XG5cdFx0XHRyZXR1cm4gJ2Z1bmN0aW9uKCl7fSdcblx0XHR9XG5cblx0XHRpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuXHRcdFx0cmV0dXJuIChcIltcIiArIChoYW5kbGVyLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZ2VuSGFuZGxlcihuYW1lLCBoYW5kbGVyKTsgfSkuam9pbignLCcpKSArIFwiXVwiKVxuXHRcdH1cblxuXHRcdHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcblx0XHR2YXIgaXNGdW5jdGlvbkV4cHJlc3Npb24gPSBmbkV4cFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG5cblx0XHRpZiAoIWhhbmRsZXIubW9kaWZpZXJzKSB7XG5cdFx0XHRyZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uXG5cdFx0XHRcdD8gaGFuZGxlci52YWx1ZVxuXHRcdFx0XHQ6IChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY29kZSA9ICcnO1xuXHRcdFx0dmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuXHRcdFx0dmFyIGtleXMgPSBbXTtcblx0XHRcdGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuXHRcdFx0XHRpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcblx0XHRcdFx0XHRnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG5cdFx0XHRcdFx0Ly8gbGVmdC9yaWdodFxuXHRcdFx0XHRcdGlmIChrZXlDb2Rlc1trZXldKSB7XG5cdFx0XHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChrZXlzLmxlbmd0aCkge1xuXHRcdFx0XHRjb2RlICs9IGdlbktleUZpbHRlcihrZXlzKTtcblx0XHRcdH1cblx0XHRcdC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG5cdFx0XHRpZiAoZ2VuTW9kaWZpZXJDb2RlKSB7XG5cdFx0XHRcdGNvZGUgKz0gZ2VuTW9kaWZpZXJDb2RlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhhbmRsZXJDb2RlID0gaXNNZXRob2RQYXRoXG5cdFx0XHRcdD8gaGFuZGxlci52YWx1ZSArICcoJGV2ZW50KSdcblx0XHRcdFx0OiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuXHRcdFx0XHQ/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG5cdFx0XHRcdDogaGFuZGxlci52YWx1ZTtcblx0XHRcdHJldHVybiAoXCJmdW5jdGlvbigkZXZlbnQpe1wiICsgY29kZSArIGhhbmRsZXJDb2RlICsgXCJ9XCIpXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuS2V5RmlsdGVyIChrZXlzKSB7XG5cdFx0cmV0dXJuIChcImlmKCEoJ2J1dHRvbicgaW4gJGV2ZW50KSYmXCIgKyAoa2V5cy5tYXAoZ2VuRmlsdGVyQ29kZSkuam9pbignJiYnKSkgKyBcIilyZXR1cm4gbnVsbDtcIilcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbkZpbHRlckNvZGUgKGtleSkge1xuXHRcdHZhciBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcblx0XHRpZiAoa2V5VmFsKSB7XG5cdFx0XHRyZXR1cm4gKFwiJGV2ZW50LmtleUNvZGUhPT1cIiArIGtleVZhbClcblx0XHR9XG5cdFx0dmFyIGFsaWFzID0ga2V5Q29kZXNba2V5XTtcblx0XHRyZXR1cm4gKFwiX2soJGV2ZW50LmtleUNvZGUsXCIgKyAoSlNPTi5zdHJpbmdpZnkoa2V5KSkgKyAoYWxpYXMgPyAnLCcgKyBKU09OLnN0cmluZ2lmeShhbGlhcykgOiAnJykgKyBcIilcIilcblx0fVxuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIGJpbmQkMSAoZWwsIGRpcikge1xuXHRcdGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcblx0XHRcdHJldHVybiAoXCJfYihcIiArIGNvZGUgKyBcIiwnXCIgKyAoZWwudGFnKSArIFwiJyxcIiArIChkaXIudmFsdWUpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuXHRcdH07XG5cdH1cblxuXHQvKiAgKi9cblxuXHR2YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG5cdFx0YmluZDogYmluZCQxLFxuXHRcdGNsb2FrOiBub29wXG5cdH07XG5cblx0LyogICovXG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxuXHR2YXIgd2FybiQzO1xuXHR2YXIgdHJhbnNmb3JtcyQxO1xuXHR2YXIgZGF0YUdlbkZucztcblx0dmFyIHBsYXRmb3JtRGlyZWN0aXZlcyQxO1xuXHR2YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnJDE7XG5cdHZhciBzdGF0aWNSZW5kZXJGbnM7XG5cdHZhciBvbmNlQ291bnQ7XG5cdHZhciBjdXJyZW50T3B0aW9ucztcblxuXHRmdW5jdGlvbiBnZW5lcmF0ZSAoXG5cdFx0YXN0LFxuXHRcdG9wdGlvbnNcblx0KSB7XG5cdFx0Ly8gc2F2ZSBwcmV2aW91cyBzdGF0aWNSZW5kZXJGbnMgc28gZ2VuZXJhdGUgY2FsbHMgY2FuIGJlIG5lc3RlZFxuXHRcdHZhciBwcmV2U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXHRcdHZhciBjdXJyZW50U3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zID0gW107XG5cdFx0dmFyIHByZXZPbmNlQ291bnQgPSBvbmNlQ291bnQ7XG5cdFx0b25jZUNvdW50ID0gMDtcblx0XHRjdXJyZW50T3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0d2FybiQzID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXHRcdHRyYW5zZm9ybXMkMSA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuXHRcdGRhdGFHZW5GbnMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ2dlbkRhdGEnKTtcblx0XHRwbGF0Zm9ybURpcmVjdGl2ZXMkMSA9IG9wdGlvbnMuZGlyZWN0aXZlcyB8fCB7fTtcblx0XHRpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMSA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcblx0XHR2YXIgY29kZSA9IGFzdCA/IGdlbkVsZW1lbnQoYXN0KSA6ICdfYyhcImRpdlwiKSc7XG5cdFx0c3RhdGljUmVuZGVyRm5zID0gcHJldlN0YXRpY1JlbmRlckZucztcblx0XHRvbmNlQ291bnQgPSBwcmV2T25jZUNvdW50O1xuXHRcdHJldHVybiB7XG5cdFx0XHRyZW5kZXI6IChcIndpdGgodGhpcyl7cmV0dXJuIFwiICsgY29kZSArIFwifVwiKSxcblx0XHRcdHN0YXRpY1JlbmRlckZuczogY3VycmVudFN0YXRpY1JlbmRlckZuc1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbkVsZW1lbnQgKGVsKSB7XG5cdFx0aWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuXHRcdFx0cmV0dXJuIGdlblN0YXRpYyhlbClcblx0XHR9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcblx0XHRcdHJldHVybiBnZW5PbmNlKGVsKVxuXHRcdH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcblx0XHRcdHJldHVybiBnZW5Gb3IoZWwpXG5cdFx0fSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcblx0XHRcdHJldHVybiBnZW5JZihlbClcblx0XHR9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuXHRcdFx0cmV0dXJuIGdlbkNoaWxkcmVuKGVsKSB8fCAndm9pZCAwJ1xuXHRcdH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcblx0XHRcdHJldHVybiBnZW5TbG90KGVsKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuXHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRpZiAoZWwuY29tcG9uZW50KSB7XG5cdFx0XHRcdGNvZGUgPSBnZW5Db21wb25lbnQoZWwuY29tcG9uZW50LCBlbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZGF0YSA9IGVsLnBsYWluID8gdW5kZWZpbmVkIDogZ2VuRGF0YShlbCk7XG5cblx0XHRcdFx0dmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuXHRcdFx0XHRjb2RlID0gXCJfYygnXCIgKyAoZWwudGFnKSArIFwiJ1wiICsgKGRhdGEgPyAoXCIsXCIgKyBkYXRhKSA6ICcnKSArIChjaGlsZHJlbiA/IChcIixcIiArIGNoaWxkcmVuKSA6ICcnKSArIFwiKVwiO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbW9kdWxlIHRyYW5zZm9ybXNcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtcyQxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvZGUgPSB0cmFuc2Zvcm1zJDFbaV0oZWwsIGNvZGUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvZGVcblx0XHR9XG5cdH1cblxuLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcblx0ZnVuY3Rpb24gZ2VuU3RhdGljIChlbCkge1xuXHRcdGVsLnN0YXRpY1Byb2Nlc3NlZCA9IHRydWU7XG5cdFx0c3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCkpICsgXCJ9XCIpKTtcblx0XHRyZXR1cm4gKFwiX20oXCIgKyAoc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDEpICsgKGVsLnN0YXRpY0luRm9yID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuXHR9XG5cbi8vIHYtb25jZVxuXHRmdW5jdGlvbiBnZW5PbmNlIChlbCkge1xuXHRcdGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuXHRcdGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcblx0XHRcdHJldHVybiBnZW5JZihlbClcblx0XHR9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG5cdFx0XHR2YXIga2V5ID0gJyc7XG5cdFx0XHR2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuXHRcdFx0d2hpbGUgKHBhcmVudCkge1xuXHRcdFx0XHRpZiAocGFyZW50LmZvcikge1xuXHRcdFx0XHRcdGtleSA9IHBhcmVudC5rZXk7XG5cdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFrZXkpIHtcblx0XHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgd2FybiQzKFxuXHRcdFx0XHRcdFwidi1vbmNlIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHYtZm9yIHRoYXQgaXMga2V5ZWQuIFwiXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHJldHVybiBnZW5FbGVtZW50KGVsKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwpKSArIFwiLFwiICsgKG9uY2VDb3VudCsrKSArIChrZXkgPyAoXCIsXCIgKyBrZXkpIDogXCJcIikgKyBcIilcIilcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGdlblN0YXRpYyhlbClcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5JZiAoZWwpIHtcblx0XHRlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuXHRcdHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCkpXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKGNvbmRpdGlvbnMpIHtcblx0XHRpZiAoIWNvbmRpdGlvbnMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gJ19lKCknXG5cdFx0fVxuXG5cdFx0dmFyIGNvbmRpdGlvbiA9IGNvbmRpdGlvbnMuc2hpZnQoKTtcblx0XHRpZiAoY29uZGl0aW9uLmV4cCkge1xuXHRcdFx0cmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMpKSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG5cdFx0fVxuXG5cdFx0Ly8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuXHRcdGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG5cdFx0XHRyZXR1cm4gZWwub25jZSA/IGdlbk9uY2UoZWwpIDogZ2VuRWxlbWVudChlbClcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5Gb3IgKGVsKSB7XG5cdFx0dmFyIGV4cCA9IGVsLmZvcjtcblx0XHR2YXIgYWxpYXMgPSBlbC5hbGlhcztcblx0XHR2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG5cdFx0dmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXG5cdFx0aWYgKFxuXHRcdFx0XCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiZcblx0XHRcdG1heWJlQ29tcG9uZW50KGVsKSAmJiBlbC50YWcgIT09ICdzbG90JyAmJiBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLmtleVxuXHRcdCkge1xuXHRcdFx0d2FybiQzKFxuXHRcdFx0XHRcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcblx0XHRcdFx0XCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG5cdFx0XHRcdFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcblx0XHRcdFx0dHJ1ZSAvKiB0aXAgKi9cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0ZWwuZm9yUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG5cdFx0cmV0dXJuIFwiX2woKFwiICsgZXhwICsgXCIpLFwiICtcblx0XHRcdFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG5cdFx0XHRcInJldHVybiBcIiArIChnZW5FbGVtZW50KGVsKSkgK1xuXHRcdFx0J30pJ1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcblx0XHR2YXIgZGF0YSA9ICd7JztcblxuXHRcdC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG5cdFx0Ly8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cblx0XHR2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwpO1xuXHRcdGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG5cdFx0Ly8ga2V5XG5cdFx0aWYgKGVsLmtleSkge1xuXHRcdFx0ZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG5cdFx0fVxuXHRcdC8vIHJlZlxuXHRcdGlmIChlbC5yZWYpIHtcblx0XHRcdGRhdGEgKz0gXCJyZWY6XCIgKyAoZWwucmVmKSArIFwiLFwiO1xuXHRcdH1cblx0XHRpZiAoZWwucmVmSW5Gb3IpIHtcblx0XHRcdGRhdGEgKz0gXCJyZWZJbkZvcjp0cnVlLFwiO1xuXHRcdH1cblx0XHQvLyBwcmVcblx0XHRpZiAoZWwucHJlKSB7XG5cdFx0XHRkYXRhICs9IFwicHJlOnRydWUsXCI7XG5cdFx0fVxuXHRcdC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG5cdFx0aWYgKGVsLmNvbXBvbmVudCkge1xuXHRcdFx0ZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcblx0XHR9XG5cdFx0Ly8gbW9kdWxlIGRhdGEgZ2VuZXJhdGlvbiBmdW5jdGlvbnNcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGRhdGEgKz0gZGF0YUdlbkZuc1tpXShlbCk7XG5cdFx0fVxuXHRcdC8vIGF0dHJpYnV0ZXNcblx0XHRpZiAoZWwuYXR0cnMpIHtcblx0XHRcdGRhdGEgKz0gXCJhdHRyczp7XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwifSxcIjtcblx0XHR9XG5cdFx0Ly8gRE9NIHByb3BzXG5cdFx0aWYgKGVsLnByb3BzKSB7XG5cdFx0XHRkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG5cdFx0fVxuXHRcdC8vIGV2ZW50IGhhbmRsZXJzXG5cdFx0aWYgKGVsLmV2ZW50cykge1xuXHRcdFx0ZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSwgd2FybiQzKSkgKyBcIixcIjtcblx0XHR9XG5cdFx0aWYgKGVsLm5hdGl2ZUV2ZW50cykge1xuXHRcdFx0ZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlLCB3YXJuJDMpKSArIFwiLFwiO1xuXHRcdH1cblx0XHQvLyBzbG90IHRhcmdldFxuXHRcdGlmIChlbC5zbG90VGFyZ2V0KSB7XG5cdFx0XHRkYXRhICs9IFwic2xvdDpcIiArIChlbC5zbG90VGFyZ2V0KSArIFwiLFwiO1xuXHRcdH1cblx0XHQvLyBzY29wZWQgc2xvdHNcblx0XHRpZiAoZWwuc2NvcGVkU2xvdHMpIHtcblx0XHRcdGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzKSkgKyBcIixcIjtcblx0XHR9XG5cdFx0Ly8gY29tcG9uZW50IHYtbW9kZWxcblx0XHRpZiAoZWwubW9kZWwpIHtcblx0XHRcdGRhdGEgKz0gXCJtb2RlbDp7dmFsdWU6XCIgKyAoZWwubW9kZWwudmFsdWUpICsgXCIsY2FsbGJhY2s6XCIgKyAoZWwubW9kZWwuY2FsbGJhY2spICsgXCIsZXhwcmVzc2lvbjpcIiArIChlbC5tb2RlbC5leHByZXNzaW9uKSArIFwifSxcIjtcblx0XHR9XG5cdFx0Ly8gaW5saW5lLXRlbXBsYXRlXG5cdFx0aWYgKGVsLmlubGluZVRlbXBsYXRlKSB7XG5cdFx0XHR2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCk7XG5cdFx0XHRpZiAoaW5saW5lVGVtcGxhdGUpIHtcblx0XHRcdFx0ZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9Jztcblx0XHQvLyB2LWJpbmQgZGF0YSB3cmFwXG5cdFx0aWYgKGVsLndyYXBEYXRhKSB7XG5cdFx0XHRkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCkge1xuXHRcdHZhciBkaXJzID0gZWwuZGlyZWN0aXZlcztcblx0XHRpZiAoIWRpcnMpIHsgcmV0dXJuIH1cblx0XHR2YXIgcmVzID0gJ2RpcmVjdGl2ZXM6Wyc7XG5cdFx0dmFyIGhhc1J1bnRpbWUgPSBmYWxzZTtcblx0XHR2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcblx0XHRmb3IgKGkgPSAwLCBsID0gZGlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGRpciA9IGRpcnNbaV07XG5cdFx0XHRuZWVkUnVudGltZSA9IHRydWU7XG5cdFx0XHR2YXIgZ2VuID0gcGxhdGZvcm1EaXJlY3RpdmVzJDFbZGlyLm5hbWVdIHx8IGJhc2VEaXJlY3RpdmVzW2Rpci5uYW1lXTtcblx0XHRcdGlmIChnZW4pIHtcblx0XHRcdFx0Ly8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cblx0XHRcdFx0Ly8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuXHRcdFx0XHRuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHdhcm4kMyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobmVlZFJ1bnRpbWUpIHtcblx0XHRcdFx0aGFzUnVudGltZSA9IHRydWU7XG5cdFx0XHRcdHJlcyArPSBcIntuYW1lOlxcXCJcIiArIChkaXIubmFtZSkgKyBcIlxcXCIscmF3TmFtZTpcXFwiXCIgKyAoZGlyLnJhd05hbWUpICsgXCJcXFwiXCIgKyAoZGlyLnZhbHVlID8gKFwiLHZhbHVlOihcIiArIChkaXIudmFsdWUpICsgXCIpLGV4cHJlc3Npb246XCIgKyAoSlNPTi5zdHJpbmdpZnkoZGlyLnZhbHVlKSkpIDogJycpICsgKGRpci5hcmcgPyAoXCIsYXJnOlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSA6ICcnKSArIChkaXIubW9kaWZpZXJzID8gKFwiLG1vZGlmaWVyczpcIiArIChKU09OLnN0cmluZ2lmeShkaXIubW9kaWZpZXJzKSkpIDogJycpICsgXCJ9LFwiO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaGFzUnVudGltZSkge1xuXHRcdFx0cmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwpIHtcblx0XHR2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG5cdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIChcblx0XHRcdFx0ZWwuY2hpbGRyZW4ubGVuZ3RoID4gMSB8fCBhc3QudHlwZSAhPT0gMVxuXHRcdFx0KSkge1xuXHRcdFx0d2FybiQzKCdJbmxpbmUtdGVtcGxhdGUgY29tcG9uZW50cyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudC4nKTtcblx0XHR9XG5cdFx0aWYgKGFzdC50eXBlID09PSAxKSB7XG5cdFx0XHR2YXIgaW5saW5lUmVuZGVyRm5zID0gZ2VuZXJhdGUoYXN0LCBjdXJyZW50T3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gKFwiaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpe1wiICsgKGlubGluZVJlbmRlckZucy5yZW5kZXIpICsgXCJ9LHN0YXRpY1JlbmRlckZuczpbXCIgKyAoaW5saW5lUmVuZGVyRm5zLnN0YXRpY1JlbmRlckZucy5tYXAoZnVuY3Rpb24gKGNvZGUpIHsgcmV0dXJuIChcImZ1bmN0aW9uKCl7XCIgKyBjb2RlICsgXCJ9XCIpOyB9KS5qb2luKCcsJykpICsgXCJdfVwiKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdlblNjb3BlZFNsb3RzIChzbG90cykge1xuXHRcdHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBnZW5TY29wZWRTbG90KGtleSwgc2xvdHNba2V5XSk7IH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5TY29wZWRTbG90IChrZXksIGVsKSB7XG5cdFx0aWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG5cdFx0XHRyZXR1cm4gZ2VuRm9yU2NvcGVkU2xvdChrZXksIGVsKVxuXHRcdH1cblx0XHRyZXR1cm4gXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46ZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLmF0dHJzTWFwLnNjb3BlKSkgKyBcIil7XCIgK1xuXHRcdFx0XCJyZXR1cm4gXCIgKyAoZWwudGFnID09PSAndGVtcGxhdGUnXG5cdFx0XHRcdD8gZ2VuQ2hpbGRyZW4oZWwpIHx8ICd2b2lkIDAnXG5cdFx0XHRcdDogZ2VuRWxlbWVudChlbCkpICsgXCJ9fVwiXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChrZXksIGVsKSB7XG5cdFx0dmFyIGV4cCA9IGVsLmZvcjtcblx0XHR2YXIgYWxpYXMgPSBlbC5hbGlhcztcblx0XHR2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG5cdFx0dmFyIGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IChcIixcIiArIChlbC5pdGVyYXRvcjIpKSA6ICcnO1xuXHRcdGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuXHRcdHJldHVybiBcIl9sKChcIiArIGV4cCArIFwiKSxcIiArXG5cdFx0XHRcImZ1bmN0aW9uKFwiICsgYWxpYXMgKyBpdGVyYXRvcjEgKyBpdGVyYXRvcjIgKyBcIil7XCIgK1xuXHRcdFx0XCJyZXR1cm4gXCIgKyAoZ2VuU2NvcGVkU2xvdChrZXksIGVsKSkgK1xuXHRcdFx0J30pJ1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKGVsLCBjaGVja1NraXApIHtcblx0XHR2YXIgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG5cdFx0XHR2YXIgZWwkMSA9IGNoaWxkcmVuWzBdO1xuXHRcdFx0Ly8gb3B0aW1pemUgc2luZ2xlIHYtZm9yXG5cdFx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG5cdFx0XHRcdGVsJDEuZm9yICYmXG5cdFx0XHRcdGVsJDEudGFnICE9PSAndGVtcGxhdGUnICYmXG5cdFx0XHRcdGVsJDEudGFnICE9PSAnc2xvdCdcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm4gZ2VuRWxlbWVudChlbCQxKVxuXHRcdFx0fVxuXHRcdFx0dmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4pIDogMDtcblx0XHRcdHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGdlbk5vZGUpLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSA/IChcIixcIiArIG5vcm1hbGl6YXRpb25UeXBlKSA6ICcnKSlcblx0XHR9XG5cdH1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcblx0ZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKGNoaWxkcmVuKSB7XG5cdFx0dmFyIHJlcyA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGVsID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoZWwudHlwZSAhPT0gMSkge1xuXHRcdFx0XHRjb250aW51ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcblx0XHRcdFx0KGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcblx0XHRcdFx0cmVzID0gMjtcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHRcdGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcblx0XHRcdFx0KGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbWF5YmVDb21wb25lbnQoYy5ibG9jayk7IH0pKSkge1xuXHRcdFx0XHRyZXMgPSAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzXG5cdH1cblxuXHRmdW5jdGlvbiBuZWVkc05vcm1hbGl6YXRpb24gKGVsKSB7XG5cdFx0cmV0dXJuIGVsLmZvciAhPT0gdW5kZWZpbmVkIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyB8fCBlbC50YWcgPT09ICdzbG90J1xuXHR9XG5cblx0ZnVuY3Rpb24gbWF5YmVDb21wb25lbnQgKGVsKSB7XG5cdFx0cmV0dXJuICFpc1BsYXRmb3JtUmVzZXJ2ZWRUYWckMShlbC50YWcpXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5Ob2RlIChub2RlKSB7XG5cdFx0aWYgKG5vZGUudHlwZSA9PT0gMSkge1xuXHRcdFx0cmV0dXJuIGdlbkVsZW1lbnQobm9kZSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGdlblRleHQobm9kZSlcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5UZXh0ICh0ZXh0KSB7XG5cdFx0cmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuXHRcdFx0PyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuXHRcdFx0OiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMoSlNPTi5zdHJpbmdpZnkodGV4dC50ZXh0KSkpICsgXCIpXCIpXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5TbG90IChlbCkge1xuXHRcdHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG5cdFx0dmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwpO1xuXHRcdHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG5cdFx0dmFyIGF0dHJzID0gZWwuYXR0cnMgJiYgKFwie1wiICsgKGVsLmF0dHJzLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gKChjYW1lbGl6ZShhLm5hbWUpKSArIFwiOlwiICsgKGEudmFsdWUpKTsgfSkuam9pbignLCcpKSArIFwifVwiKTtcblx0XHR2YXIgYmluZCQkMSA9IGVsLmF0dHJzTWFwWyd2LWJpbmQnXTtcblx0XHRpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuXHRcdFx0cmVzICs9IFwiLG51bGxcIjtcblx0XHR9XG5cdFx0aWYgKGF0dHJzKSB7XG5cdFx0XHRyZXMgKz0gXCIsXCIgKyBhdHRycztcblx0XHR9XG5cdFx0aWYgKGJpbmQkJDEpIHtcblx0XHRcdHJlcyArPSAoYXR0cnMgPyAnJyA6ICcsbnVsbCcpICsgXCIsXCIgKyBiaW5kJCQxO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzICsgJyknXG5cdH1cblxuLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuXHRmdW5jdGlvbiBnZW5Db21wb25lbnQgKGNvbXBvbmVudE5hbWUsIGVsKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHRydWUpO1xuXHRcdHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhKGVsKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcblx0fVxuXG5cdGZ1bmN0aW9uIGdlblByb3BzIChwcm9wcykge1xuXHRcdHZhciByZXMgPSAnJztcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcHJvcCA9IHByb3BzW2ldO1xuXHRcdFx0cmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuXHR9XG5cbi8vICMzODk1LCAjNDI2OFxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMgKHRleHQpIHtcblx0XHRyZXR1cm4gdGV4dFxuXHRcdFx0LnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG5cdFx0XHQucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jylcblx0fVxuXG5cdC8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxuXHR2YXIgcHJvaGliaXRlZEtleXdvcmRSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcblx0XHRcdCdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuXHRcdFx0J3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcblx0XHRcdCdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJ1xuXHRcdCkuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG5cdHZhciB1bmFyeU9wZXJhdG9yc1JFID0gbmV3IFJlZ0V4cCgnXFxcXGInICsgKFxuXHRcdFx0J2RlbGV0ZSx0eXBlb2Ysdm9pZCdcblx0XHQpLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuLy8gY2hlY2sgdmFsaWQgaWRlbnRpZmllciBmb3Igdi1mb3Jcblx0dmFyIGlkZW50UkUgPSAvW0EtWmEtel8kXVtcXHckXSovO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG5cdHZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbi8vIGRldGVjdCBwcm9ibGVtYXRpYyBleHByZXNzaW9ucyBpbiBhIHRlbXBsYXRlXG5cdGZ1bmN0aW9uIGRldGVjdEVycm9ycyAoYXN0KSB7XG5cdFx0dmFyIGVycm9ycyA9IFtdO1xuXHRcdGlmIChhc3QpIHtcblx0XHRcdGNoZWNrTm9kZShhc3QsIGVycm9ycyk7XG5cdFx0fVxuXHRcdHJldHVybiBlcnJvcnNcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG5cdFx0aWYgKG5vZGUudHlwZSA9PT0gMSkge1xuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBub2RlLmF0dHJzTWFwKSB7XG5cdFx0XHRcdGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gbm9kZS5hdHRyc01hcFtuYW1lXTtcblx0XHRcdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRcdGlmIChuYW1lID09PSAndi1mb3InKSB7XG5cdFx0XHRcdFx0XHRcdGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0Y2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNoZWNrRXhwcmVzc2lvbih2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChub2RlLmNoaWxkcmVuKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcblx0XHRcdGNoZWNrRXhwcmVzc2lvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudGV4dCwgZXJyb3JzKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja0V2ZW50IChleHAsIHRleHQsIGVycm9ycykge1xuXHRcdHZhciBzdGlwcGVkID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpO1xuXHRcdHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuXHRcdGlmIChrZXl3b3JkTWF0Y2ggJiYgc3RpcHBlZC5jaGFyQXQoa2V5d29yZE1hdGNoLmluZGV4IC0gMSkgIT09ICckJykge1xuXHRcdFx0ZXJyb3JzLnB1c2goXG5cdFx0XHRcdFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG5cdFx0XHRcdFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSlcblx0XHRcdCk7XG5cdFx0fVxuXHRcdGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIGVycm9ycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG5cdFx0Y2hlY2tFeHByZXNzaW9uKG5vZGUuZm9yIHx8ICcnLCB0ZXh0LCBlcnJvcnMpO1xuXHRcdGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCBlcnJvcnMpO1xuXHRcdGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcblx0XHRjaGVja0lkZW50aWZpZXIobm9kZS5pdGVyYXRvcjIsICd2LWZvciBpdGVyYXRvcicsIHRleHQsIGVycm9ycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKGlkZW50LCB0eXBlLCB0ZXh0LCBlcnJvcnMpIHtcblx0XHRpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJyAmJiAhaWRlbnRSRS50ZXN0KGlkZW50KSkge1xuXHRcdFx0ZXJyb3JzLnB1c2goKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjaGVja0V4cHJlc3Npb24gKGV4cCwgdGV4dCwgZXJyb3JzKSB7XG5cdFx0dHJ5IHtcblx0XHRcdG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHR2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuXHRcdFx0aWYgKGtleXdvcmRNYXRjaCkge1xuXHRcdFx0XHRlcnJvcnMucHVzaChcblx0XHRcdFx0XHRcImF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG5cdFx0XHRcdFx0XCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIiBpbiBleHByZXNzaW9uIFwiICsgKHRleHQudHJpbSgpKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXJyb3JzLnB1c2goKFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG5cdFx0dGVtcGxhdGUsXG5cdFx0b3B0aW9uc1xuXHQpIHtcblx0XHR2YXIgYXN0ID0gcGFyc2UodGVtcGxhdGUudHJpbSgpLCBvcHRpb25zKTtcblx0XHRvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuXHRcdHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YXN0OiBhc3QsXG5cdFx0XHRyZW5kZXI6IGNvZGUucmVuZGVyLFxuXHRcdFx0c3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIG1ha2VGdW5jdGlvbiAoY29kZSwgZXJyb3JzKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG5cdFx0XHRyZXR1cm4gbm9vcFxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuXHRcdHZhciBmdW5jdGlvbkNvbXBpbGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cblx0XHRmdW5jdGlvbiBjb21waWxlIChcblx0XHRcdHRlbXBsYXRlLFxuXHRcdFx0b3B0aW9uc1xuXHRcdCkge1xuXHRcdFx0dmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuXHRcdFx0dmFyIGVycm9ycyA9IFtdO1xuXHRcdFx0dmFyIHRpcHMgPSBbXTtcblx0XHRcdGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwJCQxKSB7XG5cdFx0XHRcdCh0aXAkJDEgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0XHQvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuXHRcdFx0XHRpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG5cdFx0XHRcdFx0ZmluYWxPcHRpb25zLm1vZHVsZXMgPSAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbWVyZ2UgY3VzdG9tIGRpcmVjdGl2ZXNcblx0XHRcdFx0aWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuXHRcdFx0XHRcdGZpbmFsT3B0aW9ucy5kaXJlY3RpdmVzID0gZXh0ZW5kKFxuXHRcdFx0XHRcdFx0T2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzKSxcblx0XHRcdFx0XHRcdG9wdGlvbnMuZGlyZWN0aXZlc1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gY29weSBvdGhlciBvcHRpb25zXG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG5cdFx0XHRcdFx0aWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG5cdFx0XHRcdFx0XHRmaW5hbE9wdGlvbnNba2V5XSA9IG9wdGlvbnNba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvbXBpbGVkID0gYmFzZUNvbXBpbGUodGVtcGxhdGUsIGZpbmFsT3B0aW9ucyk7XG5cdFx0XHR7XG5cdFx0XHRcdGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgZGV0ZWN0RXJyb3JzKGNvbXBpbGVkLmFzdCkpO1xuXHRcdFx0fVxuXHRcdFx0Y29tcGlsZWQuZXJyb3JzID0gZXJyb3JzO1xuXHRcdFx0Y29tcGlsZWQudGlwcyA9IHRpcHM7XG5cdFx0XHRyZXR1cm4gY29tcGlsZWRcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb21waWxlVG9GdW5jdGlvbnMgKFxuXHRcdFx0dGVtcGxhdGUsXG5cdFx0XHRvcHRpb25zLFxuXHRcdFx0dm1cblx0XHQpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdHtcblx0XHRcdFx0Ly8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRcdGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG5cdFx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0XHQnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG5cdFx0XHRcdFx0XHRcdCdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcblx0XHRcdFx0XHRcdFx0J1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcblx0XHRcdFx0XHRcdFx0J3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuXHRcdFx0XHRcdFx0XHQndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBjYWNoZVxuXHRcdFx0dmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuXHRcdFx0XHQ/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcblx0XHRcdFx0OiB0ZW1wbGF0ZTtcblx0XHRcdGlmIChmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbXBpbGVcblx0XHRcdHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG5cdFx0XHQvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuXHRcdFx0e1xuXHRcdFx0XHRpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcblx0XHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFx0XCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuXHRcdFx0XHRcdFx0Y29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuXHRcdFx0XHRcdFx0dm1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChjb21waWxlZC50aXBzICYmIGNvbXBpbGVkLnRpcHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0Y29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG5cdFx0XHR2YXIgcmVzID0ge307XG5cdFx0XHR2YXIgZm5HZW5FcnJvcnMgPSBbXTtcblx0XHRcdHJlcy5yZW5kZXIgPSBtYWtlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG5cdFx0XHR2YXIgbCA9IGNvbXBpbGVkLnN0YXRpY1JlbmRlckZucy5sZW5ndGg7XG5cdFx0XHRyZXMuc3RhdGljUmVuZGVyRm5zID0gbmV3IEFycmF5KGwpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cmVzLnN0YXRpY1JlbmRlckZuc1tpXSA9IG1ha2VGdW5jdGlvbihjb21waWxlZC5zdGF0aWNSZW5kZXJGbnNbaV0sIGZuR2VuRXJyb3JzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG5cdFx0XHQvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuXHRcdFx0Ly8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHR7XG5cdFx0XHRcdGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG5cdFx0XHRcdFx0XHRmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuXHRcdFx0XHRcdFx0XHR2YXIgZXJyID0gcmVmLmVycjtcblx0XHRcdFx0XHRcdFx0dmFyIGNvZGUgPSByZWYuY29kZTtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuXHRcdFx0XHRcdFx0fSkuam9pbignXFxuJyksXG5cdFx0XHRcdFx0XHR2bVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIChmdW5jdGlvbkNvbXBpbGVDYWNoZVtrZXldID0gcmVzKVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRjb21waWxlOiBjb21waWxlLFxuXHRcdFx0Y29tcGlsZVRvRnVuY3Rpb25zOiBjb21waWxlVG9GdW5jdGlvbnNcblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuXHRcdHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXHRcdHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuXHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuXHRcdFx0dmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG5cdFx0XHRpZiAoZXhwcmVzc2lvbikge1xuXHRcdFx0XHR3YXJuKFxuXHRcdFx0XHRcdFwiY2xhc3M9XFxcIlwiICsgc3RhdGljQ2xhc3MgKyBcIlxcXCI6IFwiICtcblx0XHRcdFx0XHQnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcblx0XHRcdFx0XHQnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcblx0XHRcdFx0XHQnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3RhdGljQ2xhc3MpIHtcblx0XHRcdGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuXHRcdH1cblx0XHR2YXIgY2xhc3NCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdjbGFzcycsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG5cdFx0aWYgKGNsYXNzQmluZGluZykge1xuXHRcdFx0ZWwuY2xhc3NCaW5kaW5nID0gY2xhc3NCaW5kaW5nO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdlbkRhdGEkMSAoZWwpIHtcblx0XHR2YXIgZGF0YSA9ICcnO1xuXHRcdGlmIChlbC5zdGF0aWNDbGFzcykge1xuXHRcdFx0ZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuXHRcdH1cblx0XHRpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG5cdFx0XHRkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cblx0dmFyIGtsYXNzJDEgPSB7XG5cdFx0c3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuXHRcdHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG5cdFx0Z2VuRGF0YTogZ2VuRGF0YSQxXG5cdH07XG5cblx0LyogICovXG5cblx0ZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSQxIChlbCwgb3B0aW9ucykge1xuXHRcdHZhciB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuXHRcdHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuXHRcdGlmIChzdGF0aWNTdHlsZSkge1xuXHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuXHRcdFx0XHRpZiAoZXhwcmVzc2lvbikge1xuXHRcdFx0XHRcdHdhcm4oXG5cdFx0XHRcdFx0XHRcInN0eWxlPVxcXCJcIiArIHN0YXRpY1N0eWxlICsgXCJcXFwiOiBcIiArXG5cdFx0XHRcdFx0XHQnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcblx0XHRcdFx0XHRcdCdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuXHRcdFx0XHRcdFx0J2luc3RlYWQgb2YgPGRpdiBzdHlsZT1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOnN0eWxlPVwidmFsXCI+Lidcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG5cdFx0fVxuXG5cdFx0dmFyIHN0eWxlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnc3R5bGUnLCBmYWxzZSAvKiBnZXRTdGF0aWMgKi8pO1xuXHRcdGlmIChzdHlsZUJpbmRpbmcpIHtcblx0XHRcdGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5EYXRhJDIgKGVsKSB7XG5cdFx0dmFyIGRhdGEgPSAnJztcblx0XHRpZiAoZWwuc3RhdGljU3R5bGUpIHtcblx0XHRcdGRhdGEgKz0gXCJzdGF0aWNTdHlsZTpcIiArIChlbC5zdGF0aWNTdHlsZSkgKyBcIixcIjtcblx0XHR9XG5cdFx0aWYgKGVsLnN0eWxlQmluZGluZykge1xuXHRcdFx0ZGF0YSArPSBcInN0eWxlOihcIiArIChlbC5zdHlsZUJpbmRpbmcpICsgXCIpLFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YVxuXHR9XG5cblx0dmFyIHN0eWxlJDEgPSB7XG5cdFx0c3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuXHRcdHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUkMSxcblx0XHRnZW5EYXRhOiBnZW5EYXRhJDJcblx0fTtcblxuXHR2YXIgbW9kdWxlcyQxID0gW1xuXHRcdGtsYXNzJDEsXG5cdFx0c3R5bGUkMVxuXHRdO1xuXG5cdC8qICAqL1xuXG5cdGZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcblx0XHRpZiAoZGlyLnZhbHVlKSB7XG5cdFx0XHRhZGRQcm9wKGVsLCAndGV4dENvbnRlbnQnLCAoXCJfcyhcIiArIChkaXIudmFsdWUpICsgXCIpXCIpKTtcblx0XHR9XG5cdH1cblxuXHQvKiAgKi9cblxuXHRmdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG5cdFx0aWYgKGRpci52YWx1ZSkge1xuXHRcdFx0YWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBkaXJlY3RpdmVzJDEgPSB7XG5cdFx0bW9kZWw6IG1vZGVsLFxuXHRcdHRleHQ6IHRleHQsXG5cdFx0aHRtbDogaHRtbFxuXHR9O1xuXG5cdC8qICAqL1xuXG5cdHZhciBiYXNlT3B0aW9ucyA9IHtcblx0XHRleHBlY3RIVE1MOiB0cnVlLFxuXHRcdG1vZHVsZXM6IG1vZHVsZXMkMSxcblx0XHRkaXJlY3RpdmVzOiBkaXJlY3RpdmVzJDEsXG5cdFx0aXNQcmVUYWc6IGlzUHJlVGFnLFxuXHRcdGlzVW5hcnlUYWc6IGlzVW5hcnlUYWcsXG5cdFx0bXVzdFVzZVByb3A6IG11c3RVc2VQcm9wLFxuXHRcdGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG5cdFx0aXNSZXNlcnZlZFRhZzogaXNSZXNlcnZlZFRhZyxcblx0XHRnZXRUYWdOYW1lc3BhY2U6IGdldFRhZ05hbWVzcGFjZSxcblx0XHRzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcblx0fTtcblxuXHR2YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG5cdHZhciBjb21waWxlVG9GdW5jdGlvbnMgPSByZWYkMS5jb21waWxlVG9GdW5jdGlvbnM7XG5cblx0LyogICovXG5cblx0dmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcblx0XHR2YXIgZWwgPSBxdWVyeShpZCk7XG5cdFx0cmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxuXHR9KTtcblxuXHR2YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuXHRWdWUkMy5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuXHRcdGVsLFxuXHRcdGh5ZHJhdGluZ1xuXHQpIHtcblx0XHRlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcblxuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdGlmIChlbCA9PT0gZG9jdW1lbnQuYm9keSB8fCBlbCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG5cdFx0XHRcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuXHRcdFx0XHRcIkRvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLlwiXG5cdFx0XHQpO1xuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG5cdFx0Ly8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cblx0XHRpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG5cdFx0XHR2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0aWYgKHRlbXBsYXRlKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdFx0aWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZSA9IGlkVG9UZW1wbGF0ZSh0ZW1wbGF0ZSk7XG5cdFx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdFx0XHRcdGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiAhdGVtcGxhdGUpIHtcblx0XHRcdFx0XHRcdFx0d2Fybihcblx0XHRcdFx0XHRcdFx0XHQoXCJUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogXCIgKyAob3B0aW9ucy50ZW1wbGF0ZSkpLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHR3YXJuKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpc1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGVsKSB7XG5cdFx0XHRcdHRlbXBsYXRlID0gZ2V0T3V0ZXJIVE1MKGVsKTtcblx0XHRcdH1cblx0XHRcdGlmICh0ZW1wbGF0ZSkge1xuXHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0XHRcdFx0aWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG5cdFx0XHRcdFx0bWFyaygnY29tcGlsZScpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHJlZiA9IGNvbXBpbGVUb0Z1bmN0aW9ucyh0ZW1wbGF0ZSwge1xuXHRcdFx0XHRcdHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcblx0XHRcdFx0XHRkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnNcblx0XHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRcdHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuXHRcdFx0XHR2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcblx0XHRcdFx0b3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG5cdFx0XHRcdG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG5cdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHRcdFx0XHRpZiAoXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcblx0XHRcdFx0XHRtYXJrKCdjb21waWxlIGVuZCcpO1xuXHRcdFx0XHRcdG1lYXN1cmUoKCh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZylcblx0fTtcblxuXHQvKipcblx0ICogR2V0IG91dGVySFRNTCBvZiBlbGVtZW50cywgdGFraW5nIGNhcmVcblx0ICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG5cdCAqL1xuXHRmdW5jdGlvbiBnZXRPdXRlckhUTUwgKGVsKSB7XG5cdFx0aWYgKGVsLm91dGVySFRNTCkge1xuXHRcdFx0cmV0dXJuIGVsLm91dGVySFRNTFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcblx0XHRcdHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MXG5cdFx0fVxuXHR9XG5cblx0VnVlJDMuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuXHRyZXR1cm4gVnVlJDM7XG5cbn0pKSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHB1YmxpYy9zY3JpcHRzL2xpYi92dWUuanMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Ozs7QUFLQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBOUVBO0FBQ0E7QUFnRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQ0E7QUFtQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBSUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFHQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBT0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQVFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoRUE7QUFDQTtBQWtFQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFNQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkRBO0FBQ0E7QUF5REE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFDQTtBQWNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFNQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQVRBO0FBV0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUlBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBOzs7QUFHQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBWUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBS0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQUdBO0FBR0E7QUFHQTtBQUNBO0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBNUNBO0FBQ0E7QUE4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQXBEQTtBQUNBO0FBc0RBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQUNBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhHQTtBQUNBO0FBMEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUEzRkE7QUFDQTtBQXNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFJQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBN0xBO0FBK0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVdBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUNBO0FBWUE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///40\n");

/***/ }),

/***/ 41:
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzPzM2OTgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDYiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41\n");

/***/ }),

/***/ 42:
/*!***************************************************!*\
  !*** ./public/scripts/business/approval/index.js ***!
  \***************************************************/
/*! no static exports found */
/*! all exports used */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar $ = __webpack_require__(/*! ../../lib/jquery */ 0);\n\nvar common = __webpack_require__(/*! ../../common */ 2);\n\nvar Vue = __webpack_require__(/*! ../../lib/vue */ 40);\n\nvar vueConfig = new Vue({\n\n\tel: '#app',\n\n\tdata: {\n\t\tformData: {\n\t\t\trating: '',\n\t\t\tresult: '',\n\t\t\tremark: ''\n\t\t}\n\n\t},\n\tmethods: {\n\t\tcheckValue: function checkValue(property, value) {\n\n\t\t\tthis.formData[property] = value;\n\t\t},\n\t\tcancelAction: function cancelAction() {\n\n\t\t\tvar bid = Lizard.query('bid');\n\n\t\t\tvar status = Lizard.query('status');\n\n\t\t\tlocation.href = '/business/' + borrowingsId + '?bid=' + bid + '&status=' + status;\n\t\t},\n\t\tsubmitAction: function submitAction() {\n\n\t\t\tvar errorInfo = { rating: '', result: '', remark: '' };\n\n\t\t\tvar isValidate = true;\n\n\t\t\tfor (var attr in this.formData) {\n\n\t\t\t\tvar value = this.formData[attr];\n\n\t\t\t\tif (value === '') {\n\n\t\t\t\t\tLizard.showToast(errorInfo[attr]);\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tLizard.ajax({\n\t\t\t\ttype: 'POST',\n\t\t\t\turl: '/business/approval/review',\n\t\t\t\tdata: {\n\t\t\t\t\tid: window.borrowingsId,\n\t\t\t\t\tdata: this.formData\n\t\t\t\t},\n\t\t\t\tsuccess: function success(data) {\n\n\t\t\t\t\tif (data) {\n\n\t\t\t\t\t\tLizard.showToast(', ...');\n\n\t\t\t\t\t\tsetTimeout(function () {\n\n\t\t\t\t\t\t\t//location.href = '/business/' + window.borrowingsId;\n\n\t\t\t\t\t\t}, 500);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t},\n\n\tmounted: function mounted() {\n\n\t\tcommon.headerMenu();\n\t}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vcHVibGljL3NjcmlwdHMvYnVzaW5lc3MvYXBwcm92YWwvaW5kZXguanM/NWRjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgJCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9qcXVlcnknKTtcblxudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uLy4uL2NvbW1vbicpO1xuXG52YXIgVnVlID0gcmVxdWlyZSgnLi4vLi4vbGliL3Z1ZScpO1xuXG52YXIgdnVlQ29uZmlnID0gbmV3IFZ1ZSh7XG5cblx0ZWw6JyNhcHAnLFxuXG5cdGRhdGE6IHtcblx0XHRmb3JtRGF0YTp7XG5cdFx0XHRyYXRpbmc6JycsXG5cdFx0XHRyZXN1bHQ6JycsXG5cdFx0XHRyZW1hcms6Jydcblx0XHR9XG5cblx0fSxcblx0bWV0aG9kczp7XG5cblx0XHRjaGVja1ZhbHVlIChwcm9wZXJ0eSx2YWx1ZSkge1xuXG5cdFx0XHR0aGlzLmZvcm1EYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xuXHRcdH0sXG5cblx0XHRjYW5jZWxBY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgYmlkID0gTGl6YXJkLnF1ZXJ5KCdiaWQnKTtcblxuXHRcdFx0dmFyIHN0YXR1cyA9IExpemFyZC5xdWVyeSgnc3RhdHVzJyk7XG5cblx0XHRcdGxvY2F0aW9uLmhyZWYgPSBgL2J1c2luZXNzLyR7Ym9ycm93aW5nc0lkfT9iaWQ9JHtiaWR9JnN0YXR1cz0ke3N0YXR1c31gO1xuXG5cdFx0fSxcblx0XHRzdWJtaXRBY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgZXJyb3JJbmZvID0ge3JhdGluZzon6K+36YCJ5oup6K+E5YiGJyxyZXN1bHQ6J+ivt+mAieaLqee7k+aenCcscmVtYXJrOifor7floavlhpnlpIfms6gnfTtcblxuXHRcdFx0dmFyIGlzVmFsaWRhdGUgPSB0cnVlO1xuXG5cdFx0XHRmb3IgKHZhciBhdHRyIGluIHRoaXMuZm9ybURhdGEpIHtcblxuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmZvcm1EYXRhW2F0dHJdO1xuXG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gJycpIHtcblxuXHRcdFx0XHRcdExpemFyZC5zaG93VG9hc3QoZXJyb3JJbmZvW2F0dHJdKTtcblxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdExpemFyZC5hamF4KHtcblx0XHRcdFx0dHlwZTonUE9TVCcsXG5cdFx0XHRcdHVybDonL2J1c2luZXNzL2FwcHJvdmFsL3JldmlldycsXG5cdFx0XHRcdGRhdGE6e1xuXHRcdFx0XHRcdGlkOndpbmRvdy5ib3Jyb3dpbmdzSWQsXG5cdFx0XHRcdFx0ZGF0YTp0aGlzLmZvcm1EYXRhXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHN1Y2Nlc3MgKGRhdGEpe1xuXG5cdFx0XHRcdFx0aWYgKGRhdGEpIHtcblxuXHRcdFx0XHRcdFx0TGl6YXJkLnNob3dUb2FzdCgn5L+u5pS55oiQ5YqfLCDot7Povazoh7PlgJ/mrL7or6bmg4UuLi4nKTtcblxuXHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xuXG5cdFx0XHRcdFx0XHRcdC8vbG9jYXRpb24uaHJlZiA9ICcvYnVzaW5lc3MvJyArIHdpbmRvdy5ib3Jyb3dpbmdzSWQ7XG5cblx0XHRcdFx0XHRcdH0sNTAwKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHRcdH1cblxuXHR9LFxuXG5cdG1vdW50ZWQgKCkge1xuXG5cdFx0Y29tbW9uLmhlYWRlck1lbnUoKTtcblx0fVxufSlcblxuXG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBwdWJsaWMvc2NyaXB0cy9idXNpbmVzcy9hcHByb3ZhbC9pbmRleC5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBRkE7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFzQkE7QUF6REE7QUFDQTtBQTREQTtBQUNBO0FBQ0E7QUFDQTtBQTVFQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///42\n");

/***/ })

/******/ });